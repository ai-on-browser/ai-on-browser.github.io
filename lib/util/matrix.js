import Complex from"./complex.js";import Tensor from"./tensor.js";const normal_random=(t,e)=>{const s=Math.sqrt(e),i=Math.random(),r=Math.random();return[Math.sqrt(-2*Math.log(i))*Math.cos(2*Math.PI*r)*s+t,Math.sqrt(-2*Math.log(i))*Math.sin(2*Math.PI*r)*s+t]};export class MatrixException extends Error{constructor(t,e){super(t),this.value=e,this.name="MatrixException"}}export default class Matrix{constructor(t,e,s){s?Array.isArray(s)?Array.isArray(s[0])?this._value=s.flat():this._value=s:this._value=Array(t*e).fill(s):this._value=Array(t*e).fill(0),this._size=[t,e]}static zeros(t,e){return new Matrix(t,e,Array(t*e).fill(0))}static ones(t,e){return new Matrix(t,e,Array(t*e).fill(1))}static eye(t,e,s=1){const i=new Matrix(t,e),r=Math.min(t,e);for(let t=0;t<r;t++)i._value[t*e+t]=s;return i}static random(t,e,s=0,i=1){const r=new Matrix(t,e);for(let t=0;t<r.length;t++)r._value[t]=Math.random()*(i-s)+s;return r}static randint(t,e,s=0,i=1){const r=new Matrix(t,e);for(let t=0;t<r.length;t++)r._value[t]=Math.floor(Math.random()*(i-s+1)+s);return r}static randn(t,e,s=0,i=1){const r=new Matrix(t,e);if(Array.isArray(s)&&(s=new Matrix(1,s.length,s)),Array.isArray(i)&&(i=Matrix.fromArray(i)),!(s instanceof Matrix||i instanceof Matrix)){for(let t=0;t<r.length;t+=2){const e=normal_random(s,i);r._value[t]=e[0],t+1<r.length&&(r._value[t+1]=e[1])}return r}if(s instanceof Matrix?s.rows!==e&&1!==s.cols||(s=s.t):s=new Matrix(1,e,s),s.cols!==e||1!==s.rows)throw new MatrixException("'myu' cols must be same as 'cols' and rows must be 1.");if(i instanceof Matrix){if(i.rows!==e||i.cols!==e)throw new MatrixException("'sigma' cols and rows must be same as 'cols'.")}else i=Matrix.eye(e,e,i);const o=i.cholesky();for(let t=0;t<r.length;t+=2){const e=normal_random(0,1);r._value[t]=e[0],t+1<r.length&&(r._value[t+1]=e[1])}const a=r.dot(o.t);return a.add(s),a}static diag(t){let e=0,s=0;for(const i of t)"number"==typeof i?(e++,s++):(e+=i.rows,s+=i.cols);const i=new Matrix(e,s);for(let r=0,o=0,a=0;o<e;r++){const e=t[r];"number"==typeof e?(i._value[o*s+a]=e,o++,a++):(i.set(o,a,e),o+=e.rows,a+=e.cols)}return i}static fromArray(t){return t instanceof Matrix?t:Array.isArray(t)?0===t.length?new Matrix(0,0):Array.isArray(t[0])?new Matrix(t.length,t[0].length,t):new Matrix(t.length,1,t):new Matrix(1,1,t)}get dimension(){return this._size.length}get sizes(){return this._size}get length(){return this._size[0]*this._size[1]}get rows(){return this._size[0]}get cols(){return this._size[1]}get value(){return this._value}get t(){return this.transpose()}*[Symbol.iterator](){yield*this._value}toArray(){const t=[],e=this.cols;for(let s=0;s<this.length;s+=e)t.push(this._value.slice(s,s+e));return t}toScaler(){if(1!==this.rows||1!==this.cols)throw new MatrixException("The matrix cannot convert to scaler.");return this._value[0]}toString(){let t="[";for(let e=0;e<this.rows;e++){e>0&&(t+=",\n "),t+="[";for(let s=0;s<this.cols;s++)s>0&&(t+=", "),t+=this._value[e*this.cols+s];t+="]"}return t+"]"}copy(t){return t===this?this:t?(t._size=[].concat(this._size),this._value.forEach(((e,s)=>t._value[s]=e)),t):new Matrix(this.rows,this.cols,[].concat(this._value))}equals(t,e=0){if(t instanceof Matrix){if(this._size[0]!==t._size[0]||this._size[1]!==t._size[1])return!1;for(let s=this.length-1;s>=0;s--)if(Math.abs(this._value[s]-t._value[s])>e)return!1;return!0}return!1}at(t,e){if(Array.isArray(t)&&([t,e]=t),t<0||this.rows<=t||e<0||this.cols<=e)throw new MatrixException("Index out of bounds.");return this._value[t*this.cols+e]}set(t,e,s){if(Array.isArray(t)&&(s=e,[t,e]=t),s instanceof Matrix){if(t<0||this.rows<=t+s.rows-1||e<0||this.cols<=e+s.cols-1)throw new MatrixException("Index out of bounds.");for(let i=0;i<s.rows;i++)for(let r=0;r<s.cols;r++)this._value[(i+t)*this.cols+r+e]=s._value[i*s.cols+r];return null}{if(t<0||this.rows<=t||e<0||this.cols<=e)throw new MatrixException("Index out of bounds.");const i=this._value[t*this.cols+e];return this._value[t*this.cols+e]=s,i}}row(t){if(Array.isArray(t)){if("boolean"==typeof t[0]){if(t.length!==this.rows)throw new MatrixException("Length is invalid.");const e=[];for(let s=0;s<t.length;s++)t[s]&&e.push(s);t=e}if(t.some((t=>t<0||this.rows<=t)))throw new MatrixException("Index out of bounds.");const e=new Matrix(t.length,this.cols);for(let s=0;s<t.length;s++)for(let i=0;i<this.cols;i++)e._value[s*this.cols+i]=this._value[t[s]*this.cols+i];return e}if(t<0||this.rows<=t)throw new MatrixException("Index out of bounds.");return new Matrix(1,this.cols,this._value.slice(t*this.cols,(t+1)*this.cols))}col(t){if(Array.isArray(t)){if("boolean"==typeof t[0]){if(t.length!==this.cols)throw new MatrixException("Length is invalid.");const e=[];for(let s=0;s<t.length;s++)t[s]&&e.push(s);t=e}if(t.some((t=>t<0||this.cols<=t)))throw new MatrixException("Index out of bounds.");const e=new Matrix(this.rows,t.length);for(let s=0;s<this.rows;s++)for(let i=0;i<t.length;i++)e._value[s*t.length+i]=this._value[s*this.cols+t[i]];return e}{if(t<0||this.cols<=t)throw new MatrixException("Index out of bounds.");const e=new Matrix(this.rows,1);for(let s=0;s<this.rows;s++)e._value[s]=this._value[s*this.cols+t];return e}}slice(t,e,s=0){if("number"!=typeof t&&(t=0),"number"!=typeof e&&(e=this._size[s]),0===s){const s=new Matrix(e-t,this.cols);return s._value=this._value.slice(t*this.cols,e*this.cols),s}if(1===s){const s=new Matrix(this.rows,e-t);for(let e=0;e<s.rows;e++)for(let i=0;i<s.cols;i++)s._value[e*s.cols+i]=this._value[e*this.cols+i+t];return s}throw new MatrixException("Invalid axis.")}block(t,e,s,i){"number"!=typeof t&&(t=0),"number"!=typeof e&&(e=0);const r=new Matrix((s||this.rows)-t,(i||this.cols)-e);for(let s=0;s<r.rows;s++)for(let i=0;i<r.cols;i++)r._value[s*r.cols+i]=this._value[(s+t)*this.cols+i+e];return r}remove(t,e=0){if(0===e)if(Array.isArray(t)){if(t.some((t=>t<0||this.rows<=t)))throw new MatrixException("Index out of bounds.");(t=[...new Set(t)]).sort(((t,e)=>e-t));for(let e=0;e<t.length;e++)this._value.splice(t[e]*this.cols,this.cols);this._size[0]-=t.length}else{if(t<0||this.rows<=t)throw new MatrixException("Index out of bounds.");this._value.splice(t*this.cols,this.cols),this._size[0]--}else{if(1!==e)throw new MatrixException("Invalid axis.");if(Array.isArray(t)){if(t.some((t=>t<0||this.cols<=t)))throw new MatrixException("Index out of bounds.");(t=[...new Set(t)]).sort(((t,e)=>t-e));let e=0,s=0;for(let i=0;i<this.rows;i++)for(let i=0,r=0;i<this.cols;i++,e++)t[r]!==i?this._value[s++]=this._value[e]:r++;this._size[1]-=t.length,this._value.length=this.length}else{if(t<0||this.cols<=t)throw new MatrixException("Index out of bounds.");let e=0,s=0;for(let i=0;i<this.rows;i++)for(let i=0;i<this.cols;i++,e++)t!==i&&(this._value[s++]=this._value[e]);this._size[1]--,this._value.length=this.length}}}removeIf(t,e=0){const s=[];if(0===e)for(let e=0;e<this.rows;e++)t(this.row(e))&&s.push(e);else{if(1!==e)throw new MatrixException("Invalid axis.");for(let e=0;e<this.cols;e++)t(this.col(e))&&s.push(e)}this.remove(s,e)}sample(t,e=0){const s=this.sizes[e],i=[];for(let e=0;e<t;e++)i.push(Math.floor(Math.random()*(s-e)));for(let e=t-1;e>=0;e--)for(let s=t-1;s>e;s--)i[e]<=i[s]&&i[s]++;if(0===e)return[this.row(i),i];if(1===e)return[this.col(i),i];throw new MatrixException("Invalid axis.")}fill(t){this._value.fill(t)}map(t){for(let e=0,s=0;e<this._size[0];e++)for(let i=0;i<this._size[1];i++,s++)this._value[s]=t(this._value[s],[e,i],this)}static map(t,e){const s=new Matrix(t.rows,t.cols);for(let i=0,r=0;i<t._size[0];i++)for(let o=0;o<t._size[1];o++,r++)s._value[r]=e(t._value[r],[i,o],t);return s}forEach(t){for(let e=0,s=0;e<this._size[0];e++)for(let i=0;i<this._size[1];i++,s++)t(this._value[s],[e,i],this)}transpose(){const t=new Matrix(this.cols,this.rows);for(let e=0;e<this.rows;e++)for(let s=0;s<this.cols;s++)t._value[s*this.rows+e]=this._value[e*this.cols+s];return t}adjoint(){return this.transpose()}flip(t=0){if(0===t)for(let t=0;t<this.rows/2;t++){const e=(this.rows-t-1)*this.cols;for(let s=0;s<this.cols;s++){const i=this._value[t*this.cols+s];this._value[t*this.cols+s]=this._value[e+s],this._value[e+s]=i}}else{if(1!==t)throw new MatrixException("Invalid axis.");for(let t=0;t<this.cols/2;t++){const e=this.cols-t-1;for(let s=0;s<this.rows;s++){const i=this._value[s*this.cols+t];this._value[s*this.cols+t]=this._value[s*this.cols+e],this._value[s*this.cols+e]=i}}}}swap(t,e,s=0){if(0===s){if(t<0||e<0||this.rows<=t||this.rows<=e)throw new MatrixException("Index out of bounds.");const s=(e-t)*this.cols;for(let e=t*this.cols;e<(t+1)*this.cols;e++)[this._value[e],this._value[e+s]]=[this._value[e+s],this._value[e]]}else{if(1!==s)throw new MatrixException("Invalid axis.");{if(t<0||e<0||this.cols<=t||this.cols<=e)throw new MatrixException("Index out of bounds.");const s=e-t;for(let e=t;e<this.length;e+=this.cols)[this._value[e],this._value[e+s]]=[this._value[e+s],this._value[e]]}}}sort(t=0){if(0===t){const t=Array.from({length:this.rows},((t,e)=>e));return t.sort(((t,e)=>{const s=t*this.cols,i=e*this.cols;for(let t=0;t<this.cols;t++){const e=this._value[s+t]-this._value[i+t];if(0!==e)return e}return 0})),this._value=this.row(t)._value,t}if(1===t){const t=Array.from({length:this.cols},((t,e)=>e));return t.sort(((t,e)=>{for(let s=0;s<this.rows;s++){const i=this._value[t+s*this.cols]-this._value[e+s*this.cols];if(0!==i)return i}return 0})),this._value=this.col(t)._value,t}throw new MatrixException("Invalid axis.")}shuffle(t=0){const e=Array.from({length:this._size[t]},((t,e)=>e));for(let t=e.length-1;t>0;t--){const s=Math.floor(Math.random()*(t+1));[e[t],e[s]]=[e[s],e[t]]}if(0===t)this._value=this.row(e)._value;else{if(1!==t)throw new MatrixException("Invalid axis.");this._value=this.col(e)._value}return e}unique(t=0,e=0){const s=[];if(0===t){let t=0;for(let i=0;i<this.rows;i++){let r=-1;for(let t=0;t<i;t++){let s=!0;for(let r=0;s&&r<this.cols;r++)Math.abs(this._value[i*this.cols+r]-this._value[t*this.cols+r])>e&&(s=!1);if(s){r=t;break}}if(r<0){for(let e=0;e<this.cols;e++)this._value[t*this.cols+e]=this._value[i*this.cols+e];s.push(i),t++}}this._size[0]=t,this._value.length=this.length}else{if(1!==t)throw new MatrixException("Invalid axis.");for(let t=0;t<this.cols;t++){let i=!1;for(let r=0;!i&&r<s.length;r++){i=!0;for(let o=0;i&&o<this.rows;o++)Math.abs(this._value[o*this.cols+t]-this._value[o*this.cols+s[r]])>e&&(i=!1)}i||s.push(t)}for(let t=0,e=0;t<this.rows;t++)for(let i=0;i<s.length;i++,e++)this._value[e]=this._value[t*this.cols+s[i]];this._size[1]=s.length,this._value.length=this.length}return s}resize(t,e,s=0){const i=Array(t*e).fill(s),r=Math.min(this.rows,t),o=Math.min(this.cols,e);for(let t=0;t<r;t++)for(let s=0;s<o;s++)i[t*e+s]=this._value[t*this.cols+s];this._value=i,this._size=[t,e]}static resize(t,e,s,i=0){const r=new Matrix(e,s);r.fill(i);const o=Math.min(t.rows,e),a=Math.min(t.cols,s);for(let e=0;e<o;e++)for(let i=0;i<a;i++)r._value[e*s+i]=t._value[e*t.cols+i];return r}reshape(t,e){if(this.length!==t*e)throw new MatrixException("Length is different.");this._size=[t,e]}repeat(t,e=0){if(Array.isArray(t)){if(t.length<this._size.length)for(let e=t.length;e<this._size.length;e++)t[e]=1}else{const s=Array(this._size.length).fill(1);s[e]=t,t=s}const s=t.reduce(((t,e)=>t*e),1);if(1===s)return;const i=Array(this.length*s),r=this._size.map(((e,s)=>e*t[s]));for(let t=0;t<r[0];t++)for(let e=0;e<r[1];e++)i[t*r[1]+e]=this._value[t%this.rows*this.cols+e%this.cols];this._value=i,this._size=r}static repeat(t,e,s=0){const i=t.copy();return i.repeat(e,s),i}concat(t,e=0){if(0===e){if(this.cols!==t.cols)throw new MatrixException("Size is different.");this._value=[].concat(this._value,t._value),this._size[0]+=t.rows}else{if(1!==e)throw new MatrixException("Invalid axis.");{if(this.rows!==t.rows)throw new MatrixException("Size is different.");const e=this.cols;this.resize(this.rows,this.cols+t.cols);for(let s=0;s<this.rows;s++)for(let i=0;i<t.cols;i++)this._value[s*this.cols+i+e]=t._value[s*t.cols+i]}}}static concat(t,e,s=0){const i=t.copy();return i.concat(e,s),i}reduce(t,e,s=-1,i=null){if(s<0){let s=e??this._value[0];for(let i=0,r=0;i<this._size[0];i++)for(let o=0;o<this._size[1];o++,r++)0===r&&null==e||(s=t(s,this._value[r],[i,o],this));return!0===i?new Matrix(1,1,s):s}if(!1===i)throw new MatrixException("keepdims only accept true if axis >= 0.");let r=0===s?1:this.cols,o=0===s?this.cols:1;const a=[].concat(this._size);a[s]=1;const l=Matrix.zeros(...a);for(let i=0,a=0;i<l.length;i++,a+=r){let r=e??this._value[a];for(let l=r===e?0:1;l<this._size[s];l++)r=t(r,this._value[l*o+a],0===s?[l,i]:[i,l],this);l._value[i]=r}return l}every(t,e=-1){return this.reduce(((e,s,i,r)=>e&&t(s,i,r)),!0,e)}some(t,e=-1){return this.reduce(((e,s,i,r)=>e||t(s,i,r)),!1,e)}max(t=-1){return this.reduce(((t,e)=>Math.max(t,e)),-1/0,t)}min(t=-1){return this.reduce(((t,e)=>Math.min(t,e)),1/0,t)}median(t=-1){if(t<0){const t=this._value.concat();return t.sort(((t,e)=>t-e)),t.length%2==1?t[(t.length-1)/2]:(t[t.length/2]+t[t.length/2-1])/2}let e=0===t?1:this.cols,s=0===t?this.cols:1;const i=[].concat(this._size);i[t]=1;const r=Matrix.zeros(...i);for(let i=0,o=0;i<r.length;i++,o+=e){const e=[];for(let i=0;i<this._size[t];i++)e.push(this._value[i*s+o]);e.sort(((t,e)=>t-e)),e.length%2==1?r._value[i]=e[(e.length-1)/2]:r._value[i]=(e[e.length/2]+e[e.length/2-1])/2}return r}quantile(t,e=-1){if(0===t)return this.min(e);if(1===t)return this.max(e);const s=(t,e)=>{if(t.sort(((t,e)=>t-e)),1===t.length)return t[0];const s=e*(t.length-1),i=Math.floor(s);return s===i?t[i]:t[i]*(1-s+i)+t[i+1]*(s-i)};if(e<0){return s(this._value.concat(),t)}const i=0===e?1:this.cols,r=0===e?this.cols:1,o=Matrix.zeros(...this._size.map(((t,s)=>s===e?1:t)));for(let a=0,l=0;a<o.length;a++,l+=i){const i=[];for(let t=0;t<this._size[e];t++)i.push(this._value[t*r+l]);o._value[a]=s(i,t)}return o}argmax(t){let e=0===t?1:this.cols,s=0===t?this.cols:1;const i=[].concat(this._size);i[t]=1;const r=Matrix.zeros(...i);for(let i=0,o=0;i<r.length;i++,o+=e){let e=this._value[o],a=0;for(let i=1;i<this._size[t];i++){let t=this._value[i*s+o];t>e&&(e=t,a=i)}r._value[i]=a}return r}argmin(t){let e=0===t?1:this.cols,s=0===t?this.cols:1;const i=[].concat(this._size);i[t]=1;const r=Matrix.zeros(...i);for(let i=0,o=0;i<r.length;i++,o+=e){let e=this._value[o],a=0;for(let i=1;i<this._size[t];i++){let t=this._value[i*s+o];t<e&&(e=t,a=i)}r._value[i]=a}return r}sum(t=-1){return this.reduce(((t,e)=>t+e),0,t)}mean(t=-1){if(t<0)return this.sum(t)/this.length;let e=this.sum(t);return e.div(this._size[t]),e}prod(t=-1){return this.reduce(((t,e)=>t*e),1,t)}variance(t=-1,e=0){const s=this.mean(t);if(t<0)return this._value.reduce(((t,e)=>t+(e-s)**2),0)/(this.length-e);let i=0===t?1:this.cols,r=0===t?this.cols:1;const o=[].concat(this._size);o[t]=1;const a=Matrix.zeros(...o);for(let o=0,l=0;o<a.length;o++,l+=i){let i=0;for(let e=0;e<this._size[t];e++)i+=(this._value[e*r+l]-s._value[o])**2;a._value[o]=i/(this._size[t]-e)}return a}std(t=-1,e=0){if(t<0)return Math.sqrt(this.variance(t,e));let s=this.variance(t,e);for(let t=0;t<s.length;t++)s._value[t]=Math.sqrt(s._value[t]);return s}isSquare(){return this.rows===this.cols}isDiag(t=0){const e=this.cols;for(let s=0;s<this.rows;s++)for(let i=0;i<e;i++)if(s!==i&&Math.abs(this._value[s*e+i])>t)return!1;return!0}isIdentity(t=0){if(!this.isSquare())return!1;const e=this.cols;for(let s=0;s<this.rows;s++)for(let i=0;i<e;i++)if(s!==i){if(Math.abs(this._value[s*e+i])>t)return!1}else if(Math.abs(this._value[s*e+i]-1)>t)return!1;return!0}isZero(t=0){const e=this.length;for(let s=0;s<e;s++)if(Math.abs(this._value[s])>t)return!1;return!0}isTriangular(t=0){return this.isLowerTriangular(t)||this.isUpperTriangular(t)}isLowerTriangular(t=0){const e=this.cols;for(let s=0;s<this.rows;s++)for(let i=s+1;i<e;i++)if(Math.abs(this._value[s*e+i])>t)return!1;return!0}isUpperTriangular(t=0){for(let e=0;e<this.rows;e++)for(let s=0;s<Math.min(e,this.cols);s++)if(Math.abs(this._value[e*this.cols+s])>t)return!1;return!0}isSymmetric(t=0){if(!this.isSquare())return!1;const e=this.cols;for(let s=0;s<this.rows;s++)for(let i=0;i<s;i++)if(t>0){if(Math.abs(this._value[s*e+i]-this._value[i*e+s])>t)return!1}else if(this._value[s*e+i]!==this._value[i*e+s])return!1;return!0}isHermitian(t=0){return this.isSymmetric(t)}isAlternating(t=0){if(!this.isSquare())return!1;const e=this.cols;for(let s=0;s<this.rows;s++)for(let i=0;i<s;i++)if(t>0){if(Math.abs(this._value[s*e+i]+this._value[i*e+s])>t)return!1}else if(this._value[s*e+i]!==-this._value[i*e+s])return!1;return!0}isSkewHermitian(t=0){return this.isAlternating(t)}isRegular(t=0){return!!this.isSquare()&&Math.abs(this.det())<=t}isNormal(t=0){return this.dot(this.t).equals(this.tDot(this),t)}isOrthogonal(t=0){const e=this.tDot(this);for(let s=0;s<this.rows;s++)for(let i=0;i<this.cols;i++){const r=e._value[s*this.cols+i];if(s===i){if(Math.abs(r-1)>t)return!1}else if(Math.abs(r)>t)return!1}return!0}isUnitary(t=0){return this.isOrthogonal(t)}isNilpotent(t=0){if(!this.isSquare())return!1;const e=this.eigenValues();for(let s=0;s<e.length;s++)if(isNaN(e[s])||Math.abs(e[s])>t)return!1;return!0}diag(){let t=[];const e=Math.min(this.rows,this.cols);for(let s=0;s<e;s++)t.push(this._value[s*this.cols+s]);return t}trace(){let t=0;const e=Math.min(this.rows,this.cols);for(let s=0;s<e;s++)t+=this._value[s*this.cols+s];return t}norm(t=2){return this.normEntrywise(t)}normInduced(t=2){if(1===t){let t=-1/0;for(let e=0;e<this.cols;e++){let s=0;for(let t=0;t<this.rows;t++)s+=Math.abs(this._value[t*this.cols+e]);t=Math.max(t,s)}return t}if(t===1/0){let t=-1/0;for(let e=0;e<this.rows;e++){let s=0;for(let t=0;t<this.cols;t++)s+=Math.abs(this._value[e*this.cols+t]);t=Math.max(t,s)}return t}if(2===t)return this.normSpectral();throw new MatrixException("Not implemented")}normSpectral(){return this.singularValues()[0]}normEntrywise(t=2){if(t===1/0)return this.normMax();if(2===t)return this.normFrobenius();let e=0;for(let s=0;s<this.length;s++)e+=Math.abs(this._value[s])**t;return e**(1/t)}normFrobenius(){let t=0;for(let e=0;e<this.length;e++)t+=Math.abs(this._value[e])**2;return Math.sqrt(t)}normMax(){let t=-1/0;for(let e=0;e<this.length;e++)t=Math.max(t,Math.abs(this._value[e]));return t}normSchatten(t=2){if(t===1/0)return this.normSpectral();if(1===t)return this.normNuclear();const e=this.singularValues(),s=Math.min(this.rows,this.cols);let i=0;for(let r=0;r<s;r++)i+=e[r]**t;return i**(1/t)}normNuclear(){const t=this.singularValues(),e=Math.min(this.rows,this.cols);let s=0;for(let i=0;i<e;i++)s+=t[i];return s}rank(t=0){const e=this.copy();let s=0;for(let i=0;s<e.rows&&i<e.cols;i++,s++){if(Math.abs(e._value[s*e.cols+i])<=t)for(let r=s+1;r<e.rows;r++)if(Math.abs(e._value[r*e.cols+i])>t){e.swap(s,r,0);break}if(Math.abs(e._value[s*e.cols+i])<=t){s--;continue}const r=e._value[s*e.cols+i];for(let t=s+1;t<e.rows;t++){const o=e._value[t*e.cols+i];for(let a=i+1;a<e.cols;a++)e._value[t*e.cols+a]-=o*e._value[s*e.cols+a]/r}}return s}det(){if(!this.isSquare())throw new MatrixException("Determine only define square matrix.",this);const t=this._value;switch(this.rows){case 0:return 0;case 1:return t[0];case 2:return t[0]*t[3]-t[1]*t[2];case 3:return t[0]*t[4]*t[8]+t[1]*t[5]*t[6]+t[2]*t[3]*t[7]-t[0]*t[5]*t[7]-t[1]*t[3]*t[8]-t[2]*t[4]*t[6];case 4:return t[0]*t[5]*t[10]*t[15]+t[0]*t[6]*t[11]*t[13]+t[0]*t[7]*t[9]*t[14]-t[0]*t[7]*t[10]*t[13]-t[0]*t[6]*t[9]*t[15]-t[0]*t[5]*t[11]*t[14]-t[1]*t[4]*t[10]*t[15]-t[2]*t[4]*t[11]*t[13]-t[3]*t[4]*t[9]*t[14]+t[3]*t[4]*t[10]*t[13]+t[2]*t[4]*t[9]*t[15]+t[1]*t[4]*t[11]*t[14]+t[1]*t[6]*t[8]*t[15]+t[2]*t[7]*t[8]*t[13]+t[3]*t[5]*t[8]*t[14]-t[3]*t[6]*t[8]*t[13]-t[2]*t[5]*t[8]*t[15]-t[1]*t[7]*t[8]*t[14]-t[1]*t[6]*t[11]*t[12]-t[2]*t[7]*t[9]*t[12]-t[3]*t[5]*t[10]*t[12]+t[3]*t[6]*t[9]*t[12]+t[2]*t[5]*t[11]*t[12]+t[1]*t[7]*t[10]*t[12]}const[e,s]=this.lu();let i=1;for(let t=0;t<this.rows;t++){const r=t*this.cols+t;i*=e._value[r]*s._value[r]}return i}negative(){this.map((t=>-t))}not(){this.map((t=>+!t))}bitnot(){this.map((t=>~t))}abs(){this.map(Math.abs)}round(){this.map(Math.round)}floor(){this.map(Math.floor)}ceil(){this.map(Math.ceil)}leftShift(t){this.map((e=>e<<t))}signedRightShift(t){this.map((e=>e>>t))}unsignedRightShift(t){this.map((e=>e>>>t))}broadcastOperate(t,e){if(t instanceof Tensor)if(2===t.dimension)t=new Matrix(t.sizes[0],t.sizes[1],t.value);else{if(1!==t.dimension)throw new MatrixException("Broadcasting size invalid.",[this,t]);t=new Matrix(1,t.sizes[0],t.value)}if(t instanceof Matrix)if(this.rows===t.rows&&this.cols===t.cols)for(let s=this.length-1;s>=0;s--)this._value[s]=e(this._value[s],t._value[s]);else if(this.rows>=t.rows&&this.cols>=t.cols){if(this.rows%t.rows!=0||this.cols%t.cols!=0)throw new MatrixException("Broadcasting size invalid.",[this,t]);for(let s=0,i=0,r=0;s<this.length;s++,r++)r>=this.cols&&(i+=t.cols,r=0),i>=t.length&&(i=0),this._value[s]=e(this._value[s],t._value[i+r%t.cols])}else{if(!(this.rows<=t.rows&&this.cols<=t.cols))throw new MatrixException("Broadcasting size invalid.",[this,t]);if(t.rows%this.rows!=0||t.cols%this.cols!=0)throw new MatrixException("Broadcasting size invalid.",[this,t]);this.repeat([t.rows/this.rows,t.cols/this.cols]);for(let s=this.length-1;s>=0;s--)this._value[s]=e(this._value[s],t._value[s])}else this.map((s=>e(s,t)))}operateAt(t,e,s){if(Array.isArray(t)&&(s=e,[t,e]=t),t<0||this.rows<=t||e<0||this.cols<=e)throw new MatrixException("Index out of bounds.");const i=this._value[t*this.cols+e];return this._value[t*this.cols+e]=s(i),i}add(t){this.broadcastOperate(t,((t,e)=>t+e))}addAt(t,e,s){return this.operateAt(t,e,(t=>t+s))}static add(t,e){if(t instanceof Matrix){const s=t.copy();return s.add(e),s}if(e instanceof Matrix){const s=e.copy();return s.add(t),s}return new Matrix(1,1,t+e)}sub(t){this.broadcastOperate(t,((t,e)=>t-e))}isub(t){this.negative(),this.add(t)}subAt(t,e,s){return this.operateAt(t,e,(t=>t-s))}isubAt(t,e,s){return this.operateAt(t,e,(t=>s-t))}static sub(t,e){if(t instanceof Matrix){const s=t.copy();return s.sub(e),s}if(e instanceof Matrix){const s=e.copy();return s.isub(t),s}return new Matrix(1,1,t-e)}mult(t){this.broadcastOperate(t,((t,e)=>t*e))}multAt(t,e,s){return this.operateAt(t,e,(t=>t*s))}static mult(t,e){if(t instanceof Matrix){const s=t.copy();return s.mult(e),s}if(e instanceof Matrix){const s=e.copy();return s.mult(t),s}return new Matrix(1,1,t*e)}div(t){this.broadcastOperate(t,((t,e)=>t/e))}idiv(t){this.broadcastOperate(t,((t,e)=>e/t))}divAt(t,e,s){return this.operateAt(t,e,(t=>t/s))}idivAt(t,e,s){return this.operateAt(t,e,(t=>s/t))}static div(t,e){if(t instanceof Matrix){const s=t.copy();return s.div(e),s}if(e instanceof Matrix){const s=e.copy();return s.idiv(t),s}return new Matrix(1,1,t/e)}mod(t){this.broadcastOperate(t,((t,e)=>t%e))}imod(t){this.broadcastOperate(t,((t,e)=>e%t))}modAt(t,e,s){return this.operateAt(t,e,(t=>t%s))}imodAt(t,e,s){return this.operateAt(t,e,(t=>s%t))}static mod(t,e){if(t instanceof Matrix){const s=t.copy();return s.mod(e),s}if(e instanceof Matrix){const s=e.copy();return s.imod(t),s}return new Matrix(1,1,t%e)}and(t){this.broadcastOperate(t,((t,e)=>+(!!t&&!!e)))}andAt(t,e,s){return this.operateAt(t,e,(t=>+(!!t&&!!s)))}static and(t,e){if(t instanceof Matrix){const s=t.copy();return s.and(e),s}if(e instanceof Matrix){const s=e.copy();return s.and(t),s}return new Matrix(1,1,+(!!t&&!!e))}or(t){this.broadcastOperate(t,((t,e)=>+(!!t||!!e)))}orAt(t,e,s){return this.operateAt(t,e,(t=>+(!!t||!!s)))}static or(t,e){if(t instanceof Matrix){const s=t.copy();return s.or(e),s}if(e instanceof Matrix){const s=e.copy();return s.or(t),s}return new Matrix(1,1,+(!!t||!!e))}bitand(t){this.broadcastOperate(t,((t,e)=>+(t&e)))}bitandAt(t,e,s){return this.operateAt(t,e,(t=>+(t&s)))}static bitand(t,e){if(t instanceof Matrix){const s=t.copy();return s.bitand(e),s}if(e instanceof Matrix){const s=e.copy();return s.bitand(t),s}return new Matrix(1,1,+(t&e))}bitor(t){this.broadcastOperate(t,((t,e)=>+(t|e)))}bitorAt(t,e,s){return this.operateAt(t,e,(t=>+(t|s)))}static bitor(t,e){if(t instanceof Matrix){const s=t.copy();return s.bitor(e),s}if(e instanceof Matrix){const s=e.copy();return s.bitor(t),s}return new Matrix(1,1,+(t|e))}bitxor(t){this.broadcastOperate(t,((t,e)=>+(t^e)))}bitxorAt(t,e,s){return this.operateAt(t,e,(t=>+(t^s)))}static bitxor(t,e){if(t instanceof Matrix){const s=t.copy();return s.bitxor(e),s}if(e instanceof Matrix){const s=e.copy();return s.bitxor(t),s}return new Matrix(1,1,+(t^e))}dot(t){if(this.cols!==t.rows)throw new MatrixException(`Dot size invalid. left = [${this.rows}, ${this.cols}], right = [${t.rows}, ${t.cols}]`);const e=t.cols,s=new Matrix(this.rows,e);let i=0;const r=this.length,o=t.length,a=this.cols,l=this._value,n=t._value,h=s._value;for(let t=0;t<r;t+=a){let s=0,r=0;for(let i=0,a=t;i<o;i+=e,a++)l[a]&&r++,s+=l[a]*n[i];if(h[i++]=s,0!==r)if(r/a<.1){let r=[],o=[];for(let e=0;e<a;e++)l[t+e]&&(r.push(l[t+e]),o.push(e));for(let t=1;t<e;t++){s=0;for(let i=0;i<r.length;i++)s+=r[i]*n[o[i]*e+t];h[i++]=s}}else for(let r=1;r<e;r++){s=0;for(let i=r,a=t;i<o;i+=e,a++)s+=l[a]*n[i];h[i++]=s}else i+=e-1}return s}tDot(t){if(this.rows!==t.rows)throw new MatrixException(`tDot size invalid. left = [${this.cols}, ${this.rows}], right = [${t.rows}, ${t.cols}]`);const e=new Matrix(this.cols,t.cols);let s=0;for(let i=0;i<this.cols;i++)for(let r=0;r<t.cols;r++){let o=0,a=i;for(let e=r;e<t.length;e+=t.cols,a+=this.cols)o+=this._value[a]*t._value[e];e._value[s++]=o}return e}kron(t){const e=new Matrix(this.rows*t.rows,this.cols*t.cols);for(let s=0;s<this.rows;s++)for(let i=0;i<this.cols;i++)for(let r=0;r<t.rows;r++)for(let o=0;o<t.cols;o++)e._value[(s*t.rows+r)*this.cols*t.cols+i*t.cols+o]=this._value[s*this.cols+i]*t._value[r*t.cols+o];return e}convolute(t,e=!0){const s=[Math.floor((t.length-1)/2),Math.floor((t[0].length-1)/2)],i=this._value.concat();for(let r=0;r<this.rows;r++)for(let o=0;o<this.cols;o++){let a=0,l=0;for(let e=0;e<t.length;e++){const n=r+e-s[0];if(!(n<0||this.rows<=n))for(let r=0;r<t[e].length;r++){const h=o+r-s[1];h<0||this.cols<=h||(a+=t[e][r]*i[n*this.cols+h],l+=t[e][r])}}e&&(a/=l),this._value[r*this.cols+o]=a}}reducedRowEchelonForm(t=0){for(let e=0,s=0;e<this.rows&&s<this.cols;s++,e++){if(Math.abs(this._value[e*this.cols+s])<=t)for(let i=e+1;i<this.rows;i++)if(Math.abs(this._value[i*this.cols+s])>t){this.swap(e,i,0);break}if(Math.abs(this._value[e*this.cols+s])<=t){e--;continue}const i=this._value[e*this.cols+s];this._value[e*this.cols+s]=1;for(let t=s+1;t<this.cols;t++)this._value[e*this.cols+t]/=i;for(let t=0;t<this.rows;t++){if(t===e)continue;const i=this._value[t*this.cols+s];this._value[t*this.cols+s]=0;for(let r=s+1;r<this.cols;r++)this._value[t*this.cols+r]-=i*this._value[e*this.cols+r]}}}inv(){if(!this.isSquare())throw new MatrixException("Inverse matrix only define square matrix.",this);const t=this._value;switch(this.rows){case 0:return new Matrix(0,0);case 1:return new Matrix(1,1,[1/t[0]]);case 2:{const e=this.det();return new Matrix(2,2,[t[3]/e,-t[1]/e,-t[2]/e,t[0]/e])}case 3:{const e=this.det();return new Matrix(3,3,[(t[4]*t[8]-t[5]*t[7])/e,(t[2]*t[7]-t[1]*t[8])/e,(t[1]*t[5]-t[2]*t[4])/e,(t[5]*t[6]-t[3]*t[8])/e,(t[0]*t[8]-t[2]*t[6])/e,(t[2]*t[3]-t[0]*t[5])/e,(t[3]*t[7]-t[4]*t[6])/e,(t[1]*t[6]-t[0]*t[7])/e,(t[0]*t[4]-t[1]*t[3])/e])}}return this.isLowerTriangular()?this.invLowerTriangular():this.isUpperTriangular()?this.invUpperTriangular():this.invLU()}invLowerTriangular(){if(!this.isSquare())throw new MatrixException("Inverse matrix only define square matrix.",this);const t=this._value,e=new Matrix(this.rows,this.cols);for(let s=0;s<this.rows;s++){const i=t[s*this.cols+s];e._value[s*this.cols+s]=1/i;for(let r=0;r<s;r++){let o=0;for(let i=r;i<s;i++)o+=t[s*this.cols+i]*e._value[i*this.cols+r];e._value[s*this.cols+r]=-o/i}}return e}invUpperTriangular(){if(!this.isSquare())throw new MatrixException("Inverse matrix only define square matrix.",this);const t=this._value,e=new Matrix(this.rows,this.cols);for(let s=this.cols-1;s>=0;s--){const i=t[s*this.cols+s];e._value[s*this.cols+s]=1/i;for(let r=s+1;r<this.cols;r++){let o=0;for(let i=s+1;i<=r;i++)o+=t[s*this.cols+i]*e._value[i*this.cols+r];e._value[s*this.cols+r]=-o/i}}return e}invRowReduction(){if(!this.isSquare())throw new MatrixException("Inverse matrix only define square matrix.",this);const t=this.copy(),e=this.rows,s=Matrix.eye(e,e);for(let i=0;i<e;i++){const r=i*e;if(0===t._value[r+i]){let o=i+1;for(;o<e&&0===t._value[o*e+i];o++);if(o===e)throw new MatrixException("",this);for(let s=i;s<e;s++)[t._value[r+s],t._value[o*e+s]]=[t._value[o*e+s],t._value[r+s]];s.swap(i,o)}const o=t._value[r+i];t._value[r+i]=1;for(let s=i+1;s<e;s++)t._value[r+s]/=o;for(let t=0;t<e;t++)s._value[r+t]=s._value[r+t]/o;for(let o=0;o<e;o++){if(i===o)continue;const a=t._value[o*e+i];t._value[o*e+i]=0;for(let s=i+1;s<e;s++)t._value[o*e+s]-=a*t._value[r+s];for(let t=0;t<e;t++)s._value[o*e+t]=s._value[o*e+t]-a*s._value[r+t]}}return s}invLU(){if(!this.isSquare())throw new MatrixException("Inverse matrix only define square matrix.",this);const[t,e]=this.lu();return e.invUpperTriangular().dot(t.invLowerTriangular())}sqrt(){if(!this.isSquare())throw new MatrixException("sqrt only define square matrix.",this);switch(this.rows){case 0:return this;case 1:return new Matrix(1,1,[Math.sqrt(this._value[0])])}if(this.isDiag())return Matrix.diag(this.diag().map(Math.sqrt));const[t,e]=this.eigen(),s=new Matrix(this.rows,this.cols);for(let e=0;e<this.rows;e++)s._value[e*this.cols+e]=Math.sqrt(t[e]);return e.dot(s).dot(e.transpose())}power(t){if(!this.isSquare())throw new MatrixException("Only square matrix can power.",this);const e=this.rows;if(this.isDiag(1e-12))return Matrix.diag(this.diag().map((e=>Math.pow(e,t))));if(Number.isInteger(t)){if(0===t)return Matrix.eye(e,e);if(1===t)return this.copy();if(2===t)return this.dot(this);if(-1===t)return this.inv();if(t<0)return this.inv().power(-t);if(!this.isSymmetric(1e-12)){let e=this.dot(this);for(let s=2;s<t;s++)e=e.dot(this);return e}const[s,i]=this.eigen(),r=Matrix.diag(s.map((e=>Math.pow(e,t))));return i.dot(r).dot(i.t)}if(t<0)return this.inv().power(-t);if(.5===t)return this.sqrt();throw new MatrixException("Power only defined integer.")}exp(){if(!this.isSquare())throw new MatrixException("Only square matrix can exp.",this);if(1===this.rows)return new Matrix(1,1,Math.exp(this._value[0]));if(this.isDiag())return Matrix.diag(this.diag().map(Math.exp));const t=Matrix.eye(this.rows,this.cols);let e=1,s=1,i=this;const r=10**(Math.floor(Math.log(Math.abs(this.trace())))-8);for(;;){const o=Matrix.div(i,e);if(t.add(o),o.norm()<r)break;i=i.dot(this),s++,e*=s}return t}log(){if(!this.isSquare())throw new MatrixException("Only square matrix can log.",this);if(1===this.rows)return new Matrix(1,1,Math.log(this._value[0]));if(this.isDiag())return Matrix.diag(this.diag().map(Math.log));const[t,e]=this.eigen(),s=e.inv();return e.dot(Matrix.diag(t.map(Math.log))).dot(s)}cov(t=0){const e=new Matrix(this.cols,this.cols),s=[];for(let i=0;i<this.cols;i++){let r=0;for(let t=i;t<this.length;t+=this.cols)r+=this._value[t];s[i]=r/this.rows;for(let r=0;r<=i;r++){let o=0;for(let t=0;t<this.length;t+=this.cols)o+=(this._value[i+t]-s[i])*(this._value[r+t]-s[r]);e._value[i*this.cols+r]=e._value[r*this.cols+i]=o/(this.rows-t)}}return e}gram(){return this.tDot(this)}solve(t){if(this.rows>this.cols)throw new MatrixException("Only square matrix or matrix with more columns than rows can be solved.",this);const e=this.rows;if(e!==t.rows)throw new MatrixException("b size is invalid.",[this,t]);const s=e<this.cols?Matrix.resize(this,e,e):this;let i;switch(e){case 0:i=s;break;case 1:i=Matrix.map(t,(t=>t/s._value[0]));break;default:{const[e,r]=s.lu(),o=e.solveLowerTriangular(t);i=r.solveUpperTriangular(o);break}}return e<this.cols&&i.resize(this.cols,i.cols),i}solveLowerTriangular(t){if(!this.isSquare())throw new MatrixException("Only square matrix can solve.",this);const e=this.rows,s=t.cols;if(e!==t.rows)throw new MatrixException("b size is invalid.",[this,t]);const i=new Matrix(e,s);for(let r=0;r<s;r++)for(let o=0;o<e;o++){let a=t._value[o*s+r];for(let t=0;t<o;t++)a-=i._value[t*s+r]*this._value[o*e+t];i._value[o*s+r]=a/this._value[o*e+o]}return i}solveUpperTriangular(t){if(!this.isSquare())throw new MatrixException("Only square matrix can solve.",this);const e=this.rows,s=t.cols;if(e!==t.rows)throw new MatrixException("b size is invalid.",[this,t]);const i=new Matrix(e,s);for(let r=0;r<s;r++)for(let o=e-1;o>=0;o--){let a=t._value[o*s+r];for(let t=e-1;t>o;t--)a-=i._value[t*s+r]*this._value[o*e+t];i._value[o*s+r]=a/this._value[o*e+o]}return i}bidiag(){const t=this.copy(),[e,s]=[this.rows,this.cols];for(let i=0;i<Math.min(e,s);i++){let r=t.block(i,i),o=r.col(0),a=o.norm()*(o._value[0]<0?1:-1);o._value[0]-=a,o.div(o.norm());let l=o.dot(o.t);l.mult(2);let n=Matrix.eye(e-i,e-i);n.sub(l),r=n.tDot(r),o=r.row(0),o._value[0]=0,o.norm()>0&&(a=o.norm()*(o._value[1]<0?1:-1),o._value[1]-=a,o.div(o.norm())),l=o.tDot(o),l.mult(2),n=Matrix.eye(s-i,s-i),n.sub(l),r=r.dot(n),t.set(i,i,r)}return t}tridiag(){return this.tridiagHouseholder()}tridiagHouseholder(){if(!this.isSymmetric())throw new MatrixException("Tridiagonal only define symmetric matrix.",this);const t=this.copy(),e=this.cols;for(let s=0;s<e-2;s++){const i=t.block(s+1,s,e,s+1),r=i.norm()*(i._value[0]<0?1:-1);i._value[0]-=r,i.div(i.norm());const o=t.block(s+1,s+1),a=o.dot(i),l=Matrix.mult(i,i.tDot(a));l.isub(a),l.mult(2),o.sub(l.dot(i.t)),o.sub(i.dot(l.t)),t.set(s+1,s+1,o),t._value[s*e+s+1]=t._value[(s+1)*e+s]=r;for(let i=s+2;i<e;i++)t._value[s*e+i]=t._value[i*e+s]=0}return t}tridiagLanczos(t=0){if(!this.isSymmetric())throw new MatrixException("Tridiagonal only define symmetric matrix.",this);const e=this.cols;t<=0&&(t=e);let s=0,i=Matrix.zeros(e,1),r=Matrix.randn(e,1);r.div(r.norm());const o=Matrix.zeros(t,t);for(let e=0;e<t;e++){const a=this.dot(r),l=r.tDot(a).toScaler();a.sub(Matrix.mult(i,s)),a.sub(Matrix.mult(r,l)),s=a.norm(),i=r,a.div(s),r=a,o.set(e,e,l),e<t-1&&(o.set(e,e+1,s),o.set(e+1,e,s))}return o}hessenberg(){return this.hessenbergArnoldi()}hessenbergArnoldi(t=0){if(!this.isSquare())throw new MatrixException("Hessenberg only define square matrix.",this);const e=this.cols;t<=0&&(t=e);const s=Matrix.zeros(t,t),i=[Matrix.random(e,1,-1,1)];i[0].div(i[0].norm());for(let e=0;e<t;e++){const r=this.dot(i[e]);for(let t=0;t<=e;t++){const o=i[t].tDot(r).toScaler();r.sub(Matrix.mult(i[t],o)),s.set(t,e,o)}const o=r.norm();r.div(o),i[e+1]=r,e<t-1&&s.set(e+1,e,o)}return s}lu(){if(!this.isSquare())throw new MatrixException("LU decomposition only define square matrix.",this);const t=this.rows;switch(t){case 0:return[this,this];case 1:return[Matrix.ones(1,1),new Matrix(1,1,[this._value[0]])];case 2:return[new Matrix(2,2,[1,0,this._value[2]/this._value[0],1]),new Matrix(2,2,[this._value[0],this._value[1],0,this._value[3]-this._value[1]*this._value[2]/this._value[0]])]}let e=this.copy();for(let s=0;s<t;s++){const i=e._value[s*t+s];for(let r=s+1;r<t;r++){const o=e._value[r*t+s]/=i;for(let i=s+1;i<t;i++)e._value[r*t+i]-=o*e._value[s*t+i]}}let s=Matrix.eye(t,t);for(let i=0;i<t;i++)for(let r=0;r<i;r++)s._value[i*t+r]=e._value[i*t+r],e._value[i*t+r]=0;return[s,e]}qr(){const t=this.rows,e=this.cols;if(0===t||0===e)return[this,this];if(1===t)return[Matrix.ones(1,1),this];if(1===e){const t=Math.sqrt(this.tDot(this).toScaler());return[Matrix.div(this,t),new Matrix(1,1,t)]}return this.qrHouseholder()}qrGramSchmidt(){const t=this.cols,e=this.copy(),s=Matrix.eye(t,t),i=[];for(let r=0;r<t;r++){for(let o=0;o<r;o++){let a=0;for(let s=0;s<this.rows;s++)a+=this._value[s*t+r]*e._value[s*t+o];const l=s._value[o*t+r]=a/i[o]**2;for(let s=0;s<this.rows;s++)e._value[s*t+r]-=e._value[s*t+o]*l}i.push(e.col(r).norm())}return e.mult(new Matrix(1,t,i.map((t=>1/t)))),s.mult(new Matrix(t,1,i)),[e,s]}qrHouseholder(){const t=this.rows,e=this.cols,s=this.copy(),i=Matrix.eye(t,t);for(let r=0;r<Math.min(t,e)-1;r++){const e=t-r,o=s.block(r,r,t,r+1),a=o.norm()*Math.sign(o._value[0]);o._value[0]-=a;const l=o.norm();o.div(0===l?1:l);const n=new Matrix(e,e);for(let t=0;t<e;t++){const s=o._value[t];if(n._value[t*e+t]=1-2*s**2,s)for(let i=0;i<t;i++)n._value[t*e+i]=n._value[i*e+t]=-2*s*o._value[i]}s.set(r,r,n.dot(s.block(r,r))),i.set(r,0,n.dot(i.block(r,0)))}return[i.t,s]}singularValues(){const t=this.dot(this.adjoint()).eigenJacobi()[0];for(let e=0;e<t.length;e++)-1e-12<t[e]&&t[e]<0&&(t[e]=0),t[e]=Math.sqrt(t[e]);return t}svd(){return this.svdEigen()}svdEigen(){const t=Math.min(this.cols,this.rows);if(this.cols<=this.rows){const e=this.tDot(this),[s,i]=e.eigen();for(let e=0;e<t;e++)s[e]=Math.sqrt(s[e]);const r=this.dot(i);for(let e=0;e<this.rows;e++)for(let i=0;i<t;i++)r._value[e*t+i]/=s[i];return[r,s,i]}{const e=this.dot(this.t),[s,i]=e.eigen();for(let e=0;e<t;e++)s[e]=Math.sqrt(s[e]);const r=i.tDot(this);for(let e=0;e<t;e++)for(let t=0;t<this.cols;t++)r._value[e*this.cols+t]/=s[e];return[i,s,r.t]}}svdGolubKahan(){}cholesky(){return this.choleskyBanachiewicz()}choleskyBanachiewicz(){if(!this.isSymmetric(1e-15))throw new MatrixException("Cholesky decomposition only define symmetric matrix.",this);const t=this.rows,e=new Matrix(t,t);for(let s=0;s<t;s++){let i=0;for(let r=0;r<s;r++){let o=0;for(let i=0;i<r;i++)o+=e._value[s*t+i]*e._value[r*t+i];e._value[s*t+r]=(this._value[s*t+r]-o)/e._value[r*t+r],i+=e._value[s*t+r]**2}e._value[s*t+s]=Math.sqrt(this._value[s*t+s]-i)}return e}choleskyLDL(){if(!this.isSymmetric(1e-15))throw new MatrixException("Cholesky decomposition only define symmetric matrix.",this);const t=this.rows,e=[],s=Matrix.eye(t,t);for(let i=0;i<t;i++){e[i]=this._value[i*t+i];for(let r=0;r<i;r++){let o=0;for(let a=0;a<r;a++)o+=s._value[i*t+a]*s._value[r*t+a]*e[a];s._value[i*t+r]=(this._value[i*t+r]-o)/e[r],e[i]-=s._value[i*t+r]**2*e[r]}}return[s,e]}schur(){if(!this.isSquare())throw new MatrixException("Schur decomposition only define square matrix.",this);return this.schurQR()}schurQR(t="single"){if(!this.isSquare())throw new MatrixException("Schur decomposition only define square matrix.",this);const e=this.rows;let s=this.copy();const i=[];for(let t=0;t<e-2;t++){const r=s.block(t+1,t),o=r.col(0),a=o.norm()*Math.sign(o._value[0]);o._value[0]-=a;const l=o.norm();o.div(0===l?1:l),r.sub(Matrix.mult(2,o.dot(o.tDot(r)))),s.set(t+1,t,r);const n=s.slice(t+1,e,1);n.sub(Matrix.mult(2,n.dot(o).dot(o.t))),s.set(0,t+1,n),i[t]=o}let r=Matrix.eye(e,e);for(let t=e-3;t>=0;t--){const e=r.block(t+1,t+1);e.sub(Matrix.mult(2,i[t].dot(i[t].tDot(e)))),r.set(t+1,t+1,e)}for(let i=e-1;i>0;i--){let o=1e4;for(;o-- >0;){const o=s.block(e-2,e-2).eigenValues();if("no"===t){const[t,e]=s.qr();s=e.dot(t),r=r.dot(t)}else if("single"===t){const t=s.at(e-1,e-1);let a=Math.abs(o[0]-t)<Math.abs(o[1]-t)?o[0]:o[1];isNaN(a)&&(a=s.at(i,i));for(let t=0;t<e;t++)s._value[t*e+t]-=a;const[l,n]=s.qr();s=n.dot(l);for(let t=0;t<e;t++)s._value[t*e+t]+=a;r=r.dot(l)}if(Math.abs(s.at(i,i-1))<1e-8)break}}return[r,s]}eigen(){if(!this.isSquare())throw new MatrixException("Eigen values only define square matrix.",this);if(this.rows>=2&&this.isZero()){const t=Array(this.rows).fill(0);t[0]=1;const e=Matrix.eye(this.rows,this.rows);return e.set(0,0,0),[t,e]}if(this.rows<=2)return[this.eigenValues(),this.eigenVectors()];if(this.isSymmetric(1e-15))return this.eigenJacobi();{const t=this.eigenValues(),e=this.rows,s=new Matrix(e,e);for(let i=0;i<e;i++){const[,r]=this.eigenInverseIteration(t[i]);for(let t=0;t<e;t++)s._value[t*e+i]=r._value[t]}return[t,s]}}eigenValues(){if(!this.isSquare())throw new MatrixException("Eigen values only define square matrix.",this);if(this.rows>=2&&this.isZero()){const t=Array(this.rows).fill(0);return t[0]=1,t}switch(this.rows){case 0:return[];case 1:return[this._value[0]];case 2:{const t=this._value[0]+this._value[3],e=Math.sqrt(t**2-4*this.det());return[(t+e)/2,(t-e)/2]}case 3:{const t=-this.det(),e=this._value[0]*this._value[4]+this._value[0]*this._value[8]+this._value[4]*this._value[8]-this._value[5]*this._value[7]-this._value[2]*this._value[6]-this._value[1]*this._value[3],s=-this._value[0]-this._value[4]-this._value[8],i=t-e*s/3+s**3*2/27,r=(i/2)**2+((e-s**2/3)/3)**3;let[o,a]=new Complex(r).sqrt();o=o.add(-i/2),a=a.add(-i/2);const[l,n,h]=o.cbrt(),[u,c,f]=a.cbrt(),v=[l.add(u),n.add(f),h.add(c)].map((t=>Math.abs(t.imaginary)<1e-12?t.real-s/3:Number.NaN));return v.sort(((t,e)=>e-t)),v}case 4:{const t=this.det(),e=-this._value[0]*this._value[5]*this._value[10]-this._value[0]*this._value[5]*this._value[15]-this._value[0]*this._value[10]*this._value[15]-this._value[5]*this._value[10]*this._value[15]+this._value[0]*this._value[11]*this._value[14]+this._value[0]*this._value[7]*this._value[13]+this._value[0]*this._value[6]*this._value[9]+this._value[5]*this._value[11]*this._value[14]+this._value[3]*this._value[5]*this._value[12]+this._value[2]*this._value[5]*this._value[8]+this._value[7]*this._value[10]*this._value[13]+this._value[3]*this._value[10]*this._value[12]+this._value[1]*this._value[4]*this._value[10]+this._value[6]*this._value[9]*this._value[15]+this._value[2]*this._value[8]*this._value[15]+this._value[1]*this._value[4]*this._value[15]-this._value[6]*this._value[11]*this._value[13]-this._value[7]*this._value[9]*this._value[14]-this._value[2]*this._value[11]*this._value[12]-this._value[3]*this._value[8]*this._value[14]-this._value[1]*this._value[7]*this._value[12]-this._value[3]*this._value[4]*this._value[13]-this._value[1]*this._value[6]*this._value[8]-this._value[2]*this._value[4]*this._value[9],s=this._value[0]*this._value[5]+this._value[0]*this._value[10]+this._value[0]*this._value[15]+this._value[5]*this._value[10]+this._value[5]*this._value[15]+this._value[10]*this._value[15]-this._value[7]*this._value[13]-this._value[6]*this._value[9]-this._value[11]*this._value[14]-this._value[1]*this._value[4]-this._value[2]*this._value[8]-this._value[3]*this._value[12],i=-this.trace(),r=Math.cbrt(2),o=4*s*i-i**3-8*e,a=s**2-3*e*i+12*t,l=2*s**3-9*e*s*i+27*t*i**2+27*e**2-72*t*s,n=new Complex(-4*a**3+l**2).sqrt()[0].add(l).cbrt()[0],h=new Complex(i**2/4-2*s/3).add(new Complex(r*a/3).div(n)).add(n.div(3*r)).sqrt(),u=new Complex(i**2/2-4*s/3).sub(new Complex(r*a/3).div(n)).sub(n.div(3*r)),c=u.add(new Complex(o/4).div(h[1])),f=u.add(new Complex(o/4).div(h[0])),v=c.sqrt(),_=f.sqrt(),w=[new Complex(-i/4).add(v[0].div(2)).add(h[1].div(2)),new Complex(-i/4).add(v[1].div(2)).add(h[1].div(2)),new Complex(-i/4).add(_[0].div(2)).add(h[0].div(2)),new Complex(-i/4).add(_[1].div(2)).add(h[0].div(2))].map((t=>Math.abs(t.imaginary)<1e-12?t.real:Number.NaN));return w.sort(((t,e)=>e-t)),w}}return this.isSymmetric(1e-15)?this.eigenJacobi()[0]:this.eigenValuesQR()}eigenVectors(){if(!this.isSquare())throw new MatrixException("Eigen vectors only define square matrix.",this);if(this.rows>=2&&this.isZero()){const t=Matrix.eye(this.rows,this.rows);return t.set(0,0,0),t}switch(this.rows){case 0:return this;case 1:return new Matrix(1,1,[1]);case 2:{const t=this.eigenValues(),e=[-this._value[1],this._value[0]-t[0]],s=Math.sqrt(e[0]**2+e[1]**2),i=[-this._value[1],this._value[0]-t[1]],r=Math.sqrt(i[0]**2+i[1]**2);return new Matrix(2,2,[e[0]/s,i[0]/r,e[1]/s,i[1]/r])}}return this.eigen()[1]}eigenValuesBiSection(){if(!this.isSymmetric(1e-15))throw new MatrixException("eigenValuesBiSection can only use symmetric matrix.",this);const t=this.tridiag(),e=this.rows;let s=0;for(let i=0;i<e;i++){const r=Math.abs(t.at(i,i))+Math.abs(i>0?t.at(i,i-1):0)+Math.abs(i<e-1?t.at(i,i+1):0);s<r&&(s=r)}const i=s=>{const i=[1,s-t.at(0,0)];for(let r=1;r<e;r++)i[r+1]=(s-t.at(r,r))*i[r]-t.at(r,r-1)**2*i[r-1];let r=0;for(let t=1;t<i.length;t++)Math.sign(i[t-1])!==Math.sign(i[t])&&r++;return r},r=[];for(let t=1;t<=e;t++){let e=-s,o=i(e),a=s;for(;Math.abs(e-a)>1e-8;){const s=(e+a)/2,r=i(s);t<=o&&t>r?a=s:(e=s,o=r)}r.push((e+a)/2)}return r}eigenValuesLR(){if(!this.isSquare())throw new MatrixException("Eigen values only define square matrix.",this);let t=this;const e=t.rows;let s=1e5;for(;s-- >0;){const[s,i]=t.lu();t=i.dot(s);let r=0;for(let s=0;s<e;s++)for(let i=0;i<s;i++)r+=t._value[s*e+i]**2;if(r<1e-15){const e=t.diag();return e.sort(((t,e)=>e-t)),e}}throw new MatrixException("eigenValuesLR not converged.",this)}eigenValuesQR(){if(!this.isSquare())throw new MatrixException("Eigen values only define square matrix.",this);let t=this.copy();const e=[];for(let s=t.rows;s>2;s--){let i=1e6;for(;;){const r=t.block(s-2,s-2).eigenValues();if(isNaN(r[0])){e.sort(((t,e)=>e-t));for(let t=0;t<s;t++,e.push(NaN));return e}const o=t._value[t._value.length-1],a=Math.abs(r[0]-o)<Math.abs(r[1]-o)?r[0]:r[1];for(let e=0;e<s;e++)t._value[e*s+e]-=a;const[l,n]=t.qr();t=n.dot(l);for(let e=0;e<s;e++)t._value[e*s+e]=t._value[e*s+e]+a;let h=0;for(let e=(s-1)*s;e<t.length-1;e++)h+=Math.abs(t._value[e]);if(h<1e-8)break;if(i--<0)throw new MatrixException("eigenValuesQR not converged.",this)}e.push(t._value[t._value.length-1]),t.resize(s-1,s-1)}const s=t.eigenValues();return e.push(...s),e.sort(((t,e)=>e-t)),e}eigenJacobi(t=1e6){if(!this.isSymmetric(1e-15))throw new MatrixException("Jacobi method can only use symmetric matrix.",this);const e=this._value.concat(),s=Matrix.eye(this.rows,this.cols);s.add(0);let i=0;const r=this.rows;let o=t;for(;;){let t=0,a=0,l=0;for(let s=0;s<r;s++)for(let i=s+1;i<r;i++){const o=Math.abs(e[s*r+i]);o>t&&(t=o,a=s,l=i)}if(t<1e-15)break;if(t===i)break;if(o--<0){console.log(new MatrixException("eigenJacobi not converged.",[this,t]));break}i=t;const n=e[a*r+a],h=e[a*r+l],u=e[l*r+l],c=(n-u)/2,f=-h,v=Math.abs(c)/Math.sqrt(c**2+f**2);let _=Math.sqrt((1-v)/2);const w=Math.sqrt((1+v)/2);c*f<0&&(_=-_);for(let t=0;t<r;t++){const s=e[a*r+t],i=e[l*r+t];e[t*r+l]=e[l*r+t]=_*s+w*i,e[t*r+a]=e[a*r+t]=w*s-_*i}e[a*r+a]=w**2*n+_**2*u-2*_*w*h,e[a*r+l]=e[l*r+a]=_*w*(n-u)+(w**2-_**2)*h,e[l*r+l]=_**2*n+w**2*u+2*_*w*h;for(let t=0;t<r;t++){const e=s._value[t*r+a],i=s._value[t*r+l];s._value[t*r+l]=_*e+w*i,s._value[t*r+a]=w*e-_*i}}const a=[];for(let t=0;t<r;t++)a.push([t,e[t*r+t]]);a.sort(((t,e)=>e[1]-t[1]));const l=s.col(a.map((t=>t[0])));return[a.map((t=>t[1])),l]}eigenPowerIteration(){if(!this.isSquare())throw new MatrixException("Eigen vectors only define square matrix.",this);const t=this.rows;let e=Matrix.randn(t,1);e.div(e.norm());let s=1/0,i=1e4;for(;i-- >0;){const i=this.dot(e);let r=0,o=0;for(let s=0;s<t;s++)r+=i._value[s]**2,o+=i._value[s]*e._value[s];const a=r/o;i.div(i.norm());const l=Math.abs(a-s);if(l<1e-15||isNaN(l))return[a,i];e=i,s=a}throw new MatrixException("eigenPowerIteration not converged.",this)}eigenInverseIteration(t=0){if(!this.isSquare())throw new MatrixException("Eigen vectors only define square matrix.",this);const e=this.rows;let s=this.copy();for(let i=0;i<e;i++)s._value[i*e+i]=s._value[i*e+i]-t+1e-15;s=s.inv();let i=Matrix.randn(e,1);i.div(i.norm());let r=1/0,o=1e4;for(;o-- >0;){const o=s.dot(i);let a=0,l=0;for(let t=0;t<e;t++)a+=o._value[t]**2,l+=i._value[t]*o._value[t];const n=l/a;o.div(o.norm());const h=Math.abs(n-r);if(h<1e-15||isNaN(h))return[n+t,o];i=o,r=n}throw new MatrixException("eigenInverseIteration not converged.",this)}}