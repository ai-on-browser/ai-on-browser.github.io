var V=Object.defineProperty;var k=(A,t)=>V(A,"name",{value:t,configurable:!0});import q from"./complex.js";import D from"./tensor.js";const I=k((A,t)=>{const s=Math.sqrt(t),e=Math.random(),i=Math.random(),o=Math.sqrt(-2*Math.log(e))*Math.cos(2*Math.PI*i),n=Math.sqrt(-2*Math.log(e))*Math.sin(2*Math.PI*i);return[o*s+A,n*s+A]},"normal_random");export class MatrixException extends Error{static{k(this,"MatrixException")}constructor(t,s){super(t),this.value=s,this.name="MatrixException"}}export default class a{static{k(this,"Matrix")}constructor(t,s,e){e?Array.isArray(e)?Array.isArray(e[0])?this._value=e.flat():this._value=e:this._value=Array(t*s).fill(e):this._value=Array(t*s).fill(0),this._size=[t,s]}static zeros(t,s){return new a(t,s,Array(t*s).fill(0))}static ones(t,s){return new a(t,s,Array(t*s).fill(1))}static eye(t,s,e=1){const i=new a(t,s),o=Math.min(t,s);for(let n=0;n<o;n++)i._value[n*s+n]=e;return i}static random(t,s,e=0,i=1){const o=new a(t,s);for(let n=0;n<o.length;n++)o._value[n]=Math.random()*(i-e)+e;return o}static randint(t,s,e=0,i=1){const o=new a(t,s);for(let n=0;n<o.length;n++)o._value[n]=Math.floor(Math.random()*(i-e+1)+e);return o}static randn(t,s,e=0,i=1){const o=new a(t,s);if(Array.isArray(e)&&(e=new a(1,e.length,e)),Array.isArray(i)&&(i=a.fromArray(i)),!(e instanceof a)&&!(i instanceof a)){for(let h=0;h<o.length;h+=2){const l=I(e,i);o._value[h]=l[0],h+1<o.length&&(o._value[h+1]=l[1])}return o}if(e instanceof a?(e.rows===s||e.cols===1)&&(e=e.t):e=new a(1,s,e),e.cols!==s||e.rows!==1)throw new MatrixException("'myu' cols must be same as 'cols' and rows must be 1.");if(!(i instanceof a))i=a.eye(s,s,i);else if(i.rows!==s||i.cols!==s)throw new MatrixException("'sigma' cols and rows must be same as 'cols'.");const n=i.cholesky();for(let h=0;h<o.length;h+=2){const l=I(0,1);o._value[h]=l[0],h+1<o.length&&(o._value[h+1]=l[1])}const r=o.dot(n.t);return r.add(e),r}static diag(t){let s=0,e=0;for(const o of t)typeof o=="number"?(s++,e++):(s+=o.rows,e+=o.cols);const i=new a(s,e);for(let o=0,n=0,r=0;n<s;o++){const h=t[o];typeof h=="number"?(i._value[n*e+r]=h,n++,r++):(i.set(n,r,h),n+=h.rows,r+=h.cols)}return i}static fromArray(t){if(t instanceof a)return t;if(Array.isArray(t)){if(t.length===0)return new a(0,0);if(!Array.isArray(t[0]))return new a(t.length,1,t)}else return new a(1,1,t);return new a(t.length,t[0].length,t)}get dimension(){return this._size.length}get sizes(){return this._size}get length(){return this._size[0]*this._size[1]}get rows(){return this._size[0]}get cols(){return this._size[1]}get value(){return this._value}get t(){return this.transpose()}*[Symbol.iterator](){yield*this._value}toArray(){const t=[],s=this.cols;for(let e=0;e<this.length;e+=s)t.push(this._value.slice(e,e+s));return t}toScaler(){if(this.rows!==1||this.cols!==1)throw new MatrixException("The matrix cannot convert to scaler.");return this._value[0]}toString(){let t="[";for(let s=0;s<this.rows;s++){s>0&&(t+=`,
 `),t+="[";for(let e=0;e<this.cols;e++)e>0&&(t+=", "),t+=this._value[s*this.cols+e];t+="]"}return t+"]"}copy(t){return t===this?this:t?(t._size=[].concat(this._size),this._value.forEach((s,e)=>t._value[e]=s),t):new a(this.rows,this.cols,[].concat(this._value))}equals(t,s=0){if(t instanceof a){if(this._size[0]!==t._size[0]||this._size[1]!==t._size[1])return!1;for(let e=this.length-1;e>=0;e--)if(Math.abs(this._value[e]-t._value[e])>s)return!1;return!0}return!1}at(t,s){if(Array.isArray(t)&&([t,s]=t),t<0||this.rows<=t||s<0||this.cols<=s)throw new MatrixException("Index out of bounds.");return this._value[t*this.cols+s]}set(t,s,e){if(Array.isArray(t)&&(e=s,[t,s]=t),e instanceof a){if(t<0||this.rows<=t+e.rows-1||s<0||this.cols<=s+e.cols-1)throw new MatrixException("Index out of bounds.");for(let i=0;i<e.rows;i++)for(let o=0;o<e.cols;o++)this._value[(i+t)*this.cols+o+s]=e._value[i*e.cols+o];return null}else{if(t<0||this.rows<=t||s<0||this.cols<=s)throw new MatrixException("Index out of bounds.");const i=this._value[t*this.cols+s];return this._value[t*this.cols+s]=e,i}}row(t){if(Array.isArray(t)){if(typeof t[0]=="boolean"){if(t.length!==this.rows)throw new MatrixException("Length is invalid.");const e=[];for(let i=0;i<t.length;i++)t[i]&&e.push(i);t=e}if(t.some(e=>e<0||this.rows<=e))throw new MatrixException("Index out of bounds.");const s=new a(t.length,this.cols);for(let e=0;e<t.length;e++)for(let i=0;i<this.cols;i++)s._value[e*this.cols+i]=this._value[t[e]*this.cols+i];return s}else{if(t<0||this.rows<=t)throw new MatrixException("Index out of bounds.");return new a(1,this.cols,this._value.slice(t*this.cols,(t+1)*this.cols))}}col(t){if(Array.isArray(t)){if(typeof t[0]=="boolean"){if(t.length!==this.cols)throw new MatrixException("Length is invalid.");const e=[];for(let i=0;i<t.length;i++)t[i]&&e.push(i);t=e}if(t.some(e=>e<0||this.cols<=e))throw new MatrixException("Index out of bounds.");const s=new a(this.rows,t.length);for(let e=0;e<this.rows;e++)for(let i=0;i<t.length;i++)s._value[e*t.length+i]=this._value[e*this.cols+t[i]];return s}else{if(t<0||this.cols<=t)throw new MatrixException("Index out of bounds.");const s=new a(this.rows,1);for(let e=0;e<this.rows;e++)s._value[e]=this._value[e*this.cols+t];return s}}slice(t,s,e=0){if(typeof t!="number"&&(t=0),typeof s!="number"&&(s=this._size[e]),t<0||this._size[e]<t||s<0||this._size[e]<s)throw new MatrixException("Index out of bounds.");if(t>s)throw new MatrixException("'to' must be greater than or equals to 'from'.");if(e===0){const i=new a(s-t,this.cols);return i._value=this._value.slice(t*this.cols,s*this.cols),i}else if(e===1){const i=new a(this.rows,s-t);for(let o=0;o<i.rows;o++)for(let n=0;n<i.cols;n++)i._value[o*i.cols+n]=this._value[o*this.cols+n+t];return i}else throw new MatrixException("Invalid axis.")}block(t,s,e,i){if(typeof t!="number"&&(t=0),typeof s!="number"&&(s=0),typeof e!="number"&&(e=this.rows),typeof i!="number"&&(i=this.cols),t<0||this.rows<t||e<0||this.rows<e||s<0||this.cols<s||i<0||this.cols<i)throw new MatrixException("Index out of bounds.");if(t>e)throw new MatrixException("'rows_to' must be greater than or equals to 'rows_from'.");if(s>i)throw new MatrixException("'cols_to' must be greater than or equals to 'cols_from'.");const o=new a(e-t,i-s);for(let n=0;n<o.rows;n++)for(let r=0;r<o.cols;r++)o._value[n*o.cols+r]=this._value[(n+t)*this.cols+r+s];return o}remove(t,s=0){if(s===0)if(Array.isArray(t)){if(t.some(e=>e<0||this.rows<=e))throw new MatrixException("Index out of bounds.");t=[...new Set(t)],t.sort((e,i)=>i-e);for(let e=0;e<t.length;e++)this._value.splice(t[e]*this.cols,this.cols);this._size[0]-=t.length}else{if(t<0||this.rows<=t)throw new MatrixException("Index out of bounds.");this._value.splice(t*this.cols,this.cols),this._size[0]--}else if(s===1)if(Array.isArray(t)){if(t.some(o=>o<0||this.cols<=o))throw new MatrixException("Index out of bounds.");t=[...new Set(t)],t.sort((o,n)=>o-n);let e=0,i=0;for(let o=0;o<this.rows;o++)for(let n=0,r=0;n<this.cols;n++,e++){if(t[r]===n){r++;continue}this._value[i++]=this._value[e]}this._size[1]-=t.length,this._value.length=this.length}else{if(t<0||this.cols<=t)throw new MatrixException("Index out of bounds.");let e=0,i=0;for(let o=0;o<this.rows;o++)for(let n=0;n<this.cols;n++,e++)t!==n&&(this._value[i++]=this._value[e]);this._size[1]--,this._value.length=this.length}else throw new MatrixException("Invalid axis.")}removeIf(t,s=0){const e=[];if(s===0)for(let i=0;i<this.rows;i++)t(this.row(i))&&e.push(i);else if(s===1)for(let i=0;i<this.cols;i++)t(this.col(i))&&e.push(i);else throw new MatrixException("Invalid axis.");this.remove(e,s)}sample(t,s=0,e=!1){const i=this.sizes[s],o=[];if(e)for(let n=0;n<t;n++)o.push(Math.floor(Math.random()*i));else{if(t>i)throw new MatrixException("Invalid sampled size.");for(let n=0;n<t;n++)o.push(Math.floor(Math.random()*(i-n)));for(let n=t-1;n>=0;n--)for(let r=t-1;r>n;r--)o[n]<=o[r]&&o[r]++}if(s===0)return[this.row(o),o];if(s===1)return[this.col(o),o];throw new MatrixException("Invalid axis.")}fill(t){this._value.fill(t)}map(t){for(let s=0,e=0;s<this._size[0];s++)for(let i=0;i<this._size[1];i++,e++)this._value[e]=t(this._value[e],[s,i],this)}static map(t,s){const e=new a(t.rows,t.cols);for(let i=0,o=0;i<t._size[0];i++)for(let n=0;n<t._size[1];n++,o++)e._value[o]=s(t._value[o],[i,n],t);return e}forEach(t){for(let s=0,e=0;s<this._size[0];s++)for(let i=0;i<this._size[1];i++,e++)t(this._value[e],[s,i],this)}transpose(){const t=new a(this.cols,this.rows);for(let s=0;s<this.rows;s++)for(let e=0;e<this.cols;e++)t._value[e*this.rows+s]=this._value[s*this.cols+e];return t}adjoint(){return this.transpose()}flip(t=0){if(t===0)for(let s=0;s<this.rows/2;s++){const e=(this.rows-s-1)*this.cols;for(let i=0;i<this.cols;i++){const o=this._value[s*this.cols+i];this._value[s*this.cols+i]=this._value[e+i],this._value[e+i]=o}}else if(t===1)for(let s=0;s<this.cols/2;s++){const e=this.cols-s-1;for(let i=0;i<this.rows;i++){const o=this._value[i*this.cols+s];this._value[i*this.cols+s]=this._value[i*this.cols+e],this._value[i*this.cols+e]=o}}else throw new MatrixException("Invalid axis.")}swap(t,s,e=0){if(e===0){if(t<0||s<0||this.rows<=t||this.rows<=s)throw new MatrixException("Index out of bounds.");const i=(s-t)*this.cols;for(let o=t*this.cols;o<(t+1)*this.cols;o++)[this._value[o],this._value[o+i]]=[this._value[o+i],this._value[o]]}else if(e===1){if(t<0||s<0||this.cols<=t||this.cols<=s)throw new MatrixException("Index out of bounds.");const i=s-t;for(let o=t;o<this.length;o+=this.cols)[this._value[o],this._value[o+i]]=[this._value[o+i],this._value[o]]}else throw new MatrixException("Invalid axis.")}sort(t=0){if(t===0){const s=Array.from({length:this.rows},(e,i)=>i);return s.sort((e,i)=>{const o=e*this.cols,n=i*this.cols;for(let r=0;r<this.cols;r++){const h=this._value[o+r],l=this._value[n+r],u=h-l;if(u!==0)return u}return 0}),this._value=this.row(s)._value,s}else if(t===1){const s=Array.from({length:this.cols},(e,i)=>i);return s.sort((e,i)=>{for(let o=0;o<this.rows;o++){const n=this._value[e+o*this.cols],r=this._value[i+o*this.cols],h=n-r;if(h!==0)return h}return 0}),this._value=this.col(s)._value,s}throw new MatrixException("Invalid axis.")}shuffle(t=0){const s=Array.from({length:this._size[t]},(e,i)=>i);for(let e=s.length-1;e>0;e--){const i=Math.floor(Math.random()*(e+1));[s[e],s[i]]=[s[i],s[e]]}if(t===0)this._value=this.row(s)._value;else if(t===1)this._value=this.col(s)._value;else throw new MatrixException("Invalid axis.");return s}unique(t=0,s=0){const e=[];if(t===0){let i=0;for(let o=0;o<this.rows;o++){let n=-1;for(let r=0;r<o;r++){let h=!0;for(let l=0;h&&l<this.cols;l++)Math.abs(this._value[o*this.cols+l]-this._value[r*this.cols+l])>s&&(h=!1);if(h){n=r;break}}if(n<0){for(let r=0;r<this.cols;r++)this._value[i*this.cols+r]=this._value[o*this.cols+r];e.push(o),i++}}this._size[0]=i,this._value.length=this.length}else if(t===1){for(let i=0;i<this.cols;i++){let o=!1;for(let n=0;!o&&n<e.length;n++){o=!0;for(let r=0;o&&r<this.rows;r++)Math.abs(this._value[r*this.cols+i]-this._value[r*this.cols+e[n]])>s&&(o=!1)}o||e.push(i)}for(let i=0,o=0;i<this.rows;i++)for(let n=0;n<e.length;n++,o++)this._value[o]=this._value[i*this.cols+e[n]];this._size[1]=e.length,this._value.length=this.length}else throw new MatrixException("Invalid axis.");return e}resize(t,s,e=0){const i=Array(t*s).fill(e),o=Math.min(this.rows,t),n=Math.min(this.cols,s);for(let r=0;r<o;r++)for(let h=0;h<n;h++)i[r*s+h]=this._value[r*this.cols+h];this._value=i,this._size=[t,s]}static resize(t,s,e,i=0){const o=new a(s,e);o.fill(i);const n=Math.min(t.rows,s),r=Math.min(t.cols,e);for(let h=0;h<n;h++)for(let l=0;l<r;l++)o._value[h*e+l]=t._value[h*t.cols+l];return o}reshape(t,s){if(t===-1){if(this.length%s!==0)throw new MatrixException("Length is different.");t=this.length/s}else if(s===-1){if(this.length%t!==0)throw new MatrixException("Length is different.");s=this.length/t}else if(this.length!==t*s)throw new MatrixException("Length is different.");this._size=[t,s]}repeat(t,s=0){if(Array.isArray(t)){if(t.length<this._size.length)for(let n=t.length;n<this._size.length;n++)t[n]=1}else{const n=Array(this._size.length).fill(1);n[s]=t,t=n}const e=t.reduce((n,r)=>n*r,1);if(e===1)return;const i=Array(this.length*e),o=this._size.map((n,r)=>n*t[r]);for(let n=0;n<o[0];n++)for(let r=0;r<o[1];r++)i[n*o[1]+r]=this._value[n%this.rows*this.cols+r%this.cols];this._value=i,this._size=o}static repeat(t,s,e=0){const i=t.copy();return i.repeat(s,e),i}concat(t,s=0){if(s===0){if(this.cols!==t.cols)throw new MatrixException("Size is different.");this._value=[].concat(this._value,t._value),this._size[0]+=t.rows}else if(s===1){if(this.rows!==t.rows)throw new MatrixException("Size is different.");const e=this.cols;this.resize(this.rows,this.cols+t.cols);for(let i=0;i<this.rows;i++)for(let o=0;o<t.cols;o++)this._value[i*this.cols+o+e]=t._value[i*t.cols+o]}else throw new MatrixException("Invalid axis.")}static concat(t,s,e=0){const i=t.copy();return i.concat(s,e),i}reduce(t,s,e=-1,i=null){if(Array.isArray(e))if(e.includes(-1)||e.includes(0)&&e.includes(1))e=-1;else if(e.includes(0))e=0;else if(e.includes(1))e=1;else throw new MatrixException("Invalid axis.");if(e>1)throw new MatrixException("Invalid axis.");if(e<0){let l=s??this._value[0];for(let u=0,c=0;u<this._size[0];u++)for(let f=0;f<this._size[1];f++,c++)c===0&&s==null||(l=t(l,this._value[c],[u,f],this));return i===!0?new a(1,1,l):l}if(i===!1)throw new MatrixException("keepdims only accept true if axis >= 0.");let o=e===0?1:this.cols,n=e===0?this.cols:1;const r=[].concat(this._size);r[e]=1;const h=a.zeros(...r);for(let l=0,u=0;l<h.length;l++,u+=o){let c=s??this._value[u];for(let f=c===s?0:1;f<this._size[e];f++)c=t(c,this._value[f*n+u],e===0?[f,l]:[l,f],this);h._value[l]=c}return h}every(t,s=-1){return this.reduce((e,i,o,n)=>e&&t(i,o,n),!0,s)}some(t,s=-1){return this.reduce((e,i,o,n)=>e||t(i,o,n),!1,s)}max(t=-1){return this.reduce((s,e)=>Math.max(s,e),-1/0,t)}min(t=-1){return this.reduce((s,e)=>Math.min(s,e),1/0,t)}median(t=-1){if(t<0){const n=this._value.concat();return n.sort((r,h)=>r-h),n.length%2===1?n[(n.length-1)/2]:(n[n.length/2]+n[n.length/2-1])/2}let s=t===0?1:this.cols,e=t===0?this.cols:1;const i=[].concat(this._size);i[t]=1;const o=a.zeros(...i);for(let n=0,r=0;n<o.length;n++,r+=s){const h=[];for(let l=0;l<this._size[t];l++)h.push(this._value[l*e+r]);h.sort((l,u)=>l-u),h.length%2===1?o._value[n]=h[(h.length-1)/2]:o._value[n]=(h[h.length/2]+h[h.length/2-1])/2}return o}quantile(t,s=-1){if(t===0)return this.min(s);if(t===1)return this.max(s);const e=k((r,h)=>{if(r.sort((c,f)=>c-f),r.length===1)return r[0];const l=h*(r.length-1),u=Math.floor(l);return l===u?r[u]:r[u]*(1-l+u)+r[u+1]*(l-u)},"quantile");if(s<0){const r=this._value.concat();return e(r,t)}const i=s===0?1:this.cols,o=s===0?this.cols:1,n=a.zeros(...this._size.map((r,h)=>h===s?1:r));for(let r=0,h=0;r<n.length;r++,h+=i){const l=[];for(let u=0;u<this._size[s];u++)l.push(this._value[u*o+h]);n._value[r]=e(l,t)}return n}argmax(t){let s=t===0?1:this.cols,e=t===0?this.cols:1;const i=[].concat(this._size);i[t]=1;const o=a.zeros(...i);for(let n=0,r=0;n<o.length;n++,r+=s){let h=this._value[r],l=0;for(let u=1;u<this._size[t];u++){let c=this._value[u*e+r];c>h&&(h=c,l=u)}o._value[n]=l}return o}argmin(t){let s=t===0?1:this.cols,e=t===0?this.cols:1;const i=[].concat(this._size);i[t]=1;const o=a.zeros(...i);for(let n=0,r=0;n<o.length;n++,r+=s){let h=this._value[r],l=0;for(let u=1;u<this._size[t];u++){let c=this._value[u*e+r];c<h&&(h=c,l=u)}o._value[n]=l}return o}sum(t=-1){return this.reduce((s,e)=>s+e,0,t)}mean(t=-1){if(t<0)return this.sum(t)/this.length;let s=this.sum(t);return s.div(this._size[t]),s}prod(t=-1){return this.reduce((s,e)=>s*e,1,t)}variance(t=-1,s=0){const e=this.mean(t);if(t<0)return this._value.reduce((h,l)=>h+(l-e)**2,0)/(this.length-s);let i=t===0?1:this.cols,o=t===0?this.cols:1;const n=[].concat(this._size);n[t]=1;const r=a.zeros(...n);for(let h=0,l=0;h<r.length;h++,l+=i){let u=0;for(let c=0;c<this._size[t];c++)u+=(this._value[c*o+l]-e._value[h])**2;r._value[h]=u/(this._size[t]-s)}return r}std(t=-1,s=0){if(t<0)return Math.sqrt(this.variance(t,s));let e=this.variance(t,s);for(let i=0;i<e.length;i++)e._value[i]=Math.sqrt(e._value[i]);return e}isSquare(){return this.rows===this.cols}isDiag(t=0){const s=this.cols;for(let e=0;e<this.rows;e++)for(let i=0;i<s;i++)if(e!==i&&Math.abs(this._value[e*s+i])>t)return!1;return!0}isIdentity(t=0){if(!this.isSquare())return!1;const s=this.cols;for(let e=0;e<this.rows;e++)for(let i=0;i<s;i++)if(e!==i){if(Math.abs(this._value[e*s+i])>t)return!1}else if(Math.abs(this._value[e*s+i]-1)>t)return!1;return!0}isZero(t=0){const s=this.length;for(let e=0;e<s;e++)if(Math.abs(this._value[e])>t)return!1;return!0}isTriangular(t=0){return this.isLowerTriangular(t)||this.isUpperTriangular(t)}isLowerTriangular(t=0){const s=this.cols;for(let e=0;e<this.rows;e++)for(let i=e+1;i<s;i++)if(Math.abs(this._value[e*s+i])>t)return!1;return!0}isUpperTriangular(t=0){for(let s=0;s<this.rows;s++)for(let e=0;e<Math.min(s,this.cols);e++)if(Math.abs(this._value[s*this.cols+e])>t)return!1;return!0}isSymmetric(t=0){if(!this.isSquare())return!1;const s=this.cols;for(let e=0;e<this.rows;e++)for(let i=0;i<e;i++)if(t>0){if(Math.abs(this._value[e*s+i]-this._value[i*s+e])>t)return!1}else if(this._value[e*s+i]!==this._value[i*s+e])return!1;return!0}isHermitian(t=0){return this.isSymmetric(t)}isAlternating(t=0){if(!this.isSquare())return!1;const s=this.cols;for(let e=0;e<this.rows;e++)for(let i=0;i<e;i++)if(t>0){if(Math.abs(this._value[e*s+i]+this._value[i*s+e])>t)return!1}else if(this._value[e*s+i]!==-this._value[i*s+e])return!1;return!0}isSkewHermitian(t=0){return this.isAlternating(t)}isRegular(t=0){return this.isSquare()?Math.abs(this.det())<=t:!1}isNormal(t=0){return this.dot(this.t).equals(this.tDot(this),t)}isOrthogonal(t=0){const s=this.tDot(this);for(let e=0;e<this.rows;e++)for(let i=0;i<this.cols;i++){const o=s._value[e*this.cols+i];if(e===i){if(Math.abs(o-1)>t)return!1}else if(Math.abs(o)>t)return!1}return!0}isUnitary(t=0){return this.isOrthogonal(t)}isNilpotent(t=0){if(!this.isSquare())return!1;const s=this.eigenValues();for(let e=0;e<s.length;e++)if(isNaN(s[e])||Math.abs(s[e])>t)return!1;return!0}diag(){let t=[];const s=Math.min(this.rows,this.cols);for(let e=0;e<s;e++)t.push(this._value[e*this.cols+e]);return t}trace(){let t=0;const s=Math.min(this.rows,this.cols);for(let e=0;e<s;e++)t+=this._value[e*this.cols+e];return t}norm(t=2){return this.normEntrywise(t)}normInduced(t=2){if(t===1){let s=-1/0;for(let e=0;e<this.cols;e++){let i=0;for(let o=0;o<this.rows;o++)i+=Math.abs(this._value[o*this.cols+e]);s=Math.max(s,i)}return s}else if(t===1/0){let s=-1/0;for(let e=0;e<this.rows;e++){let i=0;for(let o=0;o<this.cols;o++)i+=Math.abs(this._value[e*this.cols+o]);s=Math.max(s,i)}return s}else if(t===2)return this.normSpectral();throw new MatrixException("Not implemented")}normSpectral(){return this.singularValues()[0]}normEntrywise(t=2){if(t===1/0)return this.normMax();if(t===2)return this.normFrobenius();let s=0;for(let e=0;e<this.length;e++)s+=Math.abs(this._value[e])**t;return s**(1/t)}normFrobenius(){let t=0;for(let s=0;s<this.length;s++)t+=Math.abs(this._value[s])**2;return Math.sqrt(t)}normMax(){let t=-1/0;for(let s=0;s<this.length;s++)t=Math.max(t,Math.abs(this._value[s]));return t}normSchatten(t=2){if(t===1/0)return this.normSpectral();if(t===1)return this.normNuclear();const s=this.singularValues(),e=Math.min(this.rows,this.cols);let i=0;for(let o=0;o<e;o++)i+=s[o]**t;return i**(1/t)}normNuclear(){const t=this.singularValues(),s=Math.min(this.rows,this.cols);let e=0;for(let i=0;i<s;i++)e+=t[i];return e}rank(t=0){const s=this.copy();let e=0;for(let i=0;e<s.rows&&i<s.cols;i++,e++){if(Math.abs(s._value[e*s.cols+i])<=t){for(let n=e+1;n<s.rows;n++)if(Math.abs(s._value[n*s.cols+i])>t){s.swap(e,n,0);break}}if(Math.abs(s._value[e*s.cols+i])<=t){e--;continue}const o=s._value[e*s.cols+i];for(let n=e+1;n<s.rows;n++){const r=s._value[n*s.cols+i];for(let h=i+1;h<s.cols;h++)s._value[n*s.cols+h]-=r*s._value[e*s.cols+h]/o}}return e}det(){if(!this.isSquare())throw new MatrixException("Determine only define square matrix.",this);const t=this._value;switch(this.rows){case 0:return 0;case 1:return t[0];case 2:return t[0]*t[3]-t[1]*t[2];case 3:return t[0]*t[4]*t[8]+t[1]*t[5]*t[6]+t[2]*t[3]*t[7]-t[0]*t[5]*t[7]-t[1]*t[3]*t[8]-t[2]*t[4]*t[6];case 4:return t[0]*t[5]*t[10]*t[15]+t[0]*t[6]*t[11]*t[13]+t[0]*t[7]*t[9]*t[14]-t[0]*t[7]*t[10]*t[13]-t[0]*t[6]*t[9]*t[15]-t[0]*t[5]*t[11]*t[14]-t[1]*t[4]*t[10]*t[15]-t[2]*t[4]*t[11]*t[13]-t[3]*t[4]*t[9]*t[14]+t[3]*t[4]*t[10]*t[13]+t[2]*t[4]*t[9]*t[15]+t[1]*t[4]*t[11]*t[14]+t[1]*t[6]*t[8]*t[15]+t[2]*t[7]*t[8]*t[13]+t[3]*t[5]*t[8]*t[14]-t[3]*t[6]*t[8]*t[13]-t[2]*t[5]*t[8]*t[15]-t[1]*t[7]*t[8]*t[14]-t[1]*t[6]*t[11]*t[12]-t[2]*t[7]*t[9]*t[12]-t[3]*t[5]*t[10]*t[12]+t[3]*t[6]*t[9]*t[12]+t[2]*t[5]*t[11]*t[12]+t[1]*t[7]*t[10]*t[12]}const[s,e]=this.lu();let i=1;for(let o=0;o<this.rows;o++){const n=o*this.cols+o;i*=s._value[n]*e._value[n]}return i}spectralRadius(){if(!this.isSquare())throw new MatrixException("Spectral radius only define square matrix.",this);const t=this.eigenValues();let s=0;for(let e=0;e<t.length;e++)s=Math.max(s,Math.abs(t[e]));return s}negative(){this.map(t=>-t)}not(){this.map(t=>+!t)}bitnot(){this.map(t=>~t)}abs(){this.map(Math.abs)}round(){this.map(Math.round)}floor(){this.map(Math.floor)}ceil(){this.map(Math.ceil)}leftShift(t){this.map(s=>s<<t)}signedRightShift(t){this.map(s=>s>>t)}unsignedRightShift(t){this.map(s=>s>>>t)}broadcastOperate(t,s){if(t instanceof a||t instanceof D){if(t.dimension>2)throw new MatrixException(`Broadcasting size invalid. this: ${this.sizes}, other: ${t.sizes}`,[this,t]);const e=t.dimension===2?t.sizes:[1,t.length];if(this.rows===e[0]&&this.cols===e[1])for(let i=this.length-1;i>=0;i--)this._value[i]=s(this._value[i],t._value[i]);else{const i=[1,1];for(let o=0;o<2;o++)if(this._size[o]<e[o]){if(e[o]%this._size[o]!==0)throw new MatrixException(`Broadcasting size invalid. this: ${this.sizes}, other: ${t.sizes}`,[this,t]);i[o]=e[o]/this._size[o]}else if(this._size[o]%e[o]!==0)throw new MatrixException(`Broadcasting size invalid. this: ${this.sizes}, other: ${t.sizes}`,[this,t]);i.some(o=>o>1)&&this.repeat(i);for(let o=0,n=0;o<this.rows;o++){const r=o%e[0];for(let h=0;h<this.cols;h++,n++)this._value[n]=s(this._value[n],t._value[r*e[1]+h%e[1]])}}}else this.map(e=>s(e,t))}operateAt(t,s,e){if(Array.isArray(t)&&(e=s,[t,s]=t),t<0||this.rows<=t||s<0||this.cols<=s)throw new MatrixException("Index out of bounds.");const i=this._value[t*this.cols+s];return this._value[t*this.cols+s]=e(i),i}add(t){this.broadcastOperate(t,(s,e)=>s+e)}addAt(t,s,e){return this.operateAt(t,s,i=>i+e)}static add(t,s){if(t instanceof a){const e=t.copy();return e.add(s),e}else if(s instanceof a){const e=s.copy();return e.add(t),e}return new a(1,1,t+s)}sub(t){this.broadcastOperate(t,(s,e)=>s-e)}isub(t){this.negative(),this.add(t)}subAt(t,s,e){return this.operateAt(t,s,i=>i-e)}isubAt(t,s,e){return this.operateAt(t,s,i=>e-i)}static sub(t,s){if(t instanceof a){const e=t.copy();return e.sub(s),e}else if(s instanceof a){const e=s.copy();return e.isub(t),e}return new a(1,1,t-s)}mult(t){this.broadcastOperate(t,(s,e)=>s*e)}multAt(t,s,e){return this.operateAt(t,s,i=>i*e)}static mult(t,s){if(t instanceof a){const e=t.copy();return e.mult(s),e}else if(s instanceof a){const e=s.copy();return e.mult(t),e}return new a(1,1,t*s)}div(t){this.broadcastOperate(t,(s,e)=>s/e)}idiv(t){this.broadcastOperate(t,(s,e)=>e/s)}divAt(t,s,e){return this.operateAt(t,s,i=>i/e)}idivAt(t,s,e){return this.operateAt(t,s,i=>e/i)}static div(t,s){if(t instanceof a){const e=t.copy();return e.div(s),e}else if(s instanceof a){const e=s.copy();return e.idiv(t),e}return new a(1,1,t/s)}mod(t){this.broadcastOperate(t,(s,e)=>s%e)}imod(t){this.broadcastOperate(t,(s,e)=>e%s)}modAt(t,s,e){return this.operateAt(t,s,i=>i%e)}imodAt(t,s,e){return this.operateAt(t,s,i=>e%i)}static mod(t,s){if(t instanceof a){const e=t.copy();return e.mod(s),e}else if(s instanceof a){const e=s.copy();return e.imod(t),e}return new a(1,1,t%s)}and(t){this.broadcastOperate(t,(s,e)=>+(!!s&&!!e))}andAt(t,s,e){return this.operateAt(t,s,i=>+(!!i&&!!e))}static and(t,s){if(t instanceof a){const e=t.copy();return e.and(s),e}else if(s instanceof a){const e=s.copy();return e.and(t),e}return new a(1,1,+(!!t&&!!s))}or(t){this.broadcastOperate(t,(s,e)=>+(!!s||!!e))}orAt(t,s,e){return this.operateAt(t,s,i=>+(!!i||!!e))}static or(t,s){if(t instanceof a){const e=t.copy();return e.or(s),e}else if(s instanceof a){const e=s.copy();return e.or(t),e}return new a(1,1,+(!!t||!!s))}bitand(t){this.broadcastOperate(t,(s,e)=>+(s&e))}bitandAt(t,s,e){return this.operateAt(t,s,i=>+(i&e))}static bitand(t,s){if(t instanceof a){const e=t.copy();return e.bitand(s),e}else if(s instanceof a){const e=s.copy();return e.bitand(t),e}return new a(1,1,+(t&s))}bitor(t){this.broadcastOperate(t,(s,e)=>+(s|e))}bitorAt(t,s,e){return this.operateAt(t,s,i=>+(i|e))}static bitor(t,s){if(t instanceof a){const e=t.copy();return e.bitor(s),e}else if(s instanceof a){const e=s.copy();return e.bitor(t),e}return new a(1,1,+(t|s))}bitxor(t){this.broadcastOperate(t,(s,e)=>+(s^e))}bitxorAt(t,s,e){return this.operateAt(t,s,i=>+(i^e))}static bitxor(t,s){if(t instanceof a){const e=t.copy();return e.bitxor(s),e}else if(s instanceof a){const e=s.copy();return e.bitxor(t),e}return new a(1,1,+(t^s))}dot(t){if(this.cols!==t.rows)throw new MatrixException(`Dot size invalid. left = [${this.rows}, ${this.cols}], right = [${t.rows}, ${t.cols}]`);const s=t.cols,e=new a(this.rows,s);let i=0;const o=this.length,n=t.length,r=this.cols,h=this._value,l=t._value,u=e._value;for(let c=0;c<o;c+=r){let f=0,w=0;for(let v=0,d=c;v<n;v+=s,d++)h[d]&&w++,f+=h[d]*l[v];if(u[i++]=f,w===0){i+=s-1;continue}else if(w/r<.1){let v=[],d=[];for(let _=0;_<r;_++)h[c+_]&&(v.push(h[c+_]),d.push(_));for(let _=1;_<s;_++){f=0;for(let y=0;y<v.length;y++)f+=v[y]*l[d[y]*s+_];u[i++]=f}}else for(let v=1;v<s;v++){f=0;for(let d=v,_=c;d<n;d+=s,_++)f+=h[_]*l[d];u[i++]=f}}return e}tDot(t){if(this.rows!==t.rows)throw new MatrixException(`tDot size invalid. left = [${this.cols}, ${this.rows}], right = [${t.rows}, ${t.cols}]`);const s=new a(this.cols,t.cols);let e=0;for(let i=0;i<this.cols;i++)for(let o=0;o<t.cols;o++){let n=0,r=i;for(let h=o;h<t.length;h+=t.cols,r+=this.cols)n+=this._value[r]*t._value[h];s._value[e++]=n}return s}kron(t){const s=new a(this.rows*t.rows,this.cols*t.cols);for(let e=0;e<this.rows;e++)for(let i=0;i<this.cols;i++)for(let o=0;o<t.rows;o++)for(let n=0;n<t.cols;n++)s._value[(e*t.rows+o)*this.cols*t.cols+i*t.cols+n]=this._value[e*this.cols+i]*t._value[o*t.cols+n];return s}convolute(t,s=!0){const e=[Math.floor((t.length-1)/2),Math.floor((t[0].length-1)/2)],i=this._value.concat();for(let o=0;o<this.rows;o++)for(let n=0;n<this.cols;n++){let r=0,h=0;for(let l=0;l<t.length;l++){const u=o+l-e[0];if(!(u<0||this.rows<=u))for(let c=0;c<t[l].length;c++){const f=n+c-e[1];f<0||this.cols<=f||(r+=t[l][c]*i[u*this.cols+f],h+=t[l][c])}}s&&(r/=h),this._value[o*this.cols+n]=r}}reducedRowEchelonForm(t=0){for(let s=0,e=0;s<this.rows&&e<this.cols;e++,s++){if(Math.abs(this._value[s*this.cols+e])<=t){for(let o=s+1;o<this.rows;o++)if(Math.abs(this._value[o*this.cols+e])>t){this.swap(s,o,0);break}}if(Math.abs(this._value[s*this.cols+e])<=t){s--;continue}const i=this._value[s*this.cols+e];this._value[s*this.cols+e]=1;for(let o=e+1;o<this.cols;o++)this._value[s*this.cols+o]/=i;for(let o=0;o<this.rows;o++){if(o===s)continue;const n=this._value[o*this.cols+e];this._value[o*this.cols+e]=0;for(let r=e+1;r<this.cols;r++)this._value[o*this.cols+r]-=n*this._value[s*this.cols+r]}}}inv(){if(!this.isSquare())throw new MatrixException("Inverse matrix only define square matrix.",this);const t=this._value;switch(this.rows){case 0:return new a(0,0);case 1:return new a(1,1,[1/t[0]]);case 2:{const s=this.det();return new a(2,2,[t[3]/s,-t[1]/s,-t[2]/s,t[0]/s])}case 3:{const s=this.det();return new a(3,3,[(t[4]*t[8]-t[5]*t[7])/s,(t[2]*t[7]-t[1]*t[8])/s,(t[1]*t[5]-t[2]*t[4])/s,(t[5]*t[6]-t[3]*t[8])/s,(t[0]*t[8]-t[2]*t[6])/s,(t[2]*t[3]-t[0]*t[5])/s,(t[3]*t[7]-t[4]*t[6])/s,(t[1]*t[6]-t[0]*t[7])/s,(t[0]*t[4]-t[1]*t[3])/s])}}return this.isLowerTriangular()?this.invLowerTriangular():this.isUpperTriangular()?this.invUpperTriangular():this.invLU()}invLowerTriangular(){if(!this.isSquare())throw new MatrixException("Inverse matrix only define square matrix.",this);const t=this._value,s=new a(this.rows,this.cols);for(let e=0;e<this.rows;e++){const i=t[e*this.cols+e];s._value[e*this.cols+e]=1/i;for(let o=0;o<e;o++){let n=0;for(let r=o;r<e;r++)n+=t[e*this.cols+r]*s._value[r*this.cols+o];s._value[e*this.cols+o]=-n/i}}return s}invUpperTriangular(){if(!this.isSquare())throw new MatrixException("Inverse matrix only define square matrix.",this);const t=this._value,s=new a(this.rows,this.cols);for(let e=this.cols-1;e>=0;e--){const i=t[e*this.cols+e];s._value[e*this.cols+e]=1/i;for(let o=e+1;o<this.cols;o++){let n=0;for(let r=e+1;r<=o;r++)n+=t[e*this.cols+r]*s._value[r*this.cols+o];s._value[e*this.cols+o]=-n/i}}return s}invRowReduction(){if(!this.isSquare())throw new MatrixException("Inverse matrix only define square matrix.",this);const t=this.copy(),s=this.rows,e=a.eye(s,s);for(let i=0;i<s;i++){const o=i*s;if(t._value[o+i]===0){let r=i+1;for(;r<s&&t._value[r*s+i]===0;r++);if(r===s)throw new MatrixException("",this);for(let h=i;h<s;h++)[t._value[o+h],t._value[r*s+h]]=[t._value[r*s+h],t._value[o+h]];e.swap(i,r)}const n=t._value[o+i];t._value[o+i]=1;for(let r=i+1;r<s;r++)t._value[o+r]/=n;for(let r=0;r<s;r++)e._value[o+r]=e._value[o+r]/n;for(let r=0;r<s;r++){if(i===r)continue;const h=t._value[r*s+i];t._value[r*s+i]=0;for(let l=i+1;l<s;l++)t._value[r*s+l]-=h*t._value[o+l];for(let l=0;l<s;l++)e._value[r*s+l]=e._value[r*s+l]-h*e._value[o+l]}}return e}invLU(){if(!this.isSquare())throw new MatrixException("Inverse matrix only define square matrix.",this);const[t,s]=this.lu();return s.invUpperTriangular().dot(t.invLowerTriangular())}pseudoInv(){const t=this.rows,s=this.cols,e=this._value;if(t===0||s===0)return new a(s,t);if(t===1&&s===1)return new a(1,1,e[0]===0?0:1/e[0]);if(t===1||s===1){const i=e.reduce((o,n)=>o+n**2,0);return i===0?new a(s,t):new a(s,t,e.map(o=>o/i))}else if(t===2&&s===2){if(this.det()!==0)return this.inv();const o=e.reduce((n,r)=>n+r**2,0);return o===0?new a(s,t):new a(s,t,e.map(n=>n/o))}return this.pseudoInvQR()}pseudoInvNaive(){const t=this.rows<this.cols?this.adjoint():this,s=t.tDot(t).solve(t.adjoint());return this.rows<this.cols?s.adjoint():s}pseudoInvQR(){const t=this.rows<this.cols?this.adjoint():this,[,s]=t.qr(),e=s.adjoint().solveLowerTriangular(t.adjoint());s.resize(t.rows,t.rows,1);const i=s.solveUpperTriangular(e);return i.resize(t.cols,t.rows),this.rows<this.cols?i.adjoint():i}pseudoInvSVD(){const[t,s,e]=this.svd();return e.dot(a.diag(s.map(i=>i===0?0:1/i))).dot(t.t)}pseudoInvBenIsraelCohen(){const t=this.adjoint(),s=1e-5,e=t.dot(this);for(let r=0;r<e.rows;r++)e.addAt(r,r,s);let i=e.inv().dot(t);const o=1e-15;let n=1e4;for(;n-- >0;){const r=a.mult(i,2);r.sub(i.dot(this).dot(i));let h=0;for(let l=0;l<i.length;l++)h+=(i.value[l]-r.value[l])**2;if(i=r,h<o)break}return i}sqrt(){if(!this.isSquare())throw new MatrixException("sqrt only define square matrix.",this);switch(this.rows){case 0:return this;case 1:return new a(1,1,[Math.sqrt(this._value[0])])}if(this.isDiag())return a.diag(this.diag().map(Math.sqrt));const[t,s]=this.eigen(),e=new a(this.rows,this.cols);for(let i=0;i<this.rows;i++)e._value[i*this.cols+i]=Math.sqrt(t[i]);return s.dot(e).dot(s.transpose())}power(t){if(!this.isSquare())throw new MatrixException("Only square matrix can power.",this);const s=this.rows;if(this.isDiag(1e-12))return a.diag(this.diag().map(e=>Math.pow(e,t)));if(Number.isInteger(t)){if(t===0)return a.eye(s,s);if(t===1)return this.copy();if(t===2)return this.dot(this);if(t===-1)return this.inv();if(t<0)return this.inv().power(-t);if(!this.isSymmetric(1e-12)){let n=this.dot(this);for(let r=2;r<t;r++)n=n.dot(this);return n}const[e,i]=this.eigen(),o=a.diag(e.map(n=>Math.pow(n,t)));return i.dot(o).dot(i.t)}else{if(t<0)return this.inv().power(-t);if(t===.5)return this.sqrt()}throw new MatrixException("Power only defined integer.")}exp(){if(!this.isSquare())throw new MatrixException("Only square matrix can exp.",this);if(this.rows===1)return new a(1,1,Math.exp(this._value[0]));if(this.isDiag())return a.diag(this.diag().map(Math.exp));const t=a.eye(this.rows,this.cols);let s=1,e=1,i=this;const o=10**(Math.floor(Math.log(Math.abs(this.trace())))-8);for(;;){const n=a.div(i,s);if(t.add(n),n.norm()<o)break;i=i.dot(this),e++,s*=e}return t}log(){if(!this.isSquare())throw new MatrixException("Only square matrix can log.",this);if(this.rows===1)return new a(1,1,Math.log(this._value[0]));if(this.isDiag())return a.diag(this.diag().map(Math.log));const[t,s]=this.eigen(),e=s.inv();return s.dot(a.diag(t.map(Math.log))).dot(e)}cov(t=0){const s=new a(this.cols,this.cols),e=[];for(let i=0;i<this.cols;i++){let o=0;for(let n=i;n<this.length;n+=this.cols)o+=this._value[n];e[i]=o/this.rows;for(let n=0;n<=i;n++){let r=0;for(let h=0;h<this.length;h+=this.cols)r+=(this._value[i+h]-e[i])*(this._value[n+h]-e[n]);s._value[i*this.cols+n]=s._value[n*this.cols+i]=r/(this.rows-t)}}return s}gram(){return this.tDot(this)}solve(t){if(this.rows>this.cols)throw new MatrixException("Only square matrix or matrix with more columns than rows can be solved.",this);const s=this.rows;if(s!==t.rows)throw new MatrixException("b size is invalid.",[this,t]);const e=s<this.cols?a.resize(this,s,s):this;let i;switch(s){case 0:i=e;break;case 1:i=a.map(t,o=>o/e._value[0]);break;default:{const[o,n]=e.lu(),r=o.solveLowerTriangular(t);i=n.solveUpperTriangular(r);break}}return s<this.cols&&i.resize(this.cols,i.cols),i}solveLowerTriangular(t){if(this.rows>this.cols)throw new MatrixException("Matrix that column rank is less than row rank can not solve.",this);if(this.rows!==t.rows)throw new MatrixException("b size is invalid.",[this,t]);const s=this.cols,e=t.cols,i=new a(s,e);for(let o=0;o<e;o++)for(let n=0;n<this.rows;n++){let r=t._value[n*e+o];for(let h=0;h<n;h++)r-=i._value[h*e+o]*this._value[n*s+h];i._value[n*e+o]=r/this._value[n*s+n]}return i}solveUpperTriangular(t){if(this.rows>this.cols)throw new MatrixException("Matrix that column rank is less than row rank can not solve.",this);if(this.rows!==t.rows)throw new MatrixException("b size is invalid.",[this,t]);const s=this.cols,e=t.cols,i=new a(s,e);for(let o=0;o<e;o++)for(let n=this.rows-1;n>=0;n--){let r=t._value[n*e+o];for(let h=s-1;h>n;h--)r-=i._value[h*e+o]*this._value[n*s+h];i._value[n*e+o]=r/this._value[n*s+n]}return i}solveJacobi(t,s=1e3){if(!this.isSquare())throw new MatrixException("solveJacobi only define square matrix.",this);if(this.rows!==t.rows)throw new MatrixException("b size is invalid.",[this,t]);const e=this.cols,i=t.cols;let o=a.zeros(e,i);for(let n=0;n<s;n++){const r=a.zeros(e,i);for(let l=0;l<e;l++){const u=this.at(l,l);for(let c=0;c<i;c++){let f=t.at(l,c);for(let w=0;w<e;w++)l!==w&&(f-=o.at(w,c)*this.at(l,w));r.set(l,c,f/u)}}if(r.some(l=>isNaN(l)))throw new MatrixException("Can not calculate solved value.",this);if(a.sub(o,r).norm()<1e-8){o=r;break}o=r}return o}solveGaussSeidel(t,s=1e3){if(!this.isSquare())throw new MatrixException("solveGaussSeidel only define square matrix.",this);if(this.rows!==t.rows)throw new MatrixException("b size is invalid.",[this,t]);const e=this.cols,i=t.cols;let o=a.zeros(e,i);for(let n=0;n<s;n++){let r=0;for(let h=0;h<e;h++){const l=this.at(h,h);for(let u=0;u<i;u++){let c=t.at(h,u);for(let f=0;f<e;f++)h!==f&&(c-=o.at(f,u)*this.at(h,f));c/=l,r+=(o.at(h,u)-c)**2,o.set(h,u,c)}}if(o.some(h=>isNaN(h)))throw new MatrixException("Can not calculate solved value.",this);if(Math.sqrt(r)<1e-8)break}return o}solveSOR(t,s,e=1e3){if(!this.isSquare())throw new MatrixException("solveSOR only define square matrix.",this);if(this.rows!==t.rows)throw new MatrixException("b size is invalid.",[this,t]);if(s<=0||2<=s)throw new MatrixException("w must be positive and less than 2.",[this,s]);const i=this.cols,o=t.cols;let n=a.zeros(i,o);for(let r=0;r<e;r++){let h=0;for(let l=0;l<i;l++){const u=this.at(l,l);for(let c=0;c<o;c++){let f=t.at(l,c);for(let v=0;v<i;v++)l!==v&&(f-=n.at(v,c)*this.at(l,v));f/=u;const w=n.at(l,c);h+=(w-f)**2,n.set(l,c,(1-s)*w+s*f)}}if(n.some(l=>isNaN(l)))throw new MatrixException("Can not calculate solved value.",this);if(Math.sqrt(h)<1e-8)break}return n}bidiag(){return this.bidiagHouseholder()}bidiagHouseholder(t=!1){const s=this.copy(),[e,i]=[this.rows,this.cols];let o=t?a.eye(e,e):null,n=t?a.eye(i,i):null;for(let r=0;r<Math.min(e,i);r++){let h=s.block(r,r),l=h.col(0);if(l.norm()>0){const f=l.norm()*(l._value[0]<0?1:-1);l._value[0]-=f,l.div(l.norm())}let u=l.dot(l.t);u.mult(2);let c=a.eye(e-r,e-r);if(c.sub(u),h=c.tDot(h),t&&o.set(r,0,c.dot(o.slice(r,null,0))),l=h.row(0),l._value[0]=0,l.norm()>0){const f=l.norm()*(l._value[1]<0?1:-1);l._value[1]-=f,l.div(l.norm())}u=l.tDot(l),u.mult(2),c=a.eye(i-r,i-r),c.sub(u),h=h.dot(c),t&&n.set(0,r,n.slice(r,null,1).dot(c)),s.set(r,r,h)}return t?[s,o.t,n]:s}tridiag(){return this.tridiagHouseholder()}tridiagHouseholder(t=!1){if(!this.isSymmetric())throw new MatrixException("Tridiagonal only define symmetric matrix.",this);const s=this.copy(),e=this.cols;let i=t?a.eye(e,e):null;for(let o=0;o<e-2;o++){const n=s.block(o+1,o,e,o+1),r=n.norm()*(n._value[0]<0?1:-1);if(n._value[0]-=r,n.div(n.norm()),t){const c=n.dot(n.t);c.map((f,w)=>w[0]===w[1]?1-2*f:-2*f),i.set(0,o+1,i.slice(o+1,null,1).dot(c))}const h=s.block(o+1,o+1),l=h.dot(n),u=a.mult(n,n.tDot(l));u.isub(l),u.mult(2),h.sub(u.dot(n.t)),h.sub(n.dot(u.t)),s.set(o+1,o+1,h),s._value[o*e+o+1]=s._value[(o+1)*e+o]=r;for(let c=o+2;c<e;c++)s._value[o*e+c]=s._value[c*e+o]=0}return t?[s,i]:s}tridiagLanczos(t=0){if(!this.isSymmetric())throw new MatrixException("Tridiagonal only define symmetric matrix.",this);const s=this.cols;t<=0&&(t=s);let e=0,i=a.zeros(s,1),o=a.randn(s,1);o.div(o.norm());const n=a.zeros(t,t);for(let r=0;r<t;r++){const h=this.dot(o),l=o.tDot(h).toScaler();h.sub(a.mult(i,e)),h.sub(a.mult(o,l)),e=h.norm(),i=o,h.div(e),o=h,n.set(r,r,l),r<t-1&&(n.set(r,r+1,e),n.set(r+1,r,e))}return n}hessenberg(){return this.hessenbergArnoldi()}hessenbergArnoldi(t=0){if(!this.isSquare())throw new MatrixException("Hessenberg only define square matrix.",this);const s=this.cols;t<=0&&(t=s);const e=a.zeros(t,t),i=[a.random(s,1,-1,1)];i[0].div(i[0].norm());for(let o=0;o<t;o++){const n=this.dot(i[o]);for(let h=0;h<=o;h++){const l=i[h].tDot(n).toScaler();n.sub(a.mult(i[h],l)),e.set(h,o,l)}const r=n.norm();n.div(r),i[o+1]=n,o<t-1&&e.set(o+1,o,r)}return e}balancing(){if(!this.isSquare())throw new MatrixException("Doubly stochastic matrix only defined for square matrix.",this);if(this._value.some(t=>t<=0))throw new MatrixException("Doubly stochastic matrix only calculate for non negative matrix.",this);return this.rows===1?[[this._value[0]],new a(1,1,1),[1]]:this.balancingSinkhornKnopp()}balancingSinkhornKnopp(){if(!this.isSquare())throw new MatrixException("Doubly stochastic matrix only defined for square matrix.",this);if(this._value.some(n=>n<=0))throw new MatrixException("Doubly stochastic matrix only calculate for non negative matrix.",this);const t=this.rows,s=Array(t).fill(1),e=Array(t).fill(1),i=this.copy();let o=1e4;for(;o-- >0;){const n=i.sum(1);i.div(n);for(let l=0;l<t;l++)s[l]*=n.at(l,0);const r=i.sum(0);i.div(r);for(let l=0;l<t;l++)e[l]*=r.at(0,l);if(n.reduce((l,u)=>l+Math.abs(u-1),0)+r.reduce((l,u)=>l+Math.abs(u-1),0)<1e-8)break}return[s,i,e]}lu(){if(!this.isSquare())throw new MatrixException("LU decomposition only define square matrix.",this);const t=this.rows;switch(t){case 0:return[this,this];case 1:return[a.ones(1,1),new a(1,1,[this._value[0]])];case 2:return[new a(2,2,[1,0,this._value[2]/this._value[0],1]),new a(2,2,[this._value[0],this._value[1],0,this._value[3]-this._value[1]*this._value[2]/this._value[0]])]}let s=this.copy();for(let i=0;i<t;i++){const o=s._value[i*t+i];for(let n=i+1;n<t;n++){const r=s._value[n*t+i]/=o;for(let h=i+1;h<t;h++)s._value[n*t+h]-=r*s._value[i*t+h]}}let e=a.eye(t,t);for(let i=0;i<t;i++)for(let o=0;o<i;o++)e._value[i*t+o]=s._value[i*t+o],s._value[i*t+o]=0;return[e,s]}qr(){const t=this.rows,s=this.cols;if(t===0||s===0)return[this,this];if(t===1)return[a.ones(1,1),this];if(s===1){const e=Math.sqrt(this.tDot(this).toScaler());return[a.div(this,e),new a(1,1,e)]}return this.qrHouseholder()}qrGramSchmidt(){const t=this.cols,s=this.copy(),e=a.eye(t,t),i=[];for(let o=0;o<t;o++){for(let n=0;n<o;n++){let r=0;for(let l=0;l<this.rows;l++)r+=this._value[l*t+o]*s._value[l*t+n];const h=e._value[n*t+o]=i[n]===0?0:r/i[n]**2;for(let l=0;l<this.rows;l++)s._value[l*t+o]-=s._value[l*t+n]*h}i.push(s.col(o).norm())}return s.mult(new a(1,t,i.map(o=>o===0?0:1/o))),e.mult(new a(t,1,i)),[s,e]}qrHouseholder(){const t=this.rows,s=this.cols,e=this.copy(),i=a.eye(t,t);for(let o=0;o<Math.min(t,s);o++){const n=t-o,r=e.block(o,o,t,o+1),h=r.norm()*Math.sign(r._value[0]);r._value[0]-=h;const l=r.norm();r.div(l===0?1:l);const u=new a(n,n);for(let c=0;c<n;c++){const f=r._value[c];if(u._value[c*n+c]=1-2*f**2,!!f)for(let w=0;w<c;w++)u._value[c*n+w]=u._value[w*n+c]=-2*f*r._value[w]}e.set(o,o,u.dot(e.block(o,o))),i.set(o,0,u.dot(i.block(o,0)))}return[i.t,e]}singularValues(){const s=this.dot(this.adjoint()).eigenJacobi()[0];for(let e=0;e<s.length;e++)-1e-12<s[e]&&s[e]<0&&(s[e]=0),s[e]=Math.sqrt(s[e]);return s}singularValuePowerIteration(t=1e4){let e=a.randn(this.cols,1),i=a.randn(this.rows,1);e.div(e.norm()),i.div(i.norm());let o=1/0,n=t;for(;n-- >0;){const r=this.tDot(i),h=e.tDot(r).at(0,0);r.div(r.norm()),i=this.dot(r),i.div(i.norm());const l=Math.abs(h-o);if(l<1e-15||isNaN(l))return h;e=r,o=h}throw new MatrixException("singularValuePowerIteration not converged.",this)}svd(){return this.svdEigen()}svdEigen(){const t=Math.min(this.cols,this.rows);if(this.cols<=this.rows){const s=this.tDot(this),[e,i]=s.eigen();for(let n=0;n<t;n++)-1e-12<e[n]&&e[n]<=0?e[n]=0:e[n]=Math.sqrt(e[n]);const o=this.dot(i);for(let n=0;n<this.rows;n++)for(let r=0;r<t;r++)e[r]!==0&&(o._value[n*t+r]/=e[r]);return[o,e,i]}else{const s=this.dot(this.t),[e,i]=s.eigen();for(let n=0;n<t;n++)-1e-12<e[n]&&e[n]<=0?e[n]=0:e[n]=Math.sqrt(e[n]);const o=i.tDot(this);for(let n=0;n<t;n++)for(let r=0;r<this.cols;r++)e[n]!==0&&(o._value[n*this.cols+r]/=e[n]);return[i,e,o.t]}}svdGolubKahan(){const t=this.rows>=this.cols,s=Math.min(this.rows,this.cols),e=t?this:this.t,[i,,o]=e.bidiagHouseholder(!0);for(let w=0;w<s;w++)if(Math.sign(i.at(w,w))<0){i.multAt(w,w,-1),w>0&&i.multAt(w-1,w,-1);for(let d=0;d<o.rows;d++)o.multAt(d,w,-1)}const n=1e-12;let r=1e4,h=i.tDot(i),l=o;for(;r-- >0;){const[w]=h.qrGramSchmidt();h=w.tDot(h).dot(w),l=l.dot(w);let v=0;for(let d=0;d<h.rows;d++)for(let _=0;_<h.cols;_++)d!==_&&(v+=h.at(d,_)**2);if(Math.sqrt(v)<n)break}const[u,c]=e.dot(l).qr();for(let w=0;w<s;w++)if(c.at(w,w)<0)for(let v=0;v<l.rows;v++)l.multAt(v,w,-1);const f=h.diag().map(w=>Math.sqrt(w));return t?[u.slice(0,s,1),f,l.slice(0,s,1)]:[l.slice(0,s,1),f,u.slice(0,s,1)]}cholesky(){return this.choleskyBanachiewicz()}choleskyGaussian(){if(!this.isSymmetric(1e-15))throw new MatrixException("Cholesky decomposition only define symmetric matrix.",this);let t=this;const s=t.rows;let e=a.eye(s,s);for(let i=0;i<s;i++){const o=t.at(0,0),n=t.block(1,0,s-i,1),r=t.block(0,1,1,s-i);t=t.block(1,1);const h=n.dot(r);h.div(o),t.sub(h);const l=a.eye(s,s);l.set(i,i,Math.sqrt(o)),n.div(Math.sqrt(o)),l.set(i+1,i,n),e=e.dot(l)}return e}choleskyBanachiewicz(){if(!this.isSymmetric(1e-15))throw new MatrixException("Cholesky decomposition only define symmetric matrix.",this);const t=this.rows,s=new a(t,t);for(let e=0;e<t;e++){let i=0;for(let o=0;o<e;o++){let n=0;for(let r=0;r<o;r++)n+=s._value[e*t+r]*s._value[o*t+r];s._value[e*t+o]=(this._value[e*t+o]-n)/s._value[o*t+o],i+=s._value[e*t+o]**2}s._value[e*t+e]=Math.sqrt(this._value[e*t+e]-i)}return s}choleskyCrout(){if(!this.isSymmetric(1e-15))throw new MatrixException("Cholesky decomposition only define symmetric matrix.",this);const t=this.rows,s=new a(t,t);for(let e=0;e<t;e++){let i=0;for(let o=0;o<e;o++)i+=s._value[e*t+o]*s._value[e*t+o];s._value[e*t+e]=Math.sqrt(this._value[e*t+e]-i);for(let o=e+1;o<t;o++){let n=0;for(let r=0;r<e;r++)n+=s._value[o*t+r]*s._value[e*t+r];s._value[o*t+e]=(this._value[o*t+e]-n)/s._value[e*t+e]}}return s}modifiedCholesky(){if(!this.isSymmetric(1e-15))throw new MatrixException("Modified cholesky decomposition only define symmetric matrix.",this);const t=this.rows,s=[],e=a.eye(t,t);for(let i=0;i<t;i++){s[i]=this._value[i*t+i];for(let o=0;o<i;o++){let n=0;for(let r=0;r<o;r++)n+=e._value[i*t+r]*e._value[o*t+r]*s[r];e._value[i*t+o]=(this._value[i*t+o]-n)/s[o],s[i]-=e._value[i*t+o]**2*s[o]}}return[e,s]}schur(){if(!this.isSquare())throw new MatrixException("Schur decomposition only define square matrix.",this);return this.schurQR()}schurQR(t="single"){if(!this.isSquare())throw new MatrixException("Schur decomposition only define square matrix.",this);const s=this.rows;let e=this.copy();const i=[];for(let r=0;r<s-2;r++){const h=e.block(r+1,r),l=h.col(0),u=l.norm()*Math.sign(l._value[0]);l._value[0]-=u;const c=l.norm();l.div(c===0?1:c),h.sub(a.mult(2,l.dot(l.tDot(h)))),e.set(r+1,r,h);const f=e.slice(r+1,s,1);f.sub(a.mult(2,f.dot(l).dot(l.t))),e.set(0,r+1,f),i[r]=l}let o=a.eye(s,s);for(let r=s-3;r>=0;r--){const h=o.block(r+1,r+1);h.sub(a.mult(2,i[r].dot(i[r].tDot(h)))),o.set(r+1,r+1,h)}const n=1e-8;for(let r=s-1;r>0;r--){let h=1e4;for(;h-- >0;){const l=e.block(s-2,s-2).eigenValues();if(t==="no"){const[u,c]=e.qr();e=c.dot(u),o=o.dot(u)}else if(t==="single"){const u=e.at(s-1,s-1);let c=Math.abs(l[0]-u)<Math.abs(l[1]-u)?l[0]:l[1];isNaN(c)&&(c=e.at(r,r));for(let v=0;v<s;v++)e._value[v*s+v]-=c;const[f,w]=e.qr();e=w.dot(f);for(let v=0;v<s;v++)e._value[v*s+v]+=c;o=o.dot(f)}if(Math.abs(e.at(r,r-1))<n)break}}return[o,e]}rankFactorization(){const t=this.copy();t.reducedRowEchelonForm(1e-8);const s=[];let e=0;for(let i=0;i<this.cols;i++)t.at(e,i)>0&&(s.push(i),e++);return[this.col(s),t.slice(0,s.length,0)]}eigen(){if(!this.isSquare())throw new MatrixException("Eigen values only define square matrix.",this);if(this.rows>=2&&this.isZero()){const t=Array(this.rows).fill(0);t[0]=1;const s=a.eye(this.rows,this.rows);return s.set(0,0,0),[t,s]}if(this.rows<=2)return[this.eigenValues(),this.eigenVectors()];if(this.isSymmetric(1e-15))return this.eigenJacobi();{const t=this.eigenValues(),s=this.rows,e=new a(s,s);for(let i=0;i<s;i++){const[,o]=this.eigenInverseIteration(t[i]);for(let n=0;n<s;n++)e._value[n*s+i]=o._value[n]}return[t,e]}}eigenValues(){if(!this.isSquare())throw new MatrixException("Eigen values only define square matrix.",this);if(this.rows>=2&&this.isZero()){const t=Array(this.rows).fill(0);return t[0]=1,t}switch(this.rows){case 0:return[];case 1:return[this._value[0]];case 2:{const t=this._value[0]+this._value[3],s=Math.sqrt(t**2-4*this.det());return[(t+s)/2,(t-s)/2]}case 3:{const t=-this.det(),s=this._value[0]*this._value[4]+this._value[0]*this._value[8]+this._value[4]*this._value[8]-this._value[5]*this._value[7]-this._value[2]*this._value[6]-this._value[1]*this._value[3],e=-this._value[0]-this._value[4]-this._value[8],i=s-e**2/3,o=t-s*e/3+e**3*2/27,n=(o/2)**2+(i/3)**3;let[r,h]=new q(n).sqrt();r=r.add(-o/2),h=h.add(-o/2);const[l,u,c]=r.cbrt(),[f,w,v]=h.cbrt(),d=l.add(f),_=u.add(v),y=c.add(w),j=[d,_,y].map(g=>Math.abs(g.imaginary)<1e-12?g.real-e/3:Number.NaN);return j.sort((g,p)=>p-g),j}case 4:{const t=this.det(),s=-this._value[0]*this._value[5]*this._value[10]-this._value[0]*this._value[5]*this._value[15]-this._value[0]*this._value[10]*this._value[15]-this._value[5]*this._value[10]*this._value[15]+this._value[0]*this._value[11]*this._value[14]+this._value[0]*this._value[7]*this._value[13]+this._value[0]*this._value[6]*this._value[9]+this._value[5]*this._value[11]*this._value[14]+this._value[3]*this._value[5]*this._value[12]+this._value[2]*this._value[5]*this._value[8]+this._value[7]*this._value[10]*this._value[13]+this._value[3]*this._value[10]*this._value[12]+this._value[1]*this._value[4]*this._value[10]+this._value[6]*this._value[9]*this._value[15]+this._value[2]*this._value[8]*this._value[15]+this._value[1]*this._value[4]*this._value[15]-this._value[6]*this._value[11]*this._value[13]-this._value[7]*this._value[9]*this._value[14]-this._value[2]*this._value[11]*this._value[12]-this._value[3]*this._value[8]*this._value[14]-this._value[1]*this._value[7]*this._value[12]-this._value[3]*this._value[4]*this._value[13]-this._value[1]*this._value[6]*this._value[8]-this._value[2]*this._value[4]*this._value[9],e=this._value[0]*this._value[5]+this._value[0]*this._value[10]+this._value[0]*this._value[15]+this._value[5]*this._value[10]+this._value[5]*this._value[15]+this._value[10]*this._value[15]-this._value[7]*this._value[13]-this._value[6]*this._value[9]-this._value[11]*this._value[14]-this._value[1]*this._value[4]-this._value[2]*this._value[8]-this._value[3]*this._value[12],i=-this.trace(),o=Math.cbrt(2),n=-(i**3)+4*e*i-8*s,r=e**2-3*s*i+12*t,h=2*e**3-9*s*e*i+27*t*i**2+27*s**2-72*t*e,l=-4*r**3+h**2,c=new q(l).sqrt()[0].add(h).cbrt()[0],w=new q(i**2/4-2*e/3).add(new q(o*r/3).div(c)).add(c.div(3*o)).sqrt(),v=new q(i**2/2-4*e/3).sub(new q(o*r/3).div(c)).sub(c.div(3*o)),d=v.add(new q(n/4).div(w[1])),_=v.add(new q(n/4).div(w[0])),y=d.sqrt(),j=_.sqrt(),g=new q(-i/4).add(y[0].div(2)).add(w[1].div(2)),p=new q(-i/4).add(y[1].div(2)).add(w[1].div(2)),m=new q(-i/4).add(j[0].div(2)).add(w[0].div(2)),b=new q(-i/4).add(j[1].div(2)).add(w[0].div(2)),z=[g,p,m,b].map(S=>Math.abs(S.imaginary)<1e-12?S.real:Number.NaN);return z.sort((S,N)=>N-S),z}}return this.isSymmetric(1e-15)?this.eigenJacobi()[0]:this.eigenValuesQR()}eigenVectors(){if(!this.isSquare())throw new MatrixException("Eigen vectors only define square matrix.",this);if(this.rows>=2&&this.isZero()){const t=a.eye(this.rows,this.rows);return t.set(0,0,0),t}switch(this.rows){case 0:return this;case 1:return new a(1,1,[1]);case 2:{const t=this.eigenValues(),s=[-this._value[1],this._value[0]-t[0]],e=Math.sqrt(s[0]**2+s[1]**2),i=[-this._value[1],this._value[0]-t[1]],o=Math.sqrt(i[0]**2+i[1]**2);return new a(2,2,[s[0]/e,i[0]/o,s[1]/e,i[1]/o])}}return this.eigen()[1]}eigenValuesBiSection(){if(!this.isSymmetric(1e-15))throw new MatrixException("eigenValuesBiSection can only use symmetric matrix.",this);const t=this.tridiag(),s=this.rows;let e=0;for(let n=0;n<s;n++){const r=Math.abs(t.at(n,n))+Math.abs(n>0?t.at(n,n-1):0)+Math.abs(n<s-1?t.at(n,n+1):0);e<r&&(e=r)}const i=k(n=>{const r=[1,n-t.at(0,0)];for(let l=1;l<s;l++)r[l+1]=(n-t.at(l,l))*r[l]-t.at(l,l-1)**2*r[l-1];let h=0;for(let l=1;l<r.length;l++)Math.sign(r[l-1])!==Math.sign(r[l])&&h++;return h},"sturm"),o=[];for(let n=1;n<=s;n++){let r=-e,h=i(r),l=e;for(;Math.abs(r-l)>1e-8;){const u=(r+l)/2,c=i(u);n<=h&&n>c?l=u:(r=u,h=c)}o.push((r+l)/2)}return o}eigenValuesLR(t=1e5){if(!this.isSquare())throw new MatrixException("Eigen values only define square matrix.",this);let s=this;const e=s.rows,i=1e-15;let o=t;for(;o-- >0;){const[n,r]=s.lu();s=r.dot(n);let h=0;for(let l=0;l<e;l++)for(let u=0;u<l;u++)h+=s._value[l*e+u]**2;if(h<i){const l=s.diag();return l.sort((u,c)=>c-u),l}}throw new MatrixException("eigenValuesLR not converged.",this)}eigenValuesQR(t=1e6){if(!this.isSquare())throw new MatrixException("Eigen values only define square matrix.",this);let s=this.copy();const e=[],i=1e-8;for(let n=s.rows;n>2;n--){let r=t;for(;;){const h=s.block(n-2,n-2).eigenValues();if(isNaN(h[0])){e.sort((v,d)=>d-v);for(let v=0;v<n;v++,e.push(NaN));return e}const l=s._value[s._value.length-1],u=Math.abs(h[0]-l)<Math.abs(h[1]-l)?h[0]:h[1];for(let v=0;v<n;v++)s._value[v*n+v]-=u;const[c,f]=s.qr();s=f.dot(c);for(let v=0;v<n;v++)s._value[v*n+v]=s._value[v*n+v]+u;let w=0;for(let v=(n-1)*n;v<s.length-1;v++)w+=Math.abs(s._value[v]);if(w<i)break;if(r--<0)throw new MatrixException("eigenValuesQR not converged.",this)}e.push(s._value[s._value.length-1]),s.resize(n-1,n-1)}const o=s.eigenValues();return e.push(...o),e.sort((n,r)=>r-n),e}eigenJacobi(t=1e6){if(!this.isSymmetric(1e-15))throw new MatrixException("Jacobi method can only use symmetric matrix.",this);const s=this._value.concat(),e=a.eye(this.rows,this.cols);e.add(0);const i=1e-15;let o=0;const n=this.rows;let r=t;for(;;){let u=0,c=0,f=0;for(let m=0;m<n;m++)for(let b=m+1;b<n;b++){const z=Math.abs(s[m*n+b]);z>u&&(u=z,c=m,f=b)}if(u<i)break;if(u===o)break;if(r--<0){console.log(new MatrixException("eigenJacobi not converged.",[this,u]));break}o=u;const w=s[c*n+c],v=s[c*n+f],d=s[f*n+f],_=(w-d)/2,y=-v,j=Math.abs(_)/Math.sqrt(_**2+y**2);let g=Math.sqrt((1-j)/2);const p=Math.sqrt((1+j)/2);_*y<0&&(g=-g);for(let m=0;m<n;m++){const b=s[c*n+m],z=s[f*n+m];s[m*n+f]=s[f*n+m]=g*b+p*z,s[m*n+c]=s[c*n+m]=p*b-g*z}s[c*n+c]=p**2*w+g**2*d-2*g*p*v,s[c*n+f]=s[f*n+c]=g*p*(w-d)+(p**2-g**2)*v,s[f*n+f]=g**2*w+p**2*d+2*g*p*v;for(let m=0;m<n;m++){const b=e._value[m*n+c],z=e._value[m*n+f];e._value[m*n+f]=g*b+p*z,e._value[m*n+c]=p*b-g*z}}const h=[];for(let u=0;u<n;u++)h.push([u,s[u*n+u]]);h.sort((u,c)=>c[1]-u[1]);const l=e.col(h.map(u=>u[0]));return[h.map(u=>u[1]),l]}eigenPowerIteration(t=1e4){if(!this.isSquare())throw new MatrixException("Eigen vectors only define square matrix.",this);const s=this.rows,e=1e-15;let i=a.randn(s,1);i.div(i.norm());let o=1/0,n=t;for(;n-- >0;){const r=this.dot(i);let h=0,l=0;for(let f=0;f<s;f++)h+=r._value[f]**2,l+=r._value[f]*i._value[f];const u=h/l;r.div(r.norm());const c=Math.abs(u-o);if(c<e||isNaN(c))return[u,r];i=r,o=u}throw new MatrixException("eigenPowerIteration not converged.",this)}eigenSimultaneousIteration(t,s=1e4){if(!this.isSymmetric(1e-15))throw new MatrixException("Simultaneous iteration method can only use symmetric matrix.",this);const e=this.rows,i=1e-8;let o=a.ones(e,t);o.div(o.norm());let n=new a(1,t,1/0);const r=this.row(0);let h=s;for(;h-- >0;){const l=this.dot(o),[u]=l.qr();u.resize(u.rows,t);let c=r.dot(u);c.div(u.row(0)),n.sub(c);const f=n.reduce((w,v)=>w+Math.abs(v),0)/t;if(f<i||isNaN(f))return[c.value,u];o=u,n=c}throw new MatrixException("eigenSimultaneousIteration not converged.",this)}eigenInverseIteration(t=0,s=1e4){if(!this.isSquare())throw new MatrixException("Eigen vectors only define square matrix.",this);const e=this.rows,i=1e-15;let o=this.copy();for(let l=0;l<e;l++)o._value[l*e+l]=o._value[l*e+l]-t+1e-15;o=o.inv();let n=a.randn(e,1);n.div(n.norm());let r=1/0,h=s;for(;h-- >0;){const l=o.dot(n);let u=0,c=0;for(let v=0;v<e;v++)u+=l._value[v]**2,c+=n._value[v]*l._value[v];const f=c/u;l.div(l.norm());const w=Math.abs(f-r);if(w<i||isNaN(w))return[f+t,l];n=l,r=f}throw new MatrixException("eigenInverseIteration not converged.",this)}}
