import Complex from"./complex.js";const normal_random=function(t=0,s=1){const e=Math.sqrt(s),i=Math.random(),r=Math.random();return[Math.sqrt(-2*Math.log(i))*Math.cos(2*Math.PI*r)*e+t,Math.sqrt(-2*Math.log(i))*Math.sin(2*Math.PI*r)*e+t]};export function MatrixException(t,s){this.message=t,this.value=s,this.name=MatrixException}export default class Matrix{constructor(t,s,e){e?Array.isArray(e)?Array.isArray(e[0])?this._value=e.flat():this._value=e:this._value=Array(t*s).fill(e):this._value=Array(t*s).fill(0),this._size=[t,s]}static zeros(t,s){return new Matrix(t,s,Array(t*s).fill(0))}static ones(t,s){return new Matrix(t,s,Array(t*s).fill(1))}static eye(t,s,e=1){const i=new Matrix(t,s),r=Math.min(t,s);for(let t=0;t<r;t++)i._value[t*s+t]=e;return i}static random(t,s,e=0,i=1){const r=new Matrix(t,s);for(let t=0;t<r.length;t++)r._value[t]=Math.random()*(i-e)+e;return r}static randn(t,s,e=0,i=1){const r=new Matrix(t,s);if(Array.isArray(e)&&(e=new Matrix(1,e.length,e)),Array.isArray(i)&&(i=Matrix.fromArray(i)),!(e instanceof Matrix||i instanceof Matrix)){for(let t=0;t<r.length;t+=2){const s=normal_random(e,i);r._value[t]=s[0],t+1<r.length&&(r._value[t+1]=s[1])}return r}if(e instanceof Matrix?e.rows!==s&&1!==e.cols||(e=e.t):e=new Matrix(1,s,e),e.cols!==s||1!==e.rows)throw new MatrixException("'myu' cols must be same as 'cols' and rows must be 1.");if(i instanceof Matrix){if(i.rows!==s||i.cols!==s)throw new MatrixException("'sigma' cols and rows must be same as 'cols'.")}else i=Matrix.eye(s,s,i);const o=i.cholesky();for(let t=0;t<r.length;t+=2){const s=normal_random(0,1);r._value[t]=s[0],t+1<r.length&&(r._value[t+1]=s[1])}const l=r.dot(o.t);return l.add(e),l}static diag(t){let s=0,e=0;for(const i of t)"number"==typeof i?(s++,e++):(s+=i.rows,e+=i.cols);const i=new Matrix(s,e);for(let r=0,o=0,l=0;o<s;r++){const s=t[r];"number"==typeof s?(i._value[o*e+l]=s,o++,l++):(i.set(o,l,s),o+=s.rows,l+=s.cols)}return i}static fromArray(t){return t instanceof Matrix?t:Array.isArray(t)?0===t.length?new Matrix(0,0):Array.isArray(t[0])?new Matrix(t.length,t[0].length,t):new Matrix(t.length,1,t):new Matrix(1,1,t)}get dimension(){return this._size.length}get sizes(){return this._size}get length(){return this._size[0]*this._size[1]}get rows(){return this._size[0]}get cols(){return this._size[1]}get value(){return this._value}get t(){return this.transpose()}*[Symbol.iterator](){yield*this._value}toArray(){const t=[],s=this.cols;for(let e=0;e<this.length;e+=s)t.push(this._value.slice(e,e+s));return t}toScaler(){if(1!==this.rows||1!==this.cols)throw new MatrixException("The matrix cannot convert to scaler.");return this._value[0]}toString(){let t="[";for(let s=0;s<this.rows;s++){s>0&&(t+=",\n "),t+="[";for(let e=0;e<this.cols;e++)e>0&&(t+=", "),t+=this._value[s*this.cols+e];t+="]"}return t+"]"}copy(t){return t===this?this:t?(t._size=[].concat(this._size),this._value.forEach(((s,e)=>t._value[e]=s)),t):new Matrix(this.rows,this.cols,[].concat(this._value))}equals(t,s=0){if(t instanceof Matrix){if(this._size[0]!==t._size[0]||this._size[1]!==t._size[1])return!1;for(let e=this.length-1;e>=0;e--)if(Math.abs(this._value[e]-t._value[e])>s)return!1;return!0}return!1}at(t,s){if(Array.isArray(t)&&([t,s]=t),t<0||this.rows<=t||s<0||this.cols<=s)throw new MatrixException("Index out of bounds.");return this._value[t*this.cols+s]}set(t,s,e){if(Array.isArray(t)&&(e=s,[t,s]=t),e instanceof Matrix){if(t<0||this.rows<=t+e.rows-1||s<0||this.cols<=s+e.cols-1)throw new MatrixException("Index out of bounds.");for(let i=0;i<e.rows;i++)for(let r=0;r<e.cols;r++)this._value[(i+t)*this.cols+r+s]=e._value[i*e.cols+r];return null}{if(t<0||this.rows<=t||s<0||this.cols<=s)throw new MatrixException("Index out of bounds.");const i=this._value[t*this.cols+s];return this._value[t*this.cols+s]=e,i}}row(t){if(Array.isArray(t)){if("boolean"==typeof t[0]){if(t.length!==this.rows)throw new MatrixException("Length is invalid.");const s=[];for(let e=0;e<t.length;e++)t[e]&&s.push(e);t=s}if(t.some((t=>t<0||this.rows<=t)))throw new MatrixException("Index out of bounds.");const s=new Matrix(t.length,this.cols);for(let e=0;e<t.length;e++)for(let i=0;i<this.cols;i++)s._value[e*this.cols+i]=this._value[t[e]*this.cols+i];return s}if(t<0||this.rows<=t)throw new MatrixException("Index out of bounds.");return new Matrix(1,this.cols,this._value.slice(t*this.cols,(t+1)*this.cols))}col(t){if(Array.isArray(t)){if("boolean"==typeof t[0]){if(t.length!==this.cols)throw new MatrixException("Length is invalid.");const s=[];for(let e=0;e<t.length;e++)t[e]&&s.push(e);t=s}if(t.some((t=>t<0||this.cols<=t)))throw new MatrixException("Index out of bounds.");const s=new Matrix(this.rows,t.length);for(let e=0;e<this.rows;e++)for(let i=0;i<t.length;i++)s._value[e*t.length+i]=this._value[e*this.cols+t[i]];return s}{if(t<0||this.cols<=t)throw new MatrixException("Index out of bounds.");const s=new Matrix(this.rows,1);for(let e=0;e<this.rows;e++)s._value[e]=this._value[e*this.cols+t];return s}}slice(t,s,e=0){if("number"!=typeof t&&(t=0),"number"!=typeof s&&(s=this._size[e]),0===e){const e=new Matrix(s-t,this.cols);return e._value=this._value.slice(t*this.cols,s*this.cols),e}if(1===e){const e=new Matrix(this.rows,s-t);for(let s=0;s<e.rows;s++)for(let i=0;i<e.cols;i++)e._value[s*e.cols+i]=this._value[s*this.cols+i+t];return e}throw new MatrixException("Invalid axis.")}block(t,s,e,i){"number"!=typeof t&&(t=0),"number"!=typeof s&&(s=0);const r=new Matrix((e||this.rows)-t,(i||this.cols)-s);for(let e=0;e<r.rows;e++)for(let i=0;i<r.cols;i++)r._value[e*r.cols+i]=this._value[(e+t)*this.cols+i+s];return r}remove(t,s=0){if(0===s)if(Array.isArray(t)){if(t.some((t=>t<0||this.rows<=t)))throw new MatrixException("Index out of bounds.");(t=[...new Set(t)]).sort(((t,s)=>s-t));for(let s=0;s<t.length;s++)this._value.splice(t[s]*this.cols,this.cols);this._size[0]-=t.length}else{if(t<0||this.rows<=t)throw new MatrixException("Index out of bounds.");this._value.splice(t*this.cols,this.cols),this._size[0]--}else{if(1!==s)throw new MatrixException("Invalid axis.");if(Array.isArray(t)){if(t.some((t=>t<0||this.cols<=t)))throw new MatrixException("Index out of bounds.");(t=[...new Set(t)]).sort(((t,s)=>t-s));let s=0,e=0;for(let i=0;i<this.rows;i++)for(let i=0,r=0;i<this.cols;i++,s++)t[r]!==i?this._value[e++]=this._value[s]:r++;this._size[1]-=t.length,this._value.length=this.length}else{if(t<0||this.cols<=t)throw new MatrixException("Index out of bounds.");let s=0,e=0;for(let i=0;i<this.rows;i++)for(let i=0;i<this.cols;i++,s++)t!==i&&(this._value[e++]=this._value[s]);this._size[1]--,this._value.length=this.length}}}removeIf(t,s=0){const e=[];if(0===s)for(let s=0;s<this.rows;s++)t(this.row(s))&&e.push(s);else{if(1!==s)throw new MatrixException("Invalid axis.");for(let s=0;s<this.cols;s++)t(this.col(s))&&e.push(s)}this.remove(e,s)}sample(t,s=0,e=!1){const i=this.sizes[s],r=[];for(let s=0;s<t;s++)r.push(Math.floor(Math.random()*(i-s)));for(let s=t-1;s>=0;s--)for(let e=t-1;e>s;e--)r[s]<=r[e]&&r[e]++;if(0===s)return e?[this.row(r),r]:this.row(r);if(1===s)return e?[this.col(r),r]:this.col(r);throw new MatrixException("Invalid axis.")}fill(t){this._value.fill(t)}map(t){for(let s=0,e=0;s<this._size[0];s++)for(let i=0;i<this._size[1];i++,e++)this._value[e]=t(this._value[e],[s,i],this)}copyMap(t){const s=new Matrix(this.rows,this.cols);for(let e=0,i=0;e<this._size[0];e++)for(let r=0;r<this._size[1];r++,i++)s._value[i]=t(this._value[i],[e,r],this);return s}forEach(t){for(let s=0,e=0;s<this._size[0];s++)for(let i=0;i<this._size[1];i++,e++)t(this._value[e],[s,i],this)}transpose(){const t=new Matrix(this.cols,this.rows);for(let s=0;s<this.rows;s++)for(let e=0;e<this.cols;e++)t._value[e*this.rows+s]=this._value[s*this.cols+e];return t}adjoint(){return this.transpose()}flip(t=0){if(0===t)for(let t=0;t<this.rows/2;t++){const s=(this.rows-t-1)*this.cols;for(let e=0;e<this.cols;e++){const i=this._value[t*this.cols+e];this._value[t*this.cols+e]=this._value[s+e],this._value[s+e]=i}}else{if(1!==t)throw new MatrixException("Invalid axis.");for(let t=0;t<this.cols/2;t++){const s=this.cols-t-1;for(let e=0;e<this.rows;e++){const i=this._value[e*this.cols+t];this._value[e*this.cols+t]=this._value[e*this.cols+s],this._value[e*this.cols+s]=i}}}}swap(t,s,e=0){if(0===e){if(t<0||s<0||this.rows<=t||this.rows<=s)throw new MatrixException("Index out of bounds.");const e=(s-t)*this.cols;for(let s=t*this.cols;s<(t+1)*this.cols;s++)[this._value[s],this._value[s+e]]=[this._value[s+e],this._value[s]]}else{if(1!==e)throw new MatrixException("Invalid axis.");{if(t<0||s<0||this.cols<=t||this.cols<=s)throw new MatrixException("Index out of bounds.");const e=s-t;for(let s=t;s<this.length;s+=this.cols)[this._value[s],this._value[s+e]]=[this._value[s+e],this._value[s]]}}}sort(t=0){if(0===t){const t=[];for(let s=0;s<this.rows;t.push(s++));return t.sort(((t,s)=>{const e=t*this.cols,i=s*this.cols;for(let t=0;t<this.cols;t++){const s=this._value[e+t]-this._value[i+t];if(0!==s)return s}return 0})),this._value=this.row(t)._value,t}if(1===t){const t=[];for(let s=0;s<this.cols;t.push(s++));return t.sort(((t,s)=>{for(let e=0;e<this.rows;e++){const i=this._value[t+e*this.cols]-this._value[s+e*this.cols];if(0!==i)return i}return 0})),this._value=this.col(t)._value,t}throw new MatrixException("Invalid axis.")}shuffle(t=0){const s=[];for(let e=0;e<this._size[t];e++)s[e]=e;for(let t=s.length-1;t>0;t--){const e=Math.floor(Math.random()*(t+1));[s[t],s[e]]=[s[e],s[t]]}if(0===t)this._value=this.row(s)._value;else{if(1!==t)throw new MatrixException("Invalid axis.");this._value=this.col(s)._value}return s}resize(t,s,e=0){const i=new Matrix(t,s);i.fill(e);const r=Math.min(this.rows,t),o=Math.min(this.cols,s);for(let t=0;t<r;t++)for(let e=0;e<o;e++)i._value[t*s+e]=this._value[t*this.cols+e];return i}reshape(t,s){if(this.length!==t*s)throw new MatrixException("Length is different.");this._size=[t,s]}repeat(t,s=0){if(Array.isArray(t)){if(t.length<this._size.length)for(let s=t.length;s<this._size.length;s++)t[s]=1}else{const e=Array(this._size.length).fill(1);e[s]=t,t=e}const e=t.reduce(((t,s)=>t*s),1);if(1===e)return;const i=Array(this.length*e),r=this._size.map(((s,e)=>s*t[e]));for(let t=0;t<r[0];t++)for(let s=0;s<r[1];s++)i[t*r[1]+s]=this._value[t%this.rows*this.cols+s%this.cols];this._value=i,this._size=r}copyRepeat(t,s=0){let e=this.copy();return e.repeat(t,s),e}concat(t,s=0){let e=null;if(0===s){if(this.cols!==t.cols)throw new MatrixException("Size is different.");return new Matrix(this.rows+t.rows,this.cols,[].concat(this._value,t._value))}if(1===s){if(this.rows!==t.rows)throw new MatrixException("Size is different.");e=this.resize(this.rows,this.cols+t.cols);for(let s=0;s<this.rows;s++)for(let i=0;i<t.cols;i++)e._value[s*e.cols+i+this.cols]=t._value[s*t.cols+i];return e}throw new MatrixException("Invalid axis.")}reduce(t,s,e=-1){if(e<0){let e=s??this._value[0];for(let i=0,r=0;i<this._size[0];i++)for(let o=0;o<this._size[1];o++,r++)0===r&&null==s||(e=t(e,this._value[r],[i,o],this));return e}let i=0===e?1:this.cols,r=0===e?this.cols:1;const o=[].concat(this._size);o[e]=1;const l=Matrix.zeros(...o);for(let o=0,h=0;o<l.length;o++,h+=i){let i=s??this._value[h];for(let l=i===s?0:1;l<this._size[e];l++)i=t(i,this._value[l*r+h],0===e?[l,o]:[o,l],this);l._value[o]=i}return l}every(t,s=-1){return this.reduce(((s,e,i,r)=>s&&t(e,i,r)),!0,s)}some(t,s=-1){return this.reduce(((s,e,i,r)=>s||t(e,i,r)),!1,s)}max(t=-1){if(t<0){let t=-1/0;for(let s=this.length-1;s>=0;s--)t=Math.max(t,this._value[s]);return t}const s=this.argmax(t);let e=0===t?1:this.cols,i=0===t?this.cols:1;return s._value=s._value.map(((t,s)=>this._value[t*i+s*e])),s}min(t=-1){if(t<0){let t=1/0;for(let s=this.length-1;s>=0;s--)t=Math.min(t,this._value[s]);return t}const s=this.argmin(t);let e=0===t?1:this.cols,i=0===t?this.cols:1;return s._value=s._value.map(((t,s)=>this._value[t*i+s*e])),s}median(t=-1){if(t<0){const t=this._value.concat();return t.sort(((t,s)=>t-s)),t.length%2==1?t[(t.length-1)/2]:(t[t.length/2]+t[t.length/2-1])/2}let s=0===t?1:this.cols,e=0===t?this.cols:1;const i=[].concat(this._size);i[t]=1;const r=Matrix.zeros(...i);for(let i=0,o=0;i<r.length;i++,o+=s){const s=[];for(let i=0;i<this._size[t];i++)s.push(this._value[i*e+o]);s.sort(((t,s)=>t-s)),s.length%2==1?r._value[i]=s[(s.length-1)/2]:r._value[i]=(s[s.length/2]+s[s.length/2-1])/2}return r}quantile(t,s=-1){if(0===t)return this.min(s);if(1===t)return this.max(s);const e=(t,s)=>{if(t.sort(((t,s)=>t-s)),1===t.length)return t[0];const e=s*(t.length-1),i=Math.floor(e);return e===i?t[i]:t[i]*(1-e+i)+t[i+1]*(e-i)};if(s<0){return e(this._value.concat(),t)}const i=0===s?1:this.cols,r=0===s?this.cols:1,o=Matrix.zeros(...this._size.map(((t,e)=>e===s?1:t)));for(let l=0,h=0;l<o.length;l++,h+=i){const i=[];for(let t=0;t<this._size[s];t++)i.push(this._value[t*r+h]);o._value[l]=e(i,t)}return o}argmax(t){let s=0===t?1:this.cols,e=0===t?this.cols:1;const i=[].concat(this._size);i[t]=1;const r=Matrix.zeros(...i);for(let i=0,o=0;i<r.length;i++,o+=s){let s=this._value[o],l=0;for(let i=1;i<this._size[t];i++){let t=this._value[i*e+o];t>s&&(s=t,l=i)}r._value[i]=l}return r}argmin(t){let s=0===t?1:this.cols,e=0===t?this.cols:1;const i=[].concat(this._size);i[t]=1;const r=Matrix.zeros(...i);for(let i=0,o=0;i<r.length;i++,o+=s){let s=this._value[o],l=0;for(let i=1;i<this._size[t];i++){let t=this._value[i*e+o];t<s&&(s=t,l=i)}r._value[i]=l}return r}sum(t=-1){if(t<0)return this._value.reduce(((t,s)=>t+s),0);let s=0===t?1:this.cols,e=0===t?this.cols:1;const i=[].concat(this._size);i[t]=1;const r=Matrix.zeros(...i);for(let i=0,o=0;i<r.length;i++,o+=s){let s=0;for(let i=0;i<this._size[t];i++)s+=this._value[i*e+o];r._value[i]=s}return r}mean(t=-1){if(t<0)return this.sum(t)/this.length;let s=this.sum(t);return s.div(this._size[t]),s}prod(t=-1){if(t<0)return this._value.reduce(((t,s)=>t*s),1);let s=0===t?1:this.cols,e=0===t?this.cols:1;const i=[].concat(this._size);i[t]=1;const r=Matrix.zeros(...i);for(let i=0,o=0;i<r.length;i++,o+=s){let s=1;for(let i=0;i<this._size[t];i++)s*=this._value[i*e+o];r._value[i]=s}return r}variance(t=-1,s=0){const e=this.mean(t);if(t<0)return this._value.reduce(((t,s)=>t+(s-e)**2),0)/(this.length-s);let i=0===t?1:this.cols,r=0===t?this.cols:1;const o=[].concat(this._size);o[t]=1;const l=Matrix.zeros(...o);for(let o=0,h=0;o<l.length;o++,h+=i){let i=0;for(let s=0;s<this._size[t];s++)i+=(this._value[s*r+h]-e._value[o])**2;l._value[o]=i/(this._size[t]-s)}return l}std(t=-1,s=0){if(t<0)return Math.sqrt(this.variance(t,s));let e=this.variance(t,s);for(let t=0;t<e.length;t++)e._value[t]=Math.sqrt(e._value[t]);return e}isSquare(){return this.rows===this.cols}isDiag(t=0){const s=this.cols;for(let e=0;e<this.rows;e++)for(let i=0;i<s;i++)if(e!==i&&Math.abs(this._value[e*s+i])>t)return!1;return!0}isIdentity(t=0){if(!this.isSquare())return!1;const s=this.cols;for(let e=0;e<this.rows;e++)for(let i=0;i<s;i++)if(e!==i){if(Math.abs(this._value[e*s+i])>t)return!1}else if(Math.abs(this._value[e*s+i]-1)>t)return!1;return!0}isTriangular(t=0){return this.isLowerTriangular(t)||this.isUpperTriangular(t)}isLowerTriangular(t=0){const s=this.cols;for(let e=0;e<this.rows;e++)for(let i=e+1;i<s;i++)if(Math.abs(this._value[e*s+i])>t)return!1;return!0}isUpperTriangular(t=0){for(let s=0;s<this.rows;s++)for(let e=0;e<Math.min(s,this.cols);e++)if(Math.abs(this._value[s*this.cols+e])>t)return!1;return!0}isSymmetric(t=0){if(!this.isSquare())return!1;const s=this.cols;for(let e=0;e<this.rows;e++)for(let i=0;i<e;i++)if(t>0){if(Math.abs(this._value[e*s+i]-this._value[i*s+e])>t)return!1}else if(this._value[e*s+i]!==this._value[i*s+e])return!1;return!0}isHermitian(t=0){return this.isSymmetric(t)}isAlternating(t=0){if(!this.isSquare())return!1;const s=this.cols;for(let e=0;e<this.rows;e++)for(let i=0;i<e;i++)if(t>0){if(Math.abs(this._value[e*s+i]+this._value[i*s+e])>t)return!1}else if(this._value[e*s+i]!==-this._value[i*s+e])return!1;return!0}isSkewHermitian(t=0){return this.isAlternating(t)}isRegular(t=0){return!!this.isSquare()&&Math.abs(this.det())<=t}isNormal(t=0){return this.dot(this.t).equals(this.tDot(this),t)}isOrthogonal(t=0){const s=this.tDot(this);for(let e=0;e<this.rows;e++)for(let i=0;i<this.cols;i++){const r=s._value[e*this.cols+i];if(e===i){if(Math.abs(r-1)>t)return!1}else if(Math.abs(r)>t)return!1}return!0}isUnitary(t=0){return this.isOrthogonal(t)}isNilpotent(t=0){if(!this.isSquare())return!1;const s=this.eigenValues();for(let e=0;e<s.length;e++)if(isNaN(s[e])||Math.abs(s[e])>t)return!1;return!0}diag(){let t=[];const s=Math.min(this.rows,this.cols);for(let e=0;e<s;e++)t.push(this._value[e*this.cols+e]);return t}trace(){let t=0;const s=Math.min(this.rows,this.cols);for(let e=0;e<s;e++)t+=this._value[e*this.cols+e];return t}norm(t=2){if(t===1/0){let t=-1/0;for(let s=0;s<this.length;s++)t=Math.max(t,Math.abs(this._value[s]));return t}let s=0;for(let e=0;e<this.length;e++)s+=Math.abs(this._value[e])**t;return 2===t?Math.sqrt(s):s**(1/t)}rank(t=0){const s=this.copy();let e=0;for(let i=0;e<s.rows&&i<s.cols;i++,e++){if(Math.abs(s._value[e*s.cols+i])<=t)for(let r=e+1;r<s.rows;r++)if(Math.abs(s._value[r*s.cols+i])>t){s.swap(e,r,0);break}if(Math.abs(s._value[e*s.cols+i])<=t){e--;continue}const r=s._value[e*s.cols+i];for(let t=e+1;t<s.rows;t++){const o=s._value[t*s.cols+i];for(let l=i+1;l<s.cols;l++)s._value[t*s.cols+l]-=o*s._value[e*s.cols+l]/r}}return e}det(){if(!this.isSquare())throw new MatrixException("Determine only define square matrix.",this);const t=this._value;switch(this.rows){case 0:return 0;case 1:return t[0];case 2:return t[0]*t[3]-t[1]*t[2];case 3:return t[0]*t[4]*t[8]+t[1]*t[5]*t[6]+t[2]*t[3]*t[7]-t[0]*t[5]*t[7]-t[1]*t[3]*t[8]-t[2]*t[4]*t[6]}const[s,e]=this.lu();let i=1;for(let t=0;t<this.rows;t++){const r=t*this.cols+t;i*=s._value[r]*e._value[r]}return i}negative(){this.map((t=>-t))}abs(){this.map(Math.abs)}add(t){if(t instanceof Matrix)if(this.rows===t.rows&&this.cols===t.cols)for(let s=this.length-1;s>=0;s--)this._value[s]=this._value[s]+t._value[s];else if(this.rows>=t.rows&&this.cols>=t.cols){if(this.rows%t.rows!=0||this.cols%t.cols!=0)throw new MatrixException("Addition size invalid.",[this,t]);for(let s=0,e=0,i=0;s<this.length;s++,i++)i>=this.cols&&(e+=t.cols,i=0),e>=t.length&&(e=0),this._value[s]=this._value[s]+t._value[e+i%t.cols]}else{if(!(this.rows<=t.rows&&this.cols<=t.cols))throw new MatrixException("Addition size invalid.",[this,t]);if(t.rows%this.rows!=0||t.cols%this.cols!=0)throw new MatrixException("Addition size invalid.",[this,t]);this.repeat([t.rows/this.rows,t.cols/this.cols]);for(let s=this.length-1;s>=0;s--)this._value[s]=this._value[s]+t._value[s]}else this.map((s=>s+t))}addAt(t,s,e){if(t<0||this.rows<=t||s<0||this.cols<=s)throw new MatrixException("Index out of bounds.");const i=this._value[t*this.cols+s];return this._value[t*this.cols+s]=i+e,i}copyAdd(t){const s=this.copy();return s.add(t),s}sub(t){if(t instanceof Matrix)if(this.rows===t.rows&&this.cols===t.cols)for(let s=this.length-1;s>=0;s--)this._value[s]=this._value[s]-t._value[s];else if(this.rows>=t.rows&&this.cols>=t.cols){if(this.rows%t.rows!=0||this.cols%t.cols!=0)throw new MatrixException("Subtract size invalid.",[this,t]);for(let s=0,e=0,i=0;s<this.length;s++,i++)i>=this.cols&&(e+=t.cols,i=0),e>=t.length&&(e=0),this._value[s]=this._value[s]-t._value[e+i%t.cols]}else{if(!(this.rows<=t.rows&&this.cols<=t.cols))throw new MatrixException("Subtract size invalid.",[this,t]);if(t.rows%this.rows!=0||t.cols%this.cols!=0)throw new MatrixException("Subtract size invalid.",[this,t]);this.repeat([t.rows/this.rows,t.cols/this.cols]);for(let s=this.length-1;s>=0;s--)this._value[s]=this._value[s]-t._value[s]}else this.map((s=>s-t))}isub(t){this.negative(),this.add(t)}subAt(t,s,e){if(t<0||this.rows<=t||s<0||this.cols<=s)throw new MatrixException("Index out of bounds.");const i=this._value[t*this.cols+s];return this._value[t*this.cols+s]=i-e,i}isubAt(t,s,e){if(t<0||this.rows<=t||s<0||this.cols<=s)throw new MatrixException("Index out of bounds.");const i=this._value[t*this.cols+s];return this._value[t*this.cols+s]=e-i,i}copySub(t){const s=this.copy();return s.sub(t),s}copyIsub(t){const s=this.copy();return s.isub(t),s}mult(t){if(t instanceof Matrix)if(this.rows===t.rows&&this.cols===t.cols)for(let s=this.length-1;s>=0;s--)this._value[s]=this._value[s]*t._value[s];else if(this.rows>=t.rows&&this.cols>=t.cols){if(this.rows%t.rows!=0||this.cols%t.cols!=0)throw new MatrixException("Multiple size invalid.",[this,t]);for(let s=0,e=0,i=0;s<this.length;s++,i++)i>=this.cols&&(e+=t.cols,i=0),e>=t.length&&(e=0),this._value[s]=this._value[s]*t._value[e+i%t.cols]}else{if(!(this.rows<=t.rows&&this.cols<=t.cols))throw new MatrixException("Multiple size invalid.",[this,t]);if(t.rows%this.rows!=0||t.cols%this.cols!=0)throw new MatrixException("Multiple size invalid.",[this,t]);this.repeat([t.rows/this.rows,t.cols/this.cols]);for(let s=this.length-1;s>=0;s--)this._value[s]=this._value[s]*t._value[s]}else this.map((s=>s*t))}multAt(t,s,e){if(t<0||this.rows<=t||s<0||this.cols<=s)throw new MatrixException("Index out of bounds.");const i=this._value[t*this.cols+s];return this._value[t*this.cols+s]=i*e,i}copyMult(t){const s=this.copy();return s.mult(t),s}div(t){if(t instanceof Matrix)if(this.rows===t.rows&&this.cols===t.cols)for(let s=this.length-1;s>=0;s--)this._value[s]=this._value[s]/t._value[s];else if(this.rows>=t.rows&&this.cols>=t.cols){if(this.rows%t.rows!=0||this.cols%t.cols!=0)throw new MatrixException("Divide size invalid.",[this,t]);for(let s=0,e=0,i=0;s<this.length;s++,i++)i>=this.cols&&(e+=t.cols,i=0),e>=t.length&&(e=0),this._value[s]=this._value[s]/t._value[e+i%t.cols]}else{if(!(this.rows<=t.rows&&this.cols<=t.cols))throw new MatrixException("Divide size invalid.",[this,t]);if(t.rows%this.rows!=0||t.cols%this.cols!=0)throw new MatrixException("Divide size invalid.",[this,t]);this.repeat([t.rows/this.rows,t.cols/this.cols]);for(let s=this.length-1;s>=0;s--)this._value[s]=this._value[s]/t._value[s]}else this.map((s=>s/t))}idiv(t){if(t instanceof Matrix)if(this.rows===t.rows&&this.cols===t.cols)for(let s=this.length-1;s>=0;s--)this._value[s]=t._value[s]/this._value[s];else if(this.rows>=t.rows&&this.cols>=t.cols){if(this.rows%t.rows!=0||this.cols%t.cols!=0)throw new MatrixException("Divide size invalid.",[this,t]);for(let s=0,e=0,i=0;s<this.length;s++,i++)i>=this.cols&&(e+=t.cols,i=0),e>=t.length&&(e=0),this._value[s]=t._value[e+i%t.cols]/this._value[s]}else{if(!(this.rows<=t.rows&&this.cols<=t.cols))throw new MatrixException("Divide size invalid.",[this,t]);if(t.rows%this.rows!=0||t.cols%this.cols!=0)throw new MatrixException("Divide size invalid.",[this,t]);this.repeat([t.rows/this.rows,t.cols/this.cols]);for(let s=this.length-1;s>=0;s--)this._value[s]=t._value[s]/this._value[s]}else this.map((s=>t/s))}divAt(t,s,e){if(t<0||this.rows<=t||s<0||this.cols<=s)throw new MatrixException("Index out of bounds.");const i=this._value[t*this.cols+s];return this._value[t*this.cols+s]=i/e,i}idivAt(t,s,e){if(t<0||this.rows<=t||s<0||this.cols<=s)throw new MatrixException("Index out of bounds.");const i=this._value[t*this.cols+s];return this._value[t*this.cols+s]=e/i,i}copyDiv(t){const s=this.copy();return s.div(t),s}copyIdiv(t){const s=this.copy();return s.idiv(t),s}dot(t){if(this.cols!==t.rows)throw new MatrixException(`Dot size invalid. left = [${this.rows}, ${this.cols}], right = [${t.rows}, ${t.cols}]`);const s=t.cols,e=new Matrix(this.rows,s);let i=0;const r=this.length,o=t.length,l=this.cols,h=this._value,a=t._value,n=e._value;for(let t=0;t<r;t+=l){let e=0,r=0;for(let i=0,l=t;i<o;i+=s,l++)h[l]&&r++,e+=h[l]*a[i];if(n[i++]=e,0!==r)if(r/l<.1){let r=[],o=[];for(let s=0;s<l;s++)h[t+s]&&(r.push(h[t+s]),o.push(s));for(let t=1;t<s;t++){e=0;for(let i=0;i<r.length;i++)e+=r[i]*a[o[i]*s+t];n[i++]=e}}else for(let r=1;r<s;r++){e=0;for(let i=r,l=t;i<o;i+=s,l++)e+=h[l]*a[i];n[i++]=e}else i+=s-1}return e}tDot(t){if(this.rows!==t.rows)throw new MatrixException(`tDot size invalid. left = [${this.cols}, ${this.rows}], right = [${t.rows}, ${t.cols}]`);const s=new Matrix(this.cols,t.cols);let e=0;for(let i=0;i<this.cols;i++)for(let r=0;r<t.cols;r++){let o=0,l=i;for(let s=r;s<t.length;s+=t.cols,l+=this.cols)o+=this._value[l]*t._value[s];s._value[e++]=o}return s}kron(t){const s=new Matrix(this.rows*t.rows,this.cols*t.cols);for(let e=0;e<this.rows;e++)for(let i=0;i<this.cols;i++)for(let r=0;r<t.rows;r++)for(let o=0;o<t.cols;o++)s._value[(e*t.rows+r)*this.cols*t.cols+i*t.cols+o]=this._value[e*this.cols+i]*t._value[r*t.cols+o];return s}convolute(t,s=!0){const e=[Math.floor((t.length-1)/2),Math.floor((t[0].length-1)/2)],i=this._value.concat();for(let r=0;r<this.rows;r++)for(let o=0;o<this.cols;o++){let l=0,h=0;for(let s=0;s<t.length;s++){const a=r+s-e[0];if(!(a<0||this.rows<=a))for(let r=0;r<t[s].length;r++){const n=o+r-e[1];n<0||this.cols<=n||(l+=t[s][r]*i[a*this.cols+n],h+=t[s][r])}}s&&(l/=h),this._value[r*this.cols+o]=l}}reducedRowEchelonForm(t=0){for(let s=0,e=0;s<this.rows&&e<this.cols;e++,s++){if(Math.abs(this._value[s*this.cols+e])<=t)for(let i=s+1;i<this.rows;i++)if(Math.abs(this._value[i*this.cols+e])>t){this.swap(s,i,0);break}if(Math.abs(this._value[s*this.cols+e])<=t){s--;continue}const i=this._value[s*this.cols+e];this._value[s*this.cols+e]=1;for(let t=e+1;t<this.cols;t++)this._value[s*this.cols+t]/=i;for(let t=0;t<this.rows;t++){if(t===s)continue;const i=this._value[t*this.cols+e];this._value[t*this.cols+e]=0;for(let r=e+1;r<this.cols;r++)this._value[t*this.cols+r]-=i*this._value[s*this.cols+r]}}}inv(){if(!this.isSquare())throw new MatrixException("Inverse matrix only define square matrix.",this);const t=this._value;switch(this.rows){case 0:return new Matrix(0,0);case 1:return new Matrix(1,1,[1/t[0]]);case 2:{const s=this.det();return new Matrix(2,2,[t[3]/s,-t[1]/s,-t[2]/s,t[0]/s])}case 3:{const s=this.det();return new Matrix(3,3,[(t[4]*t[8]-t[5]*t[7])/s,(t[2]*t[7]-t[1]*t[8])/s,(t[1]*t[5]-t[2]*t[4])/s,(t[5]*t[6]-t[3]*t[8])/s,(t[0]*t[8]-t[2]*t[6])/s,(t[2]*t[3]-t[0]*t[5])/s,(t[3]*t[7]-t[4]*t[6])/s,(t[1]*t[6]-t[0]*t[7])/s,(t[0]*t[4]-t[1]*t[3])/s])}}return this.isLowerTriangular()?this.invLowerTriangular():this.isUpperTriangular()?this.invUpperTriangular():this.invLU()}invLowerTriangular(){if(!this.isSquare())throw new MatrixException("Inverse matrix only define square matrix.",this);const t=this._value,s=new Matrix(this.rows,this.cols);for(let e=0;e<this.rows;e++){const i=t[e*this.cols+e];s._value[e*this.cols+e]=1/i;for(let r=0;r<e;r++){let o=0;for(let i=r;i<e;i++)o+=t[e*this.cols+i]*s._value[i*this.cols+r];s._value[e*this.cols+r]=-o/i}}return s}invUpperTriangular(){if(!this.isSquare())throw new MatrixException("Inverse matrix only define square matrix.",this);const t=this._value,s=new Matrix(this.rows,this.cols);for(let e=this.cols-1;e>=0;e--){const i=t[e*this.cols+e];s._value[e*this.cols+e]=1/i;for(let r=e+1;r<this.cols;r++){let o=0;for(let i=e+1;i<=r;i++)o+=t[e*this.cols+i]*s._value[i*this.cols+r];s._value[e*this.cols+r]=-o/i}}return s}invRowReduction(){if(!this.isSquare())throw new MatrixException("Inverse matrix only define square matrix.",this);const t=this.copy(),s=this.rows,e=Matrix.eye(s,s);for(let i=0;i<s;i++){const r=i*s;if(0===t._value[r+i]){let o=i+1;for(;o<s&&0===t._value[o*s+i];o++);if(o===s)throw new MatrixException("",this);for(let e=i;e<s;e++)[t._value[r+e],t._value[o*s+e]]=[t._value[o*s+e],t._value[r+e]];e.swap(i,o)}const o=t._value[r+i];t._value[r+i]=1;for(let e=i+1;e<s;e++)t._value[r+e]/=o;for(let t=0;t<s;t++)e._value[r+t]=e._value[r+t]/o;for(let o=0;o<s;o++){if(i===o)continue;const l=t._value[o*s+i];t._value[o*s+i]=0;for(let e=i+1;e<s;e++)t._value[o*s+e]-=l*t._value[r+e];for(let t=0;t<s;t++)e._value[o*s+t]=e._value[o*s+t]-l*e._value[r+t]}}return e}invLU(){if(!this.isSquare())throw new MatrixException("Inverse matrix only define square matrix.",this);const[t,s]=this.lu();return s.invUpperTriangular().dot(t.invLowerTriangular())}sqrt(){if(!this.isSquare())throw new MatrixException("sqrt only define square matrix.",this);switch(this.rows){case 0:return this;case 1:return new Matrix(1,1,[Math.sqrt(this._value[0])])}if(this.isDiag())return Matrix.diag(this.diag().map(Math.sqrt));const[t,s]=this.eigen(),e=new Matrix(this.rows,this.cols);for(let s=0;s<this.rows;s++)e._value[s*this.cols+s]=Math.sqrt(t[s]);return s.dot(e).dot(s.transpose())}power(t){if(!this.isSquare())throw new MatrixException("Only square matrix can power.",this);const s=this.rows;if(this.isDiag(1e-12))return Matrix.diag(this.diag().map((s=>Math.pow(s,t))));if(Number.isInteger(t)){if(0===t)return Matrix.eye(s,s);if(1===t)return this.copy();if(2===t)return this.dot(this);if(-1===t)return this.inv();if(t<0)return this.inv().power(-t);if(!this.isSymmetric(1e-12)){let s=this.dot(this);for(let e=2;e<t;e++)s=s.dot(this);return s}const[e,i]=this.eigen(),r=Matrix.diag(e.map((s=>Math.pow(s,t))));return i.dot(r).dot(i.t)}if(t<0)return this.inv().power(-t);if(.5===t)return this.sqrt();throw new MatrixException("Power only defined integer.")}exp(){if(!this.isSquare())throw new MatrixException("Only square matrix can exp.",this);if(1===this.rows)return new Matrix(1,1,Math.exp(this._value[0]));if(this.isDiag())return Matrix.diag(this.diag().map(Math.exp));const t=Matrix.eye(this.rows,this.cols);let s=1,e=1,i=this;const r=10**(Math.floor(Math.log(Math.abs(this.trace())))-8);for(;;){const o=i.copyDiv(s);if(t.add(o),o.norm()<r)break;i=i.dot(this),e++,s*=e}return t}log(){if(!this.isSquare())throw new MatrixException("Only square matrix can exp.",this);if(1===this.rows)return new Matrix(1,1,Math.log(this._value[0]));if(this.isDiag())return Matrix.diag(this.diag().map(Math.log));const[t,s]=this.eigen(),e=s.inv();return s.dot(Matrix.diag(t.map(Math.log))).dot(e)}cov(t=0){const s=new Matrix(this.cols,this.cols),e=[];for(let i=0;i<this.cols;i++){let r=0;for(let t=i;t<this.length;t+=this.cols)r+=this._value[t];e[i]=r/this.rows;for(let r=0;r<=i;r++){let o=0;for(let t=0;t<this.length;t+=this.cols)o+=(this._value[i+t]-e[i])*(this._value[r+t]-e[r]);s._value[i*this.cols+r]=s._value[r*this.cols+i]=o/(this.rows-t)}}return s}gram(){return this.tDot(this)}solve(t){if(this.rows>this.cols)throw new MatrixException("Only square matrix or matrix with more columns than rows can be solved.",this);const s=this.rows;if(s!==t.rows)throw new MatrixException("b size is invalid.",[this,t]);const e=s<this.cols?this.resize(s,s):this;let i;switch(s){case 0:i=e;break;case 1:i=t.copyMap((t=>t/e._value[0]));break;default:{const[s,r]=e.lu(),o=s.solveLowerTriangular(t);i=r.solveUpperTriangular(o);break}}return s<this.cols&&(i=i.resize(this.cols,i.cols)),i}solveLowerTriangular(t){if(!this.isSquare())throw new MatrixException("Only square matrix can solve.",this);const s=this.rows,e=t.cols;if(s!==t.rows)throw new MatrixException("b size is invalid.",[this,t]);const i=new Matrix(s,e);for(let r=0;r<e;r++)for(let o=0;o<s;o++){let l=t._value[o*e+r];for(let t=0;t<o;t++)l-=i._value[t*e+r]*this._value[o*s+t];i._value[o*e+r]=l/this._value[o*s+o]}return i}solveUpperTriangular(t){if(!this.isSquare())throw new MatrixException("Only square matrix can solve.",this);const s=this.rows,e=t.cols;if(s!==t.rows)throw new MatrixException("b size is invalid.",[this,t]);const i=new Matrix(s,e);for(let r=0;r<e;r++)for(let o=s-1;o>=0;o--){let l=t._value[o*e+r];for(let t=s-1;t>o;t--)l-=i._value[t*e+r]*this._value[o*s+t];i._value[o*e+r]=l/this._value[o*s+o]}return i}bidiag(){const t=this.copy(),[s,e]=[this.rows,this.cols];for(let i=0;i<Math.min(s,e);i++){let r=t.block(i,i),o=r.col(0),l=o.norm()*(o._value[0]<0?1:-1);o._value[0]-=l,o.div(o.norm());let h=o.dot(o.t);h.mult(2);let a=Matrix.eye(s-i,s-i);a.sub(h),r=a.tDot(r),o=r.row(0),o._value[0]=0,o.norm()>0&&(l=o.norm()*(o._value[1]<0?1:-1),o._value[1]-=l,o.div(o.norm())),h=o.tDot(o),h.mult(2),a=Matrix.eye(e-i,e-i),a.sub(h),r=r.dot(a),t.set(i,i,r)}return t}tridiag(){return this.tridiagHouseholder()}tridiagHouseholder(){if(!this.isSymmetric())throw new MatrixException("Tridiagonal only define symmetric matrix.",this);const t=this.copy(),s=this.cols;for(let e=0;e<s-2;e++){const i=t.block(e+1,e,s,e+1),r=i.norm()*(i._value[0]<0?1:-1);i._value[0]-=r,i.div(i.norm());const o=t.block(e+1,e+1),l=o.dot(i),h=i.copyMult(i.tDot(l));h.isub(l),h.mult(2),o.sub(h.dot(i.t)),o.sub(i.dot(h.t)),t.set(e+1,e+1,o),t._value[e*s+e+1]=t._value[(e+1)*s+e]=r;for(let i=e+2;i<s;i++)t._value[e*s+i]=t._value[i*s+e]=0}return t}tridiagLanczos(t=0){if(!this.isSymmetric())throw new MatrixException("Tridiagonal only define symmetric matrix.",this);const s=this.cols;t<=0&&(t=s);let e=0,i=Matrix.zeros(s,1),r=Matrix.randn(s,1);r.div(r.norm());const o=Matrix.zeros(t,t);for(let s=0;s<t;s++){const l=this.dot(r),h=r.tDot(l).toScaler();l.sub(i.copyMult(e)),l.sub(r.copyMult(h)),e=l.norm(),i=r,l.div(e),r=l,o.set(s,s,h),s<t-1&&(o.set(s,s+1,e),o.set(s+1,s,e))}return o}hessenberg(){return this.hessenbergArnoldi()}hessenbergArnoldi(t=0){if(!this.isSquare())throw new MatrixException("Hessenberg only define square matrix.",this);const s=this.cols;t<=0&&(t=s);const e=Matrix.zeros(t,t),i=[Matrix.random(s,1,-1,1)];i[0].div(i[0].norm());for(let s=0;s<t;s++){const r=this.dot(i[s]);for(let t=0;t<=s;t++){const o=i[t].tDot(r).toScaler();r.sub(i[t].copyMult(o)),e.set(t,s,o)}const o=r.norm();r.div(o),i[s+1]=r,s<t-1&&e.set(s+1,s,o)}return e}lu(){if(!this.isSquare())throw new MatrixException("LU decomposition only define square matrix.",this);const t=this.rows;switch(t){case 0:return[this,this];case 1:return[Matrix.ones(1,1),new Matrix(1,1,[this._value[0]])];case 2:return[new Matrix(2,2,[1,0,this._value[2]/this._value[0],1]),new Matrix(2,2,[this._value[0],this._value[1],0,this._value[3]-this._value[1]*this._value[2]/this._value[0]])]}let s=this.copy();for(let e=0;e<t;e++){const i=s._value[e*t+e];for(let r=e+1;r<t;r++){const o=s._value[r*t+e]/=i;for(let i=e+1;i<t;i++)s._value[r*t+i]-=o*s._value[e*t+i]}}let e=Matrix.eye(t,t);for(let i=0;i<t;i++)for(let r=0;r<i;r++)e._value[i*t+r]=s._value[i*t+r],s._value[i*t+r]=0;return[e,s]}qr(){const t=this.rows,s=this.cols;if(0===t||0===s)return[this,this];if(1===t)return[Matrix.ones(1,1),this];if(1===s){const t=Math.sqrt(this.tDot(this).toScaler());return[this.copyDiv(t),new Matrix(1,1,t)]}return this.qrHouseholder()}qrGramSchmidt(){const t=this.cols,s=this.copy(),e=Matrix.eye(t,t),i=[];for(let r=0;r<t;r++){for(let o=0;o<r;o++){let l=0;for(let e=0;e<this.rows;e++)l+=this._value[e*t+r]*s._value[e*t+o];const h=e._value[o*t+r]=l/i[o]**2;for(let e=0;e<this.rows;e++)s._value[e*t+r]-=s._value[e*t+o]*h}i.push(s.col(r).norm())}return s.mult(new Matrix(1,t,i.map((t=>1/t)))),e.mult(new Matrix(t,1,i)),[s,e]}qrHouseholder(){const t=this.rows,s=this.cols,e=this.copy(),i=Matrix.eye(t,t);for(let r=0;r<Math.min(t,s)-1;r++){const s=t-r,o=e.block(r,r,t,r+1),l=o.norm()*Math.sign(o._value[0]);o._value[0]-=l,o.div(o.norm()+1e-12);const h=new Matrix(s,s);for(let t=0;t<s;t++){const e=o._value[t];if(h._value[t*s+t]=1-2*e**2,e)for(let i=0;i<t;i++)h._value[t*s+i]=h._value[i*s+t]=-2*e*o._value[i]}e.set(r,r,h.dot(e.block(r,r))),i.set(r,0,h.dot(i.block(r,0)))}return[i.t,e]}singularValues(){const t=this.dot(this.adjoint()).eigenJacobi()[0];for(let s=0;s<t.length;s++)-1e-12<t[s]&&t[s]<0&&(t[s]=0),t[s]=Math.sqrt(t[s]);return t}svd(){return this.svdEigen()}svdEigen(){const t=Math.min(this.cols,this.rows);if(this.cols<=this.rows){const s=this.tDot(this),[e,i]=s.eigenJacobi();for(let s=0;s<t;s++)e[s]=Math.sqrt(e[s]);const r=this.dot(i);for(let s=0;s<this.rows;s++)for(let i=0;i<t;i++)r._value[s*t+i]/=e[i];return[r,e,i]}{const s=this.dot(this.t),[e,i]=s.eigenJacobi();for(let s=0;s<t;s++)e[s]=Math.sqrt(e[s]);const r=i.tDot(this);for(let s=0;s<t;s++)for(let t=0;t<this.cols;t++)r._value[s*this.cols+t]/=e[s];return[i,e,r.t]}}svdGolubKahan(){}cholesky(){return this.choleskyBanachiewicz()}choleskyBanachiewicz(){if(!this.isSymmetric(1e-15))throw new MatrixException("Cholesky decomposition only define symmetric matrix.",this);const t=this.rows,s=new Matrix(t,t);for(let e=0;e<t;e++){let i=0;for(let r=0;r<e;r++){let o=0;for(let i=0;i<r;i++)o+=s._value[e*t+i]*s._value[r*t+i];s._value[e*t+r]=(this._value[e*t+r]-o)/s._value[r*t+r],i+=s._value[e*t+r]**2}s._value[e*t+e]=Math.sqrt(this._value[e*t+e]-i)}return s}choleskyLDL(){if(!this.isSymmetric(1e-15))throw new MatrixException("Cholesky decomposition only define symmetric matrix.",this);const t=this.rows,s=[],e=Matrix.eye(t,t);for(let i=0;i<t;i++){s[i]=this._value[i*t+i];for(let r=0;r<i;r++){let o=0;for(let l=0;l<r;l++)o+=e._value[i*t+l]*e._value[r*t+l]*s[l];e._value[i*t+r]=(this._value[i*t+r]-o)/s[r],s[i]-=e._value[i*t+r]**2*s[r]}}return[e,s]}schur(){throw new MatrixException("Not implemented.")}eigen(){if(!this.isSquare())throw new MatrixException("Eigen values only define square matrix.",this);if(this.rows<=2)return[this.eigenValues(),this.eigenVectors()];if(this.isSymmetric(1e-15))return this.eigenJacobi();{const t=this.eigenValues(),s=this.rows,e=new Matrix(s,s);for(let i=0;i<s;i++){const[,r]=this.eigenInverseIteration(t[i]);for(let t=0;t<s;t++)e._value[t*s+i]=r._value[t]}return[t,e]}}eigenValues(){if(!this.isSquare())throw new MatrixException("Eigen values only define square matrix.",this);switch(this.rows){case 0:return[];case 1:return[this._value[0]];case 2:{const t=this._value[0]+this._value[3],s=Math.sqrt(t**2-4*this.det());return[(t+s)/2,(t-s)/2]}case 3:{const t=-this.det(),s=this._value[0]*this._value[4]+this._value[0]*this._value[8]+this._value[4]*this._value[8]-this._value[5]*this._value[7]-this._value[2]*this._value[6]-this._value[1]*this._value[3],e=-this._value[0]-this._value[4]-this._value[8],i=t-s*e/3+e**3*2/27,r=(i/2)**2+((s-e**2/3)/3)**3;let[o,l]=new Complex(r).sqrt();o=o.add(-i/2),l=l.add(-i/2);const[h,a,n]=o.cbrt(),[c,u,f]=l.cbrt(),v=[h.add(c),a.add(f),n.add(u)].map((t=>Math.abs(t.imaginary)<1e-12?t.real-e/3:Number.NaN));return v.sort(((t,s)=>s-t)),v}}return this.isSymmetric(1e-15)?this.eigenJacobi()[0]:this.eigenValuesQR()}eigenVectors(){if(!this.isSquare())throw new MatrixException("Eigen vectors only define square matrix.",this);switch(this.rows){case 0:return this;case 1:return new Matrix(1,1,[1]);case 2:{const t=this.eigenValues(),s=[-this._value[1],this._value[0]-t[0]],e=Math.sqrt(s[0]**2+s[1]**2),i=[-this._value[1],this._value[0]-t[1]],r=Math.sqrt(i[0]**2+i[1]**2);return new Matrix(2,2,[s[0]/e,i[0]/r,s[1]/e,i[1]/r])}}return this.eigen()[1]}eigenValuesBiSection(){if(!this.isSymmetric(1e-15))throw new MatrixException("eigenValuesBiSection can only use symmetric matrix.",this);const t=this.tridiag(),s=this.rows;let e=0;for(let i=0;i<s;i++){const r=Math.abs(t.at(i,i))+Math.abs(i>0?t.at(i,i-1):0)+Math.abs(i<s-1?t.at(i,i+1):0);e<r&&(e=r)}const i=e=>{const i=[1,e-t.at(0,0)];for(let r=1;r<s;r++)i[r+1]=(e-t.at(r,r))*i[r]-t.at(r,r-1)**2*i[r-1];i.reverse();let r=0;for(let t=1;t<i.length;t++)Math.sign(i[t-1])!==Math.sign(i[t])&&r++;return r},r=[];for(let t=1;t<=s;t++){let s=-e,o=i(s),l=e;for(;Math.abs(s-l)>1e-8;){const e=(s+l)/2,r=i(e);t<=o&&t>r?l=e:(s=e,o=r)}r.push((s+l)/2)}return r}eigenValuesLR(){if(!this.isSquare())throw new MatrixException("Eigen values only define square matrix.",this);let t=this;const s=t.rows;let e=1e5;for(;e-- >0;){const[e,i]=t.lu();t=i.dot(e);let r=0;for(let e=0;e<s;e++)for(let i=0;i<e;i++)r+=t._value[e*s+i]**2;if(r<1e-15){const s=t.diag();return s.sort(((t,s)=>s-t)),s}}throw new MatrixException("eigenValuesLR not converged.",this)}eigenValuesQR(){if(!this.isSquare())throw new MatrixException("Eigen values only define square matrix.",this);let t=this.copy();const s=[];for(let e=t.rows;e>2;e--){let i=1e6;for(;;){const r=t.block(e-2,e-2).eigenValues();if(isNaN(r[0])){s.sort(((t,s)=>s-t));for(let t=0;t<e;t++,s.push(NaN));return s}const o=t._value[t._value.length-1],l=Math.abs(r[0]-o)<Math.abs(r[1]-o)?r[0]:r[1];for(let s=0;s<e;s++)t._value[s*e+s]-=l;const[h,a]=t.qr();t=a.dot(h);for(let s=0;s<e;s++)t._value[s*e+s]=t._value[s*e+s]+l;let n=0;for(let s=(e-1)*e;s<t.length-1;s++)n+=Math.abs(t._value[s]);if(n<1e-8)break;if(i--<0)throw new MatrixException("eigenValuesQR not converged.",this)}s.push(t._value[t._value.length-1]),t=t.resize(e-1,e-1)}const e=t.eigenValues();return s.push(...e),s.sort(((t,s)=>s-t)),s}eigenJacobi(t=1e6){if(!this.isSymmetric(1e-15))throw new MatrixException("Jacobi method can only use symmetric matrix.",this);const s=this._value.concat(),e=Matrix.eye(this.rows,this.cols);e.add(0);let i=0;const r=this.rows;let o=t;for(;;){let t=0,l=0,h=0;for(let e=0;e<r;e++)for(let i=e+1;i<r;i++){const o=Math.abs(s[e*r+i]);o>t&&(t=o,l=e,h=i)}if(t<1e-15)break;if(t===i)break;if(o--<0){console.log(new MatrixException("eigenJacobi not converged.",[this,t]));break}i=t;const a=s[l*r+l],n=s[l*r+h],c=s[h*r+h],u=(a-c)/2,f=-n,v=Math.abs(u)/Math.sqrt(u**2+f**2);let w=Math.sqrt((1-v)/2);const _=Math.sqrt((1+v)/2);u*f<0&&(w=-w);for(let t=0;t<r;t++){const e=s[l*r+t],i=s[h*r+t];s[t*r+h]=s[h*r+t]=w*e+_*i,s[t*r+l]=s[l*r+t]=_*e-w*i}s[l*r+l]=_**2*a+w**2*c-2*w*_*n,s[l*r+h]=s[h*r+l]=w*_*(a-c)+(_**2-w**2)*n,s[h*r+h]=w**2*a+_**2*c+2*w*_*n;for(let t=0;t<r;t++){const s=e._value[t*r+l],i=e._value[t*r+h];e._value[t*r+h]=w*s+_*i,e._value[t*r+l]=_*s-w*i}}const l=[];for(let t=0;t<r;t++)l.push([t,s[t*r+t]]);l.sort(((t,s)=>s[1]-t[1]));const h=e.col(l.map((t=>t[0])));return[l.map((t=>t[1])),h]}eigenPowerIteration(){if(!this.isSquare())throw new MatrixException("Eigen vectors only define square matrix.",this);const t=this.rows;let s=Matrix.randn(t,1);s.div(s.norm());let e=1/0,i=1e4;for(;i-- >0;){const i=this.dot(s);let r=0,o=0;for(let e=0;e<t;e++)r+=i._value[e]**2,o+=i._value[e]*s._value[e];const l=r/o;i.div(i.norm());const h=Math.abs(l-e);if(h<1e-15||isNaN(h))return[l,i];s=i,e=l}throw new MatrixException("eigenPowerIteration not converged.",this)}eigenInverseIteration(t=0){if(!this.isSquare())throw new MatrixException("Eigen vectors only define square matrix.",this);const s=this.rows;let e=this.copy();for(let i=0;i<s;i++)e._value[i*s+i]=e._value[i*s+i]-t+1e-15;e=e.inv();let i=Matrix.randn(s,1);i.div(i.norm());let r=1/0,o=1e4;for(;o-- >0;){const o=e.dot(i);let l=0,h=0;for(let t=0;t<s;t++)l+=o._value[t]**2,h+=i._value[t]*o._value[t];const a=h/l;o.div(o.norm());const n=Math.abs(a-r);if(n<1e-15||isNaN(n))return[a+t,o];i=o,r=a}throw new MatrixException("eigenInverseIteration not converged.",this)}}