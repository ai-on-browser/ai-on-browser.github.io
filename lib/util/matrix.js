var D=Object.defineProperty;var k=(A,t)=>D(A,"name",{value:t,configurable:!0});import q from"./complex.js";import N from"./tensor.js";const I=k((A,t)=>{const e=Math.sqrt(t),s=Math.random(),i=Math.random(),o=Math.sqrt(-2*Math.log(s))*Math.cos(2*Math.PI*i),n=Math.sqrt(-2*Math.log(s))*Math.sin(2*Math.PI*i);return[o*e+A,n*e+A]},"normal_random");export class MatrixException extends Error{static{k(this,"MatrixException")}constructor(t,e){super(t),this.value=e,this.name="MatrixException"}}export default class a{static{k(this,"Matrix")}constructor(t,e,s){s?Array.isArray(s)?Array.isArray(s[0])?this._value=s.flat():this._value=s:this._value=Array(t*e).fill(s):this._value=Array(t*e).fill(0),this._size=[t,e]}static zeros(t,e){return new a(t,e,Array(t*e).fill(0))}static ones(t,e){return new a(t,e,Array(t*e).fill(1))}static eye(t,e,s=1){const i=new a(t,e),o=Math.min(t,e);for(let n=0;n<o;n++)i._value[n*e+n]=s;return i}static random(t,e,s=0,i=1){const o=new a(t,e);for(let n=0;n<o.length;n++)o._value[n]=Math.random()*(i-s)+s;return o}static randint(t,e,s=0,i=1){const o=new a(t,e);for(let n=0;n<o.length;n++)o._value[n]=Math.floor(Math.random()*(i-s+1)+s);return o}static randn(t,e,s=0,i=1){const o=new a(t,e);if(Array.isArray(s)&&(s=new a(1,s.length,s)),Array.isArray(i)&&(i=a.fromArray(i)),!(s instanceof a)&&!(i instanceof a)){for(let h=0;h<o.length;h+=2){const r=I(s,i);o._value[h]=r[0],h+1<o.length&&(o._value[h+1]=r[1])}return o}if(s instanceof a?(s.rows===e||s.cols===1)&&(s=s.t):s=new a(1,e,s),s.cols!==e||s.rows!==1)throw new MatrixException("'myu' cols must be same as 'cols' and rows must be 1.");if(!(i instanceof a))i=a.eye(e,e,i);else if(i.rows!==e||i.cols!==e)throw new MatrixException("'sigma' cols and rows must be same as 'cols'.");const n=i.cholesky();for(let h=0;h<o.length;h+=2){const r=I(0,1);o._value[h]=r[0],h+1<o.length&&(o._value[h+1]=r[1])}const l=o.dot(n.t);return l.add(s),l}static diag(t){let e=0,s=0;for(const o of t)typeof o=="number"?(e++,s++):(e+=o.rows,s+=o.cols);const i=new a(e,s);for(let o=0,n=0,l=0;n<e;o++){const h=t[o];typeof h=="number"?(i._value[n*s+l]=h,n++,l++):(i.set(n,l,h),n+=h.rows,l+=h.cols)}return i}static fromArray(t){if(t instanceof a)return t;if(Array.isArray(t)){if(t.length===0)return new a(0,0);if(!Array.isArray(t[0]))return new a(t.length,1,t)}else return new a(1,1,t);return new a(t.length,t[0].length,t)}get dimension(){return this._size.length}get sizes(){return this._size}get length(){return this._size[0]*this._size[1]}get rows(){return this._size[0]}get cols(){return this._size[1]}get value(){return this._value}get t(){return this.transpose()}*[Symbol.iterator](){yield*this._value}toArray(){const t=[],e=this.cols;for(let s=0;s<this.length;s+=e)t.push(this._value.slice(s,s+e));return t}toScaler(){if(this.rows!==1||this.cols!==1)throw new MatrixException("The matrix cannot convert to scaler.");return this._value[0]}toString(){let t="[";for(let e=0;e<this.rows;e++){e>0&&(t+=`,
 `),t+="[";for(let s=0;s<this.cols;s++)s>0&&(t+=", "),t+=this._value[e*this.cols+s];t+="]"}return t+"]"}copy(t){return t===this?this:t?(t._size=[].concat(this._size),this._value.forEach((e,s)=>t._value[s]=e),t):new a(this.rows,this.cols,[].concat(this._value))}equals(t,e=0){if(t instanceof a){if(this._size[0]!==t._size[0]||this._size[1]!==t._size[1])return!1;for(let s=this.length-1;s>=0;s--)if(Math.abs(this._value[s]-t._value[s])>e)return!1;return!0}return!1}at(t,e){if(Array.isArray(t)&&([t,e]=t),t<0||this.rows<=t||e<0||this.cols<=e)throw new MatrixException("Index out of bounds.");return this._value[t*this.cols+e]}set(t,e,s){if(Array.isArray(t)&&(s=e,[t,e]=t),s instanceof a){if(t<0||this.rows<=t+s.rows-1||e<0||this.cols<=e+s.cols-1)throw new MatrixException("Index out of bounds.");for(let i=0;i<s.rows;i++)for(let o=0;o<s.cols;o++)this._value[(i+t)*this.cols+o+e]=s._value[i*s.cols+o];return null}else{if(t<0||this.rows<=t||e<0||this.cols<=e)throw new MatrixException("Index out of bounds.");const i=this._value[t*this.cols+e];return this._value[t*this.cols+e]=s,i}}row(t){if(Array.isArray(t)){if(typeof t[0]=="boolean"){if(t.length!==this.rows)throw new MatrixException("Length is invalid.");const s=[];for(let i=0;i<t.length;i++)t[i]&&s.push(i);t=s}if(t.some(s=>s<0||this.rows<=s))throw new MatrixException("Index out of bounds.");const e=new a(t.length,this.cols);for(let s=0;s<t.length;s++)for(let i=0;i<this.cols;i++)e._value[s*this.cols+i]=this._value[t[s]*this.cols+i];return e}else{if(t<0||this.rows<=t)throw new MatrixException("Index out of bounds.");return new a(1,this.cols,this._value.slice(t*this.cols,(t+1)*this.cols))}}col(t){if(Array.isArray(t)){if(typeof t[0]=="boolean"){if(t.length!==this.cols)throw new MatrixException("Length is invalid.");const s=[];for(let i=0;i<t.length;i++)t[i]&&s.push(i);t=s}if(t.some(s=>s<0||this.cols<=s))throw new MatrixException("Index out of bounds.");const e=new a(this.rows,t.length);for(let s=0;s<this.rows;s++)for(let i=0;i<t.length;i++)e._value[s*t.length+i]=this._value[s*this.cols+t[i]];return e}else{if(t<0||this.cols<=t)throw new MatrixException("Index out of bounds.");const e=new a(this.rows,1);for(let s=0;s<this.rows;s++)e._value[s]=this._value[s*this.cols+t];return e}}slice(t,e,s=0){if(typeof t!="number"&&(t=0),typeof e!="number"&&(e=this._size[s]),t<0||this._size[s]<t||e<0||this._size[s]<e)throw new MatrixException("Index out of bounds.");if(t>e)throw new MatrixException("'to' must be greater than or equals to 'from'.");if(s===0){const i=new a(e-t,this.cols);return i._value=this._value.slice(t*this.cols,e*this.cols),i}else if(s===1){const i=new a(this.rows,e-t);for(let o=0;o<i.rows;o++)for(let n=0;n<i.cols;n++)i._value[o*i.cols+n]=this._value[o*this.cols+n+t];return i}else throw new MatrixException("Invalid axis.")}block(t,e,s,i){if(typeof t!="number"&&(t=0),typeof e!="number"&&(e=0),typeof s!="number"&&(s=this.rows),typeof i!="number"&&(i=this.cols),t<0||this.rows<t||s<0||this.rows<s||e<0||this.cols<e||i<0||this.cols<i)throw new MatrixException("Index out of bounds.");if(t>s)throw new MatrixException("'rows_to' must be greater than or equals to 'rows_from'.");if(e>i)throw new MatrixException("'cols_to' must be greater than or equals to 'cols_from'.");const o=new a(s-t,i-e);for(let n=0;n<o.rows;n++)for(let l=0;l<o.cols;l++)o._value[n*o.cols+l]=this._value[(n+t)*this.cols+l+e];return o}remove(t,e=0){if(e===0)if(Array.isArray(t)){if(t.some(s=>s<0||this.rows<=s))throw new MatrixException("Index out of bounds.");t=[...new Set(t)],t.sort((s,i)=>i-s);for(let s=0;s<t.length;s++)this._value.splice(t[s]*this.cols,this.cols);this._size[0]-=t.length}else{if(t<0||this.rows<=t)throw new MatrixException("Index out of bounds.");this._value.splice(t*this.cols,this.cols),this._size[0]--}else if(e===1)if(Array.isArray(t)){if(t.some(o=>o<0||this.cols<=o))throw new MatrixException("Index out of bounds.");t=[...new Set(t)],t.sort((o,n)=>o-n);let s=0,i=0;for(let o=0;o<this.rows;o++)for(let n=0,l=0;n<this.cols;n++,s++){if(t[l]===n){l++;continue}this._value[i++]=this._value[s]}this._size[1]-=t.length,this._value.length=this.length}else{if(t<0||this.cols<=t)throw new MatrixException("Index out of bounds.");let s=0,i=0;for(let o=0;o<this.rows;o++)for(let n=0;n<this.cols;n++,s++)t!==n&&(this._value[i++]=this._value[s]);this._size[1]--,this._value.length=this.length}else throw new MatrixException("Invalid axis.")}removeIf(t,e=0){const s=[];if(e===0)for(let i=0;i<this.rows;i++)t(this.row(i))&&s.push(i);else if(e===1)for(let i=0;i<this.cols;i++)t(this.col(i))&&s.push(i);else throw new MatrixException("Invalid axis.");this.remove(s,e)}sample(t,e=0,s=!1){const i=this.sizes[e],o=[];if(s)for(let n=0;n<t;n++)o.push(Math.floor(Math.random()*i));else{if(t>i)throw new MatrixException("Invalid sampled size.");for(let n=0;n<t;n++)o.push(Math.floor(Math.random()*(i-n)));for(let n=t-1;n>=0;n--)for(let l=t-1;l>n;l--)o[n]<=o[l]&&o[l]++}if(e===0)return[this.row(o),o];if(e===1)return[this.col(o),o];throw new MatrixException("Invalid axis.")}fill(t){this._value.fill(t)}map(t){for(let e=0,s=0;e<this._size[0];e++)for(let i=0;i<this._size[1];i++,s++)this._value[s]=t(this._value[s],[e,i],this)}static map(t,e){const s=new a(t.rows,t.cols);for(let i=0,o=0;i<t._size[0];i++)for(let n=0;n<t._size[1];n++,o++)s._value[o]=e(t._value[o],[i,n],t);return s}forEach(t){for(let e=0,s=0;e<this._size[0];e++)for(let i=0;i<this._size[1];i++,s++)t(this._value[s],[e,i],this)}transpose(){const t=new a(this.cols,this.rows);for(let e=0;e<this.rows;e++)for(let s=0;s<this.cols;s++)t._value[s*this.rows+e]=this._value[e*this.cols+s];return t}adjoint(){return this.transpose()}flip(t=0){if(t===0)for(let e=0;e<this.rows/2;e++){const s=(this.rows-e-1)*this.cols;for(let i=0;i<this.cols;i++){const o=this._value[e*this.cols+i];this._value[e*this.cols+i]=this._value[s+i],this._value[s+i]=o}}else if(t===1)for(let e=0;e<this.cols/2;e++){const s=this.cols-e-1;for(let i=0;i<this.rows;i++){const o=this._value[i*this.cols+e];this._value[i*this.cols+e]=this._value[i*this.cols+s],this._value[i*this.cols+s]=o}}else throw new MatrixException("Invalid axis.")}swap(t,e,s=0){if(s===0){if(t<0||e<0||this.rows<=t||this.rows<=e)throw new MatrixException("Index out of bounds.");const i=(e-t)*this.cols;for(let o=t*this.cols;o<(t+1)*this.cols;o++)[this._value[o],this._value[o+i]]=[this._value[o+i],this._value[o]]}else if(s===1){if(t<0||e<0||this.cols<=t||this.cols<=e)throw new MatrixException("Index out of bounds.");const i=e-t;for(let o=t;o<this.length;o+=this.cols)[this._value[o],this._value[o+i]]=[this._value[o+i],this._value[o]]}else throw new MatrixException("Invalid axis.")}sort(t=0){if(t===0){const e=Array.from({length:this.rows},(s,i)=>i);return e.sort((s,i)=>{const o=s*this.cols,n=i*this.cols;for(let l=0;l<this.cols;l++){const h=this._value[o+l],r=this._value[n+l],u=h-r;if(u!==0)return u}return 0}),this._value=this.row(e)._value,e}else if(t===1){const e=Array.from({length:this.cols},(s,i)=>i);return e.sort((s,i)=>{for(let o=0;o<this.rows;o++){const n=this._value[s+o*this.cols],l=this._value[i+o*this.cols],h=n-l;if(h!==0)return h}return 0}),this._value=this.col(e)._value,e}throw new MatrixException("Invalid axis.")}shuffle(t=0){const e=Array.from({length:this._size[t]},(s,i)=>i);for(let s=e.length-1;s>0;s--){const i=Math.floor(Math.random()*(s+1));[e[s],e[i]]=[e[i],e[s]]}if(t===0)this._value=this.row(e)._value;else if(t===1)this._value=this.col(e)._value;else throw new MatrixException("Invalid axis.");return e}unique(t=0,e=0){const s=[];if(t===0){let i=0;for(let o=0;o<this.rows;o++){let n=-1;for(let l=0;l<o;l++){let h=!0;for(let r=0;h&&r<this.cols;r++)Math.abs(this._value[o*this.cols+r]-this._value[l*this.cols+r])>e&&(h=!1);if(h){n=l;break}}if(n<0){for(let l=0;l<this.cols;l++)this._value[i*this.cols+l]=this._value[o*this.cols+l];s.push(o),i++}}this._size[0]=i,this._value.length=this.length}else if(t===1){for(let i=0;i<this.cols;i++){let o=!1;for(let n=0;!o&&n<s.length;n++){o=!0;for(let l=0;o&&l<this.rows;l++)Math.abs(this._value[l*this.cols+i]-this._value[l*this.cols+s[n]])>e&&(o=!1)}o||s.push(i)}for(let i=0,o=0;i<this.rows;i++)for(let n=0;n<s.length;n++,o++)this._value[o]=this._value[i*this.cols+s[n]];this._size[1]=s.length,this._value.length=this.length}else throw new MatrixException("Invalid axis.");return s}resize(t,e,s=0){const i=Array(t*e).fill(s),o=Math.min(this.rows,t),n=Math.min(this.cols,e);for(let l=0;l<o;l++)for(let h=0;h<n;h++)i[l*e+h]=this._value[l*this.cols+h];this._value=i,this._size=[t,e]}static resize(t,e,s,i=0){const o=new a(e,s);o.fill(i);const n=Math.min(t.rows,e),l=Math.min(t.cols,s);for(let h=0;h<n;h++)for(let r=0;r<l;r++)o._value[h*s+r]=t._value[h*t.cols+r];return o}reshape(t,e){if(t===-1){if(this.length%e!==0)throw new MatrixException("Length is different.");t=this.length/e}else if(e===-1){if(this.length%t!==0)throw new MatrixException("Length is different.");e=this.length/t}else if(this.length!==t*e)throw new MatrixException("Length is different.");this._size=[t,e]}repeat(t,e=0){if(Array.isArray(t)){if(t.length<this._size.length)for(let n=t.length;n<this._size.length;n++)t[n]=1}else{const n=Array(this._size.length).fill(1);n[e]=t,t=n}const s=t.reduce((n,l)=>n*l,1);if(s===1)return;const i=Array(this.length*s),o=this._size.map((n,l)=>n*t[l]);for(let n=0;n<o[0];n++)for(let l=0;l<o[1];l++)i[n*o[1]+l]=this._value[n%this.rows*this.cols+l%this.cols];this._value=i,this._size=o}static repeat(t,e,s=0){const i=t.copy();return i.repeat(e,s),i}concat(t,e=0){if(e===0){if(this.cols!==t.cols)throw new MatrixException("Size is different.");this._value=[].concat(this._value,t._value),this._size[0]+=t.rows}else if(e===1){if(this.rows!==t.rows)throw new MatrixException("Size is different.");const s=this.cols;this.resize(this.rows,this.cols+t.cols);for(let i=0;i<this.rows;i++)for(let o=0;o<t.cols;o++)this._value[i*this.cols+o+s]=t._value[i*t.cols+o]}else throw new MatrixException("Invalid axis.")}static concat(t,e,s=0){const i=t.copy();return i.concat(e,s),i}reduce(t,e,s=-1,i=null){if(Array.isArray(s))if(s.includes(-1)||s.includes(0)&&s.includes(1))s=-1;else if(s.includes(0))s=0;else if(s.includes(1))s=1;else throw new MatrixException("Invalid axis.");if(s>1)throw new MatrixException("Invalid axis.");if(s<0){let r=e??this._value[0];for(let u=0,c=0;u<this._size[0];u++)for(let f=0;f<this._size[1];f++,c++)c===0&&e==null||(r=t(r,this._value[c],[u,f],this));return i===!0?new a(1,1,r):r}if(i===!1)throw new MatrixException("keepdims only accept true if axis >= 0.");let o=s===0?1:this.cols,n=s===0?this.cols:1;const l=[].concat(this._size);l[s]=1;const h=a.zeros(...l);for(let r=0,u=0;r<h.length;r++,u+=o){let c=e??this._value[u];for(let f=c===e?0:1;f<this._size[s];f++)c=t(c,this._value[f*n+u],s===0?[f,r]:[r,f],this);h._value[r]=c}return h}every(t,e=-1){return this.reduce((s,i,o,n)=>s&&t(i,o,n),!0,e)}some(t,e=-1){return this.reduce((s,i,o,n)=>s||t(i,o,n),!1,e)}max(t=-1){return this.reduce((e,s)=>Math.max(e,s),-1/0,t)}min(t=-1){return this.reduce((e,s)=>Math.min(e,s),1/0,t)}median(t=-1){if(t<0){const n=this._value.concat();return n.sort((l,h)=>l-h),n.length%2===1?n[(n.length-1)/2]:(n[n.length/2]+n[n.length/2-1])/2}let e=t===0?1:this.cols,s=t===0?this.cols:1;const i=[].concat(this._size);i[t]=1;const o=a.zeros(...i);for(let n=0,l=0;n<o.length;n++,l+=e){const h=[];for(let r=0;r<this._size[t];r++)h.push(this._value[r*s+l]);h.sort((r,u)=>r-u),h.length%2===1?o._value[n]=h[(h.length-1)/2]:o._value[n]=(h[h.length/2]+h[h.length/2-1])/2}return o}quantile(t,e=-1){if(t===0)return this.min(e);if(t===1)return this.max(e);const s=k((l,h)=>{if(l.sort((c,f)=>c-f),l.length===1)return l[0];const r=h*(l.length-1),u=Math.floor(r);return r===u?l[u]:l[u]*(1-r+u)+l[u+1]*(r-u)},"quantile");if(e<0){const l=this._value.concat();return s(l,t)}const i=e===0?1:this.cols,o=e===0?this.cols:1,n=a.zeros(...this._size.map((l,h)=>h===e?1:l));for(let l=0,h=0;l<n.length;l++,h+=i){const r=[];for(let u=0;u<this._size[e];u++)r.push(this._value[u*o+h]);n._value[l]=s(r,t)}return n}argmax(t){let e=t===0?1:this.cols,s=t===0?this.cols:1;const i=[].concat(this._size);i[t]=1;const o=a.zeros(...i);for(let n=0,l=0;n<o.length;n++,l+=e){let h=this._value[l],r=0;for(let u=1;u<this._size[t];u++){let c=this._value[u*s+l];c>h&&(h=c,r=u)}o._value[n]=r}return o}argmin(t){let e=t===0?1:this.cols,s=t===0?this.cols:1;const i=[].concat(this._size);i[t]=1;const o=a.zeros(...i);for(let n=0,l=0;n<o.length;n++,l+=e){let h=this._value[l],r=0;for(let u=1;u<this._size[t];u++){let c=this._value[u*s+l];c<h&&(h=c,r=u)}o._value[n]=r}return o}sum(t=-1){return this.reduce((e,s)=>e+s,0,t)}mean(t=-1){if(t<0)return this.sum(t)/this.length;let e=this.sum(t);return e.div(this._size[t]),e}prod(t=-1){return this.reduce((e,s)=>e*s,1,t)}variance(t=-1,e=0){const s=this.mean(t);if(t<0)return this._value.reduce((h,r)=>h+(r-s)**2,0)/(this.length-e);let i=t===0?1:this.cols,o=t===0?this.cols:1;const n=[].concat(this._size);n[t]=1;const l=a.zeros(...n);for(let h=0,r=0;h<l.length;h++,r+=i){let u=0;for(let c=0;c<this._size[t];c++)u+=(this._value[c*o+r]-s._value[h])**2;l._value[h]=u/(this._size[t]-e)}return l}std(t=-1,e=0){if(t<0)return Math.sqrt(this.variance(t,e));let s=this.variance(t,e);for(let i=0;i<s.length;i++)s._value[i]=Math.sqrt(s._value[i]);return s}isSquare(){return this.rows===this.cols}isDiag(t=0){const e=this.cols;for(let s=0;s<this.rows;s++)for(let i=0;i<e;i++)if(s!==i&&Math.abs(this._value[s*e+i])>t)return!1;return!0}isIdentity(t=0){if(!this.isSquare())return!1;const e=this.cols;for(let s=0;s<this.rows;s++)for(let i=0;i<e;i++)if(s!==i){if(Math.abs(this._value[s*e+i])>t)return!1}else if(Math.abs(this._value[s*e+i]-1)>t)return!1;return!0}isZero(t=0){const e=this.length;for(let s=0;s<e;s++)if(Math.abs(this._value[s])>t)return!1;return!0}isTriangular(t=0){return this.isLowerTriangular(t)||this.isUpperTriangular(t)}isLowerTriangular(t=0){const e=this.cols;for(let s=0;s<this.rows;s++)for(let i=s+1;i<e;i++)if(Math.abs(this._value[s*e+i])>t)return!1;return!0}isUpperTriangular(t=0){for(let e=0;e<this.rows;e++)for(let s=0;s<Math.min(e,this.cols);s++)if(Math.abs(this._value[e*this.cols+s])>t)return!1;return!0}isSymmetric(t=0){if(!this.isSquare())return!1;const e=this.cols;for(let s=0;s<this.rows;s++)for(let i=0;i<s;i++)if(t>0){if(Math.abs(this._value[s*e+i]-this._value[i*e+s])>t)return!1}else if(this._value[s*e+i]!==this._value[i*e+s])return!1;return!0}isHermitian(t=0){return this.isSymmetric(t)}isAlternating(t=0){if(!this.isSquare())return!1;const e=this.cols;for(let s=0;s<this.rows;s++)for(let i=0;i<s;i++)if(t>0){if(Math.abs(this._value[s*e+i]+this._value[i*e+s])>t)return!1}else if(this._value[s*e+i]!==-this._value[i*e+s])return!1;return!0}isSkewHermitian(t=0){return this.isAlternating(t)}isRegular(t=0){return this.isSquare()?Math.abs(this.det())<=t:!1}isNormal(t=0){return this.dot(this.t).equals(this.tDot(this),t)}isOrthogonal(t=0){const e=this.tDot(this);for(let s=0;s<this.rows;s++)for(let i=0;i<this.cols;i++){const o=e._value[s*this.cols+i];if(s===i){if(Math.abs(o-1)>t)return!1}else if(Math.abs(o)>t)return!1}return!0}isUnitary(t=0){return this.isOrthogonal(t)}isNilpotent(t=0){if(!this.isSquare())return!1;const e=this.eigenValues();for(let s=0;s<e.length;s++)if(isNaN(e[s])||Math.abs(e[s])>t)return!1;return!0}diag(){let t=[];const e=Math.min(this.rows,this.cols);for(let s=0;s<e;s++)t.push(this._value[s*this.cols+s]);return t}trace(){let t=0;const e=Math.min(this.rows,this.cols);for(let s=0;s<e;s++)t+=this._value[s*this.cols+s];return t}norm(t=2){return this.normEntrywise(t)}normInduced(t=2){if(t===1){let e=-1/0;for(let s=0;s<this.cols;s++){let i=0;for(let o=0;o<this.rows;o++)i+=Math.abs(this._value[o*this.cols+s]);e=Math.max(e,i)}return e}else if(t===1/0){let e=-1/0;for(let s=0;s<this.rows;s++){let i=0;for(let o=0;o<this.cols;o++)i+=Math.abs(this._value[s*this.cols+o]);e=Math.max(e,i)}return e}else if(t===2)return this.normSpectral();throw new MatrixException("Not implemented")}normSpectral(){return this.singularValues()[0]}normEntrywise(t=2){if(t===1/0)return this.normMax();if(t===2)return this.normFrobenius();let e=0;for(let s=0;s<this.length;s++)e+=Math.abs(this._value[s])**t;return e**(1/t)}normFrobenius(){let t=0;for(let e=0;e<this.length;e++)t+=Math.abs(this._value[e])**2;return Math.sqrt(t)}normMax(){let t=-1/0;for(let e=0;e<this.length;e++)t=Math.max(t,Math.abs(this._value[e]));return t}normSchatten(t=2){if(t===1/0)return this.normSpectral();if(t===1)return this.normNuclear();const e=this.singularValues(),s=Math.min(this.rows,this.cols);let i=0;for(let o=0;o<s;o++)i+=e[o]**t;return i**(1/t)}normNuclear(){const t=this.singularValues(),e=Math.min(this.rows,this.cols);let s=0;for(let i=0;i<e;i++)s+=t[i];return s}rank(t=0){const e=this.copy();let s=0;for(let i=0;s<e.rows&&i<e.cols;i++,s++){if(Math.abs(e._value[s*e.cols+i])<=t){for(let n=s+1;n<e.rows;n++)if(Math.abs(e._value[n*e.cols+i])>t){e.swap(s,n,0);break}}if(Math.abs(e._value[s*e.cols+i])<=t){s--;continue}const o=e._value[s*e.cols+i];for(let n=s+1;n<e.rows;n++){const l=e._value[n*e.cols+i];for(let h=i+1;h<e.cols;h++)e._value[n*e.cols+h]-=l*e._value[s*e.cols+h]/o}}return s}det(){if(!this.isSquare())throw new MatrixException("Determine only define square matrix.",this);const t=this._value;switch(this.rows){case 0:return 0;case 1:return t[0];case 2:return t[0]*t[3]-t[1]*t[2];case 3:return t[0]*t[4]*t[8]+t[1]*t[5]*t[6]+t[2]*t[3]*t[7]-t[0]*t[5]*t[7]-t[1]*t[3]*t[8]-t[2]*t[4]*t[6];case 4:return t[0]*t[5]*t[10]*t[15]+t[0]*t[6]*t[11]*t[13]+t[0]*t[7]*t[9]*t[14]-t[0]*t[7]*t[10]*t[13]-t[0]*t[6]*t[9]*t[15]-t[0]*t[5]*t[11]*t[14]-t[1]*t[4]*t[10]*t[15]-t[2]*t[4]*t[11]*t[13]-t[3]*t[4]*t[9]*t[14]+t[3]*t[4]*t[10]*t[13]+t[2]*t[4]*t[9]*t[15]+t[1]*t[4]*t[11]*t[14]+t[1]*t[6]*t[8]*t[15]+t[2]*t[7]*t[8]*t[13]+t[3]*t[5]*t[8]*t[14]-t[3]*t[6]*t[8]*t[13]-t[2]*t[5]*t[8]*t[15]-t[1]*t[7]*t[8]*t[14]-t[1]*t[6]*t[11]*t[12]-t[2]*t[7]*t[9]*t[12]-t[3]*t[5]*t[10]*t[12]+t[3]*t[6]*t[9]*t[12]+t[2]*t[5]*t[11]*t[12]+t[1]*t[7]*t[10]*t[12]}const[e,s]=this.lu();let i=1;for(let o=0;o<this.rows;o++){const n=o*this.cols+o;i*=e._value[n]*s._value[n]}return i}spectralRadius(){if(!this.isSquare())throw new MatrixException("Spectral radius only define square matrix.",this);const t=this.eigenValues();let e=0;for(let s=0;s<t.length;s++)e=Math.max(e,Math.abs(t[s]));return e}negative(){this.map(t=>-t)}not(){this.map(t=>+!t)}bitnot(){this.map(t=>~t)}abs(){this.map(Math.abs)}round(){this.map(Math.round)}floor(){this.map(Math.floor)}ceil(){this.map(Math.ceil)}leftShift(t){this.map(e=>e<<t)}signedRightShift(t){this.map(e=>e>>t)}unsignedRightShift(t){this.map(e=>e>>>t)}broadcastOperate(t,e){if(t instanceof a||t instanceof N){if(t.dimension>2)throw new MatrixException(`Broadcasting size invalid. this: ${this.sizes}, other: ${t.sizes}`,[this,t]);const s=t.dimension===2?t.sizes:[1,t.length];if(this.rows===s[0]&&this.cols===s[1])for(let i=this.length-1;i>=0;i--)this._value[i]=e(this._value[i],t._value[i]);else{const i=[1,1];for(let o=0;o<2;o++)if(this._size[o]<s[o]){if(s[o]%this._size[o]!==0)throw new MatrixException(`Broadcasting size invalid. this: ${this.sizes}, other: ${t.sizes}`,[this,t]);i[o]=s[o]/this._size[o]}else if(this._size[o]%s[o]!==0)throw new MatrixException(`Broadcasting size invalid. this: ${this.sizes}, other: ${t.sizes}`,[this,t]);i.some(o=>o>1)&&this.repeat(i);for(let o=0,n=0;o<this.rows;o++){const l=o%s[0];for(let h=0;h<this.cols;h++,n++)this._value[n]=e(this._value[n],t._value[l*s[1]+h%s[1]])}}}else this.map(s=>e(s,t))}operateAt(t,e,s){if(Array.isArray(t)&&(s=e,[t,e]=t),t<0||this.rows<=t||e<0||this.cols<=e)throw new MatrixException("Index out of bounds.");const i=this._value[t*this.cols+e];return this._value[t*this.cols+e]=s(i),i}add(t){this.broadcastOperate(t,(e,s)=>e+s)}addAt(t,e,s){return this.operateAt(t,e,i=>i+s)}static add(t,e){if(t instanceof a){const s=t.copy();return s.add(e),s}else if(e instanceof a){const s=e.copy();return s.add(t),s}return new a(1,1,t+e)}sub(t){this.broadcastOperate(t,(e,s)=>e-s)}isub(t){this.negative(),this.add(t)}subAt(t,e,s){return this.operateAt(t,e,i=>i-s)}isubAt(t,e,s){return this.operateAt(t,e,i=>s-i)}static sub(t,e){if(t instanceof a){const s=t.copy();return s.sub(e),s}else if(e instanceof a){const s=e.copy();return s.isub(t),s}return new a(1,1,t-e)}mult(t){this.broadcastOperate(t,(e,s)=>e*s)}multAt(t,e,s){return this.operateAt(t,e,i=>i*s)}static mult(t,e){if(t instanceof a){const s=t.copy();return s.mult(e),s}else if(e instanceof a){const s=e.copy();return s.mult(t),s}return new a(1,1,t*e)}div(t){this.broadcastOperate(t,(e,s)=>e/s)}idiv(t){this.broadcastOperate(t,(e,s)=>s/e)}divAt(t,e,s){return this.operateAt(t,e,i=>i/s)}idivAt(t,e,s){return this.operateAt(t,e,i=>s/i)}static div(t,e){if(t instanceof a){const s=t.copy();return s.div(e),s}else if(e instanceof a){const s=e.copy();return s.idiv(t),s}return new a(1,1,t/e)}mod(t){this.broadcastOperate(t,(e,s)=>e%s)}imod(t){this.broadcastOperate(t,(e,s)=>s%e)}modAt(t,e,s){return this.operateAt(t,e,i=>i%s)}imodAt(t,e,s){return this.operateAt(t,e,i=>s%i)}static mod(t,e){if(t instanceof a){const s=t.copy();return s.mod(e),s}else if(e instanceof a){const s=e.copy();return s.imod(t),s}return new a(1,1,t%e)}and(t){this.broadcastOperate(t,(e,s)=>+(!!e&&!!s))}andAt(t,e,s){return this.operateAt(t,e,i=>+(!!i&&!!s))}static and(t,e){if(t instanceof a){const s=t.copy();return s.and(e),s}else if(e instanceof a){const s=e.copy();return s.and(t),s}return new a(1,1,+(!!t&&!!e))}or(t){this.broadcastOperate(t,(e,s)=>+(!!e||!!s))}orAt(t,e,s){return this.operateAt(t,e,i=>+(!!i||!!s))}static or(t,e){if(t instanceof a){const s=t.copy();return s.or(e),s}else if(e instanceof a){const s=e.copy();return s.or(t),s}return new a(1,1,+(!!t||!!e))}bitand(t){this.broadcastOperate(t,(e,s)=>+(e&s))}bitandAt(t,e,s){return this.operateAt(t,e,i=>+(i&s))}static bitand(t,e){if(t instanceof a){const s=t.copy();return s.bitand(e),s}else if(e instanceof a){const s=e.copy();return s.bitand(t),s}return new a(1,1,+(t&e))}bitor(t){this.broadcastOperate(t,(e,s)=>+(e|s))}bitorAt(t,e,s){return this.operateAt(t,e,i=>+(i|s))}static bitor(t,e){if(t instanceof a){const s=t.copy();return s.bitor(e),s}else if(e instanceof a){const s=e.copy();return s.bitor(t),s}return new a(1,1,+(t|e))}bitxor(t){this.broadcastOperate(t,(e,s)=>+(e^s))}bitxorAt(t,e,s){return this.operateAt(t,e,i=>+(i^s))}static bitxor(t,e){if(t instanceof a){const s=t.copy();return s.bitxor(e),s}else if(e instanceof a){const s=e.copy();return s.bitxor(t),s}return new a(1,1,+(t^e))}dot(t){if(this.cols!==t.rows)throw new MatrixException(`Dot size invalid. left = [${this.rows}, ${this.cols}], right = [${t.rows}, ${t.cols}]`);const e=t.cols,s=new a(this.rows,e);let i=0;const o=this.length,n=t.length,l=this.cols,h=this._value,r=t._value,u=s._value;for(let c=0;c<o;c+=l){let f=0,w=0;for(let v=0,d=c;v<n;v+=e,d++)h[d]&&w++,f+=h[d]*r[v];if(u[i++]=f,w===0){i+=e-1;continue}else if(w/l<.1){let v=[],d=[];for(let _=0;_<l;_++)h[c+_]&&(v.push(h[c+_]),d.push(_));for(let _=1;_<e;_++){f=0;for(let y=0;y<v.length;y++)f+=v[y]*r[d[y]*e+_];u[i++]=f}}else for(let v=1;v<e;v++){f=0;for(let d=v,_=c;d<n;d+=e,_++)f+=h[_]*r[d];u[i++]=f}}return s}tDot(t){if(this.rows!==t.rows)throw new MatrixException(`tDot size invalid. left = [${this.cols}, ${this.rows}], right = [${t.rows}, ${t.cols}]`);const e=new a(this.cols,t.cols);let s=0;for(let i=0;i<this.cols;i++)for(let o=0;o<t.cols;o++){let n=0,l=i;for(let h=o;h<t.length;h+=t.cols,l+=this.cols)n+=this._value[l]*t._value[h];e._value[s++]=n}return e}kron(t){const e=new a(this.rows*t.rows,this.cols*t.cols);for(let s=0;s<this.rows;s++)for(let i=0;i<this.cols;i++)for(let o=0;o<t.rows;o++)for(let n=0;n<t.cols;n++)e._value[(s*t.rows+o)*this.cols*t.cols+i*t.cols+n]=this._value[s*this.cols+i]*t._value[o*t.cols+n];return e}convolute(t,e=!0){const s=[Math.floor((t.length-1)/2),Math.floor((t[0].length-1)/2)],i=this._value.concat();for(let o=0;o<this.rows;o++)for(let n=0;n<this.cols;n++){let l=0,h=0;for(let r=0;r<t.length;r++){const u=o+r-s[0];if(!(u<0||this.rows<=u))for(let c=0;c<t[r].length;c++){const f=n+c-s[1];f<0||this.cols<=f||(l+=t[r][c]*i[u*this.cols+f],h+=t[r][c])}}e&&(l/=h),this._value[o*this.cols+n]=l}}reducedRowEchelonForm(t=0){for(let e=0,s=0;e<this.rows&&s<this.cols;s++,e++){if(Math.abs(this._value[e*this.cols+s])<=t){for(let o=e+1;o<this.rows;o++)if(Math.abs(this._value[o*this.cols+s])>t){this.swap(e,o,0);break}}if(Math.abs(this._value[e*this.cols+s])<=t){e--;continue}const i=this._value[e*this.cols+s];this._value[e*this.cols+s]=1;for(let o=s+1;o<this.cols;o++)this._value[e*this.cols+o]/=i;for(let o=0;o<this.rows;o++){if(o===e)continue;const n=this._value[o*this.cols+s];this._value[o*this.cols+s]=0;for(let l=s+1;l<this.cols;l++)this._value[o*this.cols+l]-=n*this._value[e*this.cols+l]}}}inv(){if(!this.isSquare())throw new MatrixException("Inverse matrix only define square matrix.",this);const t=this._value;switch(this.rows){case 0:return new a(0,0);case 1:return new a(1,1,[1/t[0]]);case 2:{const e=this.det();return new a(2,2,[t[3]/e,-t[1]/e,-t[2]/e,t[0]/e])}case 3:{const e=this.det();return new a(3,3,[(t[4]*t[8]-t[5]*t[7])/e,(t[2]*t[7]-t[1]*t[8])/e,(t[1]*t[5]-t[2]*t[4])/e,(t[5]*t[6]-t[3]*t[8])/e,(t[0]*t[8]-t[2]*t[6])/e,(t[2]*t[3]-t[0]*t[5])/e,(t[3]*t[7]-t[4]*t[6])/e,(t[1]*t[6]-t[0]*t[7])/e,(t[0]*t[4]-t[1]*t[3])/e])}}return this.isLowerTriangular()?this.invLowerTriangular():this.isUpperTriangular()?this.invUpperTriangular():this.invLU()}invLowerTriangular(){if(!this.isSquare())throw new MatrixException("Inverse matrix only define square matrix.",this);const t=this._value,e=new a(this.rows,this.cols);for(let s=0;s<this.rows;s++){const i=t[s*this.cols+s];e._value[s*this.cols+s]=1/i;for(let o=0;o<s;o++){let n=0;for(let l=o;l<s;l++)n+=t[s*this.cols+l]*e._value[l*this.cols+o];e._value[s*this.cols+o]=-n/i}}return e}invUpperTriangular(){if(!this.isSquare())throw new MatrixException("Inverse matrix only define square matrix.",this);const t=this._value,e=new a(this.rows,this.cols);for(let s=this.cols-1;s>=0;s--){const i=t[s*this.cols+s];e._value[s*this.cols+s]=1/i;for(let o=s+1;o<this.cols;o++){let n=0;for(let l=s+1;l<=o;l++)n+=t[s*this.cols+l]*e._value[l*this.cols+o];e._value[s*this.cols+o]=-n/i}}return e}invRowReduction(){if(!this.isSquare())throw new MatrixException("Inverse matrix only define square matrix.",this);const t=this.copy(),e=this.rows,s=a.eye(e,e);for(let i=0;i<e;i++){const o=i*e;if(t._value[o+i]===0){let l=i+1;for(;l<e&&t._value[l*e+i]===0;l++);if(l===e)throw new MatrixException("",this);for(let h=i;h<e;h++)[t._value[o+h],t._value[l*e+h]]=[t._value[l*e+h],t._value[o+h]];s.swap(i,l)}const n=t._value[o+i];t._value[o+i]=1;for(let l=i+1;l<e;l++)t._value[o+l]/=n;for(let l=0;l<e;l++)s._value[o+l]=s._value[o+l]/n;for(let l=0;l<e;l++){if(i===l)continue;const h=t._value[l*e+i];t._value[l*e+i]=0;for(let r=i+1;r<e;r++)t._value[l*e+r]-=h*t._value[o+r];for(let r=0;r<e;r++)s._value[l*e+r]=s._value[l*e+r]-h*s._value[o+r]}}return s}invLU(){if(!this.isSquare())throw new MatrixException("Inverse matrix only define square matrix.",this);const[t,e]=this.lu();return e.invUpperTriangular().dot(t.invLowerTriangular())}pseudoInv(){const t=this.rows,e=this.cols,s=this._value;if(t===0||e===0)return new a(e,t);if(t===1&&e===1)return new a(1,1,s[0]===0?0:1/s[0]);if(t===1||e===1){const i=s.reduce((o,n)=>o+n**2,0);return i===0?new a(e,t):new a(e,t,s.map(o=>o/i))}else if(t===2&&e===2){if(this.det()!==0)return this.inv();const o=s.reduce((n,l)=>n+l**2,0);return o===0?new a(e,t):new a(e,t,s.map(n=>n/o))}return this.pseudoInvQR()}pseudoInvNaive(){const t=this.rows<this.cols?this.adjoint():this,e=t.tDot(t).solve(t.adjoint());return this.rows<this.cols?e.adjoint():e}pseudoInvQR(){const t=this.rows<this.cols?this.adjoint():this,[,e]=t.qr(),s=e.adjoint().solveLowerTriangular(t.adjoint());e.resize(t.rows,t.rows,1);const i=e.solveUpperTriangular(s);return i.resize(t.cols,t.rows),this.rows<this.cols?i.adjoint():i}pseudoInvSVD(){const[t,e,s]=this.svd();return s.dot(a.diag(e.map(i=>i===0?0:1/i))).dot(t.t)}pseudoInvBenIsraelCohen(){const t=this.adjoint(),e=1e-5,s=t.dot(this);for(let l=0;l<s.rows;l++)s.addAt(l,l,e);let i=s.inv().dot(t);const o=1e-15;let n=1e4;for(;n-- >0;){const l=a.mult(i,2);l.sub(i.dot(this).dot(i));let h=0;for(let r=0;r<i.length;r++)h+=(i.value[r]-l.value[r])**2;if(i=l,h<o)break}return i}sqrt(){if(!this.isSquare())throw new MatrixException("sqrt only define square matrix.",this);switch(this.rows){case 0:return this;case 1:return new a(1,1,[Math.sqrt(this._value[0])])}if(this.isDiag())return a.diag(this.diag().map(Math.sqrt));const[t,e]=this.eigen(),s=new a(this.rows,this.cols);for(let i=0;i<this.rows;i++)s._value[i*this.cols+i]=Math.sqrt(t[i]);return e.dot(s).dot(e.transpose())}power(t){if(!this.isSquare())throw new MatrixException("Only square matrix can power.",this);const e=this.rows;if(this.isDiag(1e-12))return a.diag(this.diag().map(s=>Math.pow(s,t)));if(Number.isInteger(t)){if(t===0)return a.eye(e,e);if(t===1)return this.copy();if(t===2)return this.dot(this);if(t===-1)return this.inv();if(t<0)return this.inv().power(-t);if(!this.isSymmetric(1e-12)){let n=this.dot(this);for(let l=2;l<t;l++)n=n.dot(this);return n}const[s,i]=this.eigen(),o=a.diag(s.map(n=>Math.pow(n,t)));return i.dot(o).dot(i.t)}else{if(t<0)return this.inv().power(-t);if(t===.5)return this.sqrt()}throw new MatrixException("Power only defined integer.")}exp(){if(!this.isSquare())throw new MatrixException("Only square matrix can exp.",this);if(this.rows===1)return new a(1,1,Math.exp(this._value[0]));if(this.isDiag())return a.diag(this.diag().map(Math.exp));const t=a.eye(this.rows,this.cols);let e=1,s=1,i=this;const o=10**(Math.floor(Math.log(Math.abs(this.trace())))-8);for(;;){const n=a.div(i,e);if(t.add(n),n.norm()<o)break;i=i.dot(this),s++,e*=s}return t}log(){if(!this.isSquare())throw new MatrixException("Only square matrix can log.",this);if(this.rows===1)return new a(1,1,Math.log(this._value[0]));if(this.isDiag())return a.diag(this.diag().map(Math.log));const[t,e]=this.eigen(),s=e.inv();return e.dot(a.diag(t.map(Math.log))).dot(s)}cov(t=0){const e=new a(this.cols,this.cols),s=[];for(let i=0;i<this.cols;i++){let o=0;for(let n=i;n<this.length;n+=this.cols)o+=this._value[n];s[i]=o/this.rows;for(let n=0;n<=i;n++){let l=0;for(let h=0;h<this.length;h+=this.cols)l+=(this._value[i+h]-s[i])*(this._value[n+h]-s[n]);e._value[i*this.cols+n]=e._value[n*this.cols+i]=l/(this.rows-t)}}return e}gram(){return this.tDot(this)}solve(t){if(this.rows>this.cols)throw new MatrixException("Only square matrix or matrix with more columns than rows can be solved.",this);const e=this.rows;if(e!==t.rows)throw new MatrixException("b size is invalid.",[this,t]);const s=e<this.cols?a.resize(this,e,e):this;let i;switch(e){case 0:i=s;break;case 1:i=a.map(t,o=>o/s._value[0]);break;default:{const[o,n]=s.lu(),l=o.solveLowerTriangular(t);i=n.solveUpperTriangular(l);break}}return e<this.cols&&i.resize(this.cols,i.cols),i}solveLowerTriangular(t){if(this.rows>this.cols)throw new MatrixException("Matrix that column rank is less than row rank can not solve.",this);if(this.rows!==t.rows)throw new MatrixException("b size is invalid.",[this,t]);const e=this.cols,s=t.cols,i=new a(e,s);for(let o=0;o<s;o++)for(let n=0;n<this.rows;n++){let l=t._value[n*s+o];for(let h=0;h<n;h++)l-=i._value[h*s+o]*this._value[n*e+h];i._value[n*s+o]=l/this._value[n*e+n]}return i}solveUpperTriangular(t){if(this.rows>this.cols)throw new MatrixException("Matrix that column rank is less than row rank can not solve.",this);if(this.rows!==t.rows)throw new MatrixException("b size is invalid.",[this,t]);const e=this.cols,s=t.cols,i=new a(e,s);for(let o=0;o<s;o++)for(let n=this.rows-1;n>=0;n--){let l=t._value[n*s+o];for(let h=e-1;h>n;h--)l-=i._value[h*s+o]*this._value[n*e+h];i._value[n*s+o]=l/this._value[n*e+n]}return i}solveJacobi(t,e=1e3){if(!this.isSquare())throw new MatrixException("solveJacobi only define square matrix.",this);if(this.rows!==t.rows)throw new MatrixException("b size is invalid.",[this,t]);const s=this.cols,i=t.cols;let o=a.zeros(s,i);for(let n=0;n<e;n++){const l=a.zeros(s,i);for(let r=0;r<s;r++){const u=this.at(r,r);for(let c=0;c<i;c++){let f=t.at(r,c);for(let w=0;w<s;w++)r!==w&&(f-=o.at(w,c)*this.at(r,w));l.set(r,c,f/u)}}if(l.some(r=>isNaN(r)))throw new MatrixException("Can not calculate solved value.",this);if(a.sub(o,l).norm()<1e-8){o=l;break}o=l}return o}solveGaussSeidel(t,e=1e3){if(!this.isSquare())throw new MatrixException("solveGaussSeidel only define square matrix.",this);if(this.rows!==t.rows)throw new MatrixException("b size is invalid.",[this,t]);const s=this.cols,i=t.cols;let o=a.zeros(s,i);for(let n=0;n<e;n++){let l=0;for(let h=0;h<s;h++){const r=this.at(h,h);for(let u=0;u<i;u++){let c=t.at(h,u);for(let f=0;f<s;f++)h!==f&&(c-=o.at(f,u)*this.at(h,f));c/=r,l+=(o.at(h,u)-c)**2,o.set(h,u,c)}}if(o.some(h=>isNaN(h)))throw new MatrixException("Can not calculate solved value.",this);if(Math.sqrt(l)<1e-8)break}return o}solveSOR(t,e,s=1e3){if(!this.isSquare())throw new MatrixException("solveSOR only define square matrix.",this);if(this.rows!==t.rows)throw new MatrixException("b size is invalid.",[this,t]);if(e<=0||2<=e)throw new MatrixException("w must be positive and less than 2.",[this,e]);const i=this.cols,o=t.cols;let n=a.zeros(i,o);for(let l=0;l<s;l++){let h=0;for(let r=0;r<i;r++){const u=this.at(r,r);for(let c=0;c<o;c++){let f=t.at(r,c);for(let v=0;v<i;v++)r!==v&&(f-=n.at(v,c)*this.at(r,v));f/=u;const w=n.at(r,c);h+=(w-f)**2,n.set(r,c,(1-e)*w+e*f)}}if(n.some(r=>isNaN(r)))throw new MatrixException("Can not calculate solved value.",this);if(Math.sqrt(h)<1e-8)break}return n}bidiag(){return this.bidiagHouseholder()}bidiagHouseholder(t=!1){const e=this.copy(),[s,i]=[this.rows,this.cols];let o=t?a.eye(s,s):null,n=t?a.eye(i,i):null;for(let l=0;l<Math.min(s,i);l++){let h=e.block(l,l),r=h.col(0);if(r.norm()>0){const f=r.norm()*(r._value[0]<0?1:-1);r._value[0]-=f,r.div(r.norm())}let u=r.dot(r.t);u.mult(2);let c=a.eye(s-l,s-l);if(c.sub(u),h=c.tDot(h),t&&o.set(l,0,c.dot(o.slice(l,null,0))),r=h.row(0),r._value[0]=0,r.norm()>0){const f=r.norm()*(r._value[1]<0?1:-1);r._value[1]-=f,r.div(r.norm())}u=r.tDot(r),u.mult(2),c=a.eye(i-l,i-l),c.sub(u),h=h.dot(c),t&&n.set(0,l,n.slice(l,null,1).dot(c)),e.set(l,l,h)}return t?[e,o.t,n]:e}tridiag(){return this.tridiagHouseholder()}tridiagHouseholder(t=!1){if(!this.isSymmetric())throw new MatrixException("Tridiagonal only define symmetric matrix.",this);const e=this.copy(),s=this.cols;let i=t?a.eye(s,s):null;for(let o=0;o<s-2;o++){const n=e.block(o+1,o,s,o+1),l=n.norm()*(n._value[0]<0?1:-1);if(n._value[0]-=l,n.div(n.norm()),t){const c=n.dot(n.t);c.map((f,w)=>w[0]===w[1]?1-2*f:-2*f),i.set(0,o+1,i.slice(o+1,null,1).dot(c))}const h=e.block(o+1,o+1),r=h.dot(n),u=a.mult(n,n.tDot(r));u.isub(r),u.mult(2),h.sub(u.dot(n.t)),h.sub(n.dot(u.t)),e.set(o+1,o+1,h),e._value[o*s+o+1]=e._value[(o+1)*s+o]=l;for(let c=o+2;c<s;c++)e._value[o*s+c]=e._value[c*s+o]=0}return t?[e,i]:e}tridiagLanczos(t=0){if(!this.isSymmetric())throw new MatrixException("Tridiagonal only define symmetric matrix.",this);const e=this.cols;t<=0&&(t=e);let s=0,i=a.zeros(e,1),o=a.randn(e,1);o.div(o.norm());const n=a.zeros(t,t);for(let l=0;l<t;l++){const h=this.dot(o),r=o.tDot(h).toScaler();h.sub(a.mult(i,s)),h.sub(a.mult(o,r)),s=h.norm(),i=o,h.div(s),o=h,n.set(l,l,r),l<t-1&&(n.set(l,l+1,s),n.set(l+1,l,s))}return n}hessenberg(){return this.hessenbergArnoldi()}hessenbergArnoldi(t=0){if(!this.isSquare())throw new MatrixException("Hessenberg only define square matrix.",this);const e=this.cols;t<=0&&(t=e);const s=a.zeros(t,t),i=[a.random(e,1,-1,1)];i[0].div(i[0].norm());for(let o=0;o<t;o++){const n=this.dot(i[o]);for(let h=0;h<=o;h++){const r=i[h].tDot(n).toScaler();n.sub(a.mult(i[h],r)),s.set(h,o,r)}const l=n.norm();n.div(l),i[o+1]=n,o<t-1&&s.set(o+1,o,l)}return s}balancing(){if(!this.isSquare())throw new MatrixException("Doubly stochastic matrix only defined for square matrix.",this);if(this._value.some(t=>t<=0))throw new MatrixException("Doubly stochastic matrix only calculate for non negative matrix.",this);return this.rows===1?[[this._value[0]],new a(1,1,1),[1]]:this.balancingSinkhornKnopp()}balancingSinkhornKnopp(){if(!this.isSquare())throw new MatrixException("Doubly stochastic matrix only defined for square matrix.",this);if(this._value.some(n=>n<=0))throw new MatrixException("Doubly stochastic matrix only calculate for non negative matrix.",this);const t=this.rows,e=Array(t).fill(1),s=Array(t).fill(1),i=this.copy();let o=1e4;for(;o-- >0;){const n=i.sum(1);i.div(n);for(let r=0;r<t;r++)e[r]*=n.at(r,0);const l=i.sum(0);i.div(l);for(let r=0;r<t;r++)s[r]*=l.at(0,r);if(n.reduce((r,u)=>r+Math.abs(u-1),0)+l.reduce((r,u)=>r+Math.abs(u-1),0)<1e-8)break}return[e,i,s]}lu(){if(!this.isSquare())throw new MatrixException("LU decomposition only define square matrix.",this);const t=this.rows;switch(t){case 0:return[this,this];case 1:return[a.ones(1,1),new a(1,1,[this._value[0]])];case 2:return[new a(2,2,[1,0,this._value[2]/this._value[0],1]),new a(2,2,[this._value[0],this._value[1],0,this._value[3]-this._value[1]*this._value[2]/this._value[0]])]}let e=this.copy();for(let i=0;i<t;i++){const o=e._value[i*t+i];for(let n=i+1;n<t;n++){const l=e._value[n*t+i]/=o;for(let h=i+1;h<t;h++)e._value[n*t+h]-=l*e._value[i*t+h]}}let s=a.eye(t,t);for(let i=0;i<t;i++)for(let o=0;o<i;o++)s._value[i*t+o]=e._value[i*t+o],e._value[i*t+o]=0;return[s,e]}qr(){const t=this.rows,e=this.cols;if(t===0||e===0)return[this,this];if(t===1)return[a.ones(1,1),this];if(e===1){const s=Math.sqrt(this.tDot(this).toScaler());return[a.div(this,s),new a(1,1,s)]}return this.qrHouseholder()}qrGramSchmidt(){const t=this.cols,e=this.copy(),s=a.eye(t,t),i=[];for(let o=0;o<t;o++){for(let n=0;n<o;n++){let l=0;for(let r=0;r<this.rows;r++)l+=this._value[r*t+o]*e._value[r*t+n];const h=s._value[n*t+o]=i[n]===0?0:l/i[n]**2;for(let r=0;r<this.rows;r++)e._value[r*t+o]-=e._value[r*t+n]*h}i.push(e.col(o).norm())}return e.mult(new a(1,t,i.map(o=>o===0?0:1/o))),s.mult(new a(t,1,i)),[e,s]}qrHouseholder(){const t=this.rows,e=this.cols,s=this.copy(),i=a.eye(t,t);for(let o=0;o<Math.min(t,e);o++){const n=t-o,l=s.block(o,o,t,o+1),h=l.norm()*Math.sign(l._value[0]);l._value[0]-=h;const r=l.norm();l.div(r===0?1:r);const u=new a(n,n);for(let c=0;c<n;c++){const f=l._value[c];if(u._value[c*n+c]=1-2*f**2,!!f)for(let w=0;w<c;w++)u._value[c*n+w]=u._value[w*n+c]=-2*f*l._value[w]}s.set(o,o,u.dot(s.block(o,o))),i.set(o,0,u.dot(i.block(o,0)))}return[i.t,s]}singularValues(){const e=this.dot(this.adjoint()).eigenJacobi()[0];for(let s=0;s<e.length;s++)-1e-12<e[s]&&e[s]<0&&(e[s]=0),e[s]=Math.sqrt(e[s]);return e}svd(){return this.svdEigen()}svdEigen(){const t=Math.min(this.cols,this.rows);if(this.cols<=this.rows){const e=this.tDot(this),[s,i]=e.eigen();for(let n=0;n<t;n++)-1e-12<s[n]&&s[n]<=0?s[n]=0:s[n]=Math.sqrt(s[n]);const o=this.dot(i);for(let n=0;n<this.rows;n++)for(let l=0;l<t;l++)s[l]!==0&&(o._value[n*t+l]/=s[l]);return[o,s,i]}else{const e=this.dot(this.t),[s,i]=e.eigen();for(let n=0;n<t;n++)-1e-12<s[n]&&s[n]<=0?s[n]=0:s[n]=Math.sqrt(s[n]);const o=i.tDot(this);for(let n=0;n<t;n++)for(let l=0;l<this.cols;l++)s[n]!==0&&(o._value[n*this.cols+l]/=s[n]);return[i,s,o.t]}}svdGolubKahan(){const t=this.rows>=this.cols,e=Math.min(this.rows,this.cols),s=t?this:this.t,[i,,o]=s.bidiagHouseholder(!0);for(let w=0;w<e;w++)if(Math.sign(i.at(w,w))<0){i.multAt(w,w,-1),w>0&&i.multAt(w-1,w,-1);for(let d=0;d<o.rows;d++)o.multAt(d,w,-1)}const n=1e-12;let l=1e4,h=i.tDot(i),r=o;for(;l-- >0;){const[w]=h.qrGramSchmidt();h=w.tDot(h).dot(w),r=r.dot(w);let v=0;for(let d=0;d<h.rows;d++)for(let _=0;_<h.cols;_++)d!==_&&(v+=h.at(d,_)**2);if(Math.sqrt(v)<n)break}const[u,c]=s.dot(r).qr();for(let w=0;w<e;w++)if(c.at(w,w)<0)for(let v=0;v<r.rows;v++)r.multAt(v,w,-1);const f=h.diag().map(w=>Math.sqrt(w));return t?[u.slice(0,e,1),f,r.slice(0,e,1)]:[r.slice(0,e,1),f,u.slice(0,e,1)]}cholesky(){return this.choleskyBanachiewicz()}choleskyGaussian(){if(!this.isSymmetric(1e-15))throw new MatrixException("Cholesky decomposition only define symmetric matrix.",this);let t=this;const e=t.rows;let s=a.eye(e,e);for(let i=0;i<e;i++){const o=t.at(0,0),n=t.block(1,0,e-i,1),l=t.block(0,1,1,e-i);t=t.block(1,1);const h=n.dot(l);h.div(o),t.sub(h);const r=a.eye(e,e);r.set(i,i,Math.sqrt(o)),n.div(Math.sqrt(o)),r.set(i+1,i,n),s=s.dot(r)}return s}choleskyBanachiewicz(){if(!this.isSymmetric(1e-15))throw new MatrixException("Cholesky decomposition only define symmetric matrix.",this);const t=this.rows,e=new a(t,t);for(let s=0;s<t;s++){let i=0;for(let o=0;o<s;o++){let n=0;for(let l=0;l<o;l++)n+=e._value[s*t+l]*e._value[o*t+l];e._value[s*t+o]=(this._value[s*t+o]-n)/e._value[o*t+o],i+=e._value[s*t+o]**2}e._value[s*t+s]=Math.sqrt(this._value[s*t+s]-i)}return e}choleskyCrout(){if(!this.isSymmetric(1e-15))throw new MatrixException("Cholesky decomposition only define symmetric matrix.",this);const t=this.rows,e=new a(t,t);for(let s=0;s<t;s++){let i=0;for(let o=0;o<s;o++)i+=e._value[s*t+o]*e._value[s*t+o];e._value[s*t+s]=Math.sqrt(this._value[s*t+s]-i);for(let o=s+1;o<t;o++){let n=0;for(let l=0;l<s;l++)n+=e._value[o*t+l]*e._value[s*t+l];e._value[o*t+s]=(this._value[o*t+s]-n)/e._value[s*t+s]}}return e}modifiedCholesky(){if(!this.isSymmetric(1e-15))throw new MatrixException("Modified cholesky decomposition only define symmetric matrix.",this);const t=this.rows,e=[],s=a.eye(t,t);for(let i=0;i<t;i++){e[i]=this._value[i*t+i];for(let o=0;o<i;o++){let n=0;for(let l=0;l<o;l++)n+=s._value[i*t+l]*s._value[o*t+l]*e[l];s._value[i*t+o]=(this._value[i*t+o]-n)/e[o],e[i]-=s._value[i*t+o]**2*e[o]}}return[s,e]}schur(){if(!this.isSquare())throw new MatrixException("Schur decomposition only define square matrix.",this);return this.schurQR()}schurQR(t="single"){if(!this.isSquare())throw new MatrixException("Schur decomposition only define square matrix.",this);const e=this.rows;let s=this.copy();const i=[];for(let l=0;l<e-2;l++){const h=s.block(l+1,l),r=h.col(0),u=r.norm()*Math.sign(r._value[0]);r._value[0]-=u;const c=r.norm();r.div(c===0?1:c),h.sub(a.mult(2,r.dot(r.tDot(h)))),s.set(l+1,l,h);const f=s.slice(l+1,e,1);f.sub(a.mult(2,f.dot(r).dot(r.t))),s.set(0,l+1,f),i[l]=r}let o=a.eye(e,e);for(let l=e-3;l>=0;l--){const h=o.block(l+1,l+1);h.sub(a.mult(2,i[l].dot(i[l].tDot(h)))),o.set(l+1,l+1,h)}const n=1e-8;for(let l=e-1;l>0;l--){let h=1e4;for(;h-- >0;){const r=s.block(e-2,e-2).eigenValues();if(t==="no"){const[u,c]=s.qr();s=c.dot(u),o=o.dot(u)}else if(t==="single"){const u=s.at(e-1,e-1);let c=Math.abs(r[0]-u)<Math.abs(r[1]-u)?r[0]:r[1];isNaN(c)&&(c=s.at(l,l));for(let v=0;v<e;v++)s._value[v*e+v]-=c;const[f,w]=s.qr();s=w.dot(f);for(let v=0;v<e;v++)s._value[v*e+v]+=c;o=o.dot(f)}if(Math.abs(s.at(l,l-1))<n)break}}return[o,s]}rankFactorization(){const t=this.copy();t.reducedRowEchelonForm(1e-8);const e=[];let s=0;for(let i=0;i<this.cols;i++)t.at(s,i)>0&&(e.push(i),s++);return[this.col(e),t.slice(0,e.length,0)]}eigen(){if(!this.isSquare())throw new MatrixException("Eigen values only define square matrix.",this);if(this.rows>=2&&this.isZero()){const t=Array(this.rows).fill(0);t[0]=1;const e=a.eye(this.rows,this.rows);return e.set(0,0,0),[t,e]}if(this.rows<=2)return[this.eigenValues(),this.eigenVectors()];if(this.isSymmetric(1e-15))return this.eigenJacobi();{const t=this.eigenValues(),e=this.rows,s=new a(e,e);for(let i=0;i<e;i++){const[,o]=this.eigenInverseIteration(t[i]);for(let n=0;n<e;n++)s._value[n*e+i]=o._value[n]}return[t,s]}}eigenValues(){if(!this.isSquare())throw new MatrixException("Eigen values only define square matrix.",this);if(this.rows>=2&&this.isZero()){const t=Array(this.rows).fill(0);return t[0]=1,t}switch(this.rows){case 0:return[];case 1:return[this._value[0]];case 2:{const t=this._value[0]+this._value[3],e=Math.sqrt(t**2-4*this.det());return[(t+e)/2,(t-e)/2]}case 3:{const t=-this.det(),e=this._value[0]*this._value[4]+this._value[0]*this._value[8]+this._value[4]*this._value[8]-this._value[5]*this._value[7]-this._value[2]*this._value[6]-this._value[1]*this._value[3],s=-this._value[0]-this._value[4]-this._value[8],i=e-s**2/3,o=t-e*s/3+s**3*2/27,n=(o/2)**2+(i/3)**3;let[l,h]=new q(n).sqrt();l=l.add(-o/2),h=h.add(-o/2);const[r,u,c]=l.cbrt(),[f,w,v]=h.cbrt(),d=r.add(f),_=u.add(v),y=c.add(w),j=[d,_,y].map(g=>Math.abs(g.imaginary)<1e-12?g.real-s/3:Number.NaN);return j.sort((g,p)=>p-g),j}case 4:{const t=this.det(),e=-this._value[0]*this._value[5]*this._value[10]-this._value[0]*this._value[5]*this._value[15]-this._value[0]*this._value[10]*this._value[15]-this._value[5]*this._value[10]*this._value[15]+this._value[0]*this._value[11]*this._value[14]+this._value[0]*this._value[7]*this._value[13]+this._value[0]*this._value[6]*this._value[9]+this._value[5]*this._value[11]*this._value[14]+this._value[3]*this._value[5]*this._value[12]+this._value[2]*this._value[5]*this._value[8]+this._value[7]*this._value[10]*this._value[13]+this._value[3]*this._value[10]*this._value[12]+this._value[1]*this._value[4]*this._value[10]+this._value[6]*this._value[9]*this._value[15]+this._value[2]*this._value[8]*this._value[15]+this._value[1]*this._value[4]*this._value[15]-this._value[6]*this._value[11]*this._value[13]-this._value[7]*this._value[9]*this._value[14]-this._value[2]*this._value[11]*this._value[12]-this._value[3]*this._value[8]*this._value[14]-this._value[1]*this._value[7]*this._value[12]-this._value[3]*this._value[4]*this._value[13]-this._value[1]*this._value[6]*this._value[8]-this._value[2]*this._value[4]*this._value[9],s=this._value[0]*this._value[5]+this._value[0]*this._value[10]+this._value[0]*this._value[15]+this._value[5]*this._value[10]+this._value[5]*this._value[15]+this._value[10]*this._value[15]-this._value[7]*this._value[13]-this._value[6]*this._value[9]-this._value[11]*this._value[14]-this._value[1]*this._value[4]-this._value[2]*this._value[8]-this._value[3]*this._value[12],i=-this.trace(),o=Math.cbrt(2),n=-(i**3)+4*s*i-8*e,l=s**2-3*e*i+12*t,h=2*s**3-9*e*s*i+27*t*i**2+27*e**2-72*t*s,r=-4*l**3+h**2,c=new q(r).sqrt()[0].add(h).cbrt()[0],w=new q(i**2/4-2*s/3).add(new q(o*l/3).div(c)).add(c.div(3*o)).sqrt(),v=new q(i**2/2-4*s/3).sub(new q(o*l/3).div(c)).sub(c.div(3*o)),d=v.add(new q(n/4).div(w[1])),_=v.add(new q(n/4).div(w[0])),y=d.sqrt(),j=_.sqrt(),g=new q(-i/4).add(y[0].div(2)).add(w[1].div(2)),p=new q(-i/4).add(y[1].div(2)).add(w[1].div(2)),m=new q(-i/4).add(j[0].div(2)).add(w[0].div(2)),b=new q(-i/4).add(j[1].div(2)).add(w[0].div(2)),z=[g,p,m,b].map(S=>Math.abs(S.imaginary)<1e-12?S.real:Number.NaN);return z.sort((S,V)=>V-S),z}}return this.isSymmetric(1e-15)?this.eigenJacobi()[0]:this.eigenValuesQR()}eigenVectors(){if(!this.isSquare())throw new MatrixException("Eigen vectors only define square matrix.",this);if(this.rows>=2&&this.isZero()){const t=a.eye(this.rows,this.rows);return t.set(0,0,0),t}switch(this.rows){case 0:return this;case 1:return new a(1,1,[1]);case 2:{const t=this.eigenValues(),e=[-this._value[1],this._value[0]-t[0]],s=Math.sqrt(e[0]**2+e[1]**2),i=[-this._value[1],this._value[0]-t[1]],o=Math.sqrt(i[0]**2+i[1]**2);return new a(2,2,[e[0]/s,i[0]/o,e[1]/s,i[1]/o])}}return this.eigen()[1]}eigenValuesBiSection(){if(!this.isSymmetric(1e-15))throw new MatrixException("eigenValuesBiSection can only use symmetric matrix.",this);const t=this.tridiag(),e=this.rows;let s=0;for(let n=0;n<e;n++){const l=Math.abs(t.at(n,n))+Math.abs(n>0?t.at(n,n-1):0)+Math.abs(n<e-1?t.at(n,n+1):0);s<l&&(s=l)}const i=k(n=>{const l=[1,n-t.at(0,0)];for(let r=1;r<e;r++)l[r+1]=(n-t.at(r,r))*l[r]-t.at(r,r-1)**2*l[r-1];let h=0;for(let r=1;r<l.length;r++)Math.sign(l[r-1])!==Math.sign(l[r])&&h++;return h},"sturm"),o=[];for(let n=1;n<=e;n++){let l=-s,h=i(l),r=s;for(;Math.abs(l-r)>1e-8;){const u=(l+r)/2,c=i(u);n<=h&&n>c?r=u:(l=u,h=c)}o.push((l+r)/2)}return o}eigenValuesLR(t=1e5){if(!this.isSquare())throw new MatrixException("Eigen values only define square matrix.",this);let e=this;const s=e.rows,i=1e-15;let o=t;for(;o-- >0;){const[n,l]=e.lu();e=l.dot(n);let h=0;for(let r=0;r<s;r++)for(let u=0;u<r;u++)h+=e._value[r*s+u]**2;if(h<i){const r=e.diag();return r.sort((u,c)=>c-u),r}}throw new MatrixException("eigenValuesLR not converged.",this)}eigenValuesQR(t=1e6){if(!this.isSquare())throw new MatrixException("Eigen values only define square matrix.",this);let e=this.copy();const s=[],i=1e-8;for(let n=e.rows;n>2;n--){let l=t;for(;;){const h=e.block(n-2,n-2).eigenValues();if(isNaN(h[0])){s.sort((v,d)=>d-v);for(let v=0;v<n;v++,s.push(NaN));return s}const r=e._value[e._value.length-1],u=Math.abs(h[0]-r)<Math.abs(h[1]-r)?h[0]:h[1];for(let v=0;v<n;v++)e._value[v*n+v]-=u;const[c,f]=e.qr();e=f.dot(c);for(let v=0;v<n;v++)e._value[v*n+v]=e._value[v*n+v]+u;let w=0;for(let v=(n-1)*n;v<e.length-1;v++)w+=Math.abs(e._value[v]);if(w<i)break;if(l--<0)throw new MatrixException("eigenValuesQR not converged.",this)}s.push(e._value[e._value.length-1]),e.resize(n-1,n-1)}const o=e.eigenValues();return s.push(...o),s.sort((n,l)=>l-n),s}eigenJacobi(t=1e6){if(!this.isSymmetric(1e-15))throw new MatrixException("Jacobi method can only use symmetric matrix.",this);const e=this._value.concat(),s=a.eye(this.rows,this.cols);s.add(0);const i=1e-15;let o=0;const n=this.rows;let l=t;for(;;){let u=0,c=0,f=0;for(let m=0;m<n;m++)for(let b=m+1;b<n;b++){const z=Math.abs(e[m*n+b]);z>u&&(u=z,c=m,f=b)}if(u<i)break;if(u===o)break;if(l--<0){console.log(new MatrixException("eigenJacobi not converged.",[this,u]));break}o=u;const w=e[c*n+c],v=e[c*n+f],d=e[f*n+f],_=(w-d)/2,y=-v,j=Math.abs(_)/Math.sqrt(_**2+y**2);let g=Math.sqrt((1-j)/2);const p=Math.sqrt((1+j)/2);_*y<0&&(g=-g);for(let m=0;m<n;m++){const b=e[c*n+m],z=e[f*n+m];e[m*n+f]=e[f*n+m]=g*b+p*z,e[m*n+c]=e[c*n+m]=p*b-g*z}e[c*n+c]=p**2*w+g**2*d-2*g*p*v,e[c*n+f]=e[f*n+c]=g*p*(w-d)+(p**2-g**2)*v,e[f*n+f]=g**2*w+p**2*d+2*g*p*v;for(let m=0;m<n;m++){const b=s._value[m*n+c],z=s._value[m*n+f];s._value[m*n+f]=g*b+p*z,s._value[m*n+c]=p*b-g*z}}const h=[];for(let u=0;u<n;u++)h.push([u,e[u*n+u]]);h.sort((u,c)=>c[1]-u[1]);const r=s.col(h.map(u=>u[0]));return[h.map(u=>u[1]),r]}eigenPowerIteration(t=1e4){if(!this.isSquare())throw new MatrixException("Eigen vectors only define square matrix.",this);const e=this.rows,s=1e-15;let i=a.randn(e,1);i.div(i.norm());let o=1/0,n=t;for(;n-- >0;){const l=this.dot(i);let h=0,r=0;for(let f=0;f<e;f++)h+=l._value[f]**2,r+=l._value[f]*i._value[f];const u=h/r;l.div(l.norm());const c=Math.abs(u-o);if(c<s||isNaN(c))return[u,l];i=l,o=u}throw new MatrixException("eigenPowerIteration not converged.",this)}eigenInverseIteration(t=0,e=1e4){if(!this.isSquare())throw new MatrixException("Eigen vectors only define square matrix.",this);const s=this.rows,i=1e-15;let o=this.copy();for(let r=0;r<s;r++)o._value[r*s+r]=o._value[r*s+r]-t+1e-15;o=o.inv();let n=a.randn(s,1);n.div(n.norm());let l=1/0,h=e;for(;h-- >0;){const r=o.dot(n);let u=0,c=0;for(let v=0;v<s;v++)u+=r._value[v]**2,c+=n._value[v]*r._value[v];const f=c/u;r.div(r.norm());const w=Math.abs(f-l);if(w<i||isNaN(w))return[f+t,r];n=r,l=f}throw new MatrixException("eigenInverseIteration not converged.",this)}}
