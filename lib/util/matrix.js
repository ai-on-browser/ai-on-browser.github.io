var V=Object.defineProperty;var A=(k,t)=>V(k,"name",{value:t,configurable:!0});import q from"./complex.js";import N from"./tensor.js";const I=A((k,t)=>{const e=Math.sqrt(t),s=Math.random(),i=Math.random(),o=Math.sqrt(-2*Math.log(s))*Math.cos(2*Math.PI*i),n=Math.sqrt(-2*Math.log(s))*Math.sin(2*Math.PI*i);return[o*e+k,n*e+k]},"normal_random");export class MatrixException extends Error{static{A(this,"MatrixException")}constructor(t,e){super(t),this.value=e,this.name="MatrixException"}}export default class a{static{A(this,"Matrix")}constructor(t,e,s){s?Array.isArray(s)?Array.isArray(s[0])?this._value=s.flat():this._value=s:this._value=Array(t*e).fill(s):this._value=Array(t*e).fill(0),this._size=[t,e]}static zeros(t,e){return new a(t,e,Array(t*e).fill(0))}static ones(t,e){return new a(t,e,Array(t*e).fill(1))}static eye(t,e,s=1){const i=new a(t,e),o=Math.min(t,e);for(let n=0;n<o;n++)i._value[n*e+n]=s;return i}static random(t,e,s=0,i=1){const o=new a(t,e);for(let n=0;n<o.length;n++)o._value[n]=Math.random()*(i-s)+s;return o}static randint(t,e,s=0,i=1){const o=new a(t,e);for(let n=0;n<o.length;n++)o._value[n]=Math.floor(Math.random()*(i-s+1)+s);return o}static randn(t,e,s=0,i=1){const o=new a(t,e);if(Array.isArray(s)&&(s=new a(1,s.length,s)),Array.isArray(i)&&(i=a.fromArray(i)),!(s instanceof a)&&!(i instanceof a)){for(let r=0;r<o.length;r+=2){const h=I(s,i);o._value[r]=h[0],r+1<o.length&&(o._value[r+1]=h[1])}return o}if(s instanceof a?(s.rows===e||s.cols===1)&&(s=s.t):s=new a(1,e,s),s.cols!==e||s.rows!==1)throw new MatrixException("'myu' cols must be same as 'cols' and rows must be 1.");if(!(i instanceof a))i=a.eye(e,e,i);else if(i.rows!==e||i.cols!==e)throw new MatrixException("'sigma' cols and rows must be same as 'cols'.");const n=i.cholesky();for(let r=0;r<o.length;r+=2){const h=I(0,1);o._value[r]=h[0],r+1<o.length&&(o._value[r+1]=h[1])}const l=o.dot(n.t);return l.add(s),l}static diag(t){let e=0,s=0;for(const o of t)typeof o=="number"?(e++,s++):(e+=o.rows,s+=o.cols);const i=new a(e,s);for(let o=0,n=0,l=0;n<e;o++){const r=t[o];typeof r=="number"?(i._value[n*s+l]=r,n++,l++):(i.set(n,l,r),n+=r.rows,l+=r.cols)}return i}static fromArray(t){if(t instanceof a)return t;if(Array.isArray(t)){if(t.length===0)return new a(0,0);if(!Array.isArray(t[0]))return new a(t.length,1,t)}else return new a(1,1,t);return new a(t.length,t[0].length,t)}get dimension(){return this._size.length}get sizes(){return this._size}get length(){return this._size[0]*this._size[1]}get rows(){return this._size[0]}get cols(){return this._size[1]}get value(){return this._value}get t(){return this.transpose()}*[Symbol.iterator](){yield*this._value}toArray(){const t=[],e=this.cols;for(let s=0;s<this.length;s+=e)t.push(this._value.slice(s,s+e));return t}toScaler(){if(this.rows!==1||this.cols!==1)throw new MatrixException("The matrix cannot convert to scaler.");return this._value[0]}toString(){let t="[";for(let e=0;e<this.rows;e++){e>0&&(t+=`,
 `),t+="[";for(let s=0;s<this.cols;s++)s>0&&(t+=", "),t+=this._value[e*this.cols+s];t+="]"}return t+"]"}copy(t){return t===this?this:t?(t._size=[].concat(this._size),this._value.forEach((e,s)=>t._value[s]=e),t):new a(this.rows,this.cols,[].concat(this._value))}equals(t,e=0){if(t instanceof a){if(this._size[0]!==t._size[0]||this._size[1]!==t._size[1])return!1;for(let s=this.length-1;s>=0;s--)if(Math.abs(this._value[s]-t._value[s])>e)return!1;return!0}return!1}at(t,e){if(Array.isArray(t)&&([t,e]=t),t<0||this.rows<=t||e<0||this.cols<=e)throw new MatrixException("Index out of bounds.");return this._value[t*this.cols+e]}set(t,e,s){if(Array.isArray(t)&&(s=e,[t,e]=t),s instanceof a){if(t<0||this.rows<=t+s.rows-1||e<0||this.cols<=e+s.cols-1)throw new MatrixException("Index out of bounds.");for(let i=0;i<s.rows;i++)for(let o=0;o<s.cols;o++)this._value[(i+t)*this.cols+o+e]=s._value[i*s.cols+o];return null}else{if(t<0||this.rows<=t||e<0||this.cols<=e)throw new MatrixException("Index out of bounds.");const i=this._value[t*this.cols+e];return this._value[t*this.cols+e]=s,i}}row(t){if(Array.isArray(t)){if(typeof t[0]=="boolean"){if(t.length!==this.rows)throw new MatrixException("Length is invalid.");const s=[];for(let i=0;i<t.length;i++)t[i]&&s.push(i);t=s}if(t.some(s=>s<0||this.rows<=s))throw new MatrixException("Index out of bounds.");const e=new a(t.length,this.cols);for(let s=0;s<t.length;s++)for(let i=0;i<this.cols;i++)e._value[s*this.cols+i]=this._value[t[s]*this.cols+i];return e}else{if(t<0||this.rows<=t)throw new MatrixException("Index out of bounds.");return new a(1,this.cols,this._value.slice(t*this.cols,(t+1)*this.cols))}}col(t){if(Array.isArray(t)){if(typeof t[0]=="boolean"){if(t.length!==this.cols)throw new MatrixException("Length is invalid.");const s=[];for(let i=0;i<t.length;i++)t[i]&&s.push(i);t=s}if(t.some(s=>s<0||this.cols<=s))throw new MatrixException("Index out of bounds.");const e=new a(this.rows,t.length);for(let s=0;s<this.rows;s++)for(let i=0;i<t.length;i++)e._value[s*t.length+i]=this._value[s*this.cols+t[i]];return e}else{if(t<0||this.cols<=t)throw new MatrixException("Index out of bounds.");const e=new a(this.rows,1);for(let s=0;s<this.rows;s++)e._value[s]=this._value[s*this.cols+t];return e}}slice(t,e,s=0){if(typeof t!="number"&&(t=0),typeof e!="number"&&(e=this._size[s]),t<0||this._size[s]<t||e<0||this._size[s]<e)throw new MatrixException("Index out of bounds.");if(t>e)throw new MatrixException("'to' must be greater than or equals to 'from'.");if(s===0){const i=new a(e-t,this.cols);return i._value=this._value.slice(t*this.cols,e*this.cols),i}else if(s===1){const i=new a(this.rows,e-t);for(let o=0;o<i.rows;o++)for(let n=0;n<i.cols;n++)i._value[o*i.cols+n]=this._value[o*this.cols+n+t];return i}else throw new MatrixException("Invalid axis.")}block(t,e,s,i){if(typeof t!="number"&&(t=0),typeof e!="number"&&(e=0),typeof s!="number"&&(s=this.rows),typeof i!="number"&&(i=this.cols),t<0||this.rows<t||s<0||this.rows<s||e<0||this.cols<e||i<0||this.cols<i)throw new MatrixException("Index out of bounds.");if(t>s)throw new MatrixException("'rows_to' must be greater than or equals to 'rows_from'.");if(e>i)throw new MatrixException("'cols_to' must be greater than or equals to 'cols_from'.");const o=new a(s-t,i-e);for(let n=0;n<o.rows;n++)for(let l=0;l<o.cols;l++)o._value[n*o.cols+l]=this._value[(n+t)*this.cols+l+e];return o}remove(t,e=0){if(e===0)if(Array.isArray(t)){if(t.some(s=>s<0||this.rows<=s))throw new MatrixException("Index out of bounds.");t=[...new Set(t)],t.sort((s,i)=>i-s);for(let s=0;s<t.length;s++)this._value.splice(t[s]*this.cols,this.cols);this._size[0]-=t.length}else{if(t<0||this.rows<=t)throw new MatrixException("Index out of bounds.");this._value.splice(t*this.cols,this.cols),this._size[0]--}else if(e===1)if(Array.isArray(t)){if(t.some(o=>o<0||this.cols<=o))throw new MatrixException("Index out of bounds.");t=[...new Set(t)],t.sort((o,n)=>o-n);let s=0,i=0;for(let o=0;o<this.rows;o++)for(let n=0,l=0;n<this.cols;n++,s++){if(t[l]===n){l++;continue}this._value[i++]=this._value[s]}this._size[1]-=t.length,this._value.length=this.length}else{if(t<0||this.cols<=t)throw new MatrixException("Index out of bounds.");let s=0,i=0;for(let o=0;o<this.rows;o++)for(let n=0;n<this.cols;n++,s++)t!==n&&(this._value[i++]=this._value[s]);this._size[1]--,this._value.length=this.length}else throw new MatrixException("Invalid axis.")}removeIf(t,e=0){const s=[];if(e===0)for(let i=0;i<this.rows;i++)t(this.row(i))&&s.push(i);else if(e===1)for(let i=0;i<this.cols;i++)t(this.col(i))&&s.push(i);else throw new MatrixException("Invalid axis.");this.remove(s,e)}sample(t,e=0){const s=this.sizes[e],i=[];for(let o=0;o<t;o++)i.push(Math.floor(Math.random()*(s-o)));for(let o=t-1;o>=0;o--)for(let n=t-1;n>o;n--)i[o]<=i[n]&&i[n]++;if(e===0)return[this.row(i),i];if(e===1)return[this.col(i),i];throw new MatrixException("Invalid axis.")}fill(t){this._value.fill(t)}map(t){for(let e=0,s=0;e<this._size[0];e++)for(let i=0;i<this._size[1];i++,s++)this._value[s]=t(this._value[s],[e,i],this)}static map(t,e){const s=new a(t.rows,t.cols);for(let i=0,o=0;i<t._size[0];i++)for(let n=0;n<t._size[1];n++,o++)s._value[o]=e(t._value[o],[i,n],t);return s}forEach(t){for(let e=0,s=0;e<this._size[0];e++)for(let i=0;i<this._size[1];i++,s++)t(this._value[s],[e,i],this)}transpose(){const t=new a(this.cols,this.rows);for(let e=0;e<this.rows;e++)for(let s=0;s<this.cols;s++)t._value[s*this.rows+e]=this._value[e*this.cols+s];return t}adjoint(){return this.transpose()}flip(t=0){if(t===0)for(let e=0;e<this.rows/2;e++){const s=(this.rows-e-1)*this.cols;for(let i=0;i<this.cols;i++){const o=this._value[e*this.cols+i];this._value[e*this.cols+i]=this._value[s+i],this._value[s+i]=o}}else if(t===1)for(let e=0;e<this.cols/2;e++){const s=this.cols-e-1;for(let i=0;i<this.rows;i++){const o=this._value[i*this.cols+e];this._value[i*this.cols+e]=this._value[i*this.cols+s],this._value[i*this.cols+s]=o}}else throw new MatrixException("Invalid axis.")}swap(t,e,s=0){if(s===0){if(t<0||e<0||this.rows<=t||this.rows<=e)throw new MatrixException("Index out of bounds.");const i=(e-t)*this.cols;for(let o=t*this.cols;o<(t+1)*this.cols;o++)[this._value[o],this._value[o+i]]=[this._value[o+i],this._value[o]]}else if(s===1){if(t<0||e<0||this.cols<=t||this.cols<=e)throw new MatrixException("Index out of bounds.");const i=e-t;for(let o=t;o<this.length;o+=this.cols)[this._value[o],this._value[o+i]]=[this._value[o+i],this._value[o]]}else throw new MatrixException("Invalid axis.")}sort(t=0){if(t===0){const e=Array.from({length:this.rows},(s,i)=>i);return e.sort((s,i)=>{const o=s*this.cols,n=i*this.cols;for(let l=0;l<this.cols;l++){const r=this._value[o+l],h=this._value[n+l],u=r-h;if(u!==0)return u}return 0}),this._value=this.row(e)._value,e}else if(t===1){const e=Array.from({length:this.cols},(s,i)=>i);return e.sort((s,i)=>{for(let o=0;o<this.rows;o++){const n=this._value[s+o*this.cols],l=this._value[i+o*this.cols],r=n-l;if(r!==0)return r}return 0}),this._value=this.col(e)._value,e}throw new MatrixException("Invalid axis.")}shuffle(t=0){const e=Array.from({length:this._size[t]},(s,i)=>i);for(let s=e.length-1;s>0;s--){const i=Math.floor(Math.random()*(s+1));[e[s],e[i]]=[e[i],e[s]]}if(t===0)this._value=this.row(e)._value;else if(t===1)this._value=this.col(e)._value;else throw new MatrixException("Invalid axis.");return e}unique(t=0,e=0){const s=[];if(t===0){let i=0;for(let o=0;o<this.rows;o++){let n=-1;for(let l=0;l<o;l++){let r=!0;for(let h=0;r&&h<this.cols;h++)Math.abs(this._value[o*this.cols+h]-this._value[l*this.cols+h])>e&&(r=!1);if(r){n=l;break}}if(n<0){for(let l=0;l<this.cols;l++)this._value[i*this.cols+l]=this._value[o*this.cols+l];s.push(o),i++}}this._size[0]=i,this._value.length=this.length}else if(t===1){for(let i=0;i<this.cols;i++){let o=!1;for(let n=0;!o&&n<s.length;n++){o=!0;for(let l=0;o&&l<this.rows;l++)Math.abs(this._value[l*this.cols+i]-this._value[l*this.cols+s[n]])>e&&(o=!1)}o||s.push(i)}for(let i=0,o=0;i<this.rows;i++)for(let n=0;n<s.length;n++,o++)this._value[o]=this._value[i*this.cols+s[n]];this._size[1]=s.length,this._value.length=this.length}else throw new MatrixException("Invalid axis.");return s}resize(t,e,s=0){const i=Array(t*e).fill(s),o=Math.min(this.rows,t),n=Math.min(this.cols,e);for(let l=0;l<o;l++)for(let r=0;r<n;r++)i[l*e+r]=this._value[l*this.cols+r];this._value=i,this._size=[t,e]}static resize(t,e,s,i=0){const o=new a(e,s);o.fill(i);const n=Math.min(t.rows,e),l=Math.min(t.cols,s);for(let r=0;r<n;r++)for(let h=0;h<l;h++)o._value[r*s+h]=t._value[r*t.cols+h];return o}reshape(t,e){if(t===-1){if(this.length%e!==0)throw new MatrixException("Length is different.");t=this.length/e}else if(e===-1){if(this.length%t!==0)throw new MatrixException("Length is different.");e=this.length/t}else if(this.length!==t*e)throw new MatrixException("Length is different.");this._size=[t,e]}repeat(t,e=0){if(Array.isArray(t)){if(t.length<this._size.length)for(let n=t.length;n<this._size.length;n++)t[n]=1}else{const n=Array(this._size.length).fill(1);n[e]=t,t=n}const s=t.reduce((n,l)=>n*l,1);if(s===1)return;const i=Array(this.length*s),o=this._size.map((n,l)=>n*t[l]);for(let n=0;n<o[0];n++)for(let l=0;l<o[1];l++)i[n*o[1]+l]=this._value[n%this.rows*this.cols+l%this.cols];this._value=i,this._size=o}static repeat(t,e,s=0){const i=t.copy();return i.repeat(e,s),i}concat(t,e=0){if(e===0){if(this.cols!==t.cols)throw new MatrixException("Size is different.");this._value=[].concat(this._value,t._value),this._size[0]+=t.rows}else if(e===1){if(this.rows!==t.rows)throw new MatrixException("Size is different.");const s=this.cols;this.resize(this.rows,this.cols+t.cols);for(let i=0;i<this.rows;i++)for(let o=0;o<t.cols;o++)this._value[i*this.cols+o+s]=t._value[i*t.cols+o]}else throw new MatrixException("Invalid axis.")}static concat(t,e,s=0){const i=t.copy();return i.concat(e,s),i}reduce(t,e,s=-1,i=null){if(Array.isArray(s))if(s.includes(-1)||s.includes(0)&&s.includes(1))s=-1;else if(s.includes(0))s=0;else if(s.includes(1))s=1;else throw new MatrixException("Invalid axis.");if(s>1)throw new MatrixException("Invalid axis.");if(s<0){let h=e??this._value[0];for(let u=0,c=0;u<this._size[0];u++)for(let v=0;v<this._size[1];v++,c++)c===0&&e==null||(h=t(h,this._value[c],[u,v],this));return i===!0?new a(1,1,h):h}if(i===!1)throw new MatrixException("keepdims only accept true if axis >= 0.");let o=s===0?1:this.cols,n=s===0?this.cols:1;const l=[].concat(this._size);l[s]=1;const r=a.zeros(...l);for(let h=0,u=0;h<r.length;h++,u+=o){let c=e??this._value[u];for(let v=c===e?0:1;v<this._size[s];v++)c=t(c,this._value[v*n+u],s===0?[v,h]:[h,v],this);r._value[h]=c}return r}every(t,e=-1){return this.reduce((s,i,o,n)=>s&&t(i,o,n),!0,e)}some(t,e=-1){return this.reduce((s,i,o,n)=>s||t(i,o,n),!1,e)}max(t=-1){return this.reduce((e,s)=>Math.max(e,s),-1/0,t)}min(t=-1){return this.reduce((e,s)=>Math.min(e,s),1/0,t)}median(t=-1){if(t<0){const n=this._value.concat();return n.sort((l,r)=>l-r),n.length%2===1?n[(n.length-1)/2]:(n[n.length/2]+n[n.length/2-1])/2}let e=t===0?1:this.cols,s=t===0?this.cols:1;const i=[].concat(this._size);i[t]=1;const o=a.zeros(...i);for(let n=0,l=0;n<o.length;n++,l+=e){const r=[];for(let h=0;h<this._size[t];h++)r.push(this._value[h*s+l]);r.sort((h,u)=>h-u),r.length%2===1?o._value[n]=r[(r.length-1)/2]:o._value[n]=(r[r.length/2]+r[r.length/2-1])/2}return o}quantile(t,e=-1){if(t===0)return this.min(e);if(t===1)return this.max(e);const s=A((l,r)=>{if(l.sort((c,v)=>c-v),l.length===1)return l[0];const h=r*(l.length-1),u=Math.floor(h);return h===u?l[u]:l[u]*(1-h+u)+l[u+1]*(h-u)},"quantile");if(e<0){const l=this._value.concat();return s(l,t)}const i=e===0?1:this.cols,o=e===0?this.cols:1,n=a.zeros(...this._size.map((l,r)=>r===e?1:l));for(let l=0,r=0;l<n.length;l++,r+=i){const h=[];for(let u=0;u<this._size[e];u++)h.push(this._value[u*o+r]);n._value[l]=s(h,t)}return n}argmax(t){let e=t===0?1:this.cols,s=t===0?this.cols:1;const i=[].concat(this._size);i[t]=1;const o=a.zeros(...i);for(let n=0,l=0;n<o.length;n++,l+=e){let r=this._value[l],h=0;for(let u=1;u<this._size[t];u++){let c=this._value[u*s+l];c>r&&(r=c,h=u)}o._value[n]=h}return o}argmin(t){let e=t===0?1:this.cols,s=t===0?this.cols:1;const i=[].concat(this._size);i[t]=1;const o=a.zeros(...i);for(let n=0,l=0;n<o.length;n++,l+=e){let r=this._value[l],h=0;for(let u=1;u<this._size[t];u++){let c=this._value[u*s+l];c<r&&(r=c,h=u)}o._value[n]=h}return o}sum(t=-1){return this.reduce((e,s)=>e+s,0,t)}mean(t=-1){if(t<0)return this.sum(t)/this.length;let e=this.sum(t);return e.div(this._size[t]),e}prod(t=-1){return this.reduce((e,s)=>e*s,1,t)}variance(t=-1,e=0){const s=this.mean(t);if(t<0)return this._value.reduce((r,h)=>r+(h-s)**2,0)/(this.length-e);let i=t===0?1:this.cols,o=t===0?this.cols:1;const n=[].concat(this._size);n[t]=1;const l=a.zeros(...n);for(let r=0,h=0;r<l.length;r++,h+=i){let u=0;for(let c=0;c<this._size[t];c++)u+=(this._value[c*o+h]-s._value[r])**2;l._value[r]=u/(this._size[t]-e)}return l}std(t=-1,e=0){if(t<0)return Math.sqrt(this.variance(t,e));let s=this.variance(t,e);for(let i=0;i<s.length;i++)s._value[i]=Math.sqrt(s._value[i]);return s}isSquare(){return this.rows===this.cols}isDiag(t=0){const e=this.cols;for(let s=0;s<this.rows;s++)for(let i=0;i<e;i++)if(s!==i&&Math.abs(this._value[s*e+i])>t)return!1;return!0}isIdentity(t=0){if(!this.isSquare())return!1;const e=this.cols;for(let s=0;s<this.rows;s++)for(let i=0;i<e;i++)if(s!==i){if(Math.abs(this._value[s*e+i])>t)return!1}else if(Math.abs(this._value[s*e+i]-1)>t)return!1;return!0}isZero(t=0){const e=this.length;for(let s=0;s<e;s++)if(Math.abs(this._value[s])>t)return!1;return!0}isTriangular(t=0){return this.isLowerTriangular(t)||this.isUpperTriangular(t)}isLowerTriangular(t=0){const e=this.cols;for(let s=0;s<this.rows;s++)for(let i=s+1;i<e;i++)if(Math.abs(this._value[s*e+i])>t)return!1;return!0}isUpperTriangular(t=0){for(let e=0;e<this.rows;e++)for(let s=0;s<Math.min(e,this.cols);s++)if(Math.abs(this._value[e*this.cols+s])>t)return!1;return!0}isSymmetric(t=0){if(!this.isSquare())return!1;const e=this.cols;for(let s=0;s<this.rows;s++)for(let i=0;i<s;i++)if(t>0){if(Math.abs(this._value[s*e+i]-this._value[i*e+s])>t)return!1}else if(this._value[s*e+i]!==this._value[i*e+s])return!1;return!0}isHermitian(t=0){return this.isSymmetric(t)}isAlternating(t=0){if(!this.isSquare())return!1;const e=this.cols;for(let s=0;s<this.rows;s++)for(let i=0;i<s;i++)if(t>0){if(Math.abs(this._value[s*e+i]+this._value[i*e+s])>t)return!1}else if(this._value[s*e+i]!==-this._value[i*e+s])return!1;return!0}isSkewHermitian(t=0){return this.isAlternating(t)}isRegular(t=0){return this.isSquare()?Math.abs(this.det())<=t:!1}isNormal(t=0){return this.dot(this.t).equals(this.tDot(this),t)}isOrthogonal(t=0){const e=this.tDot(this);for(let s=0;s<this.rows;s++)for(let i=0;i<this.cols;i++){const o=e._value[s*this.cols+i];if(s===i){if(Math.abs(o-1)>t)return!1}else if(Math.abs(o)>t)return!1}return!0}isUnitary(t=0){return this.isOrthogonal(t)}isNilpotent(t=0){if(!this.isSquare())return!1;const e=this.eigenValues();for(let s=0;s<e.length;s++)if(isNaN(e[s])||Math.abs(e[s])>t)return!1;return!0}diag(){let t=[];const e=Math.min(this.rows,this.cols);for(let s=0;s<e;s++)t.push(this._value[s*this.cols+s]);return t}trace(){let t=0;const e=Math.min(this.rows,this.cols);for(let s=0;s<e;s++)t+=this._value[s*this.cols+s];return t}norm(t=2){return this.normEntrywise(t)}normInduced(t=2){if(t===1){let e=-1/0;for(let s=0;s<this.cols;s++){let i=0;for(let o=0;o<this.rows;o++)i+=Math.abs(this._value[o*this.cols+s]);e=Math.max(e,i)}return e}else if(t===1/0){let e=-1/0;for(let s=0;s<this.rows;s++){let i=0;for(let o=0;o<this.cols;o++)i+=Math.abs(this._value[s*this.cols+o]);e=Math.max(e,i)}return e}else if(t===2)return this.normSpectral();throw new MatrixException("Not implemented")}normSpectral(){return this.singularValues()[0]}normEntrywise(t=2){if(t===1/0)return this.normMax();if(t===2)return this.normFrobenius();let e=0;for(let s=0;s<this.length;s++)e+=Math.abs(this._value[s])**t;return e**(1/t)}normFrobenius(){let t=0;for(let e=0;e<this.length;e++)t+=Math.abs(this._value[e])**2;return Math.sqrt(t)}normMax(){let t=-1/0;for(let e=0;e<this.length;e++)t=Math.max(t,Math.abs(this._value[e]));return t}normSchatten(t=2){if(t===1/0)return this.normSpectral();if(t===1)return this.normNuclear();const e=this.singularValues(),s=Math.min(this.rows,this.cols);let i=0;for(let o=0;o<s;o++)i+=e[o]**t;return i**(1/t)}normNuclear(){const t=this.singularValues(),e=Math.min(this.rows,this.cols);let s=0;for(let i=0;i<e;i++)s+=t[i];return s}rank(t=0){const e=this.copy();let s=0;for(let i=0;s<e.rows&&i<e.cols;i++,s++){if(Math.abs(e._value[s*e.cols+i])<=t){for(let n=s+1;n<e.rows;n++)if(Math.abs(e._value[n*e.cols+i])>t){e.swap(s,n,0);break}}if(Math.abs(e._value[s*e.cols+i])<=t){s--;continue}const o=e._value[s*e.cols+i];for(let n=s+1;n<e.rows;n++){const l=e._value[n*e.cols+i];for(let r=i+1;r<e.cols;r++)e._value[n*e.cols+r]-=l*e._value[s*e.cols+r]/o}}return s}det(){if(!this.isSquare())throw new MatrixException("Determine only define square matrix.",this);const t=this._value;switch(this.rows){case 0:return 0;case 1:return t[0];case 2:return t[0]*t[3]-t[1]*t[2];case 3:return t[0]*t[4]*t[8]+t[1]*t[5]*t[6]+t[2]*t[3]*t[7]-t[0]*t[5]*t[7]-t[1]*t[3]*t[8]-t[2]*t[4]*t[6];case 4:return t[0]*t[5]*t[10]*t[15]+t[0]*t[6]*t[11]*t[13]+t[0]*t[7]*t[9]*t[14]-t[0]*t[7]*t[10]*t[13]-t[0]*t[6]*t[9]*t[15]-t[0]*t[5]*t[11]*t[14]-t[1]*t[4]*t[10]*t[15]-t[2]*t[4]*t[11]*t[13]-t[3]*t[4]*t[9]*t[14]+t[3]*t[4]*t[10]*t[13]+t[2]*t[4]*t[9]*t[15]+t[1]*t[4]*t[11]*t[14]+t[1]*t[6]*t[8]*t[15]+t[2]*t[7]*t[8]*t[13]+t[3]*t[5]*t[8]*t[14]-t[3]*t[6]*t[8]*t[13]-t[2]*t[5]*t[8]*t[15]-t[1]*t[7]*t[8]*t[14]-t[1]*t[6]*t[11]*t[12]-t[2]*t[7]*t[9]*t[12]-t[3]*t[5]*t[10]*t[12]+t[3]*t[6]*t[9]*t[12]+t[2]*t[5]*t[11]*t[12]+t[1]*t[7]*t[10]*t[12]}const[e,s]=this.lu();let i=1;for(let o=0;o<this.rows;o++){const n=o*this.cols+o;i*=e._value[n]*s._value[n]}return i}negative(){this.map(t=>-t)}not(){this.map(t=>+!t)}bitnot(){this.map(t=>~t)}abs(){this.map(Math.abs)}round(){this.map(Math.round)}floor(){this.map(Math.floor)}ceil(){this.map(Math.ceil)}leftShift(t){this.map(e=>e<<t)}signedRightShift(t){this.map(e=>e>>t)}unsignedRightShift(t){this.map(e=>e>>>t)}broadcastOperate(t,e){if(t instanceof a||t instanceof N){if(t.dimension>2)throw new MatrixException(`Broadcasting size invalid. this: ${this.sizes}, other: ${t.sizes}`,[this,t]);const s=t.dimension===2?t.sizes:[1,t.length];if(this.rows===s[0]&&this.cols===s[1])for(let i=this.length-1;i>=0;i--)this._value[i]=e(this._value[i],t._value[i]);else{const i=[1,1];for(let o=0;o<2;o++)if(this._size[o]<s[o]){if(s[o]%this._size[o]!==0)throw new MatrixException(`Broadcasting size invalid. this: ${this.sizes}, other: ${t.sizes}`,[this,t]);i[o]=s[o]/this._size[o]}else if(this._size[o]%s[o]!==0)throw new MatrixException(`Broadcasting size invalid. this: ${this.sizes}, other: ${t.sizes}`,[this,t]);i.some(o=>o>1)&&this.repeat(i);for(let o=0,n=0;o<this.rows;o++){const l=o%s[0];for(let r=0;r<this.cols;r++,n++)this._value[n]=e(this._value[n],t._value[l*s[1]+r%s[1]])}}}else this.map(s=>e(s,t))}operateAt(t,e,s){if(Array.isArray(t)&&(s=e,[t,e]=t),t<0||this.rows<=t||e<0||this.cols<=e)throw new MatrixException("Index out of bounds.");const i=this._value[t*this.cols+e];return this._value[t*this.cols+e]=s(i),i}add(t){this.broadcastOperate(t,(e,s)=>e+s)}addAt(t,e,s){return this.operateAt(t,e,i=>i+s)}static add(t,e){if(t instanceof a){const s=t.copy();return s.add(e),s}else if(e instanceof a){const s=e.copy();return s.add(t),s}return new a(1,1,t+e)}sub(t){this.broadcastOperate(t,(e,s)=>e-s)}isub(t){this.negative(),this.add(t)}subAt(t,e,s){return this.operateAt(t,e,i=>i-s)}isubAt(t,e,s){return this.operateAt(t,e,i=>s-i)}static sub(t,e){if(t instanceof a){const s=t.copy();return s.sub(e),s}else if(e instanceof a){const s=e.copy();return s.isub(t),s}return new a(1,1,t-e)}mult(t){this.broadcastOperate(t,(e,s)=>e*s)}multAt(t,e,s){return this.operateAt(t,e,i=>i*s)}static mult(t,e){if(t instanceof a){const s=t.copy();return s.mult(e),s}else if(e instanceof a){const s=e.copy();return s.mult(t),s}return new a(1,1,t*e)}div(t){this.broadcastOperate(t,(e,s)=>e/s)}idiv(t){this.broadcastOperate(t,(e,s)=>s/e)}divAt(t,e,s){return this.operateAt(t,e,i=>i/s)}idivAt(t,e,s){return this.operateAt(t,e,i=>s/i)}static div(t,e){if(t instanceof a){const s=t.copy();return s.div(e),s}else if(e instanceof a){const s=e.copy();return s.idiv(t),s}return new a(1,1,t/e)}mod(t){this.broadcastOperate(t,(e,s)=>e%s)}imod(t){this.broadcastOperate(t,(e,s)=>s%e)}modAt(t,e,s){return this.operateAt(t,e,i=>i%s)}imodAt(t,e,s){return this.operateAt(t,e,i=>s%i)}static mod(t,e){if(t instanceof a){const s=t.copy();return s.mod(e),s}else if(e instanceof a){const s=e.copy();return s.imod(t),s}return new a(1,1,t%e)}and(t){this.broadcastOperate(t,(e,s)=>+(!!e&&!!s))}andAt(t,e,s){return this.operateAt(t,e,i=>+(!!i&&!!s))}static and(t,e){if(t instanceof a){const s=t.copy();return s.and(e),s}else if(e instanceof a){const s=e.copy();return s.and(t),s}return new a(1,1,+(!!t&&!!e))}or(t){this.broadcastOperate(t,(e,s)=>+(!!e||!!s))}orAt(t,e,s){return this.operateAt(t,e,i=>+(!!i||!!s))}static or(t,e){if(t instanceof a){const s=t.copy();return s.or(e),s}else if(e instanceof a){const s=e.copy();return s.or(t),s}return new a(1,1,+(!!t||!!e))}bitand(t){this.broadcastOperate(t,(e,s)=>+(e&s))}bitandAt(t,e,s){return this.operateAt(t,e,i=>+(i&s))}static bitand(t,e){if(t instanceof a){const s=t.copy();return s.bitand(e),s}else if(e instanceof a){const s=e.copy();return s.bitand(t),s}return new a(1,1,+(t&e))}bitor(t){this.broadcastOperate(t,(e,s)=>+(e|s))}bitorAt(t,e,s){return this.operateAt(t,e,i=>+(i|s))}static bitor(t,e){if(t instanceof a){const s=t.copy();return s.bitor(e),s}else if(e instanceof a){const s=e.copy();return s.bitor(t),s}return new a(1,1,+(t|e))}bitxor(t){this.broadcastOperate(t,(e,s)=>+(e^s))}bitxorAt(t,e,s){return this.operateAt(t,e,i=>+(i^s))}static bitxor(t,e){if(t instanceof a){const s=t.copy();return s.bitxor(e),s}else if(e instanceof a){const s=e.copy();return s.bitxor(t),s}return new a(1,1,+(t^e))}dot(t){if(this.cols!==t.rows)throw new MatrixException(`Dot size invalid. left = [${this.rows}, ${this.cols}], right = [${t.rows}, ${t.cols}]`);const e=t.cols,s=new a(this.rows,e);let i=0;const o=this.length,n=t.length,l=this.cols,r=this._value,h=t._value,u=s._value;for(let c=0;c<o;c+=l){let v=0,f=0;for(let w=0,d=c;w<n;w+=e,d++)r[d]&&f++,v+=r[d]*h[w];if(u[i++]=v,f===0){i+=e-1;continue}else if(f/l<.1){let w=[],d=[];for(let _=0;_<l;_++)r[c+_]&&(w.push(r[c+_]),d.push(_));for(let _=1;_<e;_++){v=0;for(let y=0;y<w.length;y++)v+=w[y]*h[d[y]*e+_];u[i++]=v}}else for(let w=1;w<e;w++){v=0;for(let d=w,_=c;d<n;d+=e,_++)v+=r[_]*h[d];u[i++]=v}}return s}tDot(t){if(this.rows!==t.rows)throw new MatrixException(`tDot size invalid. left = [${this.cols}, ${this.rows}], right = [${t.rows}, ${t.cols}]`);const e=new a(this.cols,t.cols);let s=0;for(let i=0;i<this.cols;i++)for(let o=0;o<t.cols;o++){let n=0,l=i;for(let r=o;r<t.length;r+=t.cols,l+=this.cols)n+=this._value[l]*t._value[r];e._value[s++]=n}return e}kron(t){const e=new a(this.rows*t.rows,this.cols*t.cols);for(let s=0;s<this.rows;s++)for(let i=0;i<this.cols;i++)for(let o=0;o<t.rows;o++)for(let n=0;n<t.cols;n++)e._value[(s*t.rows+o)*this.cols*t.cols+i*t.cols+n]=this._value[s*this.cols+i]*t._value[o*t.cols+n];return e}convolute(t,e=!0){const s=[Math.floor((t.length-1)/2),Math.floor((t[0].length-1)/2)],i=this._value.concat();for(let o=0;o<this.rows;o++)for(let n=0;n<this.cols;n++){let l=0,r=0;for(let h=0;h<t.length;h++){const u=o+h-s[0];if(!(u<0||this.rows<=u))for(let c=0;c<t[h].length;c++){const v=n+c-s[1];v<0||this.cols<=v||(l+=t[h][c]*i[u*this.cols+v],r+=t[h][c])}}e&&(l/=r),this._value[o*this.cols+n]=l}}reducedRowEchelonForm(t=0){for(let e=0,s=0;e<this.rows&&s<this.cols;s++,e++){if(Math.abs(this._value[e*this.cols+s])<=t){for(let o=e+1;o<this.rows;o++)if(Math.abs(this._value[o*this.cols+s])>t){this.swap(e,o,0);break}}if(Math.abs(this._value[e*this.cols+s])<=t){e--;continue}const i=this._value[e*this.cols+s];this._value[e*this.cols+s]=1;for(let o=s+1;o<this.cols;o++)this._value[e*this.cols+o]/=i;for(let o=0;o<this.rows;o++){if(o===e)continue;const n=this._value[o*this.cols+s];this._value[o*this.cols+s]=0;for(let l=s+1;l<this.cols;l++)this._value[o*this.cols+l]-=n*this._value[e*this.cols+l]}}}inv(){if(!this.isSquare())throw new MatrixException("Inverse matrix only define square matrix.",this);const t=this._value;switch(this.rows){case 0:return new a(0,0);case 1:return new a(1,1,[1/t[0]]);case 2:{const e=this.det();return new a(2,2,[t[3]/e,-t[1]/e,-t[2]/e,t[0]/e])}case 3:{const e=this.det();return new a(3,3,[(t[4]*t[8]-t[5]*t[7])/e,(t[2]*t[7]-t[1]*t[8])/e,(t[1]*t[5]-t[2]*t[4])/e,(t[5]*t[6]-t[3]*t[8])/e,(t[0]*t[8]-t[2]*t[6])/e,(t[2]*t[3]-t[0]*t[5])/e,(t[3]*t[7]-t[4]*t[6])/e,(t[1]*t[6]-t[0]*t[7])/e,(t[0]*t[4]-t[1]*t[3])/e])}}return this.isLowerTriangular()?this.invLowerTriangular():this.isUpperTriangular()?this.invUpperTriangular():this.invLU()}invLowerTriangular(){if(!this.isSquare())throw new MatrixException("Inverse matrix only define square matrix.",this);const t=this._value,e=new a(this.rows,this.cols);for(let s=0;s<this.rows;s++){const i=t[s*this.cols+s];e._value[s*this.cols+s]=1/i;for(let o=0;o<s;o++){let n=0;for(let l=o;l<s;l++)n+=t[s*this.cols+l]*e._value[l*this.cols+o];e._value[s*this.cols+o]=-n/i}}return e}invUpperTriangular(){if(!this.isSquare())throw new MatrixException("Inverse matrix only define square matrix.",this);const t=this._value,e=new a(this.rows,this.cols);for(let s=this.cols-1;s>=0;s--){const i=t[s*this.cols+s];e._value[s*this.cols+s]=1/i;for(let o=s+1;o<this.cols;o++){let n=0;for(let l=s+1;l<=o;l++)n+=t[s*this.cols+l]*e._value[l*this.cols+o];e._value[s*this.cols+o]=-n/i}}return e}invRowReduction(){if(!this.isSquare())throw new MatrixException("Inverse matrix only define square matrix.",this);const t=this.copy(),e=this.rows,s=a.eye(e,e);for(let i=0;i<e;i++){const o=i*e;if(t._value[o+i]===0){let l=i+1;for(;l<e&&t._value[l*e+i]===0;l++);if(l===e)throw new MatrixException("",this);for(let r=i;r<e;r++)[t._value[o+r],t._value[l*e+r]]=[t._value[l*e+r],t._value[o+r]];s.swap(i,l)}const n=t._value[o+i];t._value[o+i]=1;for(let l=i+1;l<e;l++)t._value[o+l]/=n;for(let l=0;l<e;l++)s._value[o+l]=s._value[o+l]/n;for(let l=0;l<e;l++){if(i===l)continue;const r=t._value[l*e+i];t._value[l*e+i]=0;for(let h=i+1;h<e;h++)t._value[l*e+h]-=r*t._value[o+h];for(let h=0;h<e;h++)s._value[l*e+h]=s._value[l*e+h]-r*s._value[o+h]}}return s}invLU(){if(!this.isSquare())throw new MatrixException("Inverse matrix only define square matrix.",this);const[t,e]=this.lu();return e.invUpperTriangular().dot(t.invLowerTriangular())}pseudoInv(){const t=this.rows,e=this.cols,s=this._value;if(t===0||e===0)return new a(e,t);if(t===1&&e===1)return new a(1,1,s[0]===0?0:1/s[0]);if(t===1||e===1){const i=s.reduce((o,n)=>o+n**2,0);return i===0?new a(e,t):new a(e,t,s.map(o=>o/i))}else if(t===2&&e===2){if(this.det()!==0)return this.inv();const o=s.reduce((n,l)=>n+l**2,0);return o===0?new a(e,t):new a(e,t,s.map(n=>n/o))}return this.pseudoInvQR()}pseudoInvNaive(){const t=this.rows<this.cols?this.adjoint():this,e=t.tDot(t).solve(t.adjoint());return this.rows<this.cols?e.adjoint():e}pseudoInvQR(){const t=this.rows<this.cols?this.adjoint():this,[,e]=t.qr(),s=e.adjoint().solveLowerTriangular(t.adjoint());e.resize(t.rows,t.rows,1);const i=e.solveUpperTriangular(s);return i.resize(t.cols,t.rows),this.rows<this.cols?i.adjoint():i}pseudoInvSVD(){const[t,e,s]=this.svd();return s.dot(a.diag(e.map(i=>i===0?0:1/i))).dot(t.t)}pseudoInvBenIsraelCohen(){const t=this.adjoint(),e=1e-5,s=t.dot(this);for(let l=0;l<s.rows;l++)s.addAt(l,l,e);let i=s.inv().dot(t);const o=1e-15;let n=1e4;for(;n-- >0;){const l=a.mult(i,2);l.sub(i.dot(this).dot(i));let r=0;for(let h=0;h<i.length;h++)r+=(i.value[h]-l.value[h])**2;if(i=l,r<o)break}return i}sqrt(){if(!this.isSquare())throw new MatrixException("sqrt only define square matrix.",this);switch(this.rows){case 0:return this;case 1:return new a(1,1,[Math.sqrt(this._value[0])])}if(this.isDiag())return a.diag(this.diag().map(Math.sqrt));const[t,e]=this.eigen(),s=new a(this.rows,this.cols);for(let i=0;i<this.rows;i++)s._value[i*this.cols+i]=Math.sqrt(t[i]);return e.dot(s).dot(e.transpose())}power(t){if(!this.isSquare())throw new MatrixException("Only square matrix can power.",this);const e=this.rows;if(this.isDiag(1e-12))return a.diag(this.diag().map(s=>Math.pow(s,t)));if(Number.isInteger(t)){if(t===0)return a.eye(e,e);if(t===1)return this.copy();if(t===2)return this.dot(this);if(t===-1)return this.inv();if(t<0)return this.inv().power(-t);if(!this.isSymmetric(1e-12)){let n=this.dot(this);for(let l=2;l<t;l++)n=n.dot(this);return n}const[s,i]=this.eigen(),o=a.diag(s.map(n=>Math.pow(n,t)));return i.dot(o).dot(i.t)}else{if(t<0)return this.inv().power(-t);if(t===.5)return this.sqrt()}throw new MatrixException("Power only defined integer.")}exp(){if(!this.isSquare())throw new MatrixException("Only square matrix can exp.",this);if(this.rows===1)return new a(1,1,Math.exp(this._value[0]));if(this.isDiag())return a.diag(this.diag().map(Math.exp));const t=a.eye(this.rows,this.cols);let e=1,s=1,i=this;const o=10**(Math.floor(Math.log(Math.abs(this.trace())))-8);for(;;){const n=a.div(i,e);if(t.add(n),n.norm()<o)break;i=i.dot(this),s++,e*=s}return t}log(){if(!this.isSquare())throw new MatrixException("Only square matrix can log.",this);if(this.rows===1)return new a(1,1,Math.log(this._value[0]));if(this.isDiag())return a.diag(this.diag().map(Math.log));const[t,e]=this.eigen(),s=e.inv();return e.dot(a.diag(t.map(Math.log))).dot(s)}cov(t=0){const e=new a(this.cols,this.cols),s=[];for(let i=0;i<this.cols;i++){let o=0;for(let n=i;n<this.length;n+=this.cols)o+=this._value[n];s[i]=o/this.rows;for(let n=0;n<=i;n++){let l=0;for(let r=0;r<this.length;r+=this.cols)l+=(this._value[i+r]-s[i])*(this._value[n+r]-s[n]);e._value[i*this.cols+n]=e._value[n*this.cols+i]=l/(this.rows-t)}}return e}gram(){return this.tDot(this)}solve(t){if(this.rows>this.cols)throw new MatrixException("Only square matrix or matrix with more columns than rows can be solved.",this);const e=this.rows;if(e!==t.rows)throw new MatrixException("b size is invalid.",[this,t]);const s=e<this.cols?a.resize(this,e,e):this;let i;switch(e){case 0:i=s;break;case 1:i=a.map(t,o=>o/s._value[0]);break;default:{const[o,n]=s.lu(),l=o.solveLowerTriangular(t);i=n.solveUpperTriangular(l);break}}return e<this.cols&&i.resize(this.cols,i.cols),i}solveLowerTriangular(t){if(this.rows>this.cols)throw new MatrixException("Matrix that column rank is less than row rank can not solve.",this);if(this.rows!==t.rows)throw new MatrixException("b size is invalid.",[this,t]);const e=this.cols,s=t.cols,i=new a(e,s);for(let o=0;o<s;o++)for(let n=0;n<this.rows;n++){let l=t._value[n*s+o];for(let r=0;r<n;r++)l-=i._value[r*s+o]*this._value[n*e+r];i._value[n*s+o]=l/this._value[n*e+n]}return i}solveUpperTriangular(t){if(this.rows>this.cols)throw new MatrixException("Matrix that column rank is less than row rank can not solve.",this);if(this.rows!==t.rows)throw new MatrixException("b size is invalid.",[this,t]);const e=this.cols,s=t.cols,i=new a(e,s);for(let o=0;o<s;o++)for(let n=this.rows-1;n>=0;n--){let l=t._value[n*s+o];for(let r=e-1;r>n;r--)l-=i._value[r*s+o]*this._value[n*e+r];i._value[n*s+o]=l/this._value[n*e+n]}return i}bidiag(){return this.bidiagHouseholder()}bidiagHouseholder(t=!1){const e=this.copy(),[s,i]=[this.rows,this.cols];let o=t?a.eye(s,s):null,n=t?a.eye(i,i):null;for(let l=0;l<Math.min(s,i);l++){let r=e.block(l,l),h=r.col(0);if(h.norm()>0){const v=h.norm()*(h._value[0]<0?1:-1);h._value[0]-=v,h.div(h.norm())}let u=h.dot(h.t);u.mult(2);let c=a.eye(s-l,s-l);if(c.sub(u),r=c.tDot(r),t&&o.set(l,0,c.dot(o.slice(l,null,0))),h=r.row(0),h._value[0]=0,h.norm()>0){const v=h.norm()*(h._value[1]<0?1:-1);h._value[1]-=v,h.div(h.norm())}u=h.tDot(h),u.mult(2),c=a.eye(i-l,i-l),c.sub(u),r=r.dot(c),t&&n.set(0,l,n.slice(l,null,1).dot(c)),e.set(l,l,r)}return t?[e,o.t,n]:e}tridiag(){return this.tridiagHouseholder()}tridiagHouseholder(t=!1){if(!this.isSymmetric())throw new MatrixException("Tridiagonal only define symmetric matrix.",this);const e=this.copy(),s=this.cols;let i=t?a.eye(s,s):null;for(let o=0;o<s-2;o++){const n=e.block(o+1,o,s,o+1),l=n.norm()*(n._value[0]<0?1:-1);if(n._value[0]-=l,n.div(n.norm()),t){const c=n.dot(n.t);c.map((v,f)=>f[0]===f[1]?1-2*v:-2*v),i.set(0,o+1,i.slice(o+1,null,1).dot(c))}const r=e.block(o+1,o+1),h=r.dot(n),u=a.mult(n,n.tDot(h));u.isub(h),u.mult(2),r.sub(u.dot(n.t)),r.sub(n.dot(u.t)),e.set(o+1,o+1,r),e._value[o*s+o+1]=e._value[(o+1)*s+o]=l;for(let c=o+2;c<s;c++)e._value[o*s+c]=e._value[c*s+o]=0}return t?[e,i]:e}tridiagLanczos(t=0){if(!this.isSymmetric())throw new MatrixException("Tridiagonal only define symmetric matrix.",this);const e=this.cols;t<=0&&(t=e);let s=0,i=a.zeros(e,1),o=a.randn(e,1);o.div(o.norm());const n=a.zeros(t,t);for(let l=0;l<t;l++){const r=this.dot(o),h=o.tDot(r).toScaler();r.sub(a.mult(i,s)),r.sub(a.mult(o,h)),s=r.norm(),i=o,r.div(s),o=r,n.set(l,l,h),l<t-1&&(n.set(l,l+1,s),n.set(l+1,l,s))}return n}hessenberg(){return this.hessenbergArnoldi()}hessenbergArnoldi(t=0){if(!this.isSquare())throw new MatrixException("Hessenberg only define square matrix.",this);const e=this.cols;t<=0&&(t=e);const s=a.zeros(t,t),i=[a.random(e,1,-1,1)];i[0].div(i[0].norm());for(let o=0;o<t;o++){const n=this.dot(i[o]);for(let r=0;r<=o;r++){const h=i[r].tDot(n).toScaler();n.sub(a.mult(i[r],h)),s.set(r,o,h)}const l=n.norm();n.div(l),i[o+1]=n,o<t-1&&s.set(o+1,o,l)}return s}balancing(){if(!this.isSquare())throw new MatrixException("Doubly stochastic matrix only defined for square matrix.",this);if(this._value.some(t=>t<=0))throw new MatrixException("Doubly stochastic matrix only calculate for non negative matrix.",this);return this.rows===1?[[this._value[0]],new a(1,1,1),[1]]:this.balancingSinkhornKnopp()}balancingSinkhornKnopp(){if(!this.isSquare())throw new MatrixException("Doubly stochastic matrix only defined for square matrix.",this);if(this._value.some(n=>n<=0))throw new MatrixException("Doubly stochastic matrix only calculate for non negative matrix.",this);const t=this.rows,e=Array(t).fill(1),s=Array(t).fill(1),i=this.copy();let o=1e4;for(;o-- >0;){const n=i.sum(1);i.div(n);for(let h=0;h<t;h++)e[h]*=n.at(h,0);const l=i.sum(0);i.div(l);for(let h=0;h<t;h++)s[h]*=l.at(0,h);if(n.reduce((h,u)=>h+Math.abs(u-1),0)+l.reduce((h,u)=>h+Math.abs(u-1),0)<1e-8)break}return[e,i,s]}lu(){if(!this.isSquare())throw new MatrixException("LU decomposition only define square matrix.",this);const t=this.rows;switch(t){case 0:return[this,this];case 1:return[a.ones(1,1),new a(1,1,[this._value[0]])];case 2:return[new a(2,2,[1,0,this._value[2]/this._value[0],1]),new a(2,2,[this._value[0],this._value[1],0,this._value[3]-this._value[1]*this._value[2]/this._value[0]])]}let e=this.copy();for(let i=0;i<t;i++){const o=e._value[i*t+i];for(let n=i+1;n<t;n++){const l=e._value[n*t+i]/=o;for(let r=i+1;r<t;r++)e._value[n*t+r]-=l*e._value[i*t+r]}}let s=a.eye(t,t);for(let i=0;i<t;i++)for(let o=0;o<i;o++)s._value[i*t+o]=e._value[i*t+o],e._value[i*t+o]=0;return[s,e]}qr(){const t=this.rows,e=this.cols;if(t===0||e===0)return[this,this];if(t===1)return[a.ones(1,1),this];if(e===1){const s=Math.sqrt(this.tDot(this).toScaler());return[a.div(this,s),new a(1,1,s)]}return this.qrHouseholder()}qrGramSchmidt(){const t=this.cols,e=this.copy(),s=a.eye(t,t),i=[];for(let o=0;o<t;o++){for(let n=0;n<o;n++){let l=0;for(let h=0;h<this.rows;h++)l+=this._value[h*t+o]*e._value[h*t+n];const r=s._value[n*t+o]=i[n]===0?0:l/i[n]**2;for(let h=0;h<this.rows;h++)e._value[h*t+o]-=e._value[h*t+n]*r}i.push(e.col(o).norm())}return e.mult(new a(1,t,i.map(o=>o===0?0:1/o))),s.mult(new a(t,1,i)),[e,s]}qrHouseholder(){const t=this.rows,e=this.cols,s=this.copy(),i=a.eye(t,t);for(let o=0;o<Math.min(t,e);o++){const n=t-o,l=s.block(o,o,t,o+1),r=l.norm()*Math.sign(l._value[0]);l._value[0]-=r;const h=l.norm();l.div(h===0?1:h);const u=new a(n,n);for(let c=0;c<n;c++){const v=l._value[c];if(u._value[c*n+c]=1-2*v**2,!!v)for(let f=0;f<c;f++)u._value[c*n+f]=u._value[f*n+c]=-2*v*l._value[f]}s.set(o,o,u.dot(s.block(o,o))),i.set(o,0,u.dot(i.block(o,0)))}return[i.t,s]}singularValues(){const e=this.dot(this.adjoint()).eigenJacobi()[0];for(let s=0;s<e.length;s++)-1e-12<e[s]&&e[s]<0&&(e[s]=0),e[s]=Math.sqrt(e[s]);return e}svd(){return this.svdEigen()}svdEigen(){const t=Math.min(this.cols,this.rows);if(this.cols<=this.rows){const e=this.tDot(this),[s,i]=e.eigen();for(let n=0;n<t;n++)-1e-12<s[n]&&s[n]<=0?s[n]=0:s[n]=Math.sqrt(s[n]);const o=this.dot(i);for(let n=0;n<this.rows;n++)for(let l=0;l<t;l++)s[l]!==0&&(o._value[n*t+l]/=s[l]);return[o,s,i]}else{const e=this.dot(this.t),[s,i]=e.eigen();for(let n=0;n<t;n++)-1e-12<s[n]&&s[n]<=0?s[n]=0:s[n]=Math.sqrt(s[n]);const o=i.tDot(this);for(let n=0;n<t;n++)for(let l=0;l<this.cols;l++)s[n]!==0&&(o._value[n*this.cols+l]/=s[n]);return[i,s,o.t]}}svdGolubKahan(){const t=this.rows>=this.cols,e=Math.min(this.rows,this.cols),s=t?this:this.t,[i,,o]=s.bidiagHouseholder(!0);for(let f=0;f<e;f++)if(Math.sign(i.at(f,f))<0){i.multAt(f,f,-1),f>0&&i.multAt(f-1,f,-1);for(let d=0;d<o.rows;d++)o.multAt(d,f,-1)}const n=1e-12;let l=1e4,r=i.tDot(i),h=o;for(;l-- >0;){const[f]=r.qrGramSchmidt();r=f.tDot(r).dot(f),h=h.dot(f);let w=0;for(let d=0;d<r.rows;d++)for(let _=0;_<r.cols;_++)d!==_&&(w+=r.at(d,_)**2);if(Math.sqrt(w)<n)break}const[u,c]=s.dot(h).qr();for(let f=0;f<e;f++)if(c.at(f,f)<0)for(let w=0;w<h.rows;w++)h.multAt(w,f,-1);const v=r.diag().map(f=>Math.sqrt(f));return t?[u.slice(0,e,1),v,h.slice(0,e,1)]:[h.slice(0,e,1),v,u.slice(0,e,1)]}cholesky(){return this.choleskyBanachiewicz()}choleskyGaussian(){if(!this.isSymmetric(1e-15))throw new MatrixException("Cholesky decomposition only define symmetric matrix.",this);let t=this;const e=t.rows;let s=a.eye(e,e);for(let i=0;i<e;i++){const o=t.at(0,0),n=t.block(1,0,e-i,1),l=t.block(0,1,1,e-i);t=t.block(1,1);const r=n.dot(l);r.div(o),t.sub(r);const h=a.eye(e,e);h.set(i,i,Math.sqrt(o)),n.div(Math.sqrt(o)),h.set(i+1,i,n),s=s.dot(h)}return s}choleskyBanachiewicz(){if(!this.isSymmetric(1e-15))throw new MatrixException("Cholesky decomposition only define symmetric matrix.",this);const t=this.rows,e=new a(t,t);for(let s=0;s<t;s++){let i=0;for(let o=0;o<s;o++){let n=0;for(let l=0;l<o;l++)n+=e._value[s*t+l]*e._value[o*t+l];e._value[s*t+o]=(this._value[s*t+o]-n)/e._value[o*t+o],i+=e._value[s*t+o]**2}e._value[s*t+s]=Math.sqrt(this._value[s*t+s]-i)}return e}choleskyCrout(){if(!this.isSymmetric(1e-15))throw new MatrixException("Cholesky decomposition only define symmetric matrix.",this);const t=this.rows,e=new a(t,t);for(let s=0;s<t;s++){let i=0;for(let o=0;o<s;o++)i+=e._value[s*t+o]*e._value[s*t+o];e._value[s*t+s]=Math.sqrt(this._value[s*t+s]-i);for(let o=s+1;o<t;o++){let n=0;for(let l=0;l<s;l++)n+=e._value[o*t+l]*e._value[s*t+l];e._value[o*t+s]=(this._value[o*t+s]-n)/e._value[s*t+s]}}return e}modifiedCholesky(){if(!this.isSymmetric(1e-15))throw new MatrixException("Modified cholesky decomposition only define symmetric matrix.",this);const t=this.rows,e=[],s=a.eye(t,t);for(let i=0;i<t;i++){e[i]=this._value[i*t+i];for(let o=0;o<i;o++){let n=0;for(let l=0;l<o;l++)n+=s._value[i*t+l]*s._value[o*t+l]*e[l];s._value[i*t+o]=(this._value[i*t+o]-n)/e[o],e[i]-=s._value[i*t+o]**2*e[o]}}return[s,e]}schur(){if(!this.isSquare())throw new MatrixException("Schur decomposition only define square matrix.",this);return this.schurQR()}schurQR(t="single"){if(!this.isSquare())throw new MatrixException("Schur decomposition only define square matrix.",this);const e=this.rows;let s=this.copy();const i=[];for(let l=0;l<e-2;l++){const r=s.block(l+1,l),h=r.col(0),u=h.norm()*Math.sign(h._value[0]);h._value[0]-=u;const c=h.norm();h.div(c===0?1:c),r.sub(a.mult(2,h.dot(h.tDot(r)))),s.set(l+1,l,r);const v=s.slice(l+1,e,1);v.sub(a.mult(2,v.dot(h).dot(h.t))),s.set(0,l+1,v),i[l]=h}let o=a.eye(e,e);for(let l=e-3;l>=0;l--){const r=o.block(l+1,l+1);r.sub(a.mult(2,i[l].dot(i[l].tDot(r)))),o.set(l+1,l+1,r)}const n=1e-8;for(let l=e-1;l>0;l--){let r=1e4;for(;r-- >0;){const h=s.block(e-2,e-2).eigenValues();if(t==="no"){const[u,c]=s.qr();s=c.dot(u),o=o.dot(u)}else if(t==="single"){const u=s.at(e-1,e-1);let c=Math.abs(h[0]-u)<Math.abs(h[1]-u)?h[0]:h[1];isNaN(c)&&(c=s.at(l,l));for(let w=0;w<e;w++)s._value[w*e+w]-=c;const[v,f]=s.qr();s=f.dot(v);for(let w=0;w<e;w++)s._value[w*e+w]+=c;o=o.dot(v)}if(Math.abs(s.at(l,l-1))<n)break}}return[o,s]}rankFactorization(){const t=this.copy();t.reducedRowEchelonForm(1e-8);const e=[];let s=0;for(let i=0;i<this.cols;i++)t.at(s,i)>0&&(e.push(i),s++);return[this.col(e),t.slice(0,e.length,0)]}eigen(){if(!this.isSquare())throw new MatrixException("Eigen values only define square matrix.",this);if(this.rows>=2&&this.isZero()){const t=Array(this.rows).fill(0);t[0]=1;const e=a.eye(this.rows,this.rows);return e.set(0,0,0),[t,e]}if(this.rows<=2)return[this.eigenValues(),this.eigenVectors()];if(this.isSymmetric(1e-15))return this.eigenJacobi();{const t=this.eigenValues(),e=this.rows,s=new a(e,e);for(let i=0;i<e;i++){const[,o]=this.eigenInverseIteration(t[i]);for(let n=0;n<e;n++)s._value[n*e+i]=o._value[n]}return[t,s]}}eigenValues(){if(!this.isSquare())throw new MatrixException("Eigen values only define square matrix.",this);if(this.rows>=2&&this.isZero()){const t=Array(this.rows).fill(0);return t[0]=1,t}switch(this.rows){case 0:return[];case 1:return[this._value[0]];case 2:{const t=this._value[0]+this._value[3],e=Math.sqrt(t**2-4*this.det());return[(t+e)/2,(t-e)/2]}case 3:{const t=-this.det(),e=this._value[0]*this._value[4]+this._value[0]*this._value[8]+this._value[4]*this._value[8]-this._value[5]*this._value[7]-this._value[2]*this._value[6]-this._value[1]*this._value[3],s=-this._value[0]-this._value[4]-this._value[8],i=e-s**2/3,o=t-e*s/3+s**3*2/27,n=(o/2)**2+(i/3)**3;let[l,r]=new q(n).sqrt();l=l.add(-o/2),r=r.add(-o/2);const[h,u,c]=l.cbrt(),[v,f,w]=r.cbrt(),d=h.add(v),_=u.add(w),y=c.add(f),j=[d,_,y].map(g=>Math.abs(g.imaginary)<1e-12?g.real-s/3:Number.NaN);return j.sort((g,p)=>p-g),j}case 4:{const t=this.det(),e=-this._value[0]*this._value[5]*this._value[10]-this._value[0]*this._value[5]*this._value[15]-this._value[0]*this._value[10]*this._value[15]-this._value[5]*this._value[10]*this._value[15]+this._value[0]*this._value[11]*this._value[14]+this._value[0]*this._value[7]*this._value[13]+this._value[0]*this._value[6]*this._value[9]+this._value[5]*this._value[11]*this._value[14]+this._value[3]*this._value[5]*this._value[12]+this._value[2]*this._value[5]*this._value[8]+this._value[7]*this._value[10]*this._value[13]+this._value[3]*this._value[10]*this._value[12]+this._value[1]*this._value[4]*this._value[10]+this._value[6]*this._value[9]*this._value[15]+this._value[2]*this._value[8]*this._value[15]+this._value[1]*this._value[4]*this._value[15]-this._value[6]*this._value[11]*this._value[13]-this._value[7]*this._value[9]*this._value[14]-this._value[2]*this._value[11]*this._value[12]-this._value[3]*this._value[8]*this._value[14]-this._value[1]*this._value[7]*this._value[12]-this._value[3]*this._value[4]*this._value[13]-this._value[1]*this._value[6]*this._value[8]-this._value[2]*this._value[4]*this._value[9],s=this._value[0]*this._value[5]+this._value[0]*this._value[10]+this._value[0]*this._value[15]+this._value[5]*this._value[10]+this._value[5]*this._value[15]+this._value[10]*this._value[15]-this._value[7]*this._value[13]-this._value[6]*this._value[9]-this._value[11]*this._value[14]-this._value[1]*this._value[4]-this._value[2]*this._value[8]-this._value[3]*this._value[12],i=-this.trace(),o=Math.cbrt(2),n=-(i**3)+4*s*i-8*e,l=s**2-3*e*i+12*t,r=2*s**3-9*e*s*i+27*t*i**2+27*e**2-72*t*s,h=-4*l**3+r**2,c=new q(h).sqrt()[0].add(r).cbrt()[0],f=new q(i**2/4-2*s/3).add(new q(o*l/3).div(c)).add(c.div(3*o)).sqrt(),w=new q(i**2/2-4*s/3).sub(new q(o*l/3).div(c)).sub(c.div(3*o)),d=w.add(new q(n/4).div(f[1])),_=w.add(new q(n/4).div(f[0])),y=d.sqrt(),j=_.sqrt(),g=new q(-i/4).add(y[0].div(2)).add(f[1].div(2)),p=new q(-i/4).add(y[1].div(2)).add(f[1].div(2)),m=new q(-i/4).add(j[0].div(2)).add(f[0].div(2)),b=new q(-i/4).add(j[1].div(2)).add(f[0].div(2)),z=[g,p,m,b].map(S=>Math.abs(S.imaginary)<1e-12?S.real:Number.NaN);return z.sort((S,D)=>D-S),z}}return this.isSymmetric(1e-15)?this.eigenJacobi()[0]:this.eigenValuesQR()}eigenVectors(){if(!this.isSquare())throw new MatrixException("Eigen vectors only define square matrix.",this);if(this.rows>=2&&this.isZero()){const t=a.eye(this.rows,this.rows);return t.set(0,0,0),t}switch(this.rows){case 0:return this;case 1:return new a(1,1,[1]);case 2:{const t=this.eigenValues(),e=[-this._value[1],this._value[0]-t[0]],s=Math.sqrt(e[0]**2+e[1]**2),i=[-this._value[1],this._value[0]-t[1]],o=Math.sqrt(i[0]**2+i[1]**2);return new a(2,2,[e[0]/s,i[0]/o,e[1]/s,i[1]/o])}}return this.eigen()[1]}eigenValuesBiSection(){if(!this.isSymmetric(1e-15))throw new MatrixException("eigenValuesBiSection can only use symmetric matrix.",this);const t=this.tridiag(),e=this.rows;let s=0;for(let n=0;n<e;n++){const l=Math.abs(t.at(n,n))+Math.abs(n>0?t.at(n,n-1):0)+Math.abs(n<e-1?t.at(n,n+1):0);s<l&&(s=l)}const i=A(n=>{const l=[1,n-t.at(0,0)];for(let h=1;h<e;h++)l[h+1]=(n-t.at(h,h))*l[h]-t.at(h,h-1)**2*l[h-1];let r=0;for(let h=1;h<l.length;h++)Math.sign(l[h-1])!==Math.sign(l[h])&&r++;return r},"sturm"),o=[];for(let n=1;n<=e;n++){let l=-s,r=i(l),h=s;for(;Math.abs(l-h)>1e-8;){const u=(l+h)/2,c=i(u);n<=r&&n>c?h=u:(l=u,r=c)}o.push((l+h)/2)}return o}eigenValuesLR(){if(!this.isSquare())throw new MatrixException("Eigen values only define square matrix.",this);let t=this;const e=t.rows,s=1e-15;let i=1e5;for(;i-- >0;){const[o,n]=t.lu();t=n.dot(o);let l=0;for(let r=0;r<e;r++)for(let h=0;h<r;h++)l+=t._value[r*e+h]**2;if(l<s){const r=t.diag();return r.sort((h,u)=>u-h),r}}throw new MatrixException("eigenValuesLR not converged.",this)}eigenValuesQR(){if(!this.isSquare())throw new MatrixException("Eigen values only define square matrix.",this);let t=this.copy();const e=[],s=1e-8;for(let o=t.rows;o>2;o--){let n=1e6;for(;;){const l=t.block(o-2,o-2).eigenValues();if(isNaN(l[0])){e.sort((f,w)=>w-f);for(let f=0;f<o;f++,e.push(NaN));return e}const r=t._value[t._value.length-1],h=Math.abs(l[0]-r)<Math.abs(l[1]-r)?l[0]:l[1];for(let f=0;f<o;f++)t._value[f*o+f]-=h;const[u,c]=t.qr();t=c.dot(u);for(let f=0;f<o;f++)t._value[f*o+f]=t._value[f*o+f]+h;let v=0;for(let f=(o-1)*o;f<t.length-1;f++)v+=Math.abs(t._value[f]);if(v<s)break;if(n--<0)throw new MatrixException("eigenValuesQR not converged.",this)}e.push(t._value[t._value.length-1]),t.resize(o-1,o-1)}const i=t.eigenValues();return e.push(...i),e.sort((o,n)=>n-o),e}eigenJacobi(t=1e6){if(!this.isSymmetric(1e-15))throw new MatrixException("Jacobi method can only use symmetric matrix.",this);const e=this._value.concat(),s=a.eye(this.rows,this.cols);s.add(0);const i=1e-15;let o=0;const n=this.rows;let l=t;for(;;){let u=0,c=0,v=0;for(let m=0;m<n;m++)for(let b=m+1;b<n;b++){const z=Math.abs(e[m*n+b]);z>u&&(u=z,c=m,v=b)}if(u<i)break;if(u===o)break;if(l--<0){console.log(new MatrixException("eigenJacobi not converged.",[this,u]));break}o=u;const f=e[c*n+c],w=e[c*n+v],d=e[v*n+v],_=(f-d)/2,y=-w,j=Math.abs(_)/Math.sqrt(_**2+y**2);let g=Math.sqrt((1-j)/2);const p=Math.sqrt((1+j)/2);_*y<0&&(g=-g);for(let m=0;m<n;m++){const b=e[c*n+m],z=e[v*n+m];e[m*n+v]=e[v*n+m]=g*b+p*z,e[m*n+c]=e[c*n+m]=p*b-g*z}e[c*n+c]=p**2*f+g**2*d-2*g*p*w,e[c*n+v]=e[v*n+c]=g*p*(f-d)+(p**2-g**2)*w,e[v*n+v]=g**2*f+p**2*d+2*g*p*w;for(let m=0;m<n;m++){const b=s._value[m*n+c],z=s._value[m*n+v];s._value[m*n+v]=g*b+p*z,s._value[m*n+c]=p*b-g*z}}const r=[];for(let u=0;u<n;u++)r.push([u,e[u*n+u]]);r.sort((u,c)=>c[1]-u[1]);const h=s.col(r.map(u=>u[0]));return[r.map(u=>u[1]),h]}eigenPowerIteration(){if(!this.isSquare())throw new MatrixException("Eigen vectors only define square matrix.",this);const t=this.rows,e=1e-15;let s=a.randn(t,1);s.div(s.norm());let i=1/0,o=1e4;for(;o-- >0;){const n=this.dot(s);let l=0,r=0;for(let c=0;c<t;c++)l+=n._value[c]**2,r+=n._value[c]*s._value[c];const h=l/r;n.div(n.norm());const u=Math.abs(h-i);if(u<e||isNaN(u))return[h,n];s=n,i=h}throw new MatrixException("eigenPowerIteration not converged.",this)}eigenInverseIteration(t=0){if(!this.isSquare())throw new MatrixException("Eigen vectors only define square matrix.",this);const e=this.rows,s=1e-15;let i=this.copy();for(let r=0;r<e;r++)i._value[r*e+r]=i._value[r*e+r]-t+1e-15;i=i.inv();let o=a.randn(e,1);o.div(o.norm());let n=1/0,l=1e4;for(;l-- >0;){const r=i.dot(o);let h=0,u=0;for(let f=0;f<e;f++)h+=r._value[f]**2,u+=o._value[f]*r._value[f];const c=u/h;r.div(r.norm());const v=Math.abs(c-n);if(v<s||isNaN(v))return[c+t,r];o=r,n=c}throw new MatrixException("eigenInverseIteration not converged.",this)}}
