import Complex from"./complex.js";const normal_random=(t,s)=>{const e=Math.sqrt(s),i=Math.random(),r=Math.random();return[Math.sqrt(-2*Math.log(i))*Math.cos(2*Math.PI*r)*e+t,Math.sqrt(-2*Math.log(i))*Math.sin(2*Math.PI*r)*e+t]};export class MatrixException extends Error{constructor(t,s){super(t),this.value=s,this.name="MatrixException"}}export default class Matrix{constructor(t,s,e){e?Array.isArray(e)?Array.isArray(e[0])?this._value=e.flat():this._value=e:this._value=Array(t*s).fill(e):this._value=Array(t*s).fill(0),this._size=[t,s]}static zeros(t,s){return new Matrix(t,s,Array(t*s).fill(0))}static ones(t,s){return new Matrix(t,s,Array(t*s).fill(1))}static eye(t,s,e=1){const i=new Matrix(t,s),r=Math.min(t,s);for(let t=0;t<r;t++)i._value[t*s+t]=e;return i}static random(t,s,e=0,i=1){const r=new Matrix(t,s);for(let t=0;t<r.length;t++)r._value[t]=Math.random()*(i-e)+e;return r}static randint(t,s,e=0,i=1){const r=new Matrix(t,s);for(let t=0;t<r.length;t++)r._value[t]=Math.floor(Math.random()*(i-e+1)+e);return r}static randn(t,s,e=0,i=1){const r=new Matrix(t,s);if(Array.isArray(e)&&(e=new Matrix(1,e.length,e)),Array.isArray(i)&&(i=Matrix.fromArray(i)),!(e instanceof Matrix||i instanceof Matrix)){for(let t=0;t<r.length;t+=2){const s=normal_random(e,i);r._value[t]=s[0],t+1<r.length&&(r._value[t+1]=s[1])}return r}if(e instanceof Matrix?e.rows!==s&&1!==e.cols||(e=e.t):e=new Matrix(1,s,e),e.cols!==s||1!==e.rows)throw new MatrixException("'myu' cols must be same as 'cols' and rows must be 1.");if(i instanceof Matrix){if(i.rows!==s||i.cols!==s)throw new MatrixException("'sigma' cols and rows must be same as 'cols'.")}else i=Matrix.eye(s,s,i);const o=i.cholesky();for(let t=0;t<r.length;t+=2){const s=normal_random(0,1);r._value[t]=s[0],t+1<r.length&&(r._value[t+1]=s[1])}const a=r.dot(o.t);return a.add(e),a}static diag(t){let s=0,e=0;for(const i of t)"number"==typeof i?(s++,e++):(s+=i.rows,e+=i.cols);const i=new Matrix(s,e);for(let r=0,o=0,a=0;o<s;r++){const s=t[r];"number"==typeof s?(i._value[o*e+a]=s,o++,a++):(i.set(o,a,s),o+=s.rows,a+=s.cols)}return i}static fromArray(t){return t instanceof Matrix?t:Array.isArray(t)?0===t.length?new Matrix(0,0):Array.isArray(t[0])?new Matrix(t.length,t[0].length,t):new Matrix(t.length,1,t):new Matrix(1,1,t)}get dimension(){return this._size.length}get sizes(){return this._size}get length(){return this._size[0]*this._size[1]}get rows(){return this._size[0]}get cols(){return this._size[1]}get value(){return this._value}get t(){return this.transpose()}*[Symbol.iterator](){yield*this._value}toArray(){const t=[],s=this.cols;for(let e=0;e<this.length;e+=s)t.push(this._value.slice(e,e+s));return t}toScaler(){if(1!==this.rows||1!==this.cols)throw new MatrixException("The matrix cannot convert to scaler.");return this._value[0]}toString(){let t="[";for(let s=0;s<this.rows;s++){s>0&&(t+=",\n "),t+="[";for(let e=0;e<this.cols;e++)e>0&&(t+=", "),t+=this._value[s*this.cols+e];t+="]"}return t+"]"}copy(t){return t===this?this:t?(t._size=[].concat(this._size),this._value.forEach(((s,e)=>t._value[e]=s)),t):new Matrix(this.rows,this.cols,[].concat(this._value))}equals(t,s=0){if(t instanceof Matrix){if(this._size[0]!==t._size[0]||this._size[1]!==t._size[1])return!1;for(let e=this.length-1;e>=0;e--)if(Math.abs(this._value[e]-t._value[e])>s)return!1;return!0}return!1}at(t,s){if(Array.isArray(t)&&([t,s]=t),t<0||this.rows<=t||s<0||this.cols<=s)throw new MatrixException("Index out of bounds.");return this._value[t*this.cols+s]}set(t,s,e){if(Array.isArray(t)&&(e=s,[t,s]=t),e instanceof Matrix){if(t<0||this.rows<=t+e.rows-1||s<0||this.cols<=s+e.cols-1)throw new MatrixException("Index out of bounds.");for(let i=0;i<e.rows;i++)for(let r=0;r<e.cols;r++)this._value[(i+t)*this.cols+r+s]=e._value[i*e.cols+r];return null}{if(t<0||this.rows<=t||s<0||this.cols<=s)throw new MatrixException("Index out of bounds.");const i=this._value[t*this.cols+s];return this._value[t*this.cols+s]=e,i}}row(t){if(Array.isArray(t)){if("boolean"==typeof t[0]){if(t.length!==this.rows)throw new MatrixException("Length is invalid.");const s=[];for(let e=0;e<t.length;e++)t[e]&&s.push(e);t=s}if(t.some((t=>t<0||this.rows<=t)))throw new MatrixException("Index out of bounds.");const s=new Matrix(t.length,this.cols);for(let e=0;e<t.length;e++)for(let i=0;i<this.cols;i++)s._value[e*this.cols+i]=this._value[t[e]*this.cols+i];return s}if(t<0||this.rows<=t)throw new MatrixException("Index out of bounds.");return new Matrix(1,this.cols,this._value.slice(t*this.cols,(t+1)*this.cols))}col(t){if(Array.isArray(t)){if("boolean"==typeof t[0]){if(t.length!==this.cols)throw new MatrixException("Length is invalid.");const s=[];for(let e=0;e<t.length;e++)t[e]&&s.push(e);t=s}if(t.some((t=>t<0||this.cols<=t)))throw new MatrixException("Index out of bounds.");const s=new Matrix(this.rows,t.length);for(let e=0;e<this.rows;e++)for(let i=0;i<t.length;i++)s._value[e*t.length+i]=this._value[e*this.cols+t[i]];return s}{if(t<0||this.cols<=t)throw new MatrixException("Index out of bounds.");const s=new Matrix(this.rows,1);for(let e=0;e<this.rows;e++)s._value[e]=this._value[e*this.cols+t];return s}}slice(t,s,e=0){if("number"!=typeof t&&(t=0),"number"!=typeof s&&(s=this._size[e]),0===e){const e=new Matrix(s-t,this.cols);return e._value=this._value.slice(t*this.cols,s*this.cols),e}if(1===e){const e=new Matrix(this.rows,s-t);for(let s=0;s<e.rows;s++)for(let i=0;i<e.cols;i++)e._value[s*e.cols+i]=this._value[s*this.cols+i+t];return e}throw new MatrixException("Invalid axis.")}block(t,s,e,i){"number"!=typeof t&&(t=0),"number"!=typeof s&&(s=0);const r=new Matrix((e||this.rows)-t,(i||this.cols)-s);for(let e=0;e<r.rows;e++)for(let i=0;i<r.cols;i++)r._value[e*r.cols+i]=this._value[(e+t)*this.cols+i+s];return r}remove(t,s=0){if(0===s)if(Array.isArray(t)){if(t.some((t=>t<0||this.rows<=t)))throw new MatrixException("Index out of bounds.");(t=[...new Set(t)]).sort(((t,s)=>s-t));for(let s=0;s<t.length;s++)this._value.splice(t[s]*this.cols,this.cols);this._size[0]-=t.length}else{if(t<0||this.rows<=t)throw new MatrixException("Index out of bounds.");this._value.splice(t*this.cols,this.cols),this._size[0]--}else{if(1!==s)throw new MatrixException("Invalid axis.");if(Array.isArray(t)){if(t.some((t=>t<0||this.cols<=t)))throw new MatrixException("Index out of bounds.");(t=[...new Set(t)]).sort(((t,s)=>t-s));let s=0,e=0;for(let i=0;i<this.rows;i++)for(let i=0,r=0;i<this.cols;i++,s++)t[r]!==i?this._value[e++]=this._value[s]:r++;this._size[1]-=t.length,this._value.length=this.length}else{if(t<0||this.cols<=t)throw new MatrixException("Index out of bounds.");let s=0,e=0;for(let i=0;i<this.rows;i++)for(let i=0;i<this.cols;i++,s++)t!==i&&(this._value[e++]=this._value[s]);this._size[1]--,this._value.length=this.length}}}removeIf(t,s=0){const e=[];if(0===s)for(let s=0;s<this.rows;s++)t(this.row(s))&&e.push(s);else{if(1!==s)throw new MatrixException("Invalid axis.");for(let s=0;s<this.cols;s++)t(this.col(s))&&e.push(s)}this.remove(e,s)}sample(t,s=0){const e=this.sizes[s],i=[];for(let s=0;s<t;s++)i.push(Math.floor(Math.random()*(e-s)));for(let s=t-1;s>=0;s--)for(let e=t-1;e>s;e--)i[s]<=i[e]&&i[e]++;if(0===s)return[this.row(i),i];if(1===s)return[this.col(i),i];throw new MatrixException("Invalid axis.")}fill(t){this._value.fill(t)}map(t){for(let s=0,e=0;s<this._size[0];s++)for(let i=0;i<this._size[1];i++,e++)this._value[e]=t(this._value[e],[s,i],this)}static map(t,s){const e=new Matrix(t.rows,t.cols);for(let i=0,r=0;i<t._size[0];i++)for(let o=0;o<t._size[1];o++,r++)e._value[r]=s(t._value[r],[i,o],t);return e}forEach(t){for(let s=0,e=0;s<this._size[0];s++)for(let i=0;i<this._size[1];i++,e++)t(this._value[e],[s,i],this)}transpose(){const t=new Matrix(this.cols,this.rows);for(let s=0;s<this.rows;s++)for(let e=0;e<this.cols;e++)t._value[e*this.rows+s]=this._value[s*this.cols+e];return t}adjoint(){return this.transpose()}flip(t=0){if(0===t)for(let t=0;t<this.rows/2;t++){const s=(this.rows-t-1)*this.cols;for(let e=0;e<this.cols;e++){const i=this._value[t*this.cols+e];this._value[t*this.cols+e]=this._value[s+e],this._value[s+e]=i}}else{if(1!==t)throw new MatrixException("Invalid axis.");for(let t=0;t<this.cols/2;t++){const s=this.cols-t-1;for(let e=0;e<this.rows;e++){const i=this._value[e*this.cols+t];this._value[e*this.cols+t]=this._value[e*this.cols+s],this._value[e*this.cols+s]=i}}}}swap(t,s,e=0){if(0===e){if(t<0||s<0||this.rows<=t||this.rows<=s)throw new MatrixException("Index out of bounds.");const e=(s-t)*this.cols;for(let s=t*this.cols;s<(t+1)*this.cols;s++)[this._value[s],this._value[s+e]]=[this._value[s+e],this._value[s]]}else{if(1!==e)throw new MatrixException("Invalid axis.");{if(t<0||s<0||this.cols<=t||this.cols<=s)throw new MatrixException("Index out of bounds.");const e=s-t;for(let s=t;s<this.length;s+=this.cols)[this._value[s],this._value[s+e]]=[this._value[s+e],this._value[s]]}}}sort(t=0){if(0===t){const t=Array.from({length:this.rows},((t,s)=>s));return t.sort(((t,s)=>{const e=t*this.cols,i=s*this.cols;for(let t=0;t<this.cols;t++){const s=this._value[e+t]-this._value[i+t];if(0!==s)return s}return 0})),this._value=this.row(t)._value,t}if(1===t){const t=Array.from({length:this.cols},((t,s)=>s));return t.sort(((t,s)=>{for(let e=0;e<this.rows;e++){const i=this._value[t+e*this.cols]-this._value[s+e*this.cols];if(0!==i)return i}return 0})),this._value=this.col(t)._value,t}throw new MatrixException("Invalid axis.")}shuffle(t=0){const s=Array.from({length:this._size[t]},((t,s)=>s));for(let t=s.length-1;t>0;t--){const e=Math.floor(Math.random()*(t+1));[s[t],s[e]]=[s[e],s[t]]}if(0===t)this._value=this.row(s)._value;else{if(1!==t)throw new MatrixException("Invalid axis.");this._value=this.col(s)._value}return s}unique(t=0,s=0){const e=[];if(0===t){let t=0;for(let i=0;i<this.rows;i++){let r=-1;for(let t=0;t<i;t++){let e=!0;for(let r=0;e&&r<this.cols;r++)Math.abs(this._value[i*this.cols+r]-this._value[t*this.cols+r])>s&&(e=!1);if(e){r=t;break}}if(r<0){for(let s=0;s<this.cols;s++)this._value[t*this.cols+s]=this._value[i*this.cols+s];e.push(i),t++}}this._size[0]=t,this._value.length=this.length}else{if(1!==t)throw new MatrixException("Invalid axis.");for(let t=0;t<this.cols;t++){let i=!1;for(let r=0;!i&&r<e.length;r++){i=!0;for(let o=0;i&&o<this.rows;o++)Math.abs(this._value[o*this.cols+t]-this._value[o*this.cols+e[r]])>s&&(i=!1)}i||e.push(t)}for(let t=0,s=0;t<this.rows;t++)for(let i=0;i<e.length;i++,s++)this._value[s]=this._value[t*this.cols+e[i]];this._size[1]=e.length,this._value.length=this.length}return e}resize(t,s,e=0){const i=Array(t*s).fill(e),r=Math.min(this.rows,t),o=Math.min(this.cols,s);for(let t=0;t<r;t++)for(let e=0;e<o;e++)i[t*s+e]=this._value[t*this.cols+e];this._value=i,this._size=[t,s]}static resize(t,s,e,i=0){const r=new Matrix(s,e);r.fill(i);const o=Math.min(t.rows,s),a=Math.min(t.cols,e);for(let s=0;s<o;s++)for(let i=0;i<a;i++)r._value[s*e+i]=t._value[s*t.cols+i];return r}reshape(t,s){if(this.length!==t*s)throw new MatrixException("Length is different.");this._size=[t,s]}repeat(t,s=0){if(Array.isArray(t)){if(t.length<this._size.length)for(let s=t.length;s<this._size.length;s++)t[s]=1}else{const e=Array(this._size.length).fill(1);e[s]=t,t=e}const e=t.reduce(((t,s)=>t*s),1);if(1===e)return;const i=Array(this.length*e),r=this._size.map(((s,e)=>s*t[e]));for(let t=0;t<r[0];t++)for(let s=0;s<r[1];s++)i[t*r[1]+s]=this._value[t%this.rows*this.cols+s%this.cols];this._value=i,this._size=r}static repeat(t,s,e=0){const i=t.copy();return i.repeat(s,e),i}concat(t,s=0){if(0===s){if(this.cols!==t.cols)throw new MatrixException("Size is different.");this._value=[].concat(this._value,t._value),this._size[0]+=t.rows}else{if(1!==s)throw new MatrixException("Invalid axis.");{if(this.rows!==t.rows)throw new MatrixException("Size is different.");const s=this.cols;this.resize(this.rows,this.cols+t.cols);for(let e=0;e<this.rows;e++)for(let i=0;i<t.cols;i++)this._value[e*this.cols+i+s]=t._value[e*t.cols+i]}}}static concat(t,s,e=0){const i=t.copy();return i.concat(s,e),i}reduce(t,s,e=-1,i=null){if(e<0){let e=s??this._value[0];for(let i=0,r=0;i<this._size[0];i++)for(let o=0;o<this._size[1];o++,r++)0===r&&null==s||(e=t(e,this._value[r],[i,o],this));return!0===i?new Matrix(1,1,e):e}if(!1===i)throw new MatrixException("keepdims only accept true if axis >= 0.");let r=0===e?1:this.cols,o=0===e?this.cols:1;const a=[].concat(this._size);a[e]=1;const n=Matrix.zeros(...a);for(let i=0,a=0;i<n.length;i++,a+=r){let r=s??this._value[a];for(let n=r===s?0:1;n<this._size[e];n++)r=t(r,this._value[n*o+a],0===e?[n,i]:[i,n],this);n._value[i]=r}return n}every(t,s=-1){return this.reduce(((s,e,i,r)=>s&&t(e,i,r)),!0,s)}some(t,s=-1){return this.reduce(((s,e,i,r)=>s||t(e,i,r)),!1,s)}max(t=-1){return this.reduce(((t,s)=>Math.max(t,s)),-1/0,t)}min(t=-1){return this.reduce(((t,s)=>Math.min(t,s)),1/0,t)}median(t=-1){if(t<0){const t=this._value.concat();return t.sort(((t,s)=>t-s)),t.length%2==1?t[(t.length-1)/2]:(t[t.length/2]+t[t.length/2-1])/2}let s=0===t?1:this.cols,e=0===t?this.cols:1;const i=[].concat(this._size);i[t]=1;const r=Matrix.zeros(...i);for(let i=0,o=0;i<r.length;i++,o+=s){const s=[];for(let i=0;i<this._size[t];i++)s.push(this._value[i*e+o]);s.sort(((t,s)=>t-s)),s.length%2==1?r._value[i]=s[(s.length-1)/2]:r._value[i]=(s[s.length/2]+s[s.length/2-1])/2}return r}quantile(t,s=-1){if(0===t)return this.min(s);if(1===t)return this.max(s);const e=(t,s)=>{if(t.sort(((t,s)=>t-s)),1===t.length)return t[0];const e=s*(t.length-1),i=Math.floor(e);return e===i?t[i]:t[i]*(1-e+i)+t[i+1]*(e-i)};if(s<0){return e(this._value.concat(),t)}const i=0===s?1:this.cols,r=0===s?this.cols:1,o=Matrix.zeros(...this._size.map(((t,e)=>e===s?1:t)));for(let a=0,n=0;a<o.length;a++,n+=i){const i=[];for(let t=0;t<this._size[s];t++)i.push(this._value[t*r+n]);o._value[a]=e(i,t)}return o}argmax(t){let s=0===t?1:this.cols,e=0===t?this.cols:1;const i=[].concat(this._size);i[t]=1;const r=Matrix.zeros(...i);for(let i=0,o=0;i<r.length;i++,o+=s){let s=this._value[o],a=0;for(let i=1;i<this._size[t];i++){let t=this._value[i*e+o];t>s&&(s=t,a=i)}r._value[i]=a}return r}argmin(t){let s=0===t?1:this.cols,e=0===t?this.cols:1;const i=[].concat(this._size);i[t]=1;const r=Matrix.zeros(...i);for(let i=0,o=0;i<r.length;i++,o+=s){let s=this._value[o],a=0;for(let i=1;i<this._size[t];i++){let t=this._value[i*e+o];t<s&&(s=t,a=i)}r._value[i]=a}return r}sum(t=-1){return this.reduce(((t,s)=>t+s),0,t)}mean(t=-1){if(t<0)return this.sum(t)/this.length;let s=this.sum(t);return s.div(this._size[t]),s}prod(t=-1){return this.reduce(((t,s)=>t*s),1,t)}variance(t=-1,s=0){const e=this.mean(t);if(t<0)return this._value.reduce(((t,s)=>t+(s-e)**2),0)/(this.length-s);let i=0===t?1:this.cols,r=0===t?this.cols:1;const o=[].concat(this._size);o[t]=1;const a=Matrix.zeros(...o);for(let o=0,n=0;o<a.length;o++,n+=i){let i=0;for(let s=0;s<this._size[t];s++)i+=(this._value[s*r+n]-e._value[o])**2;a._value[o]=i/(this._size[t]-s)}return a}std(t=-1,s=0){if(t<0)return Math.sqrt(this.variance(t,s));let e=this.variance(t,s);for(let t=0;t<e.length;t++)e._value[t]=Math.sqrt(e._value[t]);return e}isSquare(){return this.rows===this.cols}isDiag(t=0){const s=this.cols;for(let e=0;e<this.rows;e++)for(let i=0;i<s;i++)if(e!==i&&Math.abs(this._value[e*s+i])>t)return!1;return!0}isIdentity(t=0){if(!this.isSquare())return!1;const s=this.cols;for(let e=0;e<this.rows;e++)for(let i=0;i<s;i++)if(e!==i){if(Math.abs(this._value[e*s+i])>t)return!1}else if(Math.abs(this._value[e*s+i]-1)>t)return!1;return!0}isZero(t=0){const s=this.cols;for(let e=0;e<this.rows;e++)for(let i=0;i<s;i++)if(Math.abs(this._value[e*s+i])>t)return!1;return!0}isTriangular(t=0){return this.isLowerTriangular(t)||this.isUpperTriangular(t)}isLowerTriangular(t=0){const s=this.cols;for(let e=0;e<this.rows;e++)for(let i=e+1;i<s;i++)if(Math.abs(this._value[e*s+i])>t)return!1;return!0}isUpperTriangular(t=0){for(let s=0;s<this.rows;s++)for(let e=0;e<Math.min(s,this.cols);e++)if(Math.abs(this._value[s*this.cols+e])>t)return!1;return!0}isSymmetric(t=0){if(!this.isSquare())return!1;const s=this.cols;for(let e=0;e<this.rows;e++)for(let i=0;i<e;i++)if(t>0){if(Math.abs(this._value[e*s+i]-this._value[i*s+e])>t)return!1}else if(this._value[e*s+i]!==this._value[i*s+e])return!1;return!0}isHermitian(t=0){return this.isSymmetric(t)}isAlternating(t=0){if(!this.isSquare())return!1;const s=this.cols;for(let e=0;e<this.rows;e++)for(let i=0;i<e;i++)if(t>0){if(Math.abs(this._value[e*s+i]+this._value[i*s+e])>t)return!1}else if(this._value[e*s+i]!==-this._value[i*s+e])return!1;return!0}isSkewHermitian(t=0){return this.isAlternating(t)}isRegular(t=0){return!!this.isSquare()&&Math.abs(this.det())<=t}isNormal(t=0){return this.dot(this.t).equals(this.tDot(this),t)}isOrthogonal(t=0){const s=this.tDot(this);for(let e=0;e<this.rows;e++)for(let i=0;i<this.cols;i++){const r=s._value[e*this.cols+i];if(e===i){if(Math.abs(r-1)>t)return!1}else if(Math.abs(r)>t)return!1}return!0}isUnitary(t=0){return this.isOrthogonal(t)}isNilpotent(t=0){if(!this.isSquare())return!1;const s=this.eigenValues();for(let e=0;e<s.length;e++)if(isNaN(s[e])||Math.abs(s[e])>t)return!1;return!0}diag(){let t=[];const s=Math.min(this.rows,this.cols);for(let e=0;e<s;e++)t.push(this._value[e*this.cols+e]);return t}trace(){let t=0;const s=Math.min(this.rows,this.cols);for(let e=0;e<s;e++)t+=this._value[e*this.cols+e];return t}norm(t=2){return this.normEntrywise(t)}normInduced(t=2){if(1===t){let t=-1/0;for(let s=0;s<this.cols;s++){let e=0;for(let t=0;t<this.rows;t++)e+=Math.abs(this._value[t*this.cols+s]);t=Math.max(t,e)}return t}if(t===1/0){let t=-1/0;for(let s=0;s<this.rows;s++){let e=0;for(let t=0;t<this.cols;t++)e+=Math.abs(this._value[s*this.cols+t]);t=Math.max(t,e)}return t}if(2===t)return this.normSpectral();throw new MatrixException("Not implemented")}normSpectral(){return this.singularValues()[0]}normEntrywise(t=2){if(t===1/0)return this.normMax();if(2===t)return this.normFrobenius();let s=0;for(let e=0;e<this.length;e++)s+=Math.abs(this._value[e])**t;return s**(1/t)}normFrobenius(){let t=0;for(let s=0;s<this.length;s++)t+=Math.abs(this._value[s])**2;return Math.sqrt(t)}normMax(){let t=-1/0;for(let s=0;s<this.length;s++)t=Math.max(t,Math.abs(this._value[s]));return t}normSchatten(t=2){if(t===1/0)return this.normSpectral();if(1===t)return this.normNuclear();const s=this.singularValues(),e=Math.min(this.rows,this.cols);let i=0;for(let r=0;r<e;r++)i+=s[r]**t;return i**(1/t)}normNuclear(){const t=this.singularValues(),s=Math.min(this.rows,this.cols);let e=0;for(let i=0;i<s;i++)e+=t[i];return e}rank(t=0){const s=this.copy();let e=0;for(let i=0;e<s.rows&&i<s.cols;i++,e++){if(Math.abs(s._value[e*s.cols+i])<=t)for(let r=e+1;r<s.rows;r++)if(Math.abs(s._value[r*s.cols+i])>t){s.swap(e,r,0);break}if(Math.abs(s._value[e*s.cols+i])<=t){e--;continue}const r=s._value[e*s.cols+i];for(let t=e+1;t<s.rows;t++){const o=s._value[t*s.cols+i];for(let a=i+1;a<s.cols;a++)s._value[t*s.cols+a]-=o*s._value[e*s.cols+a]/r}}return e}det(){if(!this.isSquare())throw new MatrixException("Determine only define square matrix.",this);const t=this._value;switch(this.rows){case 0:return 0;case 1:return t[0];case 2:return t[0]*t[3]-t[1]*t[2];case 3:return t[0]*t[4]*t[8]+t[1]*t[5]*t[6]+t[2]*t[3]*t[7]-t[0]*t[5]*t[7]-t[1]*t[3]*t[8]-t[2]*t[4]*t[6]}const[s,e]=this.lu();let i=1;for(let t=0;t<this.rows;t++){const r=t*this.cols+t;i*=s._value[r]*e._value[r]}return i}negative(){this.map((t=>-t))}not(){this.map((t=>+!t))}bitnot(){this.map((t=>~t))}abs(){this.map(Math.abs)}round(){this.map(Math.round)}floor(){this.map(Math.floor)}ceil(){this.map(Math.ceil)}leftShift(t){this.map((s=>s<<t))}signedRightShift(t){this.map((s=>s>>t))}unsignedRightShift(t){this.map((s=>s>>>t))}broadcastOperate(t,s){if(t instanceof Matrix)if(this.rows===t.rows&&this.cols===t.cols)for(let e=this.length-1;e>=0;e--)this._value[e]=s(this._value[e],t._value[e]);else if(this.rows>=t.rows&&this.cols>=t.cols){if(this.rows%t.rows!=0||this.cols%t.cols!=0)throw new MatrixException("Broadcasting size invalid.",[this,t]);for(let e=0,i=0,r=0;e<this.length;e++,r++)r>=this.cols&&(i+=t.cols,r=0),i>=t.length&&(i=0),this._value[e]=s(this._value[e],t._value[i+r%t.cols])}else{if(!(this.rows<=t.rows&&this.cols<=t.cols))throw new MatrixException("Broadcasting size invalid.",[this,t]);if(t.rows%this.rows!=0||t.cols%this.cols!=0)throw new MatrixException("Broadcasting size invalid.",[this,t]);this.repeat([t.rows/this.rows,t.cols/this.cols]);for(let e=this.length-1;e>=0;e--)this._value[e]=s(this._value[e],t._value[e])}else this.map((e=>s(e,t)))}operateAt(t,s,e){if(Array.isArray(t)&&(e=s,[t,s]=t),t<0||this.rows<=t||s<0||this.cols<=s)throw new MatrixException("Index out of bounds.");const i=this._value[t*this.cols+s];return this._value[t*this.cols+s]=e(i),i}add(t){this.broadcastOperate(t,((t,s)=>t+s))}addAt(t,s,e){return this.operateAt(t,s,(t=>t+e))}static add(t,s){if(t instanceof Matrix){const e=t.copy();return e.add(s),e}if(s instanceof Matrix){const e=s.copy();return e.add(t),e}return new Matrix(1,1,t+s)}sub(t){this.broadcastOperate(t,((t,s)=>t-s))}isub(t){this.negative(),this.add(t)}subAt(t,s,e){return this.operateAt(t,s,(t=>t-e))}isubAt(t,s,e){return this.operateAt(t,s,(t=>e-t))}static sub(t,s){if(t instanceof Matrix){const e=t.copy();return e.sub(s),e}if(s instanceof Matrix){const e=s.copy();return e.isub(t),e}return new Matrix(1,1,t-s)}mult(t){this.broadcastOperate(t,((t,s)=>t*s))}multAt(t,s,e){return this.operateAt(t,s,(t=>t*e))}static mult(t,s){if(t instanceof Matrix){const e=t.copy();return e.mult(s),e}if(s instanceof Matrix){const e=s.copy();return e.mult(t),e}return new Matrix(1,1,t*s)}div(t){this.broadcastOperate(t,((t,s)=>t/s))}idiv(t){this.broadcastOperate(t,((t,s)=>s/t))}divAt(t,s,e){return this.operateAt(t,s,(t=>t/e))}idivAt(t,s,e){return this.operateAt(t,s,(t=>e/t))}static div(t,s){if(t instanceof Matrix){const e=t.copy();return e.div(s),e}if(s instanceof Matrix){const e=s.copy();return e.idiv(t),e}return new Matrix(1,1,t/s)}mod(t){this.broadcastOperate(t,((t,s)=>t%s))}imod(t){this.broadcastOperate(t,((t,s)=>s%t))}modAt(t,s,e){return this.operateAt(t,s,(t=>t%e))}imodAt(t,s,e){return this.operateAt(t,s,(t=>e%t))}static mod(t,s){if(t instanceof Matrix){const e=t.copy();return e.mod(s),e}if(s instanceof Matrix){const e=s.copy();return e.imod(t),e}return new Matrix(1,1,t%s)}and(t){this.broadcastOperate(t,((t,s)=>+(!!t&&!!s)))}andAt(t,s,e){return this.operateAt(t,s,(t=>+(!!t&&!!e)))}static and(t,s){if(t instanceof Matrix){const e=t.copy();return e.and(s),e}if(s instanceof Matrix){const e=s.copy();return e.and(t),e}return new Matrix(1,1,+(!!t&&!!s))}or(t){this.broadcastOperate(t,((t,s)=>+(!!t||!!s)))}orAt(t,s,e){return this.operateAt(t,s,(t=>+(!!t||!!e)))}static or(t,s){if(t instanceof Matrix){const e=t.copy();return e.or(s),e}if(s instanceof Matrix){const e=s.copy();return e.or(t),e}return new Matrix(1,1,+(!!t||!!s))}bitand(t){this.broadcastOperate(t,((t,s)=>+(t&s)))}bitandAt(t,s,e){return this.operateAt(t,s,(t=>+(t&e)))}static bitand(t,s){if(t instanceof Matrix){const e=t.copy();return e.bitand(s),e}if(s instanceof Matrix){const e=s.copy();return e.bitand(t),e}return new Matrix(1,1,+(t&s))}bitor(t){this.broadcastOperate(t,((t,s)=>+(t|s)))}bitorAt(t,s,e){return this.operateAt(t,s,(t=>+(t|e)))}static bitor(t,s){if(t instanceof Matrix){const e=t.copy();return e.bitor(s),e}if(s instanceof Matrix){const e=s.copy();return e.bitor(t),e}return new Matrix(1,1,+(t|s))}bitxor(t){this.broadcastOperate(t,((t,s)=>+(t^s)))}bitxorAt(t,s,e){return this.operateAt(t,s,(t=>+(t^e)))}static bitxor(t,s){if(t instanceof Matrix){const e=t.copy();return e.bitxor(s),e}if(s instanceof Matrix){const e=s.copy();return e.bitxor(t),e}return new Matrix(1,1,+(t^s))}dot(t){if(this.cols!==t.rows)throw new MatrixException(`Dot size invalid. left = [${this.rows}, ${this.cols}], right = [${t.rows}, ${t.cols}]`);const s=t.cols,e=new Matrix(this.rows,s);let i=0;const r=this.length,o=t.length,a=this.cols,n=this._value,l=t._value,h=e._value;for(let t=0;t<r;t+=a){let e=0,r=0;for(let i=0,a=t;i<o;i+=s,a++)n[a]&&r++,e+=n[a]*l[i];if(h[i++]=e,0!==r)if(r/a<.1){let r=[],o=[];for(let s=0;s<a;s++)n[t+s]&&(r.push(n[t+s]),o.push(s));for(let t=1;t<s;t++){e=0;for(let i=0;i<r.length;i++)e+=r[i]*l[o[i]*s+t];h[i++]=e}}else for(let r=1;r<s;r++){e=0;for(let i=r,a=t;i<o;i+=s,a++)e+=n[a]*l[i];h[i++]=e}else i+=s-1}return e}tDot(t){if(this.rows!==t.rows)throw new MatrixException(`tDot size invalid. left = [${this.cols}, ${this.rows}], right = [${t.rows}, ${t.cols}]`);const s=new Matrix(this.cols,t.cols);let e=0;for(let i=0;i<this.cols;i++)for(let r=0;r<t.cols;r++){let o=0,a=i;for(let s=r;s<t.length;s+=t.cols,a+=this.cols)o+=this._value[a]*t._value[s];s._value[e++]=o}return s}kron(t){const s=new Matrix(this.rows*t.rows,this.cols*t.cols);for(let e=0;e<this.rows;e++)for(let i=0;i<this.cols;i++)for(let r=0;r<t.rows;r++)for(let o=0;o<t.cols;o++)s._value[(e*t.rows+r)*this.cols*t.cols+i*t.cols+o]=this._value[e*this.cols+i]*t._value[r*t.cols+o];return s}convolute(t,s=!0){const e=[Math.floor((t.length-1)/2),Math.floor((t[0].length-1)/2)],i=this._value.concat();for(let r=0;r<this.rows;r++)for(let o=0;o<this.cols;o++){let a=0,n=0;for(let s=0;s<t.length;s++){const l=r+s-e[0];if(!(l<0||this.rows<=l))for(let r=0;r<t[s].length;r++){const h=o+r-e[1];h<0||this.cols<=h||(a+=t[s][r]*i[l*this.cols+h],n+=t[s][r])}}s&&(a/=n),this._value[r*this.cols+o]=a}}reducedRowEchelonForm(t=0){for(let s=0,e=0;s<this.rows&&e<this.cols;e++,s++){if(Math.abs(this._value[s*this.cols+e])<=t)for(let i=s+1;i<this.rows;i++)if(Math.abs(this._value[i*this.cols+e])>t){this.swap(s,i,0);break}if(Math.abs(this._value[s*this.cols+e])<=t){s--;continue}const i=this._value[s*this.cols+e];this._value[s*this.cols+e]=1;for(let t=e+1;t<this.cols;t++)this._value[s*this.cols+t]/=i;for(let t=0;t<this.rows;t++){if(t===s)continue;const i=this._value[t*this.cols+e];this._value[t*this.cols+e]=0;for(let r=e+1;r<this.cols;r++)this._value[t*this.cols+r]-=i*this._value[s*this.cols+r]}}}inv(){if(!this.isSquare())throw new MatrixException("Inverse matrix only define square matrix.",this);const t=this._value;switch(this.rows){case 0:return new Matrix(0,0);case 1:return new Matrix(1,1,[1/t[0]]);case 2:{const s=this.det();return new Matrix(2,2,[t[3]/s,-t[1]/s,-t[2]/s,t[0]/s])}case 3:{const s=this.det();return new Matrix(3,3,[(t[4]*t[8]-t[5]*t[7])/s,(t[2]*t[7]-t[1]*t[8])/s,(t[1]*t[5]-t[2]*t[4])/s,(t[5]*t[6]-t[3]*t[8])/s,(t[0]*t[8]-t[2]*t[6])/s,(t[2]*t[3]-t[0]*t[5])/s,(t[3]*t[7]-t[4]*t[6])/s,(t[1]*t[6]-t[0]*t[7])/s,(t[0]*t[4]-t[1]*t[3])/s])}}return this.isLowerTriangular()?this.invLowerTriangular():this.isUpperTriangular()?this.invUpperTriangular():this.invLU()}invLowerTriangular(){if(!this.isSquare())throw new MatrixException("Inverse matrix only define square matrix.",this);const t=this._value,s=new Matrix(this.rows,this.cols);for(let e=0;e<this.rows;e++){const i=t[e*this.cols+e];s._value[e*this.cols+e]=1/i;for(let r=0;r<e;r++){let o=0;for(let i=r;i<e;i++)o+=t[e*this.cols+i]*s._value[i*this.cols+r];s._value[e*this.cols+r]=-o/i}}return s}invUpperTriangular(){if(!this.isSquare())throw new MatrixException("Inverse matrix only define square matrix.",this);const t=this._value,s=new Matrix(this.rows,this.cols);for(let e=this.cols-1;e>=0;e--){const i=t[e*this.cols+e];s._value[e*this.cols+e]=1/i;for(let r=e+1;r<this.cols;r++){let o=0;for(let i=e+1;i<=r;i++)o+=t[e*this.cols+i]*s._value[i*this.cols+r];s._value[e*this.cols+r]=-o/i}}return s}invRowReduction(){if(!this.isSquare())throw new MatrixException("Inverse matrix only define square matrix.",this);const t=this.copy(),s=this.rows,e=Matrix.eye(s,s);for(let i=0;i<s;i++){const r=i*s;if(0===t._value[r+i]){let o=i+1;for(;o<s&&0===t._value[o*s+i];o++);if(o===s)throw new MatrixException("",this);for(let e=i;e<s;e++)[t._value[r+e],t._value[o*s+e]]=[t._value[o*s+e],t._value[r+e]];e.swap(i,o)}const o=t._value[r+i];t._value[r+i]=1;for(let e=i+1;e<s;e++)t._value[r+e]/=o;for(let t=0;t<s;t++)e._value[r+t]=e._value[r+t]/o;for(let o=0;o<s;o++){if(i===o)continue;const a=t._value[o*s+i];t._value[o*s+i]=0;for(let e=i+1;e<s;e++)t._value[o*s+e]-=a*t._value[r+e];for(let t=0;t<s;t++)e._value[o*s+t]=e._value[o*s+t]-a*e._value[r+t]}}return e}invLU(){if(!this.isSquare())throw new MatrixException("Inverse matrix only define square matrix.",this);const[t,s]=this.lu();return s.invUpperTriangular().dot(t.invLowerTriangular())}sqrt(){if(!this.isSquare())throw new MatrixException("sqrt only define square matrix.",this);switch(this.rows){case 0:return this;case 1:return new Matrix(1,1,[Math.sqrt(this._value[0])])}if(this.isDiag())return Matrix.diag(this.diag().map(Math.sqrt));const[t,s]=this.eigen(),e=new Matrix(this.rows,this.cols);for(let s=0;s<this.rows;s++)e._value[s*this.cols+s]=Math.sqrt(t[s]);return s.dot(e).dot(s.transpose())}power(t){if(!this.isSquare())throw new MatrixException("Only square matrix can power.",this);const s=this.rows;if(this.isDiag(1e-12))return Matrix.diag(this.diag().map((s=>Math.pow(s,t))));if(Number.isInteger(t)){if(0===t)return Matrix.eye(s,s);if(1===t)return this.copy();if(2===t)return this.dot(this);if(-1===t)return this.inv();if(t<0)return this.inv().power(-t);if(!this.isSymmetric(1e-12)){let s=this.dot(this);for(let e=2;e<t;e++)s=s.dot(this);return s}const[e,i]=this.eigen(),r=Matrix.diag(e.map((s=>Math.pow(s,t))));return i.dot(r).dot(i.t)}if(t<0)return this.inv().power(-t);if(.5===t)return this.sqrt();throw new MatrixException("Power only defined integer.")}exp(){if(!this.isSquare())throw new MatrixException("Only square matrix can exp.",this);if(1===this.rows)return new Matrix(1,1,Math.exp(this._value[0]));if(this.isDiag())return Matrix.diag(this.diag().map(Math.exp));const t=Matrix.eye(this.rows,this.cols);let s=1,e=1,i=this;const r=10**(Math.floor(Math.log(Math.abs(this.trace())))-8);for(;;){const o=Matrix.div(i,s);if(t.add(o),o.norm()<r)break;i=i.dot(this),e++,s*=e}return t}log(){if(!this.isSquare())throw new MatrixException("Only square matrix can log.",this);if(1===this.rows)return new Matrix(1,1,Math.log(this._value[0]));if(this.isDiag())return Matrix.diag(this.diag().map(Math.log));const[t,s]=this.eigen(),e=s.inv();return s.dot(Matrix.diag(t.map(Math.log))).dot(e)}cov(t=0){const s=new Matrix(this.cols,this.cols),e=[];for(let i=0;i<this.cols;i++){let r=0;for(let t=i;t<this.length;t+=this.cols)r+=this._value[t];e[i]=r/this.rows;for(let r=0;r<=i;r++){let o=0;for(let t=0;t<this.length;t+=this.cols)o+=(this._value[i+t]-e[i])*(this._value[r+t]-e[r]);s._value[i*this.cols+r]=s._value[r*this.cols+i]=o/(this.rows-t)}}return s}gram(){return this.tDot(this)}solve(t){if(this.rows>this.cols)throw new MatrixException("Only square matrix or matrix with more columns than rows can be solved.",this);const s=this.rows;if(s!==t.rows)throw new MatrixException("b size is invalid.",[this,t]);const e=s<this.cols?Matrix.resize(this,s,s):this;let i;switch(s){case 0:i=e;break;case 1:i=Matrix.map(t,(t=>t/e._value[0]));break;default:{const[s,r]=e.lu(),o=s.solveLowerTriangular(t);i=r.solveUpperTriangular(o);break}}return s<this.cols&&i.resize(this.cols,i.cols),i}solveLowerTriangular(t){if(!this.isSquare())throw new MatrixException("Only square matrix can solve.",this);const s=this.rows,e=t.cols;if(s!==t.rows)throw new MatrixException("b size is invalid.",[this,t]);const i=new Matrix(s,e);for(let r=0;r<e;r++)for(let o=0;o<s;o++){let a=t._value[o*e+r];for(let t=0;t<o;t++)a-=i._value[t*e+r]*this._value[o*s+t];i._value[o*e+r]=a/this._value[o*s+o]}return i}solveUpperTriangular(t){if(!this.isSquare())throw new MatrixException("Only square matrix can solve.",this);const s=this.rows,e=t.cols;if(s!==t.rows)throw new MatrixException("b size is invalid.",[this,t]);const i=new Matrix(s,e);for(let r=0;r<e;r++)for(let o=s-1;o>=0;o--){let a=t._value[o*e+r];for(let t=s-1;t>o;t--)a-=i._value[t*e+r]*this._value[o*s+t];i._value[o*e+r]=a/this._value[o*s+o]}return i}bidiag(){const t=this.copy(),[s,e]=[this.rows,this.cols];for(let i=0;i<Math.min(s,e);i++){let r=t.block(i,i),o=r.col(0),a=o.norm()*(o._value[0]<0?1:-1);o._value[0]-=a,o.div(o.norm());let n=o.dot(o.t);n.mult(2);let l=Matrix.eye(s-i,s-i);l.sub(n),r=l.tDot(r),o=r.row(0),o._value[0]=0,o.norm()>0&&(a=o.norm()*(o._value[1]<0?1:-1),o._value[1]-=a,o.div(o.norm())),n=o.tDot(o),n.mult(2),l=Matrix.eye(e-i,e-i),l.sub(n),r=r.dot(l),t.set(i,i,r)}return t}tridiag(){return this.tridiagHouseholder()}tridiagHouseholder(){if(!this.isSymmetric())throw new MatrixException("Tridiagonal only define symmetric matrix.",this);const t=this.copy(),s=this.cols;for(let e=0;e<s-2;e++){const i=t.block(e+1,e,s,e+1),r=i.norm()*(i._value[0]<0?1:-1);i._value[0]-=r,i.div(i.norm());const o=t.block(e+1,e+1),a=o.dot(i),n=Matrix.mult(i,i.tDot(a));n.isub(a),n.mult(2),o.sub(n.dot(i.t)),o.sub(i.dot(n.t)),t.set(e+1,e+1,o),t._value[e*s+e+1]=t._value[(e+1)*s+e]=r;for(let i=e+2;i<s;i++)t._value[e*s+i]=t._value[i*s+e]=0}return t}tridiagLanczos(t=0){if(!this.isSymmetric())throw new MatrixException("Tridiagonal only define symmetric matrix.",this);const s=this.cols;t<=0&&(t=s);let e=0,i=Matrix.zeros(s,1),r=Matrix.randn(s,1);r.div(r.norm());const o=Matrix.zeros(t,t);for(let s=0;s<t;s++){const a=this.dot(r),n=r.tDot(a).toScaler();a.sub(Matrix.mult(i,e)),a.sub(Matrix.mult(r,n)),e=a.norm(),i=r,a.div(e),r=a,o.set(s,s,n),s<t-1&&(o.set(s,s+1,e),o.set(s+1,s,e))}return o}hessenberg(){return this.hessenbergArnoldi()}hessenbergArnoldi(t=0){if(!this.isSquare())throw new MatrixException("Hessenberg only define square matrix.",this);const s=this.cols;t<=0&&(t=s);const e=Matrix.zeros(t,t),i=[Matrix.random(s,1,-1,1)];i[0].div(i[0].norm());for(let s=0;s<t;s++){const r=this.dot(i[s]);for(let t=0;t<=s;t++){const o=i[t].tDot(r).toScaler();r.sub(Matrix.mult(i[t],o)),e.set(t,s,o)}const o=r.norm();r.div(o),i[s+1]=r,s<t-1&&e.set(s+1,s,o)}return e}lu(){if(!this.isSquare())throw new MatrixException("LU decomposition only define square matrix.",this);const t=this.rows;switch(t){case 0:return[this,this];case 1:return[Matrix.ones(1,1),new Matrix(1,1,[this._value[0]])];case 2:return[new Matrix(2,2,[1,0,this._value[2]/this._value[0],1]),new Matrix(2,2,[this._value[0],this._value[1],0,this._value[3]-this._value[1]*this._value[2]/this._value[0]])]}let s=this.copy();for(let e=0;e<t;e++){const i=s._value[e*t+e];for(let r=e+1;r<t;r++){const o=s._value[r*t+e]/=i;for(let i=e+1;i<t;i++)s._value[r*t+i]-=o*s._value[e*t+i]}}let e=Matrix.eye(t,t);for(let i=0;i<t;i++)for(let r=0;r<i;r++)e._value[i*t+r]=s._value[i*t+r],s._value[i*t+r]=0;return[e,s]}qr(){const t=this.rows,s=this.cols;if(0===t||0===s)return[this,this];if(1===t)return[Matrix.ones(1,1),this];if(1===s){const t=Math.sqrt(this.tDot(this).toScaler());return[Matrix.div(this,t),new Matrix(1,1,t)]}return this.qrHouseholder()}qrGramSchmidt(){const t=this.cols,s=this.copy(),e=Matrix.eye(t,t),i=[];for(let r=0;r<t;r++){for(let o=0;o<r;o++){let a=0;for(let e=0;e<this.rows;e++)a+=this._value[e*t+r]*s._value[e*t+o];const n=e._value[o*t+r]=a/i[o]**2;for(let e=0;e<this.rows;e++)s._value[e*t+r]-=s._value[e*t+o]*n}i.push(s.col(r).norm())}return s.mult(new Matrix(1,t,i.map((t=>1/t)))),e.mult(new Matrix(t,1,i)),[s,e]}qrHouseholder(){const t=this.rows,s=this.cols,e=this.copy(),i=Matrix.eye(t,t);for(let r=0;r<Math.min(t,s)-1;r++){const s=t-r,o=e.block(r,r,t,r+1),a=o.norm()*Math.sign(o._value[0]);o._value[0]-=a,o.div(o.norm()+1e-12);const n=new Matrix(s,s);for(let t=0;t<s;t++){const e=o._value[t];if(n._value[t*s+t]=1-2*e**2,e)for(let i=0;i<t;i++)n._value[t*s+i]=n._value[i*s+t]=-2*e*o._value[i]}e.set(r,r,n.dot(e.block(r,r))),i.set(r,0,n.dot(i.block(r,0)))}return[i.t,e]}singularValues(){const t=this.dot(this.adjoint()).eigenJacobi()[0];for(let s=0;s<t.length;s++)-1e-12<t[s]&&t[s]<0&&(t[s]=0),t[s]=Math.sqrt(t[s]);return t}svd(){return this.svdEigen()}svdEigen(){const t=Math.min(this.cols,this.rows);if(this.cols<=this.rows){const s=this.tDot(this),[e,i]=s.eigen();for(let s=0;s<t;s++)e[s]=Math.sqrt(e[s]);const r=this.dot(i);for(let s=0;s<this.rows;s++)for(let i=0;i<t;i++)r._value[s*t+i]/=e[i];return[r,e,i]}{const s=this.dot(this.t),[e,i]=s.eigen();for(let s=0;s<t;s++)e[s]=Math.sqrt(e[s]);const r=i.tDot(this);for(let s=0;s<t;s++)for(let t=0;t<this.cols;t++)r._value[s*this.cols+t]/=e[s];return[i,e,r.t]}}svdGolubKahan(){}cholesky(){return this.choleskyBanachiewicz()}choleskyBanachiewicz(){if(!this.isSymmetric(1e-15))throw new MatrixException("Cholesky decomposition only define symmetric matrix.",this);const t=this.rows,s=new Matrix(t,t);for(let e=0;e<t;e++){let i=0;for(let r=0;r<e;r++){let o=0;for(let i=0;i<r;i++)o+=s._value[e*t+i]*s._value[r*t+i];s._value[e*t+r]=(this._value[e*t+r]-o)/s._value[r*t+r],i+=s._value[e*t+r]**2}s._value[e*t+e]=Math.sqrt(this._value[e*t+e]-i)}return s}choleskyLDL(){if(!this.isSymmetric(1e-15))throw new MatrixException("Cholesky decomposition only define symmetric matrix.",this);const t=this.rows,s=[],e=Matrix.eye(t,t);for(let i=0;i<t;i++){s[i]=this._value[i*t+i];for(let r=0;r<i;r++){let o=0;for(let a=0;a<r;a++)o+=e._value[i*t+a]*e._value[r*t+a]*s[a];e._value[i*t+r]=(this._value[i*t+r]-o)/s[r],s[i]-=e._value[i*t+r]**2*s[r]}}return[e,s]}schur(){throw new MatrixException("Not implemented.")}eigen(){if(!this.isSquare())throw new MatrixException("Eigen values only define square matrix.",this);if(this.rows>=2&&this.isZero()){const t=Array(this.rows).fill(0);t[0]=1;const s=Matrix.eye(this.rows,this.rows);return s.set(0,0,0),[t,s]}if(this.rows<=2)return[this.eigenValues(),this.eigenVectors()];if(this.isSymmetric(1e-15))return this.eigenJacobi();{const t=this.eigenValues(),s=this.rows,e=new Matrix(s,s);for(let i=0;i<s;i++){const[,r]=this.eigenInverseIteration(t[i]);for(let t=0;t<s;t++)e._value[t*s+i]=r._value[t]}return[t,e]}}eigenValues(){if(!this.isSquare())throw new MatrixException("Eigen values only define square matrix.",this);if(this.rows>=2&&this.isZero()){const t=Array(this.rows).fill(0);return t[0]=1,t}switch(this.rows){case 0:return[];case 1:return[this._value[0]];case 2:{const t=this._value[0]+this._value[3],s=Math.sqrt(t**2-4*this.det());return[(t+s)/2,(t-s)/2]}case 3:{const t=-this.det(),s=this._value[0]*this._value[4]+this._value[0]*this._value[8]+this._value[4]*this._value[8]-this._value[5]*this._value[7]-this._value[2]*this._value[6]-this._value[1]*this._value[3],e=-this._value[0]-this._value[4]-this._value[8],i=t-s*e/3+e**3*2/27,r=(i/2)**2+((s-e**2/3)/3)**3;let[o,a]=new Complex(r).sqrt();o=o.add(-i/2),a=a.add(-i/2);const[n,l,h]=o.cbrt(),[u,c,f]=a.cbrt(),v=[n.add(u),l.add(f),h.add(c)].map((t=>Math.abs(t.imaginary)<1e-12?t.real-e/3:Number.NaN));return v.sort(((t,s)=>s-t)),v}}return this.isSymmetric(1e-15)?this.eigenJacobi()[0]:this.eigenValuesQR()}eigenVectors(){if(!this.isSquare())throw new MatrixException("Eigen vectors only define square matrix.",this);if(this.rows>=2&&this.isZero()){const t=Matrix.eye(this.rows,this.rows);return t.set(0,0,0),t}switch(this.rows){case 0:return this;case 1:return new Matrix(1,1,[1]);case 2:{const t=this.eigenValues(),s=[-this._value[1],this._value[0]-t[0]],e=Math.sqrt(s[0]**2+s[1]**2),i=[-this._value[1],this._value[0]-t[1]],r=Math.sqrt(i[0]**2+i[1]**2);return new Matrix(2,2,[s[0]/e,i[0]/r,s[1]/e,i[1]/r])}}return this.eigen()[1]}eigenValuesBiSection(){if(!this.isSymmetric(1e-15))throw new MatrixException("eigenValuesBiSection can only use symmetric matrix.",this);const t=this.tridiag(),s=this.rows;let e=0;for(let i=0;i<s;i++){const r=Math.abs(t.at(i,i))+Math.abs(i>0?t.at(i,i-1):0)+Math.abs(i<s-1?t.at(i,i+1):0);e<r&&(e=r)}const i=e=>{const i=[1,e-t.at(0,0)];for(let r=1;r<s;r++)i[r+1]=(e-t.at(r,r))*i[r]-t.at(r,r-1)**2*i[r-1];let r=0;for(let t=1;t<i.length;t++)Math.sign(i[t-1])!==Math.sign(i[t])&&r++;return r},r=[];for(let t=1;t<=s;t++){let s=-e,o=i(s),a=e;for(;Math.abs(s-a)>1e-8;){const e=(s+a)/2,r=i(e);t<=o&&t>r?a=e:(s=e,o=r)}r.push((s+a)/2)}return r}eigenValuesLR(){if(!this.isSquare())throw new MatrixException("Eigen values only define square matrix.",this);let t=this;const s=t.rows;let e=1e5;for(;e-- >0;){const[e,i]=t.lu();t=i.dot(e);let r=0;for(let e=0;e<s;e++)for(let i=0;i<e;i++)r+=t._value[e*s+i]**2;if(r<1e-15){const s=t.diag();return s.sort(((t,s)=>s-t)),s}}throw new MatrixException("eigenValuesLR not converged.",this)}eigenValuesQR(){if(!this.isSquare())throw new MatrixException("Eigen values only define square matrix.",this);let t=this.copy();const s=[];for(let e=t.rows;e>2;e--){let i=1e6;for(;;){const r=t.block(e-2,e-2).eigenValues();if(isNaN(r[0])){s.sort(((t,s)=>s-t));for(let t=0;t<e;t++,s.push(NaN));return s}const o=t._value[t._value.length-1],a=Math.abs(r[0]-o)<Math.abs(r[1]-o)?r[0]:r[1];for(let s=0;s<e;s++)t._value[s*e+s]-=a;const[n,l]=t.qr();t=l.dot(n);for(let s=0;s<e;s++)t._value[s*e+s]=t._value[s*e+s]+a;let h=0;for(let s=(e-1)*e;s<t.length-1;s++)h+=Math.abs(t._value[s]);if(h<1e-8)break;if(i--<0)throw new MatrixException("eigenValuesQR not converged.",this)}s.push(t._value[t._value.length-1]),t.resize(e-1,e-1)}const e=t.eigenValues();return s.push(...e),s.sort(((t,s)=>s-t)),s}eigenJacobi(t=1e6){if(!this.isSymmetric(1e-15))throw new MatrixException("Jacobi method can only use symmetric matrix.",this);const s=this._value.concat(),e=Matrix.eye(this.rows,this.cols);e.add(0);let i=0;const r=this.rows;let o=t;for(;;){let t=0,a=0,n=0;for(let e=0;e<r;e++)for(let i=e+1;i<r;i++){const o=Math.abs(s[e*r+i]);o>t&&(t=o,a=e,n=i)}if(t<1e-15)break;if(t===i)break;if(o--<0){console.log(new MatrixException("eigenJacobi not converged.",[this,t]));break}i=t;const l=s[a*r+a],h=s[a*r+n],u=s[n*r+n],c=(l-u)/2,f=-h,v=Math.abs(c)/Math.sqrt(c**2+f**2);let w=Math.sqrt((1-v)/2);const _=Math.sqrt((1+v)/2);c*f<0&&(w=-w);for(let t=0;t<r;t++){const e=s[a*r+t],i=s[n*r+t];s[t*r+n]=s[n*r+t]=w*e+_*i,s[t*r+a]=s[a*r+t]=_*e-w*i}s[a*r+a]=_**2*l+w**2*u-2*w*_*h,s[a*r+n]=s[n*r+a]=w*_*(l-u)+(_**2-w**2)*h,s[n*r+n]=w**2*l+_**2*u+2*w*_*h;for(let t=0;t<r;t++){const s=e._value[t*r+a],i=e._value[t*r+n];e._value[t*r+n]=w*s+_*i,e._value[t*r+a]=_*s-w*i}}const a=[];for(let t=0;t<r;t++)a.push([t,s[t*r+t]]);a.sort(((t,s)=>s[1]-t[1]));const n=e.col(a.map((t=>t[0])));return[a.map((t=>t[1])),n]}eigenPowerIteration(){if(!this.isSquare())throw new MatrixException("Eigen vectors only define square matrix.",this);const t=this.rows;let s=Matrix.randn(t,1);s.div(s.norm());let e=1/0,i=1e4;for(;i-- >0;){const i=this.dot(s);let r=0,o=0;for(let e=0;e<t;e++)r+=i._value[e]**2,o+=i._value[e]*s._value[e];const a=r/o;i.div(i.norm());const n=Math.abs(a-e);if(n<1e-15||isNaN(n))return[a,i];s=i,e=a}throw new MatrixException("eigenPowerIteration not converged.",this)}eigenInverseIteration(t=0){if(!this.isSquare())throw new MatrixException("Eigen vectors only define square matrix.",this);const s=this.rows;let e=this.copy();for(let i=0;i<s;i++)e._value[i*s+i]=e._value[i*s+i]-t+1e-15;e=e.inv();let i=Matrix.randn(s,1);i.div(i.norm());let r=1/0,o=1e4;for(;o-- >0;){const o=e.dot(i);let a=0,n=0;for(let t=0;t<s;t++)a+=o._value[t]**2,n+=i._value[t]*o._value[t];const l=n/a;o.div(o.norm());const h=Math.abs(l-r);if(h<1e-15||isNaN(h))return[l+t,o];i=o,r=l}throw new MatrixException("eigenInverseIteration not converged.",this)}}