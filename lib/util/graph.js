import Matrix from"./matrix.js";export class GraphException extends Error{constructor(e,t){super(e),this.value=t,this.name="GraphException"}}export class Edge{constructor(e,t,n=null,s=!1){this[0]=e,this[1]=t,this.value=n??1,this.direct=s,this.weighted=null!=n}get value0(){return this.weighted?this.value:null}}export default class Graph{constructor(e=0,t=[]){Array.isArray(e)?this._nodes=e:this._nodes=Array(e),this._edges=t.map((e=>new Edge(e[0],e[1],e instanceof Edge?e.value0:e.value,e.direct)))}static fromAdjacency(e){const t=e.length,n=[];for(let s=0;s<t;s++)for(let t=0;t<=s;t++)(e[s][t]||e[t][s])&&(e[s][t]===e[t][s]?n.push(new Edge(t,s,+e[s][t])):(e[s][t]&&n.push(new Edge(s,t,+e[s][t],!0)),e[t][s]&&n.push(new Edge(t,s,+e[t][s],!0))));return new Graph(t,n)}static complete(e){const t=[];for(let n=0;n<e;n++)for(let e=0;e<n;e++)t.push([n,e]);return new Graph(e,t)}static completeBipartite(e,t){const n=[];for(let s=0;s<e;s++)for(let r=0;r<t;r++)n.push([s,r+e]);return new Graph(e+t,n)}static cycle(e,t=!1){if(e<3)throw new GraphException("Index out of bounds.");const n=[];for(let s=0;s<e;s++)n.push(new Edge(s,(s+1)%e,null,t));return new Graph(e,n)}static wheel(e){if(e<4)throw new GraphException("Index out of bounds.");const t=[];for(let n=1;n<e;n++)t.push([n,n%(e-1)+1]),t.push([0,n]);return new Graph(e,t)}get order(){return this._nodes.length}get size(){return this._edges.length}get nodes(){return this._nodes}get edges(){return this._edges}toDot(){let e=this.isUndirected()?"graph":"digraph";e+=" g {\n";for(let t=0;t<this._nodes.length;t++)e+=`  ${t} [label="${JSON.stringify(this._nodes[t]??t).replace('"',"'")}"];\n`;for(const t of this._edges)e+=`  ${t[0]} ${t.direct?"->":"--"} ${t[1]}`,t.weighted&&(e+=` [label="${JSON.stringify(t.value).replace('"',"'")}"]`),e+=";\n";return e+"}"}toString(){let e=`Number of nodes: ${this._nodes.length}\n`;this._nodes.some((e=>null!=e))&&(e+=`Node values: ${JSON.stringify(this._nodes)}\n`),e+=`Number of edges: ${this._edges.length}`,this._edges.length>0&&(e+="\nEdges");for(const t of this._edges)e+=`\n  From ${t[0]} to ${t[1]}, value: ${JSON.stringify(t.value)} (${t.direct?"directed":"undirected"})`;return e}copy(){const e=this._edges.map((e=>new Edge(e[0],e[1],e.value0,e.direct))),t=this._nodes.concat();return new Graph(t,e)}degree(e,t=!0,n=!0){"in"!==t&&"out"!==t||(n=t,t=!1);let s=0;for(const r of this._edges)(!t||r.direct||r[0]!==e&&r[1]!==e)&&(!0!==n||!r.direct||r[0]!==e&&r[1]!==e)?("in"===n&&r.direct&&r[1]===e||"out"===n&&r.direct&&r[0]===e)&&s++:s++;return s}adjacencies(e,t=!0,n=!0){"in"!==t&&"out"!==t||(n=t,t=!1);const s=[];for(const r of this._edges)(!t||r.direct||r[0]!==e&&r[1]!==e)&&(!0!==n||!r.direct||r[0]!==e&&r[1]!==e)?"in"===n&&r.direct&&r[1]===e?s.push(r[0]):"out"===n&&r.direct&&r[0]===e&&s.push(r[1]):s.push(r[0]===e?r[1]:r[0]);return s.sort(((e,t)=>e-t)),s}components(){const e=Array(this._nodes.length).fill(!1),t=[0],n=[];let s=[];for(;t.length>0||e.some((e=>!e));){0===t.length&&(n.push(s),s=[]);const r=t.length>0?t.pop():e.indexOf(!1);if(!e[r]){e[r]=!0,s.push(r);for(const e of this._edges)e[0]===r&&t.push(e[1]),e[1]===r&&t.push(e[0])}}return s.length>0&&n.push(s),n}diameter(){const e=this.shortestPathFloydWarshall();let t=-1/0;for(let n=0;n<this._nodes.length;n++)for(let s=0;s<this._nodes.length;s++)t<e[n][s].length&&(t=e[n][s].length);return t}eccentricity(e){const t=this.shortestPathBellmanFord(e);let n=-1/0;for(let e=0;e<this._nodes.length;e++)n<t[e].length&&(n=t[e].length);return n}radius(){const e=this.shortestPathFloydWarshall();let t=1/0;for(let n=0;n<this._nodes.length;n++){let s=-1/0;for(let t=0;t<this._nodes.length;t++)s<e[n][t].length&&(s=e[n][t].length);t>s&&(t=s)}return t}center(){const e=this.shortestPathFloydWarshall(),t=Array(this._nodes.length).fill(-1/0);let n=1/0;for(let s=0;s<this._nodes.length;s++){for(let n=0;n<this._nodes.length;n++)t[s]<e[s][n].length&&(t[s]=e[s][n].length);n>t[s]&&(n=t[s])}const s=[];for(let e=0;e<t.length;e++)t[e]===n&&s.push(e);return s}girth(){throw new GraphException("Not implemented")}clique(e){const t=this._nodes.length;if(null!=e&&e>t)return[];const n=Array.from({length:t},((e,t)=>[t]));if(1===e)return n;if(1===t)return[n];const s=[],r=[];for(let e=0;e<t;e++){s[e]=[];for(let t=0;t<e;t++)this.getEdges(e,t).length>0&&(s[e][t]=!0,s[t][e]=!0,r.push([t,e]))}if(2===e)return r;const o=e??this._nodes.length,h=[n,r];for(let e=2;e<o;e++){const n=[];for(let r=0;r<h[e-1].length;r++){const o=h[e-1][r];for(let e=o.at(-1)+1;e<t;e++)o.every((t=>s[t][e]))&&n.push(o.concat(e))}h.push(n)}return null==e?h:h[e-1]}addNode(e){this._nodes[this._nodes.length]=e}getNode(e){if(null==e)return this._nodes;if(Array.isArray(e)){if(e.some((e=>e<0||this._nodes.length<=e)))throw new GraphException("Index out of bounds.");return e.map((e=>this._nodes[e]))}if(e<0||this._nodes.length<=e)throw new GraphException("Index out of bounds.");return this._nodes[e]}removeNode(e){if(e<0||this._nodes.length<=e)throw new GraphException("Index out of bounds.");this._nodes.splice(e,1);for(let t=this._edges.length-1;t>=0;t--){const n=this._edges[t];n[0]===e||n[1]===e?this._edges.splice(t,1):(n[0]>e&&n[0]--,n[1]>e&&n[1]--)}}addEdge(e,t,n=null,s=!1){if(e<0||this._nodes.length<=e||t<0||this._nodes.length<=t)throw new GraphException("Index out of bounds.");this._edges.push(new Edge(e,t,n,s))}getEdges(e,t,n=null){if(e<0||this._nodes.length<=e||t<0||this._nodes.length<=t)throw new GraphException("Index out of bounds.");const s=[];for(const r of this._edges)null!==n&&!n!=!r.direct||(r[0]===e&&r[1]===t||r[1]===e&&r[0]===t)&&s.push(r);return s}removeEdges(e,t,n=null){if(e<0||this._nodes.length<=e||t<0||this._nodes.length<=t)throw new GraphException("Index out of bounds.");for(let s=this._edges.length-1;s>=0;s--){const r=this._edges[s];null!==n&&!n!=!r.direct||(r[0]===e&&r[1]===t||r[1]===e&&r[0]===t)&&this._edges.splice(s,1)}}adjacencyMatrix(){const e=Array.from({length:this._nodes.length},(()=>Array(this._nodes.length).fill(0)));for(const t of this._edges)t.direct?e[t[0]][t[1]]+=t.value:(e[t[0]][t[1]]+=t.value,e[t[1]][t[0]]+=t.value);return e}degreeMatrix(e="both"){const t=Array.from({length:this._nodes.length},(()=>Array(this._nodes.length).fill(0)));for(const n of this._edges)n.direct&&"both"!==e?"in"===e?t[n[1]][n[1]]+=n.value:t[n[0]][n[0]]+=n.value:(t[n[0]][n[0]]+=n.value,t[n[1]][n[1]]+=n.value);return t}laplacianMatrix(){const e=this.adjacencyMatrix(),t=[];for(let n=0;n<this._nodes.length;n++){t[n]=e[n].map((e=>-e));for(let s=0;s<this._nodes.length;s++)t[n][n]+=e[n][s]}return t}isNull(){return 0===this._nodes.length}isEdgeless(){return 0===this._edges.length}isUndirected(){return this._edges.every((e=>!e.direct))}isDirected(){return this._edges.every((e=>e.direct))}isMixed(){let e=!1,t=!1;for(const n of this._edges)if(n.direct?e=!0:t=!0,e&&t)return!0;return!1}isWeighted(){return this._edges.some((e=>e.weighted))}isSimple(){const e=Array.from({length:this._nodes.length},(()=>[]));for(const t of this._edges){if(t[0]===t[1])return!1;if(e[t[0]].indexOf(t[1])>=0||e[t[1]].indexOf(t[0])>=0)return!1;e[t[0]].push(t[1])}return!0}isConnected(){const e=Array(this._nodes.length).fill(!1),t=[0];for(;t.length>0;){const n=t.pop();if(!e[n]){e[n]=!0;for(const s of this._edges)s[0]!==n||e[s[1]]||t.push(s[1]),s.direct||s[1]!==n||e[s[0]]||t.push(s[0])}}return e.every((e=>e))}isBiconnected(){const e=new Graph(this._nodes.length);for(const t of this._edges)e.addEdge(t[0],t[1],1,t.direct);for(let t=0;t<this._nodes.length;t++){const n=e.copy();if(n.removeNode(t),!n.isConnected())return!1}return!0}isTree(){return this.isConnected()&&!this.hasCycle()}isForest(){return!this.hasCycle()}isBipartite(){const e=Array(this._nodes.length).fill(!1),t=[[0,1]];for(;t.length>0||e.some((e=>!e));){const[n,s]=t.length>0?t.pop():[e.indexOf(!1),1];if(e[n]){if(e[n]===s)continue;return!1}e[n]=s;for(const r of this._edges){if(r[0]===n){if(e[r[1]]===s)return!1;t.push([r[1],s%2+1])}if(!r.direct&&r[1]===n){if(e[r[0]]===s)return!1;t.push([r[0],s%2+1])}}}return!0}isRegular(){if(this._nodes.length<=1)return!0;const e=this.degree(0);for(let t=1;t<this._nodes.length;t++){if(e!==this.degree(t))return!1}return!0}isPlainer(){if(this._nodes.length<=3)return!0;if(this.clique(5).length>0)return!1;throw new GraphException("Not implemented")}isSymmetric(){if(this._nodes.length<=1)return!0;throw new GraphException("Not implemented")}isDAG(){return this.isDirected()&&!this.hasCycle()}hasCycle(){return this.isUndirected()?this.hasCycleDFS():this.hasCycleEachNodes()}hasCycleDFS(){if(!this.isUndirected())throw new GraphException("This method only works undirected graph.");const e=Array(this._nodes.length).fill(!1),t=Array(this._edges.length).fill(!1),n=[0];for(;n.length>0||e.some((e=>!e));){const s=n.length>0?n.pop():e.indexOf(!1);if(e[s])return!0;e[s]=!0;for(let r=0;r<this._edges.length;r++){if(t[r])continue;const o=this._edges[r];if(o[0]===s){if(e[o[1]])return!0;t[r]=!0,n.push(o[1])}if(!o.direct&&o[1]===s){if(e[o[0]])return!0;t[r]=!0,n.push(o[0])}}}return!1}hasCycleEachNodes(){for(let e=0;e<this._nodes.length;e++){const t=[[[e],Array(this._edges.length).fill(!1)]];for(;t.length>0;){const[n,s]=t.pop(),r=n[n.length-1];for(let o=0;o<this._edges.length;o++){if(s[o])continue;const h=this._edges[o];if(h[0]===r){if(h[1]===e)return!0;if(n.indexOf(h[1])>=0)continue;const r=s.concat();r[o]=!0,t.push([n.concat(h[1]),r])}if(!h.direct&&h[1]===r){if(h[0]===e)return!0;if(n.indexOf(h[1])>=0)continue;const r=s.concat();r[o]=!0,t.push([n.concat(h[0]),r])}}}}return!1}isomorphism(e){if(e===this)return!0;if(this._nodes.length!==e._nodes.length||this._edges.length!==e._edges.length)return!1;if(0===this._nodes.length||0===this._edges.length)return!0;throw new GraphException("Not implemented")}inducedSub(e){const t=[];for(const n of this._edges){const s=e.indexOf(n[0]),r=e.indexOf(n[1]);s>=0&&r>=0&&t.push(new Edge(s,r,n.value0,n.direct))}const n=e.map((e=>this._nodes[e]));return new Graph(n,t)}complement(){if(0===this._nodes.length)return new Graph(0);const e=[];for(let t=0;t<this._nodes.length;t++)for(let n=0;n<t;n++)0===this.getEdges(t,n).length&&e.push(new Edge(n,t));return new Graph(this._nodes.concat(),e)}contraction(e,t){if(e!==t){t<e&&([e,t]=[t,e]),this._nodes.splice(t,1);for(let n=this._edges.length-1;n>=0;n--){const s=this._edges[n];s[0]===e&&s[1]===t||s[1]===e&&s[0]===t?this._edges.splice(n,1):(s[0]===t?s[0]=e:s[0]>e&&s[0]--,s[1]===t?s[1]=e:s[1]>e&&s[1]--)}}}subdivision(e,t){this._nodes.push(null);const n=this._nodes.length-1;for(let s=this._edges.length-1;s>=0;s--){const r=this._edges[s];(r[0]===e&&r[1]===t||r[1]===e&&r[0]===t)&&(this._edges.splice(s,1),this._edges.push(new Edge(r[0],n,r.value0,r.direct)),this._edges.push(new Edge(n,r[0],r.value0,r.direct)))}}disjointUnion(e){const t=this._nodes.length;this._nodes=this._nodes.concat(e._nodes);for(const n of e._edges)this._edges.push(new Edge(n[0]+t,n[1]+t,n.value0,n.direct))}substitution(e,t){if(0===t._nodes.length)this.removeNode(e);else if(1===t._nodes.length)for(const n of t._edges)this._edges.push(new Edge(n[0]+e,n[1]+e,n.value0,n.direct));else{const n=this._nodes.length;this._nodes[e]=t._nodes[0],this._nodes=this._nodes.concat(t._nodes.slice(1));for(const s of this._edges)if(s[0]===e||s[1]===e)for(let r=0;r<t._nodes.length-1;r++)this._edges.push(new Edge(s[0]===e?n+r:s[0],s[1]===e?n+r:s[1],s.value0,s.direct));for(const s of t._edges)this._edges.push(new Edge(0===s[0]?e:s[0]+n-1,0===s[1]?e:s[1]+n-1,s.value0,s.direct))}}cartesianProduct(e){const t=this._nodes.length,n=e._nodes.length,s=[];for(let r=0;r<t;r++)for(let t=0;t<n;t++)null!=this._nodes[r]||null!=e._nodes[t]?s.push([this._nodes[r],this._nodes[t]]):s.push(null);const r=[];for(const e of this._edges)for(let s=0;s<n;s++)r.push(new Edge(e[0]+t*s,e[1]+t*s,e.value0,e.direct));for(const n of e._edges)for(let e=0;e<t;e++)r.push(new Edge(e+n[0]*t,e+n[1]*t,n.value0,n.direct));return new Graph(s,r)}tensorProduct(e){const t=this._nodes.length,n=e._nodes.length,s=[];for(let r=0;r<t;r++)for(let t=0;t<n;t++)null!=this._nodes[r]||null!=e._nodes[t]?s.push([this._nodes[r],this._nodes[t]]):s.push(null);const r=[];for(const n of this._edges)for(const s of e._edges)n.direct===s.direct&&(r.push(new Edge(n[0]+s[0]*t,n[1]+s[1]*t,n.weighted||s.weighted?[n.value0,s.value0]:null,n.direct)),n.direct||r.push(new Edge(n[1]+s[0]*t,n[0]+s[1]*t,n.weighted||s.weighted?[n.value0,s.value0]:null,n.direct)));return new Graph(s,r)}strongProduct(e){const t=this._nodes.length,n=e._nodes.length,s=[];for(let r=0;r<t;r++)for(let t=0;t<n;t++)null!=this._nodes[r]||null!=e._nodes[t]?s.push([this._nodes[r],this._nodes[t]]):s.push(null);const r=[];for(const e of this._edges)for(let s=0;s<n;s++)r.push(new Edge(e[0]+t*s,e[1]+t*s,e.value0,e.direct));for(const n of e._edges)for(let e=0;e<t;e++)r.push(new Edge(e+n[0]*t,e+n[1]*t,n.value0,n.direct));for(const n of this._edges)for(const s of e._edges)n.direct===s.direct&&(r.push(new Edge(n[0]+s[0]*t,n[1]+s[1]*t,n.weighted||s.weighted?[n.value0,s.value0]:null,n.direct)),n.direct||r.push(new Edge(n[1]+s[0]*t,n[0]+s[1]*t,n.weighted||s.weighted?[n.value0,s.value0]:null,n.direct)));return new Graph(s,r)}lexicographicProduct(e){const t=this._nodes.length,n=e._nodes.length,s=[];for(let r=0;r<t;r++)for(let t=0;t<n;t++)null!=this._nodes[r]||null!=e._nodes[t]?s.push([this._nodes[r],this._nodes[t]]):s.push(null);const r=[];for(const e of this._edges)for(let s=0;s<n;s++)for(let o=0;o<n;o++)r.push(new Edge(e[0]+t*s,e[1]+t*o,e.value0,e.direct));for(const n of e._edges)for(let e=0;e<t;e++)r.push(new Edge(e+n[0]*t,e+n[1]*t,n.value0,n.direct));return new Graph(s,r)}shortestPath(e){return null==e?this.shortestPathFloydWarshall():this.shortestPathDijkstra(e)}shortestPathBreadthFirstSearch(e){const t=Array.from({length:this._nodes.length},(()=>({length:1/0,prev:null,path:[]}))),n=[[e,null]];t[e]={length:0,prev:null,path:[e]};const s=Array(this._nodes.length).fill(!1);for(;n.length>0;){const[e,r]=n.shift();if(!s[e]){s[e]=!0,null!=r&&(t[e].prev=r,t[e].length=t[r].length+1,t[e].path=t[r].path.concat(e));for(const t of this._edges)t.value<=0||(t[0]!==e||s[t[1]]||n.push([t[1],e]),t.direct||t[1]!==e||s[t[0]]||n.push([t[0],e]))}}return t}shortestPathDijkstra(e){const t=Array.from({length:this._nodes.length},(()=>({length:1/0,prev:null,path:[]}))),n=[e];for(t[e]={length:0,prev:null,path:[e]};n.length>0;){const e=n.shift();for(const s of this._edges)s.value<=0||(s[0]===e&&t[s[1]].length>t[e].length+s.value&&(t[s[1]].length=t[e].length+s.value,t[s[1]].prev=e,t[s[1]].path=t[e].path.concat(s[1]),n.push(s[1])),!s.direct&&s[1]===e&&t[s[0]].length>t[e].length+s.value&&(t[s[0]].length=t[e].length+s.value,t[s[0]].prev=e,t[s[0]].path=t[e].path.concat(s[0]),n.push(s[0])))}return t}shortestPathBellmanFord(e){const t=Array.from({length:this._nodes.length},(()=>({length:1/0,prev:null,path:[]})));t[e]={length:0,prev:null,path:[e]};for(let e=0;e<this._nodes.length-1;e++)for(const e of this._edges)t[e[1]].length>t[e[0]].length+e.value&&(t[e[1]].length=t[e[0]].length+e.value,t[e[1]].prev=e[0],t[e[1]].path=t[e[0]].path.concat(e[1])),!e.direct&&t[e[0]].length>t[e[1]].length+e.value&&(t[e[0]].length=t[e[1]].length+e.value,t[e[0]].prev=e[1],t[e[0]].path=t[e[1]].path.concat(e[0]));return t}shortestPathFloydWarshall(){const e=[];for(let t=0;t<this._nodes.length;t++)e[t]=Array.from({length:this._nodes.length},(()=>({length:1/0,path:[]}))),e[t][t]={length:0,path:[t]};for(const t of this._edges)e[t[0]][t[1]].length>t.value&&(e[t[0]][t[1]].length=t.value,e[t[0]][t[1]].path=[t[0],t[1]]),!t.direct&&e[t[1]][t[0]].length>t.value&&(e[t[1]][t[0]].length=t.value,e[t[1]][t[0]].path=[t[1],t[0]]);for(let t=0;t<this._nodes.length;t++)for(let n=0;n<this._nodes.length;n++)for(let s=0;s<this._nodes.length;s++)e[n][s].length>e[n][t].length+e[t][s].length&&(e[n][s].length=e[n][t].length+e[t][s].length,e[n][s].path=e[n][t].path.concat(e[t][s].path.slice(1)));return e}minimumSpanningTree(){return this.minimumSpanningTreePrim()}minimumSpanningTreePrim(){const e=Array(this._nodes.length).fill(!1);e[0]=!0;const t=this._edges.concat(),n=[];for(;e.some((e=>!e));){let s=1/0,r=null;for(let n=t.length-1;n>=0;n--)e[t[n][0]]&&e[t[n][1]]?t.splice(n,1):(e[t[n][0]]&&!e[t[n][1]]||!t[n].direct&&e[t[n][1]]&&!e[t[n][0]])&&s>t[n].value&&(r=t[n],s=t[n].value);n.push(r),e[r[0]]=e[r[1]]=!0}return new Graph(this._nodes.length,n)}minimumSpanningTreeKruskal(){const e=Array.from({length:this._nodes.length},((e,t)=>t)),t=[],n=this._edges.concat();n.sort(((e,t)=>e.value-t.value));for(let s=0;s<n.length;s++){const r=n[s],o=e[r[1]];if(e[r[0]]!==o){t.push(r);for(let t=0;t<this._nodes.length;t++)e[t]===o&&(e[t]=e[r[0]])}}return new Graph(this._nodes.length,t)}minimumSpanningTreeBoruvka(){const e=Array.from({length:this._nodes.length},((e,t)=>t)),t=new Set;for(let n=0;n<this._nodes.length-1;n++){const n=[];for(const t of this._edges)e[t[0]]!==e[t[1]]&&((!n[e[t[0]]]||n[e[t[0]]].value>t.value)&&(n[e[t[0]]]=t),(!n[e[t[1]]]||n[e[t[1]]].value>t.value)&&(n[e[t[1]]]=t));if(0===n.length)break;for(const s of n){t.add(s);const n=e[s[1]];for(let t=0;t<this._nodes.length;t++)e[t]===n&&(e[t]=e[s[0]])}}return new Graph(this._nodes.length,[...t])}cut(e,t){const n=this.adjacencyMatrix();let s=0;for(let r=0;r<e.length;r++)for(let o=0;o<t.length;o++)s+=n[e[r]][t[o]];return s}mincut(e=1){if(e>Math.floor(this._nodes.length/2))throw new Error(`Invalid minv. ${e}, ${this._nodes.length}`);if(this._nodes.length<=6)return this.mincutBruteForce(e);let[t,n]=this.mincutStoerWagner(e);for(let s=1;s<this._nodes.length&&t!==1/0;s++)[t,n]=this.mincutStoerWagner(e,s);return t===1/0&&([t,n]=this.mincutKargersStein(e)),[t,n]}mincutBruteForce(e=1){const t=this.adjacencyMatrix(),n=Array(this._nodes.length).fill(!1);let s=null,r=1/0;do{const o=[],h=[];for(let e=0;e<this._nodes.length;e++)n[e]?o.push(e):h.push(e);if(o.length>=e&&h.length>=e){let e=0;for(let n=0;n<o.length;n++)for(let s=0;s<h.length;s++)t[o[n]][h[s]]&&(e+=t[o[n]][h[s]]);e<r&&(r=e,s=[o,h])}if(0===r)return[0,s];for(let e=0;e<this._nodes.length;e++){if(!n[e]){n[e]=!0;break}n[e]=!1}}while(n.some((e=>e)));return[r,s]}mincutStoerWagner(e=1,t=0){const n=this.adjacencyMatrix(),s=Array.from({length:this._nodes.length},((e,t)=>[t]));let r=null,o=1/0;const h=n.map((e=>e.concat()));for(let n=1;n<this._nodes.length;n++){const l=h[t].concat();let i=0,d=t;for(let e=0;e<this._nodes.length-n;e++){l[d]=-1/0,i=d;let e=-1/0;for(let t=0;t<l.length;t++)l[t]>e&&(e=l[t],d=t);for(let e=0;e<this._nodes.length;e++)l[e]+=h[d][e]}l[d]-h[d][d]<o&&s[d].length>=e&&this._nodes.length-s[d].length>=e&&(o=l[d]-h[d][d],r=s[d].concat()),s[i].push(...s[d]);for(let e=0;e<this._nodes.length;e++)h[e][i]=h[i][e]+=h[d][e];h[t][d]=-1/0}if(!r)return[o,[Array.from({length:this._nodes.length},((e,t)=>t))]];const l=[];for(let e=0;e<this._nodes.length;e++)r.indexOf(e)<0&&l.push(e);return[o,[r,l]]}mincutKargers(e=1,t=null){const n=this.adjacencyMatrix();let s=null,r=1/0;null==t&&(t=this._nodes.length**2*Math.log(this._nodes.length));const o=[];let h=0;for(let e=0;e<this._nodes.length;e++){o[e]=new Set;for(let t=0;t<this._nodes.length;t++)n[e][t]&&(o[e].add(t),h++)}for(let l=0;l<t;l++){const t=Array.from({length:this._nodes.length},((e,t)=>[t])),l=n.map((e=>e.concat())),i=o.map((e=>new Set(e)));let d=h,g=0;for(let e=0;e<this._nodes.length-2&&d>0;e++){let e=Math.floor(Math.random()*d);for(g=0;g<this._nodes.length&&i[g].size<=e;g++)e-=i[g].size;let n=0;for(const t of i[g]){if(0===e){n=t;break}e--}for(const e of i[n])i[e].delete(n),d-=1,e!==g&&(l[g][e]||(i[g].add(e),i[e].add(g),d+=2),l[g][e]+=l[n][e],l[e][g]+=l[e][n]);t[g].push(...t[n]),t[n]=null,d-=i[n].size,i[n].clear()}if(0===d)return[0,t.filter((e=>null!==e))];const c=i[g].values().next().value;t[g].length<e||t[c].length<e||l[g][c]<r&&(r=l[g][c],s=[t[g],t[c]])}return s?[r,s]:[r,[Array.from({length:this._nodes.length},((e,t)=>t))]]}mincutKargersStein(e=1,t=null){const n=this.adjacencyMatrix(),s=Array.from({length:this._nodes.length},((e,t)=>[t]));null===t&&(t=Math.log(this._nodes.length)**2);let r=null,o=1/0;for(let h=0;h<t;h++){const[t,h]=this._mincutKargersStein0(n,s,e);t<o&&(o=t,r=h)}return[o,r]}_mincutKargersStein0(e,t,n){const s=e.length;if(s<=6){const r=Array(s).fill(!1);let o=null,h=1/0;do{const l=[],i=[];for(let e=0;e<s;e++)r[e]?l.push(e):i.push(e);const d=l.reduce(((e,n)=>e+t[n].length),0),g=i.reduce(((e,n)=>e+t[n].length),0);if(d>=n&&g>=n){let n=0;for(let t=0;t<l.length;t++)for(let s=0;s<i.length;s++)e[l[t]][i[s]]&&(n+=e[l[t]][i[s]]);n<h&&(h=n,o=[l.reduce(((e,n)=>e.concat(t[n])),[]),i.reduce(((e,n)=>e.concat(t[n])),[])])}if(0===h)return[0,o];for(let e=0;e<s;e++){if(!r[e]){r[e]=!0;break}r[e]=!1}}while(r.some((e=>e)));return[h,o]}const r=[];let o=0;for(let t=0;t<s;t++){r[t]=new Set;for(let n=0;n<s;n++)e[t][n]&&(r[t].add(n),o++)}const h=s/Math.sqrt(2)+1;let l=null,i=1/0;for(let d=0;d<2;d++){const d=t.map((e=>e.concat())),g=e.map((e=>e.concat())),c=r.map((e=>new Set(e)));let u=o,a=0;const f=[];for(let e=0;e<s-h;e++){let e=Math.floor(Math.random()*u);for(a=0;a<this._nodes.length&&c[a].size<=e;a++)e-=c[a].size;let t=0;for(const n of c[a]){if(0===e){t=n;break}e--}for(const e of c[t])c[e].delete(t),u-=1,e!==a&&(g[a][e]||(c[a].add(e),c[e].add(a),u+=2),g[a][e]+=g[t][e],g[e][a]+=g[e][t]);d[a].push(...d[t]),d[t]=null,u-=c[t].size,c[t].clear(),f.push(t)}f.sort(((e,t)=>t-e));for(let e=s-1;e>=0;e--)if(null===d[e])g.splice(e,1),d.splice(e,1);else for(let t=0;t<f.length;t++)g[e].splice(f[t],1);const[_,p]=this._mincutKargersStein0(g,d,n);_<i&&(i=_,l=p)}return[i,l]}bisectionSpectral(){const e=Matrix.fromArray(this.laplacianMatrix()).tridiagLanczos(),t=e.eigenValuesQR(),[,n]=e.eigenInverseIteration(t[1]),s=n.median(),r=[],o=[];for(let e=0;e<this._nodes.length;e++)n.at(e,0)>s?r.push(e):o.push(e);return[this.cut(r,o),[r,o]]}}