var C=Object.defineProperty;var j=(k,s)=>C(k,"name",{value:s,configurable:!0});import x from"./matrix.js";export class GraphException extends Error{static{j(this,"GraphException")}constructor(s,t){super(s),this.value=t,this.name="GraphException"}}export class Edge{static{j(this,"Edge")}constructor(s,t,e=null,n=!1){this[0]=s,this[1]=t,this.value=e??1,this.direct=n,this.weighted=e!=null}get from(){return this[0]}get to(){return this[1]}get value0(){return this.weighted?this.value:null}}export default class m{static{j(this,"Graph")}constructor(s=0,t=[]){Array.isArray(s)?this._nodes=s:this._nodes=Array(s),this._edges=t.map(e=>new Edge(e[0]|e.from,e[1]|e.to,e instanceof Edge?e.value0:e.value,e.direct))}static fromAdjacency(s){const t=s.length,e=[];for(let n=0;n<t;n++)for(let i=0;i<=n;i++)!s[n][i]&&!s[i][n]||(s[n][i]===s[i][n]?e.push(new Edge(i,n,+s[n][i])):(s[n][i]&&e.push(new Edge(n,i,+s[n][i],!0)),s[i][n]&&e.push(new Edge(i,n,+s[i][n],!0))));return new m(t,e)}static complete(s){const t=[];for(let e=0;e<s;e++)for(let n=0;n<e;n++)t.push([e,n]);return new m(s,t)}static completeBipartite(s,t){const e=[];for(let n=0;n<s;n++)for(let i=0;i<t;i++)e.push([n,i+s]);return new m(s+t,e)}static cycle(s,t=!1){if(s<3)throw new GraphException("Index out of bounds.");const e=[];for(let n=0;n<s;n++)e.push(new Edge(n,(n+1)%s,null,t));return new m(s,e)}static wheel(s){if(s<4)throw new GraphException("Index out of bounds.");const t=[];for(let e=1;e<s;e++)t.push([e,e%(s-1)+1]),t.push([0,e]);return new m(s,t)}static windmill(s,t){if(s===1)return new m(1);const e=[];for(let n=0;n<t;n++)for(let i=0;i<s;i++)for(let l=0;l<i;l++)e.push([l===0?0:n*(s-1)+l,n*(s-1)+i]);return new m(t*(s-1)+1,e)}static fromName(s){switch(s){case"balaban 10 cage":{const t=[];for(let e=0;e<10;e++)t.push([e*2,(e+3)%10*2+1]),t.push([e*2+1,(e+3)%10*2]),t.push([e*2,e*3+20]),t.push([e*2+1,e*3+22]),t.push([e*3+20,e*3+21]),t.push([e*3+21,e*3+22]),e<5&&t.push([e*3+21,(e+5)*3+21]),t.push([e*3+20,e*2+50]),t.push([e*3+22,e*2+51]),t.push([e*2+50,(e+1)%10*2+50]),t.push([e*2+51,(e+1)%10*2+51]);return new m(70,t)}case"bidiakis cube":{const t=[];for(let e=0;e<12;e++)t.push([e,(e+1)%12]);return t.push([0,8],[1,7],[2,6],[3,11],[4,10],[5,9]),new m(12,t)}case"biggs smith":{const t=[];for(let e=0;e<17;e++)t.push([e,(e+8)%17]),t.push([e,e+17]),t.push([e+17,e+51]),t.push([e+17,e+68]),t.push([e+34,(e+4)%17+34]),t.push([e+34,e+68]),t.push([e+51,(e+2)%17+51]),t.push([e+68,e+85]),t.push([e+85,(e+1)%17+85]);return new m(102,t)}case"brinkmann":{const t=[];for(let e=0;e<7;e++)t.push([e,(e+3)%7]),t.push([e,e+7]),t.push([e,(e+5)%7+7]),t.push([e+7,e+14]),t.push([e+7,(e+1)%7+14]),t.push([e+14,(e+2)%7+14]);return new m(21,t)}case"bull":return new m(5,[[0,1],[1,2],[1,3],[2,3],[3,4]]);case"butterfly":return new m(5,[[0,1],[0,2],[1,2],[2,3],[2,4],[3,4]]);case"chvatal":{const t=[];for(let e=0;e<4;e++)t.push([e,(e+1)%4]),t.push([e,e*2+4]),t.push([e,(e*2+7)%8+4]),t.push([e*2+4,e*2+5]),t.push([e*2+4,(e*2+3)%8+4]);return t.push([4,8],[5,9],[6,10],[7,11]),new m(12,t)}case"clebsch":{const t=[];for(let e=0;e<8;e++)t.push([e,(e+3)%8]),t.push([e,e+8]),t.push([e,(e+2)%8+8]),t.push([e+8,(e+1)%8+8]);for(let e=0;e<4;e++)t.push([e,e+4]),t.push([e+8,e+12]);return new m(16,t)}case"coxeter":{const t=[];for(let e=0;e<3;e++)t.push([0,e*8+4]),t.push([e+1,e*8+8]),t.push([e+1,(e*8+15)%24+4]),t.push([e+1,(e*8+22)%24+4]),t.push([e*8+5,(e*8+19)%24+4]),t.push([e*8+9,(e*8+18)%24+4]);for(let e=0;e<24;e++)t.push([e+4,(e+1)%24+4]);return new m(28,t)}case"desargues":{const t=[];for(let e=0;e<10;e++)t.push([e,(e+3)%10]),t.push([e,e+10]),t.push([e+10,(e+1)%10+10]);return new m(20,t)}case"diamond":return new m(4,[[0,1],[0,2],[1,2],[1,3],[2,3]]);case"durer":{const t=[];for(let e=0;e<6;e++)t.push([e,(e+1)%6]),t.push([e,e+6]),t.push([e+6,(e+2)%6+6]);return new m(12,t)}case"dyck":{const t=[];for(let e=0;e<32;e++)t.push([e,(e+1)%32]);for(let e=0;e<8;e++)t.push([e*4,(e*4+5)%32]),t.push([e*4+2,(e*4+15)%32]);return new m(32,t)}case"errera":{const t=[[0,1],[2,3],[5,6],[9,10],[15,16]];for(let e=0;e<2;e++)t.push([0,11+e]),t.push([0,15+e]),t.push([1,5+e]),t.push([1,11+e]),t.push([2,5+e]),t.push([2,7+e]),t.push([3,7+e]),t.push([3,9+e]),t.push([4,9+e]),t.push([4,13+e]),t.push([4,15+e]),t.push([5+e,7+e]),t.push([5+e,11+e]),t.push([5+e,13+e]),t.push([7+e,9+e]),t.push([7+e,13+e]),t.push([9+e,13+e]),t.push([11+e,13+e]),t.push([11+e,15+e]),t.push([13+e,15+e]);return new m(17,t)}case"folkman":{const t=[];for(let e=0;e<5;e++)for(let n=0;n<4;n++)t.push([e*4+n,e*4+(n+1)%4]);for(let e=0;e<4;e++)t.push([e*4+2,(e+1)*4+1]),t.push([e*4+2,(e+1)*4+3]);for(let e=0;e<3;e++)t.push([e*4,(e+2)*4+1]),t.push([e*4,(e+2)*4+3]);return t.push([1,12],[1,18],[3,12],[3,18],[5,16],[7,16]),new m(20,t)}case"foster":{const t=[];for(let e=0;e<15;e++){for(let n=0;n<6;n++)t.push([e*6+n,(e*6+n+1)%90]);t.push([e*6,(e+8)%15*6+5]),t.push([e*6+1,(e+1)%15*6+4]),t.push([e*6+2,(e+12)%15*6+3])}return new m(90,t)}case"franklin":{const t=[];for(let e=0;e<12;e++)t.push([e,(e+1)%12]);return t.push([0,7],[1,6],[2,9],[3,8],[4,11],[5,10]),new m(12,t)}case"frucht":{const t=[];for(let e=0;e<7;e++)t.push([e,(e+1)%7]);return t.push([0,7],[1,8],[2,8],[3,9],[4,9],[5,10],[6,10],[7,10],[7,11],[8,11],[9,11]),new m(12,t)}case"goldner-harary":{const t=[];for(let e=0;e<4;e++)t.push([0,e+1]),t.push([0,e+5]),t.push([e+1,e+5]),t.push([e+1,(e+3)%4+5]),t.push([e+5,(e+3)%4+5]);return t.push([5,9],[9,7],[7,10],[10,5],[5,7],[6,9],[8,10]),new m(11,t)}case"golomb":{const t=[];for(let e=0;e<6;e++)t.push([0,e+1]),t.push([e+1,(e+1)%6+1]);for(let e=0;e<3;e++)t.push([e+7,(e+1)%3+7]),t.push([e*2+1,e+7]);return new m(10,t)}case"gray":{const t=[];for(let e=0;e<54;e++)t.push([e,(e+1)%54]);for(let e=0;e<9;e++)t.push([e*6,(e+4)%9*6+1]),t.push([e*6+2,(e+2)%9*6+3]),t.push([e*6+4,(e+1)%9*6+5]);return new m(54,t)}case"grotzsch":{const t=[];for(let e=0;e<5;e++)t.push([0,e+1]),t.push([e+1,e+6]),t.push([e+6,(e+4)%5+1]),t.push([e+6,(e+2)%5+6]);return new m(11,t)}case"harries":{const t=[];for(let e=0;e<10;e++)t.push([e,(e+3)%10]),t.push([e,e*5+20]),e%2===0?(t.push([e+10,(e+1)%10+10]),t.push([e+10,e*5+22])):(t.push([e+10,(e+3)%10+10]),t.push([e+10,e*5+24]));for(let e=0;e<50;e++)t.push([e+20,(e+1)%50+20]);for(let e=0;e<5;e++)t.push([e*10+24,(e*10+13)%50+20]),t.push([e*10+28,(e*10+17)%50+20]),t.push([e*5+21,(e*5+25)%50+21]);return new m(70,t)}case"heawood":{const t=[];for(let e=0;e<7;e++)t.push([e*2,e*2+1]),t.push([e*2+1,(e*2+2)%14]),t.push([e*2,(e*2+5)%14]);return new m(14,t)}case"herschel":{const t=[];for(let e=0;e<4;e++)t.push([0,e+1]),t.push([e+1,e+5]),t.push([e+1,(e+3)%4+5]);return t.push([5,9],[5,10],[6,9],[7,9],[7,10],[8,10]),new m(11,t)}case"hoffman":{const t=[];for(let e=0;e<2;e++)t.push([0,6+e]),t.push([0,10+e]),t.push([1,8+e]),t.push([1,10+e]),t.push([2,6+e]),t.push([2,14+e]),t.push([3,8+e]),t.push([3,14+e]),t.push([4+e,6+e]),t.push([4+e,10+e]),t.push([4+e,9-e]),t.push([4+e,15-e]),t.push([6+e,12+e]),t.push([8+e,12+e]),t.push([10+e,12+e]),t.push([12+e,14+e]);return new m(16,t)}case"holt":{const t=[];for(let e=0;e<9;e++)t.push([e,(e+4)%9]),t.push([e,(e+7)%9+9]),t.push([e,(e+1)%9+18]),t.push([e+9,(e+1)%9+9]),t.push([e+9,e+18]),t.push([e+18,(e+2)%9+18]);return new m(27,t)}case"kittell":return new m(23,[[0,1],[0,2],[0,3],[0,4],[0,15],[0,16],[1,2],[1,4],[1,5],[1,6],[1,7],[1,12],[2,3],[2,7],[2,8],[3,8],[3,14],[3,15],[4,5],[4,9],[4,16],[4,17],[5,6],[5,9],[5,10],[6,10],[6,11],[6,12],[7,8],[7,12],[7,13],[8,13],[8,14],[9,10],[9,17],[9,18],[10,11],[10,18],[10,19],[11,12],[11,19],[11,20],[12,13],[12,20],[12,21],[13,14],[13,21],[14,15],[14,21],[15,16],[15,21],[16,17],[16,21],[16,22],[17,18],[17,22],[18,19],[18,22],[19,20],[19,22],[20,21],[20,22],[21,22]]);case"markstrom":{const t=[];for(let e=0;e<3;e++)t.push([e*8,e*8+1]),t.push([e*8,e*8+4]),t.push([e*8+1,e*8+2]),t.push([e*8+1,e*8+3]),t.push([e*8+2,e*8+3]),t.push([e*8+2,(e+1)%3*8]),t.push([e*8+3,e*8+5]),t.push([e*8+4,e*8+5]),t.push([e*8+4,e*8+6]),t.push([e*8+5,e*8+6]),t.push([e*8+6,e*8+7]),t.push([e*8+7,(e+1)%3*8+7]);return new m(24,t)}case"mcgee":{const t=[];for(let e=0;e<24;e++)t.push([e,(e+1)%24]);for(let e=0;e<8;e++)t.push([e*3+1,(e*3+8)%24]);for(let e=0;e<4;e++)t.push([e*3,e*3+12]);return new m(24,t)}case"meredith":{const t=[];for(let e=0;e<5;e++){for(let n=0;n<4;n++)for(let i=0;i<3;i++)t.push([e*14+n,e*14+4+i]),t.push([e*14+7+n,e*14+11+i]);t.push([e*14+1,e*14+8]),t.push([e*14+2,e*14+9]),t.push([e*14+3,(e+2)%5*14]),t.push([e*14+10,(e+1)%5*14+7])}return new m(70,t)}case"mobius kantor":{const t=[];for(let e=0;e<8;e++)t.push([e,(e+3)%8]),t.push([e,e+8]),t.push([e+8,(e+1)%8+8]);return new m(16,t)}case"moser spindle":return new m(7,[[0,1],[0,2],[0,3],[0,4],[1,2],[1,5],[2,5],[3,4],[3,6],[4,6],[5,6]]);case"nauru":{const t=[];for(let e=0;e<24;e++)t.push([e,(e+1)%24]);for(let e=0;e<4;e++)t.push([e*6,e*6+5]),t.push([e*6+2,(e*6+9)%24]),t.push([e*6+1,(e*6+16)%24]);return new m(24,t)}case"pappus":{const t=[];for(let e=0;e<6;e++)t.push([e,(e+1)%6+6]),t.push([e,(e+5)%6+6]),t.push([e+6,e+12]),t.push([e+12,(e+1)%6+12]);return t.push([0,3],[1,4],[2,5]),new m(18,t)}case"petersen":{const t=[];for(let e=0;e<5;e++)t.push([e,(e+1)%5]),t.push([e,e+5]),t.push([e+5,(e+2)%5+5]);return new m(10,t)}case"poussin":{const t=[[0,1],[1,2],[3,4],[5,6],[13,14]];for(let e=0;e<2;e++)t.push([0,7+e]),t.push([0,13+e]),t.push([1,7+e]),t.push([1,9+e]),t.push([2,5+e]),t.push([2,9+e]),t.push([3,5+e]),t.push([3,11+e]),t.push([4,11+e]),t.push([4,13+e]),t.push([5+e,9+e]),t.push([5+e,11+e]),t.push([7+e,9+e]),t.push([7+e,13+e]),t.push([9+e,13+e]),t.push([9+e,11+e]),t.push([11+e,13+e]);return new m(15,t)}case"robertson":{const t=[[0,2],[1,3]];for(let e=0;e<4;e++)t.push([e,e*3+4]),t.push([(e+3)%4,e*3+5]),t.push([(e+2)%4,e*3+6]),t.push([e*3+4,e*3+5]),t.push([e*3+5,e*3+6]),t.push([e*3+6,(e+1)%4*3+4]);for(let e=0;e<3;e++)for(let n=0;n<4;n++)t.push([e+16,(e*4+n*3)%12+4]);return new m(19,t)}case"shrikhande":{const t=[];for(let e=0;e<4;e++)t.push([e*4,(e+1)%4*4]),t.push([e*4,e*4+1]),t.push([e*4,e*4+2]),t.push([e*4,(e+1)%4*4+1]),t.push([e*4,(e+1)%4*4+2]),t.push([e*4+1,(e+1)%4*4+2]),t.push([e*4+1,e*4+3]),t.push([e*4+2,(e+1)%4*4+1]),t.push([e*4+2,(e+1)%4*4+3]),t.push([e*4+2,(e+2)%4*4+3]),t.push([e*4+3,(e+1)%4*4+1]),t.push([e*4+3,(e+1)%4*4+3]);return new m(16,t)}case"sousselier":{const t=[];for(let e=0;e<5;e++)t.push([0,e*3+1]),t.push([e*3+2,(e*3+5)%15+1]);for(let e=0;e<15;e++)t.push([e+1,(e+1)%15+1]);return t.push([2,12],[5,15]),new m(16,t)}case"sylvester":{const t=[];for(let e=0;e<6;e++)t.push([e*6,e*6+2]),t.push([e*6,e*6+5]),t.push([e*6,(e+1)%6*6+4]),t.push([e*6,(e+3)%6*6+1]),t.push([e*6,(e+3)%6*6+3]),t.push([e*6+1,e*6+2]),t.push([e*6+1,(e+2)%6*6+4]),t.push([e*6+1,(e+3)%6*6+4]),t.push([e*6+1,(e+4)%6*6+2]),t.push([e*6+2,(e+1)%6*6+5]),t.push([e*6+2,(e+2)%6*6+5]),t.push([e*6+3,e*6+4]),t.push([e*6+3,(e+1)%6*6+3]),t.push([e*6+3,(e+1)%6*6+5]),e<3&&(t.push([e*6+4,(e+3)%6*6+4]),t.push([e*6+5,(e+3)%6*6+5]));return new m(36,t)}case"tutte":{const t=[];for(let e=0;e<3;e++)t.push([0,e*15+1]),t.push([e*15+1,e*15+2]),t.push([e*15+1,e*15+4]),t.push([e*15+2,e*15+3]),t.push([e*15+2,e*15+5]),t.push([e*15+3,e*15+4]),t.push([e*15+3,e*15+7]),t.push([e*15+4,e*15+9]),t.push([e*15+5,e*15+6]),t.push([e*15+5,e*15+10]),t.push([e*15+6,e*15+7]),t.push([e*15+6,e*15+11]),t.push([e*15+7,e*15+8]),t.push([e*15+8,e*15+9]),t.push([e*15+8,e*15+12]),t.push([e*15+9,e*15+15]),t.push([e*15+10,e*15+11]),t.push([e*15+10,e*15+13]),t.push([e*15+11,e*15+12]),t.push([e*15+12,e*15+14]),t.push([e*15+13,e*15+14]),t.push([e*15+14,e*15+15]),t.push([e*15+15,(e+1)%3*15+13]);return new m(46,t)}case"tutte coxeter":{const t=[];for(let e=0;e<30;e++)t.push([e,(e+1)%30]);for(let e=0;e<5;e++)t.push([e*6,(e+1)%5*6+3]),t.push([e*6+1,(e+2)%5*6+2]),t.push([e*6+4,(e+1)%5*6+5]);return new m(30,t)}case"wagner":{const t=[];for(let e=0;e<4;e++)t.push([e,e+1]),t.push([e,e+4]),t.push([e+4,(e+5)%8]);return new m(8,t)}case"wells":{const t=[];for(let e=0;e<8;e++)t.push([e*4,(e+1)%8*4]),t.push([e*4,(e+2)%8*4+3]),t.push([e*4+1,(e+1)%8*4+3]),t.push([e*4+1,(e+2)%8*4]),t.push([e*4+1,(e+2)%8*4+3]),t.push([e*4+1,(e+3)%8*4+2]),t.push([e*4+2,(e+1)%8*4]),t.push([e*4+2,(e+3)%8*4+2]),t.push([e*4+3,(e+1)%8*4+1]),t.push([e*4+3,(e+3)%8*4+2]);return new m(32,t)}case"wiener araya":{const t=[];for(let e=0;e<4;e++)t.push([e*10,e*10+1]),t.push([e*10,e*10+2]),t.push([e*10,(e+1)%4*10]),t.push([e*10+1,e*10+3]),t.push([e*10+1,e*10+5]),t.push([e*10+2,e*10+4]),t.push([e*10+2,(e+1)%4*10+5]),t.push([e*10+3,e*10+4]),t.push([e*10+3,e*10+7]),t.push([e*10+4,e*10+9]),t.push([e*10+5,e*10+6]),t.push([e*10+6,e*10+7]),t.push([e*10+6,(e+3)%4*10+9]),t.push([e*10+7,e*10+8]),t.push([e*10+8,e*10+9]),e%2===1?(t.push([e*10+8,(e+1)%4*10+8]),t.push([e*10+8,e===1?40:41])):t.push([e*10+9,e===0?40:41]);return t.push([40,41]),new m(42,t)}}}get order(){return this._nodes.length}get size(){return this._edges.length}get nodes(){return this._nodes}get edges(){return this._edges}toDot(){let s=this.isUndirected()?"graph":"digraph";s+=` g {
`;for(let t=0;t<this._nodes.length;t++)s+=`  ${t} [label="${JSON.stringify(this._nodes[t]??t).replace('"',"'")}"];
`;for(const t of this._edges)s+=`  ${t[0]} ${t.direct?"->":"--"} ${t[1]}`,t.weighted&&(s+=` [label="${JSON.stringify(t.value).replace('"',"'")}"]`),s+=`;
`;return s+"}"}toString(){let s=`Number of nodes: ${this._nodes.length}
`;this._nodes.some(t=>t!=null)&&(s+=`Node values: ${JSON.stringify(this._nodes)}
`),s+=`Number of edges: ${this._edges.length}`,this._edges.length>0&&(s+=`
Edges`);for(const t of this._edges)s+=`
  From ${t[0]} to ${t[1]}, value: ${JSON.stringify(t.value)} (${t.direct?"directed":"undirected"})`;return s}copy(){const s=this._edges.map(e=>new Edge(e[0],e[1],e.value0,e.direct)),t=this._nodes.concat();return new m(t,s)}degree(s,t=!0,e=!0){(t==="in"||t==="out")&&(e=t,t=!1);let n=0;for(const i of this._edges)(t&&!i.direct&&(i[0]===s||i[1]===s)||e===!0&&i.direct&&(i[0]===s||i[1]===s)||e==="in"&&i.direct&&i[1]===s||e==="out"&&i.direct&&i[0]===s)&&n++;return n}adjacencies(s,t=!0,e=!0){(t==="in"||t==="out")&&(e=t,t=!1);const n=new Set;for(const l of this._edges)t&&!l.direct&&(l[0]===s||l[1]===s)||e===!0&&l.direct&&(l[0]===s||l[1]===s)?n.add(l[0]===s?l[1]:l[0]):e==="in"&&l.direct&&l[1]===s?n.add(l[0]):e==="out"&&l.direct&&l[0]===s&&n.add(l[1]);const i=[...n];return i.sort((l,h)=>l-h),i}components(){const s=Array(this._nodes.length).fill(!1),t=[0],e=[];let n=[];for(;t.length>0||s.some(i=>!i);){t.length===0&&(n.sort((l,h)=>l-h),e.push(n),n=[]);const i=t.length>0?t.pop():s.indexOf(!1);if(!s[i]){s[i]=!0,n.push(i);for(const l of this._edges)l[0]===i&&t.push(l[1]),l[1]===i&&t.push(l[0])}}return n.length>0&&(n.sort((i,l)=>i-l),e.push(n)),e}biconnectedComponents(){const s=this.toSimple().toUndirected(),t=s.components(),e=[];for(;t.length>0;){const n=t.pop(),i=s.inducedSub(n),l=i.articulations();if(l.length===0){e.push(n);continue}const h=l[0];i.removeNode(h);const c=i.components();for(let r=0;r<c.length;r++){const f=[];for(let u=0;u<c[r].length;u++)c[r][u]>=h?f.push(n[c[r][u]+1]):f.push(n[c[r][u]]);f.push(n[h]),f.sort((u,d)=>u-d),t.push(f)}}return e}diameter(){const s=this.shortestPathFloydWarshall();let t=-1/0;for(let e=0;e<this._nodes.length;e++)for(let n=0;n<this._nodes.length;n++)t<s[e][n].length&&(t=s[e][n].length);return t}eccentricity(s){const t=this.shortestPathBellmanFord(s);let e=-1/0;for(let n=0;n<this._nodes.length;n++)e<t[n].length&&(e=t[n].length);return e}radius(){const s=this.shortestPathFloydWarshall();let t=1/0;for(let e=0;e<this._nodes.length;e++){let n=-1/0;for(let i=0;i<this._nodes.length;i++)n<s[e][i].length&&(n=s[e][i].length);t>n&&(t=n)}return t}center(){const s=this.shortestPathFloydWarshall(),t=Array(this._nodes.length).fill(-1/0);let e=1/0;for(let i=0;i<this._nodes.length;i++){for(let l=0;l<this._nodes.length;l++)t[i]<s[i][l].length&&(t[i]=s[i][l].length);e>t[i]&&(e=t[i])}const n=[];for(let i=0;i<t.length;i++)t[i]===e&&n.push(i);return n}girth(){let s=1/0;for(let t=0;t<this._nodes.length;t++){const e=[[[t],Array(this._edges.length).fill(!1)]];for(;e.length>0;){const[n,i]=e.shift(),l=n[n.length-1];for(let h=0;h<this._edges.length;h++){if(i[h])continue;const c=this._edges[h];if(c[0]===l){if(c[1]===t){n.length<s&&(s=n.length),e.length=0;break}else if(n.includes(c[1]))continue;const r=i.concat();r[h]=!0,e.push([n.concat(c[1]),r])}if(!c.direct&&c[1]===l){if(c[0]===t){n.length<s&&(s=n.length),e.length=0;break}else if(n.includes(c[0]))continue;const r=i.concat();r[h]=!0,e.push([n.concat(c[0]),r])}}}}return s}clique(s){const t=this._nodes.length;if(s!=null&&s>t)return[];const e=Array.from({length:t},(c,r)=>[r]);if(s===1)return e;if(t===1)return[e];const n=[],i=[];for(let c=0;c<t;c++){n[c]=[];for(let r=0;r<c;r++)this.getEdges(c,r).length>0&&(n[c][r]=!0,n[r][c]=!0,i.push([r,c]))}if(s===2)return i;const l=s??this._nodes.length,h=[e,i];for(let c=2;c<l;c++){const r=[];for(let f=0;f<h[c-1].length;f++){const u=h[c-1][f];for(let d=u.at(-1)+1;d<t;d++)u.every(o=>n[o][d])&&r.push(u.concat(d))}h.push(r)}return s==null?h:h[s-1]}chromaticNumber(){const s=this._nodes.length;return s<=1?s:this._edges.length===0?1:this.isBipartite()?2:this.isComplete()?this._nodes.length:this.chromaticNumberWelchPowell()}chromaticNumberWelchPowell(){const s=this._nodes.length,t=this.adjacencyList(),e=[];for(let l=0;l<s;l++)e[l]=[l,this.degree(l)];e.sort((l,h)=>h[1]-l[1]);let n=0;const i=Array(s).fill(-1);for(;;){const l=i.indexOf(-1);if(l<0)break;i[l]=n;for(let h=0;h<s;h++)i[h]>=0||t[h].every(c=>i[c]!==n)&&(i[h]=n);n++}return n}chromaticIndex(){const s=this.components();let t=0;for(let e=0;e<s.length;e++){const n=this.inducedSub(s[e]);let i=-1;if(n._edges.length<=1)i=n._edges.length;else if(n.isBipartite()){i=0;for(let l=0;l<n._nodes.length;l++)i=Math.max(i,n.degree(l))}else if(n.isComplete())i=n._nodes.length%2===0?n._nodes.length-1:n._nodes.length;else throw new GraphException("Not implemented");t=Math.max(t,i)}return t}articulations(){return this.articulationsLowLink()}articulationsEachNodes(){const s=this._nodes.length,t=[];for(let e=0;e<s;e++){const n=this.adjacencies(e).filter(h=>h!==e);if(n.length<=1)continue;const i=Array(s).fill(!1);i[e]=!0;const l=[n[0]];for(;l.length>0;){const h=l.pop();if(!i[h]){i[h]=!0;for(const c of this._edges)c[0]===h&&l.push(c[1]),c[1]===h&&l.push(c[0])}}n.some(h=>!i[h])&&t.push(e)}return t}articulationsLowLink(){const s=this._nodes.length;if(s===0)return[];const t=Array(s).fill(-1),e=[],n=Array(s).fill(-1),i=this.adjacencyList();let l=0;const h=[],c=j(r=>{t[r]=e[r]=l++;let f=0,u=!1;for(const d of i[r])t[d]<0?(n[d]=r,c(d),f++,e[d]>=t[r]&&(u=!0),e[r]=Math.min(e[r],e[d])):d!==n[r]&&(e[r]=Math.min(e[r],t[d]));(n[r]>=0&&u||n[r]<0&&f>1)&&h.push(r)},"search");return c(0),h.sort((r,f)=>r-f),h}bridges(){return this.bridgesLowLink()}bridgesLowLink(){const s=this._nodes.length;if(s===0||this._edges.length===0)return[];const t=Array(s).fill(-1),e=[],n=Array(s).fill(-1),i=this.adjacencyList();let l=0;const h=j(f=>{t[f]=e[f]=l++;for(const u of i[f])t[u]<0?(n[u]=f,h(u),e[f]=Math.min(e[f],e[u])):u!==n[f]&&(e[f]=Math.min(e[f],t[u]))},"search");h(0);const c=Array.from({length:s},()=>Array(s).fill(0));for(const f of this._edges)c[f[0]][f[1]]++,c[f[1]][f[0]]++;const r=[];for(const f of this._edges)c[f[0]][f[1]]===1&&(t[f[0]]<e[f[1]]||t[f[1]]<e[f[0]])&&r.push(f);return r}addNode(s){this._nodes[this._nodes.length]=s}getNode(s){if(s==null)return this._nodes;if(Array.isArray(s)){if(s.some(t=>t<0||this._nodes.length<=t))throw new GraphException("Index out of bounds.");return s.map(t=>this._nodes[t])}if(s<0||this._nodes.length<=s)throw new GraphException("Index out of bounds.");return this._nodes[s]}removeNode(s){if(s<0||this._nodes.length<=s)throw new GraphException("Index out of bounds.");this._nodes.splice(s,1);for(let t=this._edges.length-1;t>=0;t--){const e=this._edges[t];e[0]===s||e[1]===s?this._edges.splice(t,1):(e[0]>s&&e[0]--,e[1]>s&&e[1]--)}}clearNodes(){this._nodes=[],this._edges=[]}addEdge(s,t,e=null,n=!1){if(s<0||this._nodes.length<=s||t<0||this._nodes.length<=t)throw new GraphException("Index out of bounds.");this._edges.push(new Edge(s,t,e,n))}getEdges(s,t,e=!0,n=!0){if(s<0||this._nodes.length<=s||t<0||this._nodes.length<=t)throw new GraphException("Index out of bounds.");(e==="forward"||e==="backward")&&(n=e,e=!1);const i=[];for(const l of this._edges)((e&&!l.direct||n===!0&&l.direct)&&(l[0]===s&&l[1]===t||l[0]===t&&l[1]===s)||n==="forward"&&l.direct&&l[0]===s&&l[1]===t||n==="backward"&&l.direct&&l[0]===t&&l[1]===s)&&i.push(l);return i}removeEdges(s,t,e=null){if(s<0||this._nodes.length<=s||t<0||this._nodes.length<=t)throw new GraphException("Index out of bounds.");for(let n=this._edges.length-1;n>=0;n--){const i=this._edges[n];(e===null||!e==!i.direct)&&(i[0]===s&&i[1]===t||i[1]===s&&i[0]===t)&&this._edges.splice(n,1)}}clearEdges(){this._edges=[]}adjacencyMatrix(){const s=Array.from({length:this._nodes.length},()=>Array(this._nodes.length).fill(0));for(const t of this._edges)t.direct?s[t[0]][t[1]]+=t.value:(s[t[0]][t[1]]+=t.value,s[t[1]][t[0]]+=t.value);return s}adjacencyList(s="both"){const t=this._nodes.length,e=Array.from({length:t},()=>new Set);for(const n of this._edges)n[0]===n[1]?e[n[0]].add(n[1]):n.direct&&s!=="both"?s==="in"?e[n[1]].add(n[0]):e[n[0]].add(n[1]):(e[n[0]].add(n[1]),e[n[1]].add(n[0]));for(let n=0;n<t;n++)e[n]=[...e[n]],e[n].sort((i,l)=>i-l);return e}degreeMatrix(s="both"){const t=Array.from({length:this._nodes.length},()=>Array(this._nodes.length).fill(0));for(const e of this._edges)e.direct&&s!=="both"?s==="in"?t[e[1]][e[1]]+=e.value:t[e[0]][e[0]]+=e.value:(t[e[0]][e[0]]+=e.value,t[e[1]][e[1]]+=e.value);return t}laplacianMatrix(){const s=this.adjacencyMatrix(),t=[];for(let e=0;e<this._nodes.length;e++){t[e]=s[e].map(n=>-n);for(let n=0;n<this._nodes.length;n++)t[e][e]+=s[e][n]}return t}isNull(){return this._nodes.length===0}isEdgeless(){return this._edges.length===0}isUndirected(){return this._edges.every(s=>!s.direct)}isDirected(){return this._edges.every(s=>s.direct)}isMixed(){let s=!1,t=!1;for(const e of this._edges)if(e.direct?s=!0:t=!0,s&&t)return!0;return!1}isOriented(){const s=this._nodes.length,t=Array.from({length:s},()=>Array(s).fill(!1));for(const e of this._edges){if(!e.direct||t[e[0]][e[1]])return!1;t[e[0]][e[1]]=t[e[1]][e[0]]=!0}return!0}isWeighted(){return this._edges.some(s=>s.weighted)}isSimple(){const s=Array.from({length:this._nodes.length},()=>[]);for(const t of this._edges){if(t[0]===t[1]||s[t[0]].includes(t[1])||s[t[1]].includes(t[0]))return!1;s[t[0]].push(t[1])}return!0}isConnected(){const s=Array(this._nodes.length).fill(!1),t=[0];for(;t.length>0;){const e=t.pop();if(!s[e]){s[e]=!0;for(const n of this._edges)n[0]===e&&!s[n[1]]&&t.push(n[1]),!n.direct&&n[1]===e&&!s[n[0]]&&t.push(n[0])}}return s.every(e=>e)}isBiconnected(){return this.articulations().length===0}isTree(){return this.isConnected()&&!this.hasCycle()}isForest(){return!this.hasCycle()}isBipartite(){const s=Array(this._nodes.length).fill(!1),t=[[0,1]];for(;t.length>0||s.some(e=>!e);){const[e,n]=t.length>0?t.pop():[s.indexOf(!1),1];if(s[e]){if(s[e]===n)continue;return!1}s[e]=n;for(const i of this._edges){if(i[0]===e){if(s[i[1]]===n)return!1;t.push([i[1],n%2+1])}if(!i.direct&&i[1]===e){if(s[i[0]]===n)return!1;t.push([i[0],n%2+1])}}}return!0}isComplete(){for(let s=0;s<this._nodes.length;s++)for(let t=0;t<s;t++)if(this.getEdges(s,t).length===0)return!1;return!0}isRegular(s=null){if(this._nodes.length<=1)return!0;const t=this.degree(0);for(let e=1;e<this._nodes.length;e++){const n=this.degree(e);if(t!==n||s!==null&&n!==s)return!1}return!0}isPlainer(){const s=this.toSimple().toUndirected();return s.components().every(e=>{const n=s.inducedSub(e),i=n._nodes.length,l=n._edges.length;if(i<=4||l<=8)return!0;if(l>3*i-6||n.clique(5).length>0)return!1;if(i<=5)return!0;const h=n.girth();if(l>h*(i-2)/(h-2))return!1;let c=[];for(let r=0;r<i;r++)this.adjacencies(r).length<=5&&c.push(r);return c.length===0?!1:n.isPlainerAddVertex()})}isPlainerAddEdge(){throw new Error("Not implement")}isPlainerAddVertex(){const s=j((i,l)=>{let h=0,c=0;const r=[],f=[i];for(;f.length>0;){const u=f.pop();u.children&&u.children.length>0?f.push(...u.children):l.includes(u.value)&&r.push(u)}for(;r.length+h+c>1;){if(r.length===0)return!1;const u=r.shift();u.mark="blocked";const d=u.parent?.children.indexOf(u)??null,o=[];d!==null&&u.parent.type==="q"&&(d>0&&o.push(u.parent.children[d-1]),d<u.parent.children.length-1&&o.push(u.parent.children[d+1]));const p=o.filter(a=>a.mark==="blocked");if((o.filter(a=>a.mark==="unblocked").length>0||o.length<2)&&(u.mark="unblocked"),u.mark==="unblocked"){const a=u.parent;if(p.length>0){for(let g=d-1;g>=0&&a.children[g].mark==="blocked";g--)a.children[g].mark="unblocked",a.pertinentChildCount=(a.pertinentChildCount??0)+1;for(let g=d+1;g<a.children.length&&a.children[g].mark==="blocked";g++)a.children[g].mark="unblocked",a.pertinentChildCount=(a.pertinentChildCount??0)+1}a?(a.pertinentChildCount=(a.pertinentChildCount??0)+1,a.mark||(a.mark="queued",r.push(a))):c=1,h-=p.length}else h+=1-p.length}return!0},"bubble"),t=j((i,l)=>{const h=[i];for(;;){const r=[];let f=!1;for(let u=0;u<h.length;u++)h[u].label=null,h[u].pertinentLeafCount=0,h[u].children&&h[u].children.length>0?(r.push(...h[u].children),f=!0):(l.includes(h[u].value)&&(h[u].pertinentLeafCount=1),r.push(h[u]));if(h.splice(0,h.length,...r),!f)break}const c=h.reduce((r,f)=>r+(l.includes(f.value)?1:0),0);for(;h.length>0;){const r=h.shift();if(r.parent&&(r.parent.pertinentLeafCount+=r.pertinentLeafCount),!r.children||r.children.length===0)r.label=l.includes(r.value)?"full":"empty";else{const f=[],u=[],d=[];for(let o=0;o<r.children.length;o++)r.children[o].label==="empty"?f.push(r.children[o]):r.children[o].label==="full"?u.push(r.children[o]):d.push(r.children[o]);if(f.length===r.children.length)r.label="empty";else if(u.length===r.children.length)r.label="full";else if(r.type==="p")if(f.length+u.length===r.children.length)if(r.pertinentLeafCount===c){r.children=f;const o={type:"p",children:u,label:"full",parent:r};o.children.forEach(p=>p.parent=o),r.children.push(o)}else{if(r.type="q",r.children=[],f.length===1)r.children.push(f[0]);else{const o={type:"p",children:f,label:"empty",parent:r};o.children.forEach(p=>p.parent=o),r.children.push(o)}if(u.length===1)r.children.push(u[0]);else{const o={type:"p",children:u,label:"full",parent:r};o.children.forEach(p=>p.parent=o),r.children.push(o)}r.label="partial"}else if(r.pertinentLeafCount===c)if(r.children=f,d.length===1){if(r.children.push(d[0]),u.length>0){const o={type:"p",children:u,label:"full",parent:d[0]};o.children.forEach(p=>p.parent=o),d[0].children.push(o)}}else if(d.length===2){const o={type:"q",children:[],label:"partial"};o.children.push(...d[0].children),o.children.push(...u),o.children.push(...d[1].children.reverse()),o.children.forEach(p=>p.parent=o),r.children.push(o),r.children.forEach(p=>p.parent=r)}else return!1;else if(d.length===1){if(r.type="q",r.children=[],f.length>0){const o={type:"p",children:f,label:"empty"};o.children.forEach(p=>p.parent=o),r.children.push(o)}if(r.children.push(...d[0].children),u.length>0){const o={type:"p",children:u,label:"full"};o.children.forEach(p=>p.parent=o),r.children.push(o)}r.label="partial",r.children.forEach(o=>o.parent=r)}else return!1;else if(r.type==="q"){if(r.children.at(-1).label==="empty"&&r.children.reverse(),r.pertinentLeafCount===c)if(d.length===0){let o="empty",p=0;for(let _=0;_<r.children.length;_++)if(r.children[_].label!==o&&p<2)o=o==="empty"?"full":"empty",p++;else if(r.children[_].label!==o)return!1}else if(d.length===1){let o="empty",p=0;const _=[];for(let a=0;a<r.children.length;a++)if(r.children[a].label==="partial")o==="empty"?(_.push(...r.children[a].children),o="full"):(_.push(...r.children[a].children.reverse()),o="empty");else if(r.children[a].label!==o&&p<1)o=o==="empty"?"full":"empty",p++,_.push(r.children[a]);else if(r.children[a].label===o)_.push(r.children[a]);else return!1;r.children=_,r.children.forEach(a=>a.parent=r)}else if(d.length===2){let o="empty";const p=[];for(let _=0;_<r.children.length;_++)if(r.children[_].label==="partial")o==="empty"?(p.push(...r.children[_].children),o="full"):(p.push(...r.children[_].children.reverse()),o="empty");else if(r.children[_].label===o)p.push(r.children[_]);else return!1;r.children=p,r.children.forEach(_=>_.parent=r)}else return!1;else if(d.length===0){let o="empty";for(let p=0;p<r.children.length;p++)if(r.children[p].label==="full")o="full";else if(r.children[p].label!==o)return!1}else if(d.length===1){let o="empty";const p=[];for(let _=0;_<r.children.length;_++)if(r.children[_].label==="partial")p.push(...r.children[_].children),o="full";else if(r.children[_].label===o)p.push(r.children[_]);else return!1;r.children=p,r.children.forEach(_=>_.parent=r)}else return!1;r.label="partial"}}if(r.pertinentLeafCount===c)break;r.parent&&r.parent.children.every(f=>f.label)&&h.push(r.parent)}return!0},"reduce"),e=j((i,l)=>{const h=[],c=[i];for(;c.length>0;){const f=c.pop();f.children&&f.children.length>0?(f.pertinentLeafCount=0,c.push(...f.children)):l.includes(f.value)&&(f.pertinentLeafCount=1,h.push(f))}const r=h.length;for(;h.length>0;){const f=h.pop();if(f.pertinentLeafCount===r)return f;const u=f.parent;u&&(u.pertinentLeafCount++,h.push(u))}return i},"getRoot");return this.biconnectedComponents().every(i=>{const l=this.inducedSub(i),h=l._nodes.length,c=l.adjacencyList();for(let o=0;o<h;o++){const p=c[o].indexOf(o);p>=0&&c[o].splice(p,1)}const f=l._stNumbering().map((o,p)=>[o,p]);f.sort((o,p)=>o[0]-p[0]);const u=f.map(o=>o[1]),d={type:"p",children:c[u[0]].map(o=>({value:o}))};d.children.forEach(o=>o.parent=d);for(let o=1;o<h;o++){const p=s(d,[u[o]]),_=t(d,[u[o]]);if(!p||!_)return!1;const a=c[u[o]].filter(w=>u.indexOf(w)>o).map(w=>({value:w})),g=e(d,[u[o]]);if(g.type==="q"){const w={type:"p",children:a,parent:g};w.children.forEach(v=>v.parent=w);const y=[];let b=!1;for(let v=0;v<g.children.length;v++)g.children[v].label==="full"?b||(y.push(w),b=!0):y.push(g.children[v]);g.children=y,g.children.length===2&&(g.type="p")}else g.type="p",g.value=void 0,g.children=a,g.children.forEach(w=>w.parent=g)}return!0})}_stNumbering(s=0,t=null){const e=this._nodes.length;if(e===0)return[];if(e===1)return[1];if(this.articulations().length>0)throw new Error("Only biconnected graph can calculate st-numbering");const n=this.adjacencyList();for(let a=0;a<e;a++){const g=n[a].indexOf(a);g>=0&&n[a].splice(g,1)}t??=n[s][0];const i=Array(e).fill("new"),l=Array(e).fill(1/0),h=Array(e).fill(-1),c=Array(e).fill(1/0),r=[];let f=1;const u=j(a=>{i[a]="old",l[a]=f++,c[a]=l[a];for(const g of n[a])i[g]==="new"?(r.push([a,g,"tree"]),h[g]=a,u(g),c[a]=Math.min(c[a],c[g])):h[a]!==g&&(r.push([a,g,"back"]),c[a]=Math.min(c[a],l[g]))},"search");u(t);const d=[t,s],o=[];i.fill("new");const p=Array(r.length).fill("new");p[0]="old";let _=1;for(;d.length>0;){const a=d.pop();if(a===t){o[t]=_;break}const g=[];for(let w=0;w<r.length;w++){if(p[w]!=="new")continue;const y=r[w];if(y[0]===a&&y[2]==="back"){p[w]="old",g.push(a,y[1]);break}else if(y[0]===a&&y[2]==="tree"){let b=y[1];for(g.push(a,b),p[w]=i[b]=i[a]="old";b>=0;){const v=c[b];for(let A=0;A<r.length;A++)if(r[A][0]===b&&r[A][2]==="back"&&l[r[A][1]]===v){b=r[A][1],g.push(b),i[b]=p[A]="old",b=-1;break}else if(r[A][0]===b&&r[A][2]==="tree"){b=r[A][1],g.push(b),i[b]=p[A]="old";break}}break}else if(y[1]===a&&y[2]==="back"){let b=y[0];for(g.push(a,b),i[a]=p[w]="old";i[b]!=="old";){i[b]="old";for(let v=0;v<r.length;v++)if(r[v][1]===b&&r[v][2]==="tree"){b=r[v][0],g.push(b),p[v]="old";break}}break}}if(g.length===0)o[a]=_++;else for(let w=g.length-2;w>=0;w--)d.push(g[w])}return o}isSymmetric(){if(this._nodes.length<=1||this._edges.length<=1)return!0;throw new GraphException("Not implemented")}isDAG(){return this.isDirected()&&!this.hasCycle()}isSeparable(){return!this.isBiconnected()}isEulerian(){if(!this.isConnected())return!1;const s=Array.from(this._nodes,()=>({und:0,dir:0}));for(const t of this._edges)t.direct?(s[t[0]].dir--,s[t[1]].dir++):(s[t[0]].und++,s[t[1]].und++);for(let t=0;t<s.length;t++){if(Math.abs(s[t].dir)>s[t].und)return!1;if((s[t].und-Math.abs(s[t].dir))%2===1)return!1}return!0}isSemiEulerian(){if(!this.isConnected())return!1;const s=Array.from(this._nodes,()=>({und:0,dir:0}));for(const i of this._edges)i.direct?(s[i[0]].dir--,s[i[1]].dir++):(s[i[0]].und++,s[i[1]].und++);let t=0,e=0,n=0;for(let i=0;i<s.length;i++){if(Math.abs(s[i].dir)<=s[i].und)(s[i].und-Math.abs(s[i].dir))%2===1&&t++;else{if(Math.abs(s[i].dir)>=2)return!1;s[i].dir>0?e++:n++}if(t+e+n>2||e>=2||n>=2)return!1}return!(t===0&&e===0&&n===0)}isHamiltonian(){if(this._nodes.length>=3&&this.isSimple()){let t=1/0;for(let e=0;e<this._nodes.length;e++)t=Math.min(t,this.degree(e));if(t>=this._nodes.length/2)return!0}return this.isConnected()?this.hamiltonianCycle().length>0:!1}isSemiHamiltonian(){if(this._nodes.length>=3&&this.isSimple()){let t=1/0;for(let e=0;e<this._nodes.length;e++)t=Math.min(t,this.degree(e));if(t>=this._nodes.length/2)return!1}if(!this.isConnected())return!1;const s=this.hamiltonianPath();return s.length===0?!1:this._nodes.length<=2?this.hamiltonianCycle().length===0:s.every(t=>this.getEdges(t.at(-1),t[0],!0,"forward").length===0)}hasCycle(){return this.isUndirected()?this.hasCycleDFS():this.hasCycleEachNodes()}hasCycleDFS(){if(!this.isUndirected())throw new GraphException("This method only works undirected graph.");const s=Array(this._nodes.length).fill(!1),t=Array(this._edges.length).fill(!1),e=[0];for(;e.length>0||s.some(n=>!n);){const n=e.length>0?e.pop():s.indexOf(!1);if(s[n])return!0;s[n]=!0;for(let i=0;i<this._edges.length;i++){if(t[i])continue;const l=this._edges[i];if(l[0]===n){if(s[l[1]])return!0;t[i]=!0,e.push(l[1])}if(!l.direct&&l[1]===n){if(s[l[0]])return!0;t[i]=!0,e.push(l[0])}}}return!1}hasCycleEachNodes(){for(let s=0;s<this._nodes.length;s++){const t=[[[s],Array(this._edges.length).fill(!1)]];for(;t.length>0;){const[e,n]=t.pop(),i=e[e.length-1];for(let l=0;l<this._edges.length;l++){if(n[l])continue;const h=this._edges[l];if(h[0]===i){if(h[1]===s)return!0;if(e.includes(h[1]))continue;const c=n.concat();c[l]=!0,t.push([e.concat(h[1]),c])}if(!h.direct&&h[1]===i){if(h[0]===s)return!0;if(e.includes(h[0]))continue;const c=n.concat();c[l]=!0,t.push([e.concat(h[0]),c])}}}}return!1}toUndirected(){const s=this.copy();for(const t of s._edges)t.direct=!1;return s}toSimple(){const s=this._nodes.length,t=new m(this._nodes.concat()),e=Array.from({length:s},()=>Array(s).fill(!1));for(const n of this._edges)n[0]!==n[1]&&!e[n[0]][n[1]]&&(t.addEdge(n[0],n[1],n.value0,n.direct),e[n[0]][n[1]]=e[n[1]][n[0]]=!0);return t}isomorphism(s){return this.isomorphismUllmann(s)}isomorphismUllmann(s){if(!this.isUndirected())throw new GraphException("Currentry, isomorphismUllmann is only implemented for undirected graph.");const t=this._nodes.length,e=x.zeros(t,t);for(const u of this._edges)e.set(u[0],u[1],1),e.set(u[1],u[0],1);const n=this.adjacencyList(),i=s._nodes.length,l=Array.from(s._nodes,()=>Array(i).fill(0));for(const u of s._edges)l[u[0]][u[1]]=l[u[1]][u[0]]=1;const h=s.adjacencyList(),c=[],r=j((u,d,o)=>{if(d===i){const p=o.dot(o.dot(e).t);let _=!0;for(let a=0;a<i&&_;a++)for(let g=0;g<i&&_;g++)l[a][g]===1&&p.at(a,g)===0&&(_=!1);if(_){const a=[];for(let g=0;g<t;g++)u[g]>=0&&(a[u[g]]=g);c.push(a)}return}o=o.copy();for(let p=0;p<i;p++)for(let _=0;_<t;_++)if(o.at(p,_)===1){for(const a of h[p])if(n[_].every(g=>o.at(a,g)!==1)){o.set(p,_,0);break}}if(!o.sum(1).every(p=>p===0))for(let p=0;p<t;p++){if(u[p]>=0||o.at(d,p)===0)continue;const _=[];for(let a=0;a<t;a++)_.push(o.at(d,a)),o.set(d,a,a===p?1:0);u[p]=d,r(u.concat(),d+1,o),u[p]=-1;for(let a=0;a<t;a++)o.set(d,a,_[a])}},"check"),f=x.zeros(i,t);for(let u=0;u<i;u++)for(let d=0;d<t;d++)h[u].length<=n[d].length&&f.set(u,d,1);return r(Array(t).fill(-1),0,f),c}isomorphismVF2(s){throw new GraphException("Not implemented")}inducedSub(s){const t=[];for(const n of this._edges){const i=s.indexOf(n[0]),l=s.indexOf(n[1]);i>=0&&l>=0&&t.push(new Edge(i,l,n.value0,n.direct))}const e=s.map(n=>this._nodes[n]);return new m(e,t)}complement(){if(this._nodes.length===0)return new m(0);const s=[];for(let t=0;t<this._nodes.length;t++)for(let e=0;e<t;e++)this.getEdges(t,e).length===0&&s.push(new Edge(e,t));return new m(this._nodes.concat(),s)}line(){const s=new m(this._edges.concat()),t=s._nodes.length;for(let e=0;e<t;e++)for(let n=0;n<e;n++)s._nodes[e][0]===s._nodes[n][0]||s._nodes[e][0]===s._nodes[n][1]?s.addEdge(e,n,this._nodes[s._nodes[e][0]]):(s._nodes[e][1]===s._nodes[n][0]||s._nodes[e][1]===s._nodes[n][1])&&s.addEdge(e,n,this._nodes[s._nodes[e][1]]);return s}contraction(s,t){if(s!==t){t<s&&([s,t]=[t,s]),this._nodes.splice(t,1);for(let e=this._edges.length-1;e>=0;e--){const n=this._edges[e];n[0]===s&&n[1]===t||n[1]===s&&n[0]===t?this._edges.splice(e,1):(n[0]===t?n[0]=s:n[0]>s&&n[0]--,n[1]===t?n[1]=s:n[1]>s&&n[1]--)}}}subdivision(s,t){this._nodes.push(null);const e=this._nodes.length-1;for(let n=this._edges.length-1;n>=0;n--){const i=this._edges[n];(i[0]===s&&i[1]===t||i[1]===s&&i[0]===t)&&(this._edges.splice(n,1),this._edges.push(new Edge(i[0],e,i.value0,i.direct)),this._edges.push(new Edge(e,i[1],i.value0,i.direct)))}}cleaving(s){this._nodes.push(null);const t=this._nodes.length-1;for(let e=this._edges.length-1;e>=0;e--){const n=this._edges[e];n[0]===s&&n[1]===s?this._edges.push(new Edge(t,t,n.value0,n.direct)):n[0]===s?this._edges.push(new Edge(t,n[1],n.value0,n.direct)):n[1]===s&&this._edges.push(new Edge(n[0],t,n.value0,n.direct))}}disjointUnion(s){const t=this._nodes.length;this._nodes=this._nodes.concat(s._nodes);for(const e of s._edges)this._edges.push(new Edge(e[0]+t,e[1]+t,e.value0,e.direct))}substitution(s,t){if(t._nodes.length===0)this.removeNode(s);else if(t._nodes.length===1)for(const e of t._edges)this._edges.push(new Edge(e[0]+s,e[1]+s,e.value0,e.direct));else{const e=this._nodes.length;this._nodes[s]=t._nodes[0],this._nodes=this._nodes.concat(t._nodes.slice(1));for(const n of this._edges)if(n[0]===s||n[1]===s)for(let i=0;i<t._nodes.length-1;i++)this._edges.push(new Edge(n[0]===s?e+i:n[0],n[1]===s?e+i:n[1],n.value0,n.direct));for(const n of t._edges)this._edges.push(new Edge(n[0]===0?s:n[0]+e-1,n[1]===0?s:n[1]+e-1,n.value0,n.direct))}}cartesianProduct(s){const t=this._nodes.length,e=s._nodes.length,n=[];for(let l=0;l<t;l++)for(let h=0;h<e;h++)this._nodes[l]!=null||s._nodes[h]!=null?n.push([this._nodes[l],s._nodes[h]]):n.push(null);const i=[];for(const l of this._edges)for(let h=0;h<e;h++)i.push(new Edge(l[0]+t*h,l[1]+t*h,l.value0,l.direct));for(const l of s._edges)for(let h=0;h<t;h++)i.push(new Edge(h+l[0]*t,h+l[1]*t,l.value0,l.direct));return new m(n,i)}tensorProduct(s){const t=this._nodes.length,e=s._nodes.length,n=[];for(let l=0;l<t;l++)for(let h=0;h<e;h++)this._nodes[l]!=null||s._nodes[h]!=null?n.push([this._nodes[l],s._nodes[h]]):n.push(null);const i=[];for(const l of this._edges)for(const h of s._edges)l.direct===h.direct&&(i.push(new Edge(l[0]+h[0]*t,l[1]+h[1]*t,l.weighted||h.weighted?[l.value0,h.value0]:null,l.direct)),l.direct||i.push(new Edge(l[1]+h[0]*t,l[0]+h[1]*t,l.weighted||h.weighted?[l.value0,h.value0]:null,l.direct)));return new m(n,i)}strongProduct(s){const t=this._nodes.length,e=s._nodes.length,n=[];for(let l=0;l<t;l++)for(let h=0;h<e;h++)this._nodes[l]!=null||s._nodes[h]!=null?n.push([this._nodes[l],s._nodes[h]]):n.push(null);const i=[];for(const l of this._edges)for(let h=0;h<e;h++)i.push(new Edge(l[0]+t*h,l[1]+t*h,l.value0,l.direct));for(const l of s._edges)for(let h=0;h<t;h++)i.push(new Edge(h+l[0]*t,h+l[1]*t,l.value0,l.direct));for(const l of this._edges)for(const h of s._edges)l.direct===h.direct&&(i.push(new Edge(l[0]+h[0]*t,l[1]+h[1]*t,l.weighted||h.weighted?[l.value0,h.value0]:null,l.direct)),l.direct||i.push(new Edge(l[1]+h[0]*t,l[0]+h[1]*t,l.weighted||h.weighted?[l.value0,h.value0]:null,l.direct)));return new m(n,i)}lexicographicProduct(s){const t=this._nodes.length,e=s._nodes.length,n=[];for(let l=0;l<t;l++)for(let h=0;h<e;h++)this._nodes[l]!=null||s._nodes[h]!=null?n.push([this._nodes[l],s._nodes[h]]):n.push(null);const i=[];for(const l of this._edges)for(let h=0;h<e;h++)for(let c=0;c<e;c++)i.push(new Edge(l[0]+t*h,l[1]+t*c,l.value0,l.direct));for(const l of s._edges)for(let h=0;h<t;h++)i.push(new Edge(h+l[0]*t,h+l[1]*t,l.value0,l.direct));return new m(n,i)}shortestPath(s){return s==null?this.shortestPathFloydWarshall():this.shortestPathDijkstra(s)}shortestPathBreadthFirstSearch(s){const t=Array.from({length:this._nodes.length},()=>({length:1/0,prev:null,path:[]})),e=[[s,null]];t[s]={length:0,prev:null,path:[s]};const n=Array(this._nodes.length).fill(!1);for(;e.length>0;){const[i,l]=e.shift();if(!n[i]){n[i]=!0,l!=null&&(t[i].prev=l,t[i].length=t[l].length+1,t[i].path=t[l].path.concat(i));for(const h of this._edges)h.value<=0||(h[0]===i&&!n[h[1]]&&e.push([h[1],i]),!h.direct&&h[1]===i&&!n[h[0]]&&e.push([h[0],i]))}}return t}shortestPathDijkstra(s){const t=Array.from({length:this._nodes.length},()=>({length:1/0,prev:null,path:[]})),e=[s];for(t[s]={length:0,prev:null,path:[s]};e.length>0;){const n=e.shift();for(const i of this._edges)i.value<=0||(i[0]===n&&t[i[1]].length>t[n].length+i.value&&(t[i[1]].length=t[n].length+i.value,t[i[1]].prev=n,t[i[1]].path=t[n].path.concat(i[1]),e.push(i[1])),!i.direct&&i[1]===n&&t[i[0]].length>t[n].length+i.value&&(t[i[0]].length=t[n].length+i.value,t[i[0]].prev=n,t[i[0]].path=t[n].path.concat(i[0]),e.push(i[0])))}return t}shortestPathBellmanFord(s){const t=Array.from({length:this._nodes.length},()=>({length:1/0,prev:null,path:[]}));t[s]={length:0,prev:null,path:[s]};for(let e=0;e<this._nodes.length-1;e++)for(const n of this._edges)t[n[1]].length>t[n[0]].length+n.value&&(t[n[1]].length=t[n[0]].length+n.value,t[n[1]].prev=n[0],t[n[1]].path=t[n[0]].path.concat(n[1])),!n.direct&&t[n[0]].length>t[n[1]].length+n.value&&(t[n[0]].length=t[n[1]].length+n.value,t[n[0]].prev=n[1],t[n[0]].path=t[n[1]].path.concat(n[0]));return t}shortestPathFloydWarshall(){const s=[];for(let t=0;t<this._nodes.length;t++)s[t]=Array.from({length:this._nodes.length},()=>({length:1/0,path:[]})),s[t][t]={length:0,path:[t]};for(const t of this._edges)s[t[0]][t[1]].length>t.value&&(s[t[0]][t[1]].length=t.value,s[t[0]][t[1]].path=[t[0],t[1]]),!t.direct&&s[t[1]][t[0]].length>t.value&&(s[t[1]][t[0]].length=t.value,s[t[1]][t[0]].path=[t[1],t[0]]);for(let t=0;t<this._nodes.length;t++)for(let e=0;e<this._nodes.length;e++)for(let n=0;n<this._nodes.length;n++)s[e][n].length>s[e][t].length+s[t][n].length&&(s[e][n].length=s[e][t].length+s[t][n].length,s[e][n].path=s[e][t].path.concat(s[t][n].path.slice(1)));return s}minimumSpanningTree(){return this.minimumSpanningTreePrim()}minimumSpanningTreePrim(){const s=Array(this._nodes.length).fill(!1);s[0]=!0;const t=this._edges.concat(),e=[];for(;s.some(n=>!n);){let n=1/0,i=null;for(let l=t.length-1;l>=0;l--)s[t[l][0]]&&s[t[l][1]]?t.splice(l,1):(s[t[l][0]]&&!s[t[l][1]]||!t[l].direct&&s[t[l][1]]&&!s[t[l][0]])&&n>t[l].value&&(i=t[l],n=t[l].value);e.push(i),s[i[0]]=s[i[1]]=!0}return new m(this._nodes.length,e)}minimumSpanningTreeKruskal(){const s=Array.from({length:this._nodes.length},(n,i)=>i),t=[],e=this._edges.concat();e.sort((n,i)=>n.value-i.value);for(let n=0;n<e.length;n++){const i=e[n],l=s[i[1]];if(s[i[0]]!==l){t.push(i);for(let h=0;h<this._nodes.length;h++)s[h]===l&&(s[h]=s[i[0]])}}return new m(this._nodes.length,t)}minimumSpanningTreeBoruvka(){const s=Array.from({length:this._nodes.length},(e,n)=>n),t=new Set;for(let e=0;e<this._nodes.length-1;e++){const n=[];for(const i of this._edges)s[i[0]]!==s[i[1]]&&((!n[s[i[0]]]||n[s[i[0]]].value>i.value)&&(n[s[i[0]]]=i),(!n[s[i[1]]]||n[s[i[1]]].value>i.value)&&(n[s[i[1]]]=i));if(n.length===0)break;for(const i of n){t.add(i);const l=s[i[1]];for(let h=0;h<this._nodes.length;h++)s[h]===l&&(s[h]=s[i[0]])}}return new m(this._nodes.length,[...t])}hamiltonianPath(s){return this.isConnected()?this.hamiltonianPathDynamicProgramming(s):[]}hamiltonianPathDynamicProgramming(s){const t=this._nodes.length;let e=[];if(typeof s=="number")e.push({s:new Set([s]),v:new Map([[s,[[s]]]])});else for(let i=0;i<t;i++)e.push({s:new Set([i]),v:new Map([[i,[[i]]]])});const n=this.adjacencyList("in");for(let i=1;i<t;i++){const l=[];for(let h=0;h<t;h++)for(let c=0;c<e.length;c++){const r=e[c];if(r.s.has(h))continue;const f=[];for(const d of r.v.keys())n[h].indexOf(d)<0||f.push(...r.v.get(d).map(o=>[...o,h]));if(f.length===0)continue;const u=l.find(d=>[...r.s,h].every(o=>d.s.has(o)));u?u.v.set(h,f):l.push({s:new Set([...r.s,h]),v:new Map([[h,f]])})}e=l}return e.flatMap(i=>[...i.v.values()].flat())}hamiltonianCycle(){if(!this.isConnected())return[];const s=this.hamiltonianPath();return this.order<=1?s:this.order===2?s.length<=1||this.getEdges(0,1).length<=1?[]:[[0,1,0],[1,0,1]]:s.filter(t=>this.getEdges(t.at(-1),t[0],!0,"forward").length>0)}cut(s,t){const e=this.adjacencyMatrix();let n=0;for(let i=0;i<s.length;i++)for(let l=0;l<t.length;l++)n+=e[s[i]][t[l]];return n}mincut(s=1){if(s>Math.floor(this._nodes.length/2))throw new Error(`Invalid minv. ${s}, ${this._nodes.length}`);if(this._nodes.length<=6)return this.mincutBruteForce(s);let[t,e]=this.mincutStoerWagner(s);for(let n=1;n<this._nodes.length&&t!==1/0;n++)[t,e]=this.mincutStoerWagner(s,n);return t===1/0&&([t,e]=this.mincutKargersStein(s)),[t,e]}mincutBruteForce(s=1){const t=this.adjacencyMatrix(),e=Array(this._nodes.length).fill(!1);let n=null,i=1/0;do{const l=[],h=[];for(let c=0;c<this._nodes.length;c++)e[c]?l.push(c):h.push(c);if(l.length>=s&&h.length>=s){let c=0;for(let r=0;r<l.length;r++)for(let f=0;f<h.length;f++)t[l[r]][h[f]]&&(c+=t[l[r]][h[f]]);c<i&&(i=c,n=[l,h])}if(i===0)return[0,n];for(let c=0;c<this._nodes.length;c++){if(!e[c]){e[c]=!0;break}e[c]=!1}}while(e.some(l=>l));return[i,n]}mincutStoerWagner(s=1,t=0){const e=this.adjacencyMatrix(),n=Array.from({length:this._nodes.length},(r,f)=>[f]);let i=null,l=1/0;const h=e.map(r=>r.concat());for(let r=1;r<this._nodes.length;r++){const f=h[t].concat();let u=0,d=t;for(let o=0;o<this._nodes.length-r;o++){f[d]=-1/0,u=d;let p=-1/0;for(let _=0;_<f.length;_++)f[_]>p&&(p=f[_],d=_);for(let _=0;_<this._nodes.length;_++)f[_]+=h[d][_]}f[d]-h[d][d]<l&&n[d].length>=s&&this._nodes.length-n[d].length>=s&&(l=f[d]-h[d][d],i=n[d].concat()),n[u].push(...n[d]);for(let o=0;o<this._nodes.length;o++)h[o][u]=h[u][o]+=h[d][o];h[t][d]=-1/0}if(!i)return[l,[Array.from({length:this._nodes.length},(r,f)=>f)]];const c=[];for(let r=0;r<this._nodes.length;r++)i.includes(r)||c.push(r);return[l,[i,c]]}mincutKargers(s=1,t=null){const e=this.adjacencyMatrix();let n=null,i=1/0;t==null&&(t=this._nodes.length**2*Math.log(this._nodes.length));const l=[];let h=0;for(let c=0;c<this._nodes.length;c++){l[c]=new Set;for(let r=0;r<this._nodes.length;r++)e[c][r]&&(l[c].add(r),h++)}for(let c=0;c<t;c++){const r=Array.from({length:this._nodes.length},(_,a)=>[a]),f=e.map(_=>_.concat()),u=l.map(_=>new Set(_));let d=h,o=0;for(let _=0;_<this._nodes.length-2&&d>0;_++){let a=Math.floor(Math.random()*d);for(o=0;o<this._nodes.length&&u[o].size<=a;o++)a-=u[o].size;let g=0;for(const w of u[o]){if(a===0){g=w;break}a--}for(const w of u[g])u[w].delete(g),d-=1,w!==o&&(f[o][w]||(u[o].add(w),u[w].add(o),d+=2),f[o][w]+=f[g][w],f[w][o]+=f[w][g]);r[o].push(...r[g]),r[g]=null,d-=u[g].size,u[g].clear()}if(d===0)return[0,r.filter(_=>_!==null)];const p=u[o].values().next().value;r[o].length<s||r[p].length<s||f[o][p]<i&&(i=f[o][p],n=[r[o],r[p]])}return n?[i,n]:[i,[Array.from({length:this._nodes.length},(c,r)=>r)]]}mincutKargersStein(s=1,t=null){const e=this.adjacencyMatrix(),n=Array.from({length:this._nodes.length},(h,c)=>[c]);t===null&&(t=Math.log(this._nodes.length)**2);let i=null,l=1/0;for(let h=0;h<t;h++){const[c,r]=this._mincutKargersStein0(e,n,s);c<l&&(l=c,i=r)}return[l,i]}_mincutKargersStein0(s,t,e){const n=s.length;if(n<=6){const f=Array(n).fill(!1);let u=null,d=1/0;do{const o=[],p=[];for(let g=0;g<n;g++)f[g]?o.push(g):p.push(g);const _=o.reduce((g,w)=>g+t[w].length,0),a=p.reduce((g,w)=>g+t[w].length,0);if(_>=e&&a>=e){let g=0;for(let w=0;w<o.length;w++)for(let y=0;y<p.length;y++)s[o[w]][p[y]]&&(g+=s[o[w]][p[y]]);g<d&&(d=g,u=[o.reduce((w,y)=>w.concat(t[y]),[]),p.reduce((w,y)=>w.concat(t[y]),[])])}if(d===0)return[0,u];for(let g=0;g<n;g++){if(!f[g]){f[g]=!0;break}f[g]=!1}}while(f.some(o=>o));return[d,u]}const i=[];let l=0;for(let f=0;f<n;f++){i[f]=new Set;for(let u=0;u<n;u++)s[f][u]&&(i[f].add(u),l++)}const h=n/Math.sqrt(2)+1;let c=null,r=1/0;for(let f=0;f<2;f++){const u=t.map(y=>y.concat()),d=s.map(y=>y.concat()),o=i.map(y=>new Set(y));let p=l,_=0;const a=[];for(let y=0;y<n-h;y++){let b=Math.floor(Math.random()*p);for(_=0;_<this._nodes.length&&o[_].size<=b;_++)b-=o[_].size;let v=0;for(const A of o[_]){if(b===0){v=A;break}b--}for(const A of o[v])o[A].delete(v),p-=1,A!==_&&(d[_][A]||(o[_].add(A),o[A].add(_),p+=2),d[_][A]+=d[v][A],d[A][_]+=d[A][v]);u[_].push(...u[v]),u[v]=null,p-=o[v].size,o[v].clear(),a.push(v)}a.sort((y,b)=>b-y);for(let y=n-1;y>=0;y--)if(u[y]===null)d.splice(y,1),u.splice(y,1);else for(let b=0;b<a.length;b++)d[y].splice(a[b],1);const[g,w]=this._mincutKargersStein0(d,u,e);g<r&&(r=g,c=w)}return[r,c]}bisectionSpectral(){const t=x.fromArray(this.laplacianMatrix()).tridiagLanczos(),e=t.eigenValuesQR(),[,n]=t.eigenInverseIteration(e[1]),i=n.median(),l=[],h=[];for(let r=0;r<this._nodes.length;r++)n.at(r,0)>i?l.push(r):h.push(r);return[this.cut(l,h),[l,h]]}}
