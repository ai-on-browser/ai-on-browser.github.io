import Matrix from"./matrix.js";export default class Graph{constructor(t,e){this._n=t,this._edges=e}static fromAdjacency(t){const e=t.length,n=[];for(let r=0;r<e;r++)for(let l=0;l<e;l++)t[r][l]&&n.push([r,l,+t[r][l]]);return new Graph(e,n)}get order(){return this._n}get size(){return this._edges.length}get edges(){return this._edges}get adjacencyMatrix(){const t=Array.from({length:this._n},(()=>Array(this._n).fill(0)));for(const[e,n,r]of this._edges)t[e][n]=r||1;return t}degreeMatrix(){const t=this.adjacencyMatrix,e=[];for(let n=0;n<this._n;n++){e[n]=Array(this._n).fill(0);for(let r=0;r<this._n;r++)e[n][n]+=t[n][r]}return e}laplacianMatrix(){const t=this.adjacencyMatrix,e=[];for(let n=0;n<this._n;n++){e[n]=t[n].map((t=>-t));for(let r=0;r<this._n;r++)e[n][n]+=t[n][r]}return e}cut(t,e){const n=this.adjacencyMatrix;let r=0;for(let l=0;l<t.length;l++)for(let s=0;s<e.length;s++)r+=n[t[l]][e[s]];return r}mincut(t=1){if(t>Math.floor(this._n/2))throw new Error(`Invalid minv. ${t}, ${this._n}`);if(this._n<=6)return this.mincutBruteForce(t);let[e,n]=this.mincutStoerWagner(t);for(let r=1;r<this._n&&e!==1/0;r++)[e,n]=this.mincutStoerWagner(t,r);return e===1/0&&([e,n]=this.mincutKargersStein(t)),[e,n]}mincutBruteForce(t=1){const e=this.adjacencyMatrix,n=Array(this._n).fill(!1);let r=null,l=1/0;do{const s=[],i=[];for(let t=0;t<this._n;t++)n[t]?s.push(t):i.push(t);if(s.length>=t&&i.length>=t){let t=0;for(let n=0;n<s.length;n++)for(let r=0;r<i.length;r++)e[s[n]][i[r]]&&(t+=e[s[n]][i[r]]);t<l&&(l=t,r=[s,i])}if(0===l)return[0,r];for(let t=0;t<this._n;t++){if(!n[t]){n[t]=!0;break}n[t]=!1}}while(n.some((t=>t)));return[l,r]}mincutStoerWagner(t=1,e=0){const n=this.adjacencyMatrix,r=Array.from({length:this._n},((t,e)=>[e]));let l=null,s=1/0;const i=n.map((t=>t.concat()));for(let n=1;n<this._n;n++){const o=i[e].concat();let a=0,h=e;for(let t=0;t<this._n-n;t++){o[h]=-1/0,a=h;let t=-1/0;for(let e=0;e<o.length;e++)o[e]>t&&(t=o[e],h=e);for(let t=0;t<this._n;t++)o[t]+=i[h][t]}o[h]-i[h][h]<s&&r[h].length>=t&&this._n-r[h].length>=t&&(s=o[h]-i[h][h],l=r[h].concat()),r[a].push(...r[h]);for(let t=0;t<this._n;t++)i[t][a]=i[a][t]+=i[h][t];i[e][h]=-1/0}if(!l)return[s,[Array.from({length:this._n},((t,e)=>e))]];const o=[];for(let t=0;t<this._n;t++)l.indexOf(t)<0&&o.push(t);return[s,[l,o]]}mincutKargers(t=1,e=null){const n=this.adjacencyMatrix;let r=null,l=1/0;null==e&&(e=this._n**2*Math.log(this._n));const s=[];let i=0;for(let t=0;t<this._n;t++){s[t]=new Set;for(let e=0;e<this._n;e++)n[t][e]&&(s[t].add(e),i++)}for(let o=0;o<e;o++){const e=Array.from({length:this._n},((t,e)=>[e])),o=n.map((t=>t.concat())),a=s.map((t=>new Set(t)));let h=i,c=0;for(let t=0;t<this._n-2&&h>0;t++){let t=Math.floor(Math.random()*h);for(c=0;c<this._n&&a[c].size<=t;c++)t-=a[c].size;let n=0;for(const e of a[c]){if(0===t){n=e;break}t--}for(const t of a[n])a[t].delete(n),h-=1,t!==c&&(o[c][t]||(a[c].add(t),a[t].add(c),h+=2),o[c][t]+=o[n][t],o[t][c]+=o[t][n]);e[c].push(...e[n]),e[n]=null,h-=a[n].size,a[n].clear()}if(0===h)return[0,e.filter((t=>null!==t))];const f=a[c].values().next().value;e[c].length<t||e[f].length<t||o[c][f]<l&&(l=o[c][f],r=[e[c],e[f]])}return r?[l,r]:[l,[Array.from({length:this._n},((t,e)=>e))]]}mincutKargersStein(t=1,e=null){const n=this.adjacencyMatrix,r=Array.from({length:this._n},((t,e)=>[e]));null===e&&(e=Math.log(this._n)**2);let l=null,s=1/0;for(let i=0;i<e;i++){const[e,i]=this._mincutKargersStein0(n,r,t);e<s&&(s=e,l=i)}return[s,l]}_mincutKargersStein0(t,e,n){const r=t.length;if(r<=6){const l=Array(r).fill(!1);let s=null,i=1/0;do{const o=[],a=[];for(let t=0;t<r;t++)l[t]?o.push(t):a.push(t);const h=o.reduce(((t,n)=>t+e[n].length),0),c=a.reduce(((t,n)=>t+e[n].length),0);if(h>=n&&c>=n){let n=0;for(let e=0;e<o.length;e++)for(let r=0;r<a.length;r++)t[o[e]][a[r]]&&(n+=t[o[e]][a[r]]);n<i&&(i=n,s=[o.reduce(((t,n)=>t.concat(e[n])),[]),a.reduce(((t,n)=>t.concat(e[n])),[])])}if(0===i)return[0,s];for(let t=0;t<r;t++){if(!l[t]){l[t]=!0;break}l[t]=!1}}while(l.some((t=>t)));return[i,s]}const l=[];let s=0;for(let e=0;e<r;e++){l[e]=new Set;for(let n=0;n<r;n++)t[e][n]&&(l[e].add(n),s++)}const i=r/Math.sqrt(2)+1;let o=null,a=1/0;for(let h=0;h<2;h++){const h=e.map((t=>t.concat())),c=t.map((t=>t.concat())),f=l.map((t=>new Set(t)));let u=s,g=0;const d=[];for(let t=0;t<r-i;t++){let t=Math.floor(Math.random()*u);for(g=0;g<this._n&&f[g].size<=t;g++)t-=f[g].size;let e=0;for(const n of f[g]){if(0===t){e=n;break}t--}for(const t of f[e])f[t].delete(e),u-=1,t!==g&&(c[g][t]||(f[g].add(t),f[t].add(g),u+=2),c[g][t]+=c[e][t],c[t][g]+=c[t][e]);h[g].push(...h[e]),h[e]=null,u-=f[e].size,f[e].clear(),d.push(e)}d.sort(((t,e)=>e-t));for(let t=r-1;t>=0;t--)if(null===h[t])c.splice(t,1),h.splice(t,1);else for(let e=0;e<d.length;e++)c[t].splice(d[e],1);const[_,m]=this._mincutKargersStein0(c,h,n);_<a&&(a=_,o=m)}return[a,o]}bisectionSpectral(){const t=Matrix.fromArray(this.laplacianMatrix()).tridiagLanczos(),e=t.eigenValuesQR(),[,n]=t.eigenInverseIteration(e[1]),r=n.median(),l=[],s=[];for(let t=0;t<this._n;t++)n.at(t,0)>r?l.push(t):s.push(t);return[this.cut(l,s),[l,s]]}}