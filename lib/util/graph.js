import Matrix from"./matrix.js";export class GraphException extends Error{constructor(e,t){super(e),this.value=t,this.name="GraphException"}}export class Edge{constructor(e,t,n=null,s=!1){this[0]=e,this[1]=t,this.value=n??1,this.direct=s,this.weighted=null!=n}get value0(){return this.weighted?this.value:null}}export default class Graph{constructor(e=0,t=[]){Array.isArray(e)?this._nodes=e:this._nodes=Array(e),this._edges=t.map((e=>new Edge(e[0],e[1],e instanceof Edge?e.value0:e.value,e.direct)))}static fromAdjacency(e){const t=e.length,n=[];for(let s=0;s<t;s++)for(let t=0;t<=s;t++)(e[s][t]||e[t][s])&&(e[s][t]===e[t][s]?n.push(new Edge(t,s,+e[s][t])):(e[s][t]&&n.push(new Edge(s,t,+e[s][t],!0)),e[t][s]&&n.push(new Edge(t,s,+e[t][s],!0))));return new Graph(t,n)}static complete(e){const t=[];for(let n=0;n<e;n++)for(let e=0;e<n;e++)t.push([n,e]);return new Graph(e,t)}static completeBipartite(e,t){const n=[];for(let s=0;s<e;s++)for(let r=0;r<t;r++)n.push([s,r+e]);return new Graph(e+t,n)}static cycle(e,t=!1){if(e<3)throw new GraphException("Index out of bounds.");const n=[];for(let s=0;s<e;s++)n.push(new Edge(s,(s+1)%e,null,t));return new Graph(e,n)}static wheel(e){if(e<4)throw new GraphException("Index out of bounds.");const t=[];for(let n=1;n<e;n++)t.push([n,n%(e-1)+1]),t.push([0,n]);return new Graph(e,t)}static windmill(e,t){if(1===e)return new Graph(1);const n=[];for(let s=0;s<t;s++)for(let t=0;t<e;t++)for(let r=0;r<t;r++)n.push([0===r?0:s*(e-1)+r,s*(e-1)+t]);return new Graph(t*(e-1)+1,n)}static fromName(e){switch(e){case"balaban 10 cage":{const e=[];for(let t=0;t<10;t++)e.push([2*t,(t+3)%10*2+1]),e.push([2*t+1,(t+3)%10*2]),e.push([2*t,3*t+20]),e.push([2*t+1,3*t+22]),e.push([3*t+20,3*t+21]),e.push([3*t+21,3*t+22]),t<5&&e.push([3*t+21,3*(t+5)+21]),e.push([3*t+20,2*t+50]),e.push([3*t+22,2*t+51]),e.push([2*t+50,(t+1)%10*2+50]),e.push([2*t+51,(t+1)%10*2+51]);return new Graph(70,e)}case"bidiakis cube":{const e=[];for(let t=0;t<12;t++)e.push([t,(t+1)%12]);return e.push([0,8],[1,7],[2,6],[3,11],[4,10],[5,9]),new Graph(12,e)}case"biggs smith":{const e=[];for(let t=0;t<17;t++)e.push([t,(t+8)%17]),e.push([t,t+17]),e.push([t+17,t+51]),e.push([t+17,t+68]),e.push([t+34,(t+4)%17+34]),e.push([t+34,t+68]),e.push([t+51,(t+2)%17+51]),e.push([t+68,t+85]),e.push([t+85,(t+1)%17+85]);return new Graph(102,e)}case"brinkmann":{const e=[];for(let t=0;t<7;t++)e.push([t,(t+3)%7]),e.push([t,t+7]),e.push([t,(t+5)%7+7]),e.push([t+7,t+14]),e.push([t+7,(t+1)%7+14]),e.push([t+14,(t+2)%7+14]);return new Graph(21,e)}case"bull":return new Graph(5,[[0,1],[1,2],[1,3],[2,3],[3,4]]);case"butterfly":return new Graph(5,[[0,1],[0,2],[1,2],[2,3],[2,4],[3,4]]);case"chvatal":{const e=[];for(let t=0;t<4;t++)e.push([t,(t+1)%4]),e.push([t,2*t+4]),e.push([t,(2*t+7)%8+4]),e.push([2*t+4,2*t+5]),e.push([2*t+4,(2*t+3)%8+4]);return e.push([4,8],[5,9],[6,10],[7,11]),new Graph(12,e)}case"clebsch":{const e=[];for(let t=0;t<8;t++)e.push([t,(t+3)%8]),e.push([t,t+8]),e.push([t,(t+2)%8+8]),e.push([t+8,(t+1)%8+8]);for(let t=0;t<4;t++)e.push([t,t+4]),e.push([t+8,t+12]);return new Graph(16,e)}case"coxeter":{const e=[];for(let t=0;t<3;t++)e.push([0,8*t+4]),e.push([t+1,8*t+8]),e.push([t+1,(8*t+15)%24+4]),e.push([t+1,(8*t+22)%24+4]),e.push([8*t+5,(8*t+19)%24+4]),e.push([8*t+9,(8*t+18)%24+4]);for(let t=0;t<24;t++)e.push([t+4,(t+1)%24+4]);return new Graph(28,e)}case"desargues":{const e=[];for(let t=0;t<10;t++)e.push([t,(t+3)%10]),e.push([t,t+10]),e.push([t+10,(t+1)%10+10]);return new Graph(20,e)}case"diamond":return new Graph(4,[[0,1],[0,2],[1,2],[1,3],[2,3]]);case"durer":{const e=[];for(let t=0;t<6;t++)e.push([t,(t+1)%6]),e.push([t,t+6]),e.push([t+6,(t+2)%6+6]);return new Graph(12,e)}case"dyck":{const e=[];for(let t=0;t<32;t++)e.push([t,(t+1)%32]);for(let t=0;t<8;t++)e.push([4*t,(4*t+5)%32]),e.push([4*t+2,(4*t+15)%32]);return new Graph(32,e)}case"errera":{const e=[[0,1],[2,3],[5,6],[9,10],[15,16]];for(let t=0;t<2;t++)e.push([0,11+t]),e.push([0,15+t]),e.push([1,5+t]),e.push([1,11+t]),e.push([2,5+t]),e.push([2,7+t]),e.push([3,7+t]),e.push([3,9+t]),e.push([4,9+t]),e.push([4,13+t]),e.push([4,15+t]),e.push([5+t,7+t]),e.push([5+t,11+t]),e.push([5+t,13+t]),e.push([7+t,9+t]),e.push([7+t,13+t]),e.push([9+t,13+t]),e.push([11+t,13+t]),e.push([11+t,15+t]),e.push([13+t,15+t]);return new Graph(17,e)}case"folkman":{const e=[];for(let t=0;t<5;t++)for(let n=0;n<4;n++)e.push([4*t+n,4*t+(n+1)%4]);for(let t=0;t<4;t++)e.push([4*t+2,4*(t+1)+1]),e.push([4*t+2,4*(t+1)+3]);for(let t=0;t<3;t++)e.push([4*t,4*(t+2)+1]),e.push([4*t,4*(t+2)+3]);return e.push([1,12],[1,18],[3,12],[3,18],[5,16],[7,16]),new Graph(20,e)}case"foster":{const e=[];for(let t=0;t<15;t++){for(let n=0;n<6;n++)e.push([6*t+n,(6*t+n+1)%90]);e.push([6*t,(t+8)%15*6+5]),e.push([6*t+1,(t+1)%15*6+4]),e.push([6*t+2,(t+12)%15*6+3])}return new Graph(90,e)}case"franklin":{const e=[];for(let t=0;t<12;t++)e.push([t,(t+1)%12]);return e.push([0,7],[1,6],[2,9],[3,8],[4,11],[5,10]),new Graph(12,e)}case"frucht":{const e=[];for(let t=0;t<7;t++)e.push([t,(t+1)%7]);return e.push([0,7],[1,8],[2,8],[3,9],[4,9],[5,10],[6,10],[7,10],[7,11],[8,11],[9,11]),new Graph(12,e)}case"goldner-harary":{const e=[];for(let t=0;t<4;t++)e.push([0,t+1]),e.push([0,t+5]),e.push([t+1,t+5]),e.push([t+1,(t+3)%4+5]),e.push([t+5,(t+3)%4+5]);return e.push([5,9],[9,7],[7,10],[10,5],[5,7],[6,9],[8,10]),new Graph(11,e)}case"golomb":{const e=[];for(let t=0;t<6;t++)e.push([0,t+1]),e.push([t+1,(t+1)%6+1]);for(let t=0;t<3;t++)e.push([t+7,(t+1)%3+7]),e.push([2*t+1,t+7]);return new Graph(10,e)}case"gray":{const e=[];for(let t=0;t<54;t++)e.push([t,(t+1)%54]);for(let t=0;t<9;t++)e.push([6*t,(t+4)%9*6+1]),e.push([6*t+2,(t+2)%9*6+3]),e.push([6*t+4,(t+1)%9*6+5]);return new Graph(54,e)}case"grotzsch":{const e=[];for(let t=0;t<5;t++)e.push([0,t+1]),e.push([t+1,t+6]),e.push([t+6,(t+4)%5+1]),e.push([t+6,(t+2)%5+6]);return new Graph(11,e)}case"harries":{const e=[];for(let t=0;t<10;t++)e.push([t,(t+3)%10]),e.push([t,5*t+20]),t%2==0?(e.push([t+10,(t+1)%10+10]),e.push([t+10,5*t+22])):(e.push([t+10,(t+3)%10+10]),e.push([t+10,5*t+24]));for(let t=0;t<50;t++)e.push([t+20,(t+1)%50+20]);for(let t=0;t<5;t++)e.push([10*t+24,(10*t+13)%50+20]),e.push([10*t+28,(10*t+17)%50+20]),e.push([5*t+21,(5*t+25)%50+21]);return new Graph(70,e)}case"heawood":{const e=[];for(let t=0;t<7;t++)e.push([2*t,2*t+1]),e.push([2*t+1,(2*t+2)%14]),e.push([2*t,(2*t+5)%14]);return new Graph(14,e)}case"herschel":{const e=[];for(let t=0;t<4;t++)e.push([0,t+1]),e.push([t+1,t+5]),e.push([t+1,(t+3)%4+5]);return e.push([5,9],[5,10],[6,9],[7,9],[7,10],[8,10]),new Graph(11,e)}case"hoffman":{const e=[];for(let t=0;t<2;t++)e.push([0,6+t]),e.push([0,10+t]),e.push([1,8+t]),e.push([1,10+t]),e.push([2,6+t]),e.push([2,14+t]),e.push([3,8+t]),e.push([3,14+t]),e.push([4+t,6+t]),e.push([4+t,10+t]),e.push([4+t,9-t]),e.push([4+t,15-t]),e.push([6+t,12+t]),e.push([8+t,12+t]),e.push([10+t,12+t]),e.push([12+t,14+t]);return new Graph(16,e)}case"holt":{const e=[];for(let t=0;t<9;t++)e.push([t,(t+4)%9]),e.push([t,(t+7)%9+9]),e.push([t,(t+1)%9+18]),e.push([t+9,(t+1)%9+9]),e.push([t+9,t+18]),e.push([t+18,(t+2)%9+18]);return new Graph(27,e)}case"kittell":return new Graph(23,[[0,1],[0,2],[0,3],[0,4],[0,15],[0,16],[1,2],[1,4],[1,5],[1,6],[1,7],[1,12],[2,3],[2,7],[2,8],[3,8],[3,14],[3,15],[4,5],[4,9],[4,16],[4,17],[5,6],[5,9],[5,10],[6,10],[6,11],[6,12],[7,8],[7,12],[7,13],[8,13],[8,14],[9,10],[9,17],[9,18],[10,11],[10,18],[10,19],[11,12],[11,19],[11,20],[12,13],[12,20],[12,21],[13,14],[13,21],[14,15],[14,21],[15,16],[15,21],[16,17],[16,21],[16,22],[17,18],[17,22],[18,19],[18,22],[19,20],[19,22],[20,21],[20,22],[21,22]]);case"markstrom":{const e=[];for(let t=0;t<3;t++)e.push([8*t,8*t+1]),e.push([8*t,8*t+4]),e.push([8*t+1,8*t+2]),e.push([8*t+1,8*t+3]),e.push([8*t+2,8*t+3]),e.push([8*t+2,(t+1)%3*8]),e.push([8*t+3,8*t+5]),e.push([8*t+4,8*t+5]),e.push([8*t+4,8*t+6]),e.push([8*t+5,8*t+6]),e.push([8*t+6,8*t+7]),e.push([8*t+7,(t+1)%3*8+7]);return new Graph(24,e)}case"mcgee":{const e=[];for(let t=0;t<24;t++)e.push([t,(t+1)%24]);for(let t=0;t<8;t++)e.push([3*t+1,(3*t+8)%24]);for(let t=0;t<4;t++)e.push([3*t,3*t+12]);return new Graph(24,e)}case"meredith":{const e=[];for(let t=0;t<5;t++){for(let n=0;n<4;n++)for(let s=0;s<3;s++)e.push([14*t+n,14*t+4+s]),e.push([14*t+7+n,14*t+11+s]);e.push([14*t+1,14*t+8]),e.push([14*t+2,14*t+9]),e.push([14*t+3,(t+2)%5*14]),e.push([14*t+10,(t+1)%5*14+7])}return new Graph(70,e)}case"mobius kantor":{const e=[];for(let t=0;t<8;t++)e.push([t,(t+3)%8]),e.push([t,t+8]),e.push([t+8,(t+1)%8+8]);return new Graph(16,e)}case"moser spindle":return new Graph(7,[[0,1],[0,2],[0,3],[0,4],[1,2],[1,5],[2,5],[3,4],[3,6],[4,6],[5,6]]);case"nauru":{const e=[];for(let t=0;t<24;t++)e.push([t,(t+1)%24]);for(let t=0;t<4;t++)e.push([6*t,6*t+5]),e.push([6*t+2,(6*t+9)%24]),e.push([6*t+1,(6*t+16)%24]);return new Graph(24,e)}case"pappus":{const e=[];for(let t=0;t<6;t++)e.push([t,(t+1)%6+6]),e.push([t,(t+5)%6+6]),e.push([t+6,t+12]),e.push([t+12,(t+1)%6+12]);return e.push([0,3],[1,4],[2,5]),new Graph(18,e)}case"petersen":{const e=[];for(let t=0;t<5;t++)e.push([t,(t+1)%5]),e.push([t,t+5]),e.push([t+5,(t+2)%5+5]);return new Graph(10,e)}case"poussin":{const e=[[0,1],[1,2],[3,4],[5,6],[13,14]];for(let t=0;t<2;t++)e.push([0,7+t]),e.push([0,13+t]),e.push([1,7+t]),e.push([1,9+t]),e.push([2,5+t]),e.push([2,9+t]),e.push([3,5+t]),e.push([3,11+t]),e.push([4,11+t]),e.push([4,13+t]),e.push([5+t,9+t]),e.push([5+t,11+t]),e.push([7+t,9+t]),e.push([7+t,13+t]),e.push([9+t,13+t]),e.push([9+t,11+t]),e.push([11+t,13+t]);return new Graph(15,e)}case"robertson":{const e=[[0,2],[1,3]];for(let t=0;t<4;t++)e.push([t,3*t+4]),e.push([(t+3)%4,3*t+5]),e.push([(t+2)%4,3*t+6]),e.push([3*t+4,3*t+5]),e.push([3*t+5,3*t+6]),e.push([3*t+6,(t+1)%4*3+4]);for(let t=0;t<3;t++)for(let n=0;n<4;n++)e.push([t+16,(4*t+3*n)%12+4]);return new Graph(19,e)}case"shrikhande":{const e=[];for(let t=0;t<4;t++)e.push([4*t,(t+1)%4*4]),e.push([4*t,4*t+1]),e.push([4*t,4*t+2]),e.push([4*t,(t+1)%4*4+1]),e.push([4*t,(t+1)%4*4+2]),e.push([4*t+1,(t+1)%4*4+2]),e.push([4*t+1,4*t+3]),e.push([4*t+2,(t+1)%4*4+1]),e.push([4*t+2,(t+1)%4*4+3]),e.push([4*t+2,(t+2)%4*4+3]),e.push([4*t+3,(t+1)%4*4+1]),e.push([4*t+3,(t+1)%4*4+3]);return new Graph(16,e)}case"sousselier":{const e=[];for(let t=0;t<5;t++)e.push([0,3*t+1]),e.push([3*t+2,(3*t+5)%15+1]);for(let t=0;t<15;t++)e.push([t+1,(t+1)%15+1]);return e.push([2,12],[5,15]),new Graph(16,e)}case"sylvester":{const e=[];for(let t=0;t<6;t++)e.push([6*t,6*t+2]),e.push([6*t,6*t+5]),e.push([6*t,(t+1)%6*6+4]),e.push([6*t,(t+3)%6*6+1]),e.push([6*t,(t+3)%6*6+3]),e.push([6*t+1,6*t+2]),e.push([6*t+1,(t+2)%6*6+4]),e.push([6*t+1,(t+3)%6*6+4]),e.push([6*t+1,(t+4)%6*6+2]),e.push([6*t+2,(t+1)%6*6+5]),e.push([6*t+2,(t+2)%6*6+5]),e.push([6*t+3,6*t+4]),e.push([6*t+3,(t+1)%6*6+3]),e.push([6*t+3,(t+1)%6*6+5]),t<3&&(e.push([6*t+4,(t+3)%6*6+4]),e.push([6*t+5,(t+3)%6*6+5]));return new Graph(36,e)}case"tutte":{const e=[];for(let t=0;t<3;t++)e.push([0,15*t+1]),e.push([15*t+1,15*t+2]),e.push([15*t+1,15*t+4]),e.push([15*t+2,15*t+3]),e.push([15*t+2,15*t+5]),e.push([15*t+3,15*t+4]),e.push([15*t+3,15*t+7]),e.push([15*t+4,15*t+9]),e.push([15*t+5,15*t+6]),e.push([15*t+5,15*t+10]),e.push([15*t+6,15*t+7]),e.push([15*t+6,15*t+11]),e.push([15*t+7,15*t+8]),e.push([15*t+8,15*t+9]),e.push([15*t+8,15*t+12]),e.push([15*t+9,15*t+15]),e.push([15*t+10,15*t+11]),e.push([15*t+10,15*t+13]),e.push([15*t+11,15*t+12]),e.push([15*t+12,15*t+14]),e.push([15*t+13,15*t+14]),e.push([15*t+14,15*t+15]),e.push([15*t+15,(t+1)%3*15+13]);return new Graph(46,e)}case"tutte coxeter":{const e=[];for(let t=0;t<30;t++)e.push([t,(t+1)%30]);for(let t=0;t<5;t++)e.push([6*t,(t+1)%5*6+3]),e.push([6*t+1,(t+2)%5*6+2]),e.push([6*t+4,(t+1)%5*6+5]);return new Graph(30,e)}case"wagner":{const e=[];for(let t=0;t<4;t++)e.push([t,t+1]),e.push([t,t+4]),e.push([t+4,(t+5)%8]);return new Graph(8,e)}case"wells":{const e=[];for(let t=0;t<8;t++)e.push([4*t,(t+1)%8*4]),e.push([4*t,(t+2)%8*4+3]),e.push([4*t+1,(t+1)%8*4+3]),e.push([4*t+1,(t+2)%8*4]),e.push([4*t+1,(t+2)%8*4+3]),e.push([4*t+1,(t+3)%8*4+2]),e.push([4*t+2,(t+1)%8*4]),e.push([4*t+2,(t+3)%8*4+2]),e.push([4*t+3,(t+1)%8*4+1]),e.push([4*t+3,(t+3)%8*4+2]);return new Graph(32,e)}case"wiener araya":{const e=[];for(let t=0;t<4;t++)e.push([10*t,10*t+1]),e.push([10*t,10*t+2]),e.push([10*t,(t+1)%4*10]),e.push([10*t+1,10*t+3]),e.push([10*t+1,10*t+5]),e.push([10*t+2,10*t+4]),e.push([10*t+2,(t+1)%4*10+5]),e.push([10*t+3,10*t+4]),e.push([10*t+3,10*t+7]),e.push([10*t+4,10*t+9]),e.push([10*t+5,10*t+6]),e.push([10*t+6,10*t+7]),e.push([10*t+6,(t+3)%4*10+9]),e.push([10*t+7,10*t+8]),e.push([10*t+8,10*t+9]),t%2==1?(e.push([10*t+8,(t+1)%4*10+8]),e.push([10*t+8,1===t?40:41])):e.push([10*t+9,0===t?40:41]);return e.push([40,41]),new Graph(42,e)}}}get order(){return this._nodes.length}get size(){return this._edges.length}get nodes(){return this._nodes}get edges(){return this._edges}toDot(){let e=this.isUndirected()?"graph":"digraph";e+=" g {\n";for(let t=0;t<this._nodes.length;t++)e+=`  ${t} [label="${JSON.stringify(this._nodes[t]??t).replace('"',"'")}"];\n`;for(const t of this._edges)e+=`  ${t[0]} ${t.direct?"->":"--"} ${t[1]}`,t.weighted&&(e+=` [label="${JSON.stringify(t.value).replace('"',"'")}"]`),e+=";\n";return e+"}"}toString(){let e=`Number of nodes: ${this._nodes.length}\n`;this._nodes.some((e=>null!=e))&&(e+=`Node values: ${JSON.stringify(this._nodes)}\n`),e+=`Number of edges: ${this._edges.length}`,this._edges.length>0&&(e+="\nEdges");for(const t of this._edges)e+=`\n  From ${t[0]} to ${t[1]}, value: ${JSON.stringify(t.value)} (${t.direct?"directed":"undirected"})`;return e}copy(){const e=this._edges.map((e=>new Edge(e[0],e[1],e.value0,e.direct))),t=this._nodes.concat();return new Graph(t,e)}degree(e,t=!0,n=!0){"in"!==t&&"out"!==t||(n=t,t=!1);let s=0;for(const r of this._edges)(!t||r.direct||r[0]!==e&&r[1]!==e)&&(!0!==n||!r.direct||r[0]!==e&&r[1]!==e)?("in"===n&&r.direct&&r[1]===e||"out"===n&&r.direct&&r[0]===e)&&s++:s++;return s}adjacencies(e,t=!0,n=!0){"in"!==t&&"out"!==t||(n=t,t=!1);const s=[],r=Array(this._nodes.length).fill(!1);for(const h of this._edges)if(!t||h.direct||h[0]!==e&&h[1]!==e)if(!0!==n||!h.direct||h[0]!==e&&h[1]!==e){if("in"===n&&h.direct&&h[1]===e){if(r[h[0]])continue;s.push(h[0]),r[h[0]]=!0}else if("out"===n&&h.direct&&h[0]===e){if(r[h[1]])continue;s.push(h[1]),r[h[1]]=!0}}else{const t=h[0]===e?h[1]:h[0];if(r[t])continue;s.push(t),r[t]=!0}else{const t=h[0]===e?h[1]:h[0];if(r[t])continue;s.push(t),r[t]=!0}return s.sort(((e,t)=>e-t)),s}components(){const e=Array(this._nodes.length).fill(!1),t=[0],n=[];let s=[];for(;t.length>0||e.some((e=>!e));){0===t.length&&(s.sort(((e,t)=>e-t)),n.push(s),s=[]);const r=t.length>0?t.pop():e.indexOf(!1);if(!e[r]){e[r]=!0,s.push(r);for(const e of this._edges)e[0]===r&&t.push(e[1]),e[1]===r&&t.push(e[0])}}return s.length>0&&(s.sort(((e,t)=>e-t)),n.push(s)),n}biconnectedComponents(){const e=this._nodes.length,t=new Graph(e),n=Array.from({length:e},(()=>Array(e).fill(!1)));for(const e of this._edges)e[0]===e[1]||n[e[0]][e[1]]||(t.addEdge(e[0],e[1]),n[e[0]][e[1]]=n[e[1]][e[0]]=!0);const s=t.components(),r=[];for(;s.length>0;){const e=s.pop(),n=t.inducedSub(e),h=n.articulations();if(0===h.length){r.push(e);continue}const l=h[0];n.removeNode(l);const o=n.components();for(let t=0;t<o.length;t++){const n=[];for(let s=0;s<o[t].length;s++)o[t][s]>=l?n.push(e[o[t][s]+1]):n.push(e[o[t][s]]);n.push(e[l]),n.sort(((e,t)=>e-t)),s.push(n)}}return r}diameter(){const e=this.shortestPathFloydWarshall();let t=-1/0;for(let n=0;n<this._nodes.length;n++)for(let s=0;s<this._nodes.length;s++)t<e[n][s].length&&(t=e[n][s].length);return t}eccentricity(e){const t=this.shortestPathBellmanFord(e);let n=-1/0;for(let e=0;e<this._nodes.length;e++)n<t[e].length&&(n=t[e].length);return n}radius(){const e=this.shortestPathFloydWarshall();let t=1/0;for(let n=0;n<this._nodes.length;n++){let s=-1/0;for(let t=0;t<this._nodes.length;t++)s<e[n][t].length&&(s=e[n][t].length);t>s&&(t=s)}return t}center(){const e=this.shortestPathFloydWarshall(),t=Array(this._nodes.length).fill(-1/0);let n=1/0;for(let s=0;s<this._nodes.length;s++){for(let n=0;n<this._nodes.length;n++)t[s]<e[s][n].length&&(t[s]=e[s][n].length);n>t[s]&&(n=t[s])}const s=[];for(let e=0;e<t.length;e++)t[e]===n&&s.push(e);return s}girth(){let e=1/0;for(let t=0;t<this._nodes.length;t++){const n=[[[t],Array(this._edges.length).fill(!1)]];for(;n.length>0;){const[s,r]=n.shift(),h=s[s.length-1];for(let l=0;l<this._edges.length;l++){if(r[l])continue;const o=this._edges[l];if(o[0]===h){if(o[1]===t){s.length<e&&(e=s.length),n.length=0;break}if(s.includes(o[1]))continue;const h=r.concat();h[l]=!0,n.push([s.concat(o[1]),h])}if(!o.direct&&o[1]===h){if(o[0]===t){s.length<e&&(e=s.length),n.length=0;break}if(s.includes(o[0]))continue;const h=r.concat();h[l]=!0,n.push([s.concat(o[0]),h])}}}}return e}clique(e){const t=this._nodes.length;if(null!=e&&e>t)return[];const n=Array.from({length:t},((e,t)=>[t]));if(1===e)return n;if(1===t)return[n];const s=[],r=[];for(let e=0;e<t;e++){s[e]=[];for(let t=0;t<e;t++)this.getEdges(e,t).length>0&&(s[e][t]=!0,s[t][e]=!0,r.push([t,e]))}if(2===e)return r;const h=e??this._nodes.length,l=[n,r];for(let e=2;e<h;e++){const n=[];for(let r=0;r<l[e-1].length;r++){const h=l[e-1][r];for(let e=h.at(-1)+1;e<t;e++)h.every((t=>s[t][e]))&&n.push(h.concat(e))}l.push(n)}return null==e?l:l[e-1]}chromaticNumber(){const e=this._nodes.length;return e<=1?e:0===this._edges.length?1:this.isBipartite()?2:this.isComplete()?this._nodes.length:this.chromaticNumberWelchPowell()}chromaticNumberWelchPowell(){const e=this._nodes.length,t=this.adjacencyList(),n=[];for(let t=0;t<e;t++)n[t]=[t,this.degree(t)];n.sort(((e,t)=>t[1]-e[1]));let s=0;const r=Array(e).fill(-1);for(;;){const n=r.indexOf(-1);if(n<0)break;r[n]=s;for(let n=0;n<e;n++)r[n]>=0||t[n].every((e=>r[e]!==s))&&(r[n]=s);s++}return s}chromaticIndex(){if(this._edges.length<=1)return this._edges.length;if(this.isBipartite()){let e=0;for(let t=0;t<this._nodes.length;t++)e=Math.max(e,this.degree(t));return e}if(this.isComplete())return this._nodes.length%2==0?this._nodes.length-1:this._nodes.length;throw new GraphException("Not implemented")}articulations(){return this.articulationsLowLink()}articulationsEachNodes(){const e=this._nodes.length,t=[];for(let n=0;n<e;n++){const s=this.adjacencies(n).filter((e=>e!==n));if(s.length<=1)continue;const r=Array(e).fill(!1);r[n]=!0;const h=[s[0]];for(;h.length>0;){const e=h.pop();if(!r[e]){r[e]=!0;for(const t of this._edges)t[0]===e&&h.push(t[1]),t[1]===e&&h.push(t[0])}}s.some((e=>!r[e]))&&t.push(n)}return t}articulationsLowLink(){const e=this._nodes.length;if(0===e)return[];const t=Array(e).fill(-1),n=[],s=Array(e).fill(-1),r=this.adjacencyList();let h=0;const l=[],o=e=>{t[e]=n[e]=h++;let i=0,u=!1;for(const h of r[e])t[h]<0?(s[h]=e,o(h),i++,n[h]>=t[e]&&(u=!0),n[e]=Math.min(n[e],n[h])):h!==s[e]&&(n[e]=Math.min(n[e],t[h]));(s[e]>=0&&u||s[e]<0&&i>1)&&l.push(e)};return o(0),l.sort(((e,t)=>e-t)),l}bridges(){return this.bridgesLowLink()}bridgesLowLink(){const e=this._nodes.length;if(0===e||0===this._edges.length)return[];const t=Array(e).fill(-1),n=[],s=Array(e).fill(-1),r=this.adjacencyList();let h=0;const l=e=>{t[e]=n[e]=h++;for(const h of r[e])t[h]<0?(s[h]=e,l(h),n[e]=Math.min(n[e],n[h])):h!==s[e]&&(n[e]=Math.min(n[e],t[h]))};l(0);const o=Array.from({length:e},(()=>Array(e).fill(0)));for(const e of this._edges)o[e[0]][e[1]]++,o[e[1]][e[0]]++;const i=[];for(const e of this._edges)1===o[e[0]][e[1]]&&(t[e[0]]<n[e[1]]||t[e[1]]<n[e[0]])&&i.push(e);return i}addNode(e){this._nodes[this._nodes.length]=e}getNode(e){if(null==e)return this._nodes;if(Array.isArray(e)){if(e.some((e=>e<0||this._nodes.length<=e)))throw new GraphException("Index out of bounds.");return e.map((e=>this._nodes[e]))}if(e<0||this._nodes.length<=e)throw new GraphException("Index out of bounds.");return this._nodes[e]}removeNode(e){if(e<0||this._nodes.length<=e)throw new GraphException("Index out of bounds.");this._nodes.splice(e,1);for(let t=this._edges.length-1;t>=0;t--){const n=this._edges[t];n[0]===e||n[1]===e?this._edges.splice(t,1):(n[0]>e&&n[0]--,n[1]>e&&n[1]--)}}addEdge(e,t,n=null,s=!1){if(e<0||this._nodes.length<=e||t<0||this._nodes.length<=t)throw new GraphException("Index out of bounds.");this._edges.push(new Edge(e,t,n,s))}getEdges(e,t,n=null){if(e<0||this._nodes.length<=e||t<0||this._nodes.length<=t)throw new GraphException("Index out of bounds.");const s=[];for(const r of this._edges)null!==n&&!n!=!r.direct||(r[0]===e&&r[1]===t||r[1]===e&&r[0]===t)&&s.push(r);return s}removeEdges(e,t,n=null){if(e<0||this._nodes.length<=e||t<0||this._nodes.length<=t)throw new GraphException("Index out of bounds.");for(let s=this._edges.length-1;s>=0;s--){const r=this._edges[s];null!==n&&!n!=!r.direct||(r[0]===e&&r[1]===t||r[1]===e&&r[0]===t)&&this._edges.splice(s,1)}}adjacencyMatrix(){const e=Array.from({length:this._nodes.length},(()=>Array(this._nodes.length).fill(0)));for(const t of this._edges)t.direct?e[t[0]][t[1]]+=t.value:(e[t[0]][t[1]]+=t.value,e[t[1]][t[0]]+=t.value);return e}adjacencyList(e="both"){const t=this._nodes.length,n=Array.from({length:t},(()=>[])),s=Array.from({length:t},(()=>Array(t).fill(!1)));for(const t of this._edges)t[0]===t[1]?s[t[0]][t[1]]||(n[t[0]].push(t[1]),s[t[0]][t[1]]=!0):t.direct&&"both"!==e?"in"===e?s[t[1]][t[0]]||(n[t[1]].push(t[0]),s[t[1]][t[0]]=!0):s[t[0]][t[1]]||(n[t[0]].push(t[1]),s[t[0]][t[1]]=!0):(s[t[0]][t[1]]||n[t[0]].push(t[1]),s[t[1]][t[0]]||n[t[1]].push(t[0]),s[t[0]][t[1]]=s[t[1]][t[0]]=!0);for(let e=0;e<t;e++)n[e].sort(((e,t)=>e-t));return n}degreeMatrix(e="both"){const t=Array.from({length:this._nodes.length},(()=>Array(this._nodes.length).fill(0)));for(const n of this._edges)n.direct&&"both"!==e?"in"===e?t[n[1]][n[1]]+=n.value:t[n[0]][n[0]]+=n.value:(t[n[0]][n[0]]+=n.value,t[n[1]][n[1]]+=n.value);return t}laplacianMatrix(){const e=this.adjacencyMatrix(),t=[];for(let n=0;n<this._nodes.length;n++){t[n]=e[n].map((e=>-e));for(let s=0;s<this._nodes.length;s++)t[n][n]+=e[n][s]}return t}isNull(){return 0===this._nodes.length}isEdgeless(){return 0===this._edges.length}isUndirected(){return this._edges.every((e=>!e.direct))}isDirected(){return this._edges.every((e=>e.direct))}isMixed(){let e=!1,t=!1;for(const n of this._edges)if(n.direct?e=!0:t=!0,e&&t)return!0;return!1}isOriented(){const e=this._nodes.length,t=Array.from({length:e},(()=>Array(e).fill(!1)));for(const e of this._edges){if(!e.direct)return!1;if(t[e[0]][e[1]])return!1;t[e[0]][e[1]]=t[e[1]][e[0]]=!0}return!0}isWeighted(){return this._edges.some((e=>e.weighted))}isSimple(){const e=Array.from({length:this._nodes.length},(()=>[]));for(const t of this._edges){if(t[0]===t[1])return!1;if(e[t[0]].includes(t[1])||e[t[1]].includes(t[0]))return!1;e[t[0]].push(t[1])}return!0}isConnected(){const e=Array(this._nodes.length).fill(!1),t=[0];for(;t.length>0;){const n=t.pop();if(!e[n]){e[n]=!0;for(const s of this._edges)s[0]!==n||e[s[1]]||t.push(s[1]),s.direct||s[1]!==n||e[s[0]]||t.push(s[0])}}return e.every((e=>e))}isBiconnected(){return 0===this.articulations().length}isTree(){return this.isConnected()&&!this.hasCycle()}isForest(){return!this.hasCycle()}isBipartite(){const e=Array(this._nodes.length).fill(!1),t=[[0,1]];for(;t.length>0||e.some((e=>!e));){const[n,s]=t.length>0?t.pop():[e.indexOf(!1),1];if(e[n]){if(e[n]===s)continue;return!1}e[n]=s;for(const r of this._edges){if(r[0]===n){if(e[r[1]]===s)return!1;t.push([r[1],s%2+1])}if(!r.direct&&r[1]===n){if(e[r[0]]===s)return!1;t.push([r[0],s%2+1])}}}return!0}isComplete(){for(let e=0;e<this._nodes.length;e++)for(let t=0;t<e;t++)if(0===this.getEdges(e,t).length)return!1;return!0}isRegular(e=null){if(this._nodes.length<=1)return!0;const t=this.degree(0);for(let n=1;n<this._nodes.length;n++){const s=this.degree(n);if(t!==s||null!==e&&s!==e)return!1}return!0}isPlainer(){const e=this._nodes.length,t=new Graph(e),n=Array.from({length:e},(()=>Array(e).fill(!1)));for(const e of this._edges)e[0]===e[1]||n[e[0]][e[1]]||(t.addEdge(e[0],e[1]),n[e[0]][e[1]]=n[e[1]][e[0]]=!0);return t.components().every((e=>{const n=t.inducedSub(e),s=n._nodes.length,r=n._edges.length;if(s<=4||r<=8)return!0;if(r>3*s-6)return!1;if(n.clique(5).length>0)return!1;if(s<=5)return!0;const h=n.girth();if(r>h*(s-2)/(h-2))return!1;let l=[];for(let e=0;e<s;e++){this.adjacencies(e).length<=5&&l.push(e)}return 0!==l.length&&n.isPlainerAddVertex()}))}isPlainerAddEdge(){throw new Error("Not implement")}isPlainerAddVertex(){return this.biconnectedComponents().every((e=>{const t=this.inducedSub(e),n=t._nodes.length,s=t.adjacencyList();for(let e=0;e<n;e++){const t=s[e].indexOf(e);t>=0&&s[e].splice(t,1)}const r=t._stNumbering().map(((e,t)=>[e,t]));r.sort(((e,t)=>e[0]-t[0]));const h=r.map((e=>e[1])),l={type:"p",children:s[h[0]].map((e=>({value:e})))};l.children.forEach((e=>e.parent=l));const o=(e,t)=>{let n=0,s=0;const r=[],h=[e];for(;h.length>0;){const e=h.pop();e.children&&e.children.length>0?h.push(...e.children):t.includes(e.value)&&r.push(e)}for(;r.length+n+s>1;){if(0===r.length)return!1;const e=r.shift();e.mark="blocked";const t=e.parent?.children.indexOf(e)??null,h=[];null!==t&&"q"===e.parent.type&&(t>0&&h.push(e.parent.children[t-1]),t<e.parent.children.length-1&&h.push(e.parent.children[t+1]));const l=h.filter((e=>"blocked"===e.mark));if((h.filter((e=>"unblocked"===e.mark)).length>0||h.length<2)&&(e.mark="unblocked"),"unblocked"===e.mark){const h=e.parent;if(l.length>0){for(let e=t-1;e>=0&&"blocked"===h.children[e].mark;e--)h.children[e].mark="unblocked",h.pertinentChildCount=(h.pertinentChildCount??0)+1;for(let e=t+1;e<h.children.length&&"blocked"===h.children[e].mark;e++)h.children[e].mark="unblocked",h.pertinentChildCount=(h.pertinentChildCount??0)+1}h?(h.pertinentChildCount=(h.pertinentChildCount??0)+1,h.mark||(h.mark="queued",r.push(h))):s=1,n-=l.length}else n+=1-l.length}return!0},i=(e,t)=>{const n=[e];for(;;){const e=[];let s=!1;for(let r=0;r<n.length;r++)n[r].label=null,n[r].pertinentLeafCount=0,n[r].children&&n[r].children.length>0?(e.push(...n[r].children),s=!0):t.includes(n[r].value)?(n[r].pertinentLeafCount=1,e.push(n[r])):e.push(n[r]);if(n.splice(0,n.length,...e),!s)break}const s=n.reduce(((e,n)=>e+(t.includes(n.value)?1:0)),0);for(;n.length>0;){const e=n.shift();if(e.parent&&(e.parent.pertinentLeafCount+=e.pertinentLeafCount),e.children&&0!==e.children.length){const t=[],n=[],r=[];for(let s=0;s<e.children.length;s++)"empty"===e.children[s].label?t.push(e.children[s]):"full"===e.children[s].label?n.push(e.children[s]):r.push(e.children[s]);if(t.length===e.children.length)e.label="empty";else if(n.length===e.children.length)e.label="full";else if("p"===e.type)if(t.length+n.length===e.children.length)if(e.pertinentLeafCount===s){e.children=t;const s={type:"p",children:n,label:"full",parent:e};s.children.forEach((e=>e.parent=s)),e.children.push(s)}else{if(e.type="q",e.children=[],1===t.length)e.children.push(t[0]);else{const n={type:"p",children:t,label:"empty",parent:e};n.children.forEach((e=>e.parent=n)),e.children.push(n)}if(1===n.length)e.children.push(n[0]);else{const t={type:"p",children:n,label:"full",parent:e};t.children.forEach((e=>e.parent=t)),e.children.push(t)}e.label="partial"}else if(e.pertinentLeafCount===s)if(e.children=t,1===r.length){if(e.children.push(r[0]),n.length>0){const e={type:"p",children:n,label:"full",parent:r[0]};e.children.forEach((t=>t.parent=e)),r[0].children.push(e)}}else{if(2!==r.length)return!1;{const t={type:"q",children:[],label:"partial"};t.children.push(...r[0].children),t.children.push(...n),t.children.push(...r[1].children.reverse()),t.children.forEach((e=>e.parent=t)),e.children.push(t),e.children.forEach((t=>t.parent=e))}}else{if(1!==r.length)return!1;if(e.type="q",e.children=[],t.length>0){const n={type:"p",children:t,label:"empty"};n.children.forEach((e=>e.parent=n)),e.children.push(n)}if(e.children.push(...r[0].children),n.length>0){const t={type:"p",children:n,label:"full"};t.children.forEach((e=>e.parent=t)),e.children.push(t)}e.label="partial",e.children.forEach((t=>t.parent=e))}else if("q"===e.type){if("empty"===e.children.at(-1).label&&e.children.reverse(),e.pertinentLeafCount===s)if(0===r.length){let t="empty",n=0;for(let s=0;s<e.children.length;s++)if(e.children[s].label!==t&&n<2)t="empty"===t?"full":"empty",n++;else if(e.children[s].label!==t)return!1}else if(1===r.length){let t="empty",n=0;const s=[];for(let r=0;r<e.children.length;r++)if("partial"===e.children[r].label)"empty"===t?(s.push(...e.children[r].children),t="full"):(s.push(...e.children[r].children.reverse()),t="empty");else if(e.children[r].label!==t&&n<1)t="empty"===t?"full":"empty",n++,s.push(e.children[r]);else{if(e.children[r].label!==t)return!1;s.push(e.children[r])}e.children=s,e.children.forEach((t=>t.parent=e))}else{if(2!==r.length)return!1;{let t="empty";const n=[];for(let s=0;s<e.children.length;s++)if("partial"===e.children[s].label)"empty"===t?(n.push(...e.children[s].children),t="full"):(n.push(...e.children[s].children.reverse()),t="empty");else{if(e.children[s].label!==t)return!1;n.push(e.children[s])}e.children=n,e.children.forEach((t=>t.parent=e))}}else if(0===r.length){let t="empty";for(let n=0;n<e.children.length;n++)if("full"===e.children[n].label)t="full";else if(e.children[n].label!==t)return!1}else{if(1!==r.length)return!1;{let t="empty";const n=[];for(let s=0;s<e.children.length;s++)if("partial"===e.children[s].label)n.push(...e.children[s].children),t="full";else{if(e.children[s].label!==t)return!1;n.push(e.children[s])}e.children=n,e.children.forEach((t=>t.parent=e))}}e.label="partial"}}else e.label=t.includes(e.value)?"full":"empty";if(e.pertinentLeafCount===s)break;e.parent&&e.parent.children.every((e=>e.label))&&n.push(e.parent)}return!0},u=(e,t)=>{const n=[],s=[e];for(;s.length>0;){const e=s.pop();e.children&&e.children.length>0?(e.pertinentLeafCount=0,s.push(...e.children)):t.includes(e.value)&&(e.pertinentLeafCount=1,n.push(e))}const r=n.length;for(;n.length>0;){const e=n.pop();if(e.pertinentLeafCount===r)return e;const t=e.parent;t&&(t.pertinentLeafCount++,n.push(t))}return e};for(let e=1;e<n;e++){const t=o(l,[h[e]]),n=i(l,[h[e]]);if(!t||!n)return!1;const r=s[h[e]].filter((t=>h.indexOf(t)>e)).map((e=>({value:e}))),c=u(l,[h[e]]);if("q"===c.type){const e={type:"p",children:r,parent:c};e.children.forEach((t=>t.parent=e));const t=[];let n=!1;for(let s=0;s<c.children.length;s++)"full"===c.children[s].label?n||(t.push(e),n=!0):t.push(c.children[s]);c.children=t,2===c.children.length&&(c.type="p")}else c.type="p",c.value=void 0,c.children=r,c.children.forEach((e=>e.parent=c))}return!0}))}_stNumbering(e=0,t=null){const n=this._nodes.length;if(0===n)return[];if(1===n)return[1];if(this.articulations().length>0)throw new Error("Only biconnected graph can calculate st-numbering");const s=this.adjacencyList();for(let e=0;e<n;e++){const t=s[e].indexOf(e);t>=0&&s[e].splice(t,1)}t??=s[e][0];const r=Array(n).fill("new"),h=Array(n).fill(1/0),l=Array(n).fill(-1),o=Array(n).fill(1/0),i=[];let u=1;const c=e=>{r[e]="old",h[e]=u++,o[e]=h[e];for(const t of s[e])"new"===r[t]?(i.push([e,t,"tree"]),l[t]=e,c(t),o[e]=Math.min(o[e],o[t])):l[e]!==t&&(i.push([e,t,"back"]),o[e]=Math.min(o[e],h[t]))};c(t);const p=[t,e],a=[];r.fill("new");const d=Array(i.length).fill("new");d[0]="old";let f=1;for(;p.length>0;){const e=p.pop();if(e===t){a[t]=f;break}const n=[];for(let t=0;t<i.length;t++){if("new"!==d[t])continue;const s=i[t];if(s[0]===e&&"back"===s[2]){d[t]="old",n.push(e,s[1]);break}if(s[0]===e&&"tree"===s[2]){let l=s[1];for(n.push(e,l),d[t]=r[l]=r[e]="old";l>=0;){const e=o[l];for(let t=0;t<i.length;t++){if(i[t][0]===l&&"back"===i[t][2]&&h[i[t][1]]===e){l=i[t][1],n.push(l),r[l]=d[t]="old",l=-1;break}if(i[t][0]===l&&"tree"===i[t][2]){l=i[t][1],n.push(l),r[l]=d[t]="old";break}}}break}if(s[1]===e&&"back"===s[2]){let h=s[0];for(n.push(e,h),r[e]=d[t]="old";"old"!==r[h];){r[h]="old";for(let e=0;e<i.length;e++)if(i[e][1]===h&&"tree"===i[e][2]){h=i[e][0],n.push(h),d[e]="old";break}}break}}if(0===n.length)a[e]=f++;else for(let e=n.length-2;e>=0;e--)p.push(n[e])}return a}isSymmetric(){if(this._nodes.length<=1)return!0;throw new GraphException("Not implemented")}isDAG(){return this.isDirected()&&!this.hasCycle()}isSeparable(){return!this.isBiconnected()}hasCycle(){return this.isUndirected()?this.hasCycleDFS():this.hasCycleEachNodes()}hasCycleDFS(){if(!this.isUndirected())throw new GraphException("This method only works undirected graph.");const e=Array(this._nodes.length).fill(!1),t=Array(this._edges.length).fill(!1),n=[0];for(;n.length>0||e.some((e=>!e));){const s=n.length>0?n.pop():e.indexOf(!1);if(e[s])return!0;e[s]=!0;for(let r=0;r<this._edges.length;r++){if(t[r])continue;const h=this._edges[r];if(h[0]===s){if(e[h[1]])return!0;t[r]=!0,n.push(h[1])}if(!h.direct&&h[1]===s){if(e[h[0]])return!0;t[r]=!0,n.push(h[0])}}}return!1}hasCycleEachNodes(){for(let e=0;e<this._nodes.length;e++){const t=[[[e],Array(this._edges.length).fill(!1)]];for(;t.length>0;){const[n,s]=t.pop(),r=n[n.length-1];for(let h=0;h<this._edges.length;h++){if(s[h])continue;const l=this._edges[h];if(l[0]===r){if(l[1]===e)return!0;if(n.includes(l[1]))continue;const r=s.concat();r[h]=!0,t.push([n.concat(l[1]),r])}if(!l.direct&&l[1]===r){if(l[0]===e)return!0;if(n.includes(l[1]))continue;const r=s.concat();r[h]=!0,t.push([n.concat(l[0]),r])}}}}return!1}isomorphism(e){return this.isomorphismUllmann(e)}isomorphismUllmann(e){if(!this.isUndirected())throw new GraphException("Currentry, isomorphismUllmann is only implemented for undirected graph.");const t=this._nodes.length,n=Matrix.zeros(t,t);for(const e of this._edges)n.set(e[0],e[1],1),n.set(e[1],e[0],1);const s=this.adjacencyList(),r=e._nodes.length,h=Array.from(e._nodes,(()=>Array(r).fill(0)));for(const t of e._edges)h[t[0]][t[1]]=h[t[1]][t[0]]=1;const l=e.adjacencyList(),o=[],i=(e,u,c)=>{if(u!==r){c=c.copy();for(let e=0;e<r;e++)for(let n=0;n<t;n++)if(1===c.at(e,n))for(const t of l[e])if(s[n].every((e=>1!==c.at(t,e)))){c.set(e,n,0);break}if(!c.sum(1).every((e=>0===e)))for(let n=0;n<t;n++){if(e[n]>=0||0===c.at(u,n))continue;const s=[];for(let e=0;e<t;e++)s.push(c.at(u,e)),c.set(u,e,e===n?1:0);e[n]=u,i(e.concat(),u+1,c),e[n]=-1;for(let e=0;e<t;e++)c.set(u,e,s[e])}}else{const s=c.dot(c.dot(n).t);let l=!0;for(let e=0;e<r&&l;e++)for(let t=0;t<r&&l;t++)1===h[e][t]&&0===s.at(e,t)&&(l=!1);if(l){const n=[];for(let s=0;s<t;s++)e[s]>=0&&(n[e[s]]=s);o.push(n)}}},u=Matrix.zeros(r,t);for(let e=0;e<r;e++)for(let n=0;n<t;n++)l[e].length<=s[n].length&&u.set(e,n,1);return i(Array(t).fill(-1),0,u),o}isomorphismVF2(e){throw new GraphException("Not implemented")}inducedSub(e){const t=[];for(const n of this._edges){const s=e.indexOf(n[0]),r=e.indexOf(n[1]);s>=0&&r>=0&&t.push(new Edge(s,r,n.value0,n.direct))}const n=e.map((e=>this._nodes[e]));return new Graph(n,t)}complement(){if(0===this._nodes.length)return new Graph(0);const e=[];for(let t=0;t<this._nodes.length;t++)for(let n=0;n<t;n++)0===this.getEdges(t,n).length&&e.push(new Edge(n,t));return new Graph(this._nodes.concat(),e)}contraction(e,t){if(e!==t){t<e&&([e,t]=[t,e]),this._nodes.splice(t,1);for(let n=this._edges.length-1;n>=0;n--){const s=this._edges[n];s[0]===e&&s[1]===t||s[1]===e&&s[0]===t?this._edges.splice(n,1):(s[0]===t?s[0]=e:s[0]>e&&s[0]--,s[1]===t?s[1]=e:s[1]>e&&s[1]--)}}}subdivision(e,t){this._nodes.push(null);const n=this._nodes.length-1;for(let s=this._edges.length-1;s>=0;s--){const r=this._edges[s];(r[0]===e&&r[1]===t||r[1]===e&&r[0]===t)&&(this._edges.splice(s,1),this._edges.push(new Edge(r[0],n,r.value0,r.direct)),this._edges.push(new Edge(n,r[0],r.value0,r.direct)))}}disjointUnion(e){const t=this._nodes.length;this._nodes=this._nodes.concat(e._nodes);for(const n of e._edges)this._edges.push(new Edge(n[0]+t,n[1]+t,n.value0,n.direct))}substitution(e,t){if(0===t._nodes.length)this.removeNode(e);else if(1===t._nodes.length)for(const n of t._edges)this._edges.push(new Edge(n[0]+e,n[1]+e,n.value0,n.direct));else{const n=this._nodes.length;this._nodes[e]=t._nodes[0],this._nodes=this._nodes.concat(t._nodes.slice(1));for(const s of this._edges)if(s[0]===e||s[1]===e)for(let r=0;r<t._nodes.length-1;r++)this._edges.push(new Edge(s[0]===e?n+r:s[0],s[1]===e?n+r:s[1],s.value0,s.direct));for(const s of t._edges)this._edges.push(new Edge(0===s[0]?e:s[0]+n-1,0===s[1]?e:s[1]+n-1,s.value0,s.direct))}}cartesianProduct(e){const t=this._nodes.length,n=e._nodes.length,s=[];for(let r=0;r<t;r++)for(let t=0;t<n;t++)null!=this._nodes[r]||null!=e._nodes[t]?s.push([this._nodes[r],this._nodes[t]]):s.push(null);const r=[];for(const e of this._edges)for(let s=0;s<n;s++)r.push(new Edge(e[0]+t*s,e[1]+t*s,e.value0,e.direct));for(const n of e._edges)for(let e=0;e<t;e++)r.push(new Edge(e+n[0]*t,e+n[1]*t,n.value0,n.direct));return new Graph(s,r)}tensorProduct(e){const t=this._nodes.length,n=e._nodes.length,s=[];for(let r=0;r<t;r++)for(let t=0;t<n;t++)null!=this._nodes[r]||null!=e._nodes[t]?s.push([this._nodes[r],this._nodes[t]]):s.push(null);const r=[];for(const n of this._edges)for(const s of e._edges)n.direct===s.direct&&(r.push(new Edge(n[0]+s[0]*t,n[1]+s[1]*t,n.weighted||s.weighted?[n.value0,s.value0]:null,n.direct)),n.direct||r.push(new Edge(n[1]+s[0]*t,n[0]+s[1]*t,n.weighted||s.weighted?[n.value0,s.value0]:null,n.direct)));return new Graph(s,r)}strongProduct(e){const t=this._nodes.length,n=e._nodes.length,s=[];for(let r=0;r<t;r++)for(let t=0;t<n;t++)null!=this._nodes[r]||null!=e._nodes[t]?s.push([this._nodes[r],this._nodes[t]]):s.push(null);const r=[];for(const e of this._edges)for(let s=0;s<n;s++)r.push(new Edge(e[0]+t*s,e[1]+t*s,e.value0,e.direct));for(const n of e._edges)for(let e=0;e<t;e++)r.push(new Edge(e+n[0]*t,e+n[1]*t,n.value0,n.direct));for(const n of this._edges)for(const s of e._edges)n.direct===s.direct&&(r.push(new Edge(n[0]+s[0]*t,n[1]+s[1]*t,n.weighted||s.weighted?[n.value0,s.value0]:null,n.direct)),n.direct||r.push(new Edge(n[1]+s[0]*t,n[0]+s[1]*t,n.weighted||s.weighted?[n.value0,s.value0]:null,n.direct)));return new Graph(s,r)}lexicographicProduct(e){const t=this._nodes.length,n=e._nodes.length,s=[];for(let r=0;r<t;r++)for(let t=0;t<n;t++)null!=this._nodes[r]||null!=e._nodes[t]?s.push([this._nodes[r],this._nodes[t]]):s.push(null);const r=[];for(const e of this._edges)for(let s=0;s<n;s++)for(let h=0;h<n;h++)r.push(new Edge(e[0]+t*s,e[1]+t*h,e.value0,e.direct));for(const n of e._edges)for(let e=0;e<t;e++)r.push(new Edge(e+n[0]*t,e+n[1]*t,n.value0,n.direct));return new Graph(s,r)}shortestPath(e){return null==e?this.shortestPathFloydWarshall():this.shortestPathDijkstra(e)}shortestPathBreadthFirstSearch(e){const t=Array.from({length:this._nodes.length},(()=>({length:1/0,prev:null,path:[]}))),n=[[e,null]];t[e]={length:0,prev:null,path:[e]};const s=Array(this._nodes.length).fill(!1);for(;n.length>0;){const[e,r]=n.shift();if(!s[e]){s[e]=!0,null!=r&&(t[e].prev=r,t[e].length=t[r].length+1,t[e].path=t[r].path.concat(e));for(const t of this._edges)t.value<=0||(t[0]!==e||s[t[1]]||n.push([t[1],e]),t.direct||t[1]!==e||s[t[0]]||n.push([t[0],e]))}}return t}shortestPathDijkstra(e){const t=Array.from({length:this._nodes.length},(()=>({length:1/0,prev:null,path:[]}))),n=[e];for(t[e]={length:0,prev:null,path:[e]};n.length>0;){const e=n.shift();for(const s of this._edges)s.value<=0||(s[0]===e&&t[s[1]].length>t[e].length+s.value&&(t[s[1]].length=t[e].length+s.value,t[s[1]].prev=e,t[s[1]].path=t[e].path.concat(s[1]),n.push(s[1])),!s.direct&&s[1]===e&&t[s[0]].length>t[e].length+s.value&&(t[s[0]].length=t[e].length+s.value,t[s[0]].prev=e,t[s[0]].path=t[e].path.concat(s[0]),n.push(s[0])))}return t}shortestPathBellmanFord(e){const t=Array.from({length:this._nodes.length},(()=>({length:1/0,prev:null,path:[]})));t[e]={length:0,prev:null,path:[e]};for(let e=0;e<this._nodes.length-1;e++)for(const e of this._edges)t[e[1]].length>t[e[0]].length+e.value&&(t[e[1]].length=t[e[0]].length+e.value,t[e[1]].prev=e[0],t[e[1]].path=t[e[0]].path.concat(e[1])),!e.direct&&t[e[0]].length>t[e[1]].length+e.value&&(t[e[0]].length=t[e[1]].length+e.value,t[e[0]].prev=e[1],t[e[0]].path=t[e[1]].path.concat(e[0]));return t}shortestPathFloydWarshall(){const e=[];for(let t=0;t<this._nodes.length;t++)e[t]=Array.from({length:this._nodes.length},(()=>({length:1/0,path:[]}))),e[t][t]={length:0,path:[t]};for(const t of this._edges)e[t[0]][t[1]].length>t.value&&(e[t[0]][t[1]].length=t.value,e[t[0]][t[1]].path=[t[0],t[1]]),!t.direct&&e[t[1]][t[0]].length>t.value&&(e[t[1]][t[0]].length=t.value,e[t[1]][t[0]].path=[t[1],t[0]]);for(let t=0;t<this._nodes.length;t++)for(let n=0;n<this._nodes.length;n++)for(let s=0;s<this._nodes.length;s++)e[n][s].length>e[n][t].length+e[t][s].length&&(e[n][s].length=e[n][t].length+e[t][s].length,e[n][s].path=e[n][t].path.concat(e[t][s].path.slice(1)));return e}minimumSpanningTree(){return this.minimumSpanningTreePrim()}minimumSpanningTreePrim(){const e=Array(this._nodes.length).fill(!1);e[0]=!0;const t=this._edges.concat(),n=[];for(;e.some((e=>!e));){let s=1/0,r=null;for(let n=t.length-1;n>=0;n--)e[t[n][0]]&&e[t[n][1]]?t.splice(n,1):(e[t[n][0]]&&!e[t[n][1]]||!t[n].direct&&e[t[n][1]]&&!e[t[n][0]])&&s>t[n].value&&(r=t[n],s=t[n].value);n.push(r),e[r[0]]=e[r[1]]=!0}return new Graph(this._nodes.length,n)}minimumSpanningTreeKruskal(){const e=Array.from({length:this._nodes.length},((e,t)=>t)),t=[],n=this._edges.concat();n.sort(((e,t)=>e.value-t.value));for(let s=0;s<n.length;s++){const r=n[s],h=e[r[1]];if(e[r[0]]!==h){t.push(r);for(let t=0;t<this._nodes.length;t++)e[t]===h&&(e[t]=e[r[0]])}}return new Graph(this._nodes.length,t)}minimumSpanningTreeBoruvka(){const e=Array.from({length:this._nodes.length},((e,t)=>t)),t=new Set;for(let n=0;n<this._nodes.length-1;n++){const n=[];for(const t of this._edges)e[t[0]]!==e[t[1]]&&((!n[e[t[0]]]||n[e[t[0]]].value>t.value)&&(n[e[t[0]]]=t),(!n[e[t[1]]]||n[e[t[1]]].value>t.value)&&(n[e[t[1]]]=t));if(0===n.length)break;for(const s of n){t.add(s);const n=e[s[1]];for(let t=0;t<this._nodes.length;t++)e[t]===n&&(e[t]=e[s[0]])}}return new Graph(this._nodes.length,[...t])}cut(e,t){const n=this.adjacencyMatrix();let s=0;for(let r=0;r<e.length;r++)for(let h=0;h<t.length;h++)s+=n[e[r]][t[h]];return s}mincut(e=1){if(e>Math.floor(this._nodes.length/2))throw new Error(`Invalid minv. ${e}, ${this._nodes.length}`);if(this._nodes.length<=6)return this.mincutBruteForce(e);let[t,n]=this.mincutStoerWagner(e);for(let s=1;s<this._nodes.length&&t!==1/0;s++)[t,n]=this.mincutStoerWagner(e,s);return t===1/0&&([t,n]=this.mincutKargersStein(e)),[t,n]}mincutBruteForce(e=1){const t=this.adjacencyMatrix(),n=Array(this._nodes.length).fill(!1);let s=null,r=1/0;do{const h=[],l=[];for(let e=0;e<this._nodes.length;e++)n[e]?h.push(e):l.push(e);if(h.length>=e&&l.length>=e){let e=0;for(let n=0;n<h.length;n++)for(let s=0;s<l.length;s++)t[h[n]][l[s]]&&(e+=t[h[n]][l[s]]);e<r&&(r=e,s=[h,l])}if(0===r)return[0,s];for(let e=0;e<this._nodes.length;e++){if(!n[e]){n[e]=!0;break}n[e]=!1}}while(n.some((e=>e)));return[r,s]}mincutStoerWagner(e=1,t=0){const n=this.adjacencyMatrix(),s=Array.from({length:this._nodes.length},((e,t)=>[t]));let r=null,h=1/0;const l=n.map((e=>e.concat()));for(let n=1;n<this._nodes.length;n++){const o=l[t].concat();let i=0,u=t;for(let e=0;e<this._nodes.length-n;e++){o[u]=-1/0,i=u;let e=-1/0;for(let t=0;t<o.length;t++)o[t]>e&&(e=o[t],u=t);for(let e=0;e<this._nodes.length;e++)o[e]+=l[u][e]}o[u]-l[u][u]<h&&s[u].length>=e&&this._nodes.length-s[u].length>=e&&(h=o[u]-l[u][u],r=s[u].concat()),s[i].push(...s[u]);for(let e=0;e<this._nodes.length;e++)l[e][i]=l[i][e]+=l[u][e];l[t][u]=-1/0}if(!r)return[h,[Array.from({length:this._nodes.length},((e,t)=>t))]];const o=[];for(let e=0;e<this._nodes.length;e++)r.includes(e)||o.push(e);return[h,[r,o]]}mincutKargers(e=1,t=null){const n=this.adjacencyMatrix();let s=null,r=1/0;null==t&&(t=this._nodes.length**2*Math.log(this._nodes.length));const h=[];let l=0;for(let e=0;e<this._nodes.length;e++){h[e]=new Set;for(let t=0;t<this._nodes.length;t++)n[e][t]&&(h[e].add(t),l++)}for(let o=0;o<t;o++){const t=Array.from({length:this._nodes.length},((e,t)=>[t])),o=n.map((e=>e.concat())),i=h.map((e=>new Set(e)));let u=l,c=0;for(let e=0;e<this._nodes.length-2&&u>0;e++){let e=Math.floor(Math.random()*u);for(c=0;c<this._nodes.length&&i[c].size<=e;c++)e-=i[c].size;let n=0;for(const t of i[c]){if(0===e){n=t;break}e--}for(const e of i[n])i[e].delete(n),u-=1,e!==c&&(o[c][e]||(i[c].add(e),i[e].add(c),u+=2),o[c][e]+=o[n][e],o[e][c]+=o[e][n]);t[c].push(...t[n]),t[n]=null,u-=i[n].size,i[n].clear()}if(0===u)return[0,t.filter((e=>null!==e))];const p=i[c].values().next().value;t[c].length<e||t[p].length<e||o[c][p]<r&&(r=o[c][p],s=[t[c],t[p]])}return s?[r,s]:[r,[Array.from({length:this._nodes.length},((e,t)=>t))]]}mincutKargersStein(e=1,t=null){const n=this.adjacencyMatrix(),s=Array.from({length:this._nodes.length},((e,t)=>[t]));null===t&&(t=Math.log(this._nodes.length)**2);let r=null,h=1/0;for(let l=0;l<t;l++){const[t,l]=this._mincutKargersStein0(n,s,e);t<h&&(h=t,r=l)}return[h,r]}_mincutKargersStein0(e,t,n){const s=e.length;if(s<=6){const r=Array(s).fill(!1);let h=null,l=1/0;do{const o=[],i=[];for(let e=0;e<s;e++)r[e]?o.push(e):i.push(e);const u=o.reduce(((e,n)=>e+t[n].length),0),c=i.reduce(((e,n)=>e+t[n].length),0);if(u>=n&&c>=n){let n=0;for(let t=0;t<o.length;t++)for(let s=0;s<i.length;s++)e[o[t]][i[s]]&&(n+=e[o[t]][i[s]]);n<l&&(l=n,h=[o.reduce(((e,n)=>e.concat(t[n])),[]),i.reduce(((e,n)=>e.concat(t[n])),[])])}if(0===l)return[0,h];for(let e=0;e<s;e++){if(!r[e]){r[e]=!0;break}r[e]=!1}}while(r.some((e=>e)));return[l,h]}const r=[];let h=0;for(let t=0;t<s;t++){r[t]=new Set;for(let n=0;n<s;n++)e[t][n]&&(r[t].add(n),h++)}const l=s/Math.sqrt(2)+1;let o=null,i=1/0;for(let u=0;u<2;u++){const u=t.map((e=>e.concat())),c=e.map((e=>e.concat())),p=r.map((e=>new Set(e)));let a=h,d=0;const f=[];for(let e=0;e<s-l;e++){let e=Math.floor(Math.random()*a);for(d=0;d<this._nodes.length&&p[d].size<=e;d++)e-=p[d].size;let t=0;for(const n of p[d]){if(0===e){t=n;break}e--}for(const e of p[t])p[e].delete(t),a-=1,e!==d&&(c[d][e]||(p[d].add(e),p[e].add(d),a+=2),c[d][e]+=c[t][e],c[e][d]+=c[e][t]);u[d].push(...u[t]),u[t]=null,a-=p[t].size,p[t].clear(),f.push(t)}f.sort(((e,t)=>t-e));for(let e=s-1;e>=0;e--)if(null===u[e])c.splice(e,1),u.splice(e,1);else for(let t=0;t<f.length;t++)c[e].splice(f[t],1);const[g,_]=this._mincutKargersStein0(c,u,n);g<i&&(i=g,o=_)}return[i,o]}bisectionSpectral(){const e=Matrix.fromArray(this.laplacianMatrix()).tridiagLanczos(),t=e.eigenValuesQR(),[,n]=e.eigenInverseIteration(t[1]),s=n.median(),r=[],h=[];for(let e=0;e<this._nodes.length;e++)n.at(e,0)>s?r.push(e):h.push(e);return[this.cut(r,h),[r,h]]}}