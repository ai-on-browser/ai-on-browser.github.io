import Matrix from"./matrix.js";export class GraphException extends Error{constructor(e,t){super(e),this.value=t,this.name="GraphException"}}export class Edge{constructor(e,t,n=null,s=!1){this[0]=e,this[1]=t,this.value=n??1,this.direct=s,this.weighted=null!=n}get value0(){return this.weighted?this.value:null}}export default class Graph{constructor(e=0,t=[]){Array.isArray(e)?this._nodes=e:this._nodes=Array(e),this._edges=t.map((e=>new Edge(e[0],e[1],e instanceof Edge?e.value0:e.value,e.direct)))}static fromAdjacency(e){const t=e.length,n=[];for(let s=0;s<t;s++)for(let t=0;t<=s;t++)(e[s][t]||e[t][s])&&(e[s][t]===e[t][s]?n.push(new Edge(t,s,+e[s][t])):(e[s][t]&&n.push(new Edge(s,t,+e[s][t],!0)),e[t][s]&&n.push(new Edge(t,s,+e[t][s],!0))));return new Graph(t,n)}static complete(e){const t=[];for(let n=0;n<e;n++)for(let e=0;e<n;e++)t.push([n,e]);return new Graph(e,t)}static completeBipartite(e,t){const n=[];for(let s=0;s<e;s++)for(let h=0;h<t;h++)n.push([s,h+e]);return new Graph(e+t,n)}static cycle(e,t=!1){if(e<3)throw new GraphException("Index out of bounds.");const n=[];for(let s=0;s<e;s++)n.push(new Edge(s,(s+1)%e,null,t));return new Graph(e,n)}static wheel(e){if(e<4)throw new GraphException("Index out of bounds.");const t=[];for(let n=1;n<e;n++)t.push([n,n%(e-1)+1]),t.push([0,n]);return new Graph(e,t)}static windmill(e,t){if(1===e)return new Graph(1);const n=[];for(let s=0;s<t;s++)for(let t=0;t<e;t++)for(let h=0;h<t;h++)n.push([0===h?0:s*(e-1)+h,s*(e-1)+t]);return new Graph(t*(e-1)+1,n)}static fromName(e){switch(e){case"balaban 10 cage":{const e=[];for(let t=0;t<10;t++)e.push([2*t,(t+3)%10*2+1]),e.push([2*t+1,(t+3)%10*2]),e.push([2*t,3*t+20]),e.push([2*t+1,3*t+22]),e.push([3*t+20,3*t+21]),e.push([3*t+21,3*t+22]),t<5&&e.push([3*t+21,3*(t+5)+21]),e.push([3*t+20,2*t+50]),e.push([3*t+22,2*t+51]),e.push([2*t+50,(t+1)%10*2+50]),e.push([2*t+51,(t+1)%10*2+51]);return new Graph(70,e)}case"bidiakis cube":{const e=[];for(let t=0;t<12;t++)e.push([t,(t+1)%12]);return e.push([0,8],[1,7],[2,6],[3,11],[4,10],[5,9]),new Graph(12,e)}case"biggs smith":{const e=[];for(let t=0;t<17;t++)e.push([t,(t+8)%17]),e.push([t,t+17]),e.push([t+17,t+51]),e.push([t+17,t+68]),e.push([t+34,(t+4)%17+34]),e.push([t+34,t+68]),e.push([t+51,(t+2)%17+51]),e.push([t+68,t+85]),e.push([t+85,(t+1)%17+85]);return new Graph(102,e)}case"brinkmann":{const e=[];for(let t=0;t<7;t++)e.push([t,(t+3)%7]),e.push([t,t+7]),e.push([t,(t+5)%7+7]),e.push([t+7,t+14]),e.push([t+7,(t+1)%7+14]),e.push([t+14,(t+2)%7+14]);return new Graph(21,e)}case"bull":return new Graph(5,[[0,1],[1,2],[1,3],[2,3],[3,4]]);case"butterfly":return new Graph(5,[[0,1],[0,2],[1,2],[2,3],[2,4],[3,4]]);case"chvatal":{const e=[];for(let t=0;t<4;t++)e.push([t,(t+1)%4]),e.push([t,2*t+4]),e.push([t,(2*t+7)%8+4]),e.push([2*t+4,2*t+5]),e.push([2*t+4,(2*t+3)%8+4]);return e.push([4,8],[5,9],[6,10],[7,11]),new Graph(12,e)}case"clebsch":{const e=[];for(let t=0;t<8;t++)e.push([t,(t+3)%8]),e.push([t,t+8]),e.push([t,(t+2)%8+8]),e.push([t+8,(t+1)%8+8]);for(let t=0;t<4;t++)e.push([t,t+4]),e.push([t+8,t+12]);return new Graph(16,e)}case"coxeter":{const e=[];for(let t=0;t<3;t++)e.push([0,8*t+4]),e.push([t+1,8*t+8]),e.push([t+1,(8*t+15)%24+4]),e.push([t+1,(8*t+22)%24+4]),e.push([8*t+5,(8*t+19)%24+4]),e.push([8*t+9,(8*t+18)%24+4]);for(let t=0;t<24;t++)e.push([t+4,(t+1)%24+4]);return new Graph(28,e)}case"desargues":{const e=[];for(let t=0;t<10;t++)e.push([t,(t+3)%10]),e.push([t,t+10]),e.push([t+10,(t+1)%10+10]);return new Graph(20,e)}case"diamond":return new Graph(4,[[0,1],[0,2],[1,2],[1,3],[2,3]]);case"durer":{const e=[];for(let t=0;t<6;t++)e.push([t,(t+1)%6]),e.push([t,t+6]),e.push([t+6,(t+2)%6+6]);return new Graph(12,e)}case"dyck":{const e=[];for(let t=0;t<32;t++)e.push([t,(t+1)%32]);for(let t=0;t<8;t++)e.push([4*t,(4*t+5)%32]),e.push([4*t+2,(4*t+15)%32]);return new Graph(32,e)}case"errera":{const e=[[0,1],[2,3],[5,6],[9,10],[15,16]];for(let t=0;t<2;t++)e.push([0,11+t]),e.push([0,15+t]),e.push([1,5+t]),e.push([1,11+t]),e.push([2,5+t]),e.push([2,7+t]),e.push([3,7+t]),e.push([3,9+t]),e.push([4,9+t]),e.push([4,13+t]),e.push([4,15+t]),e.push([5+t,7+t]),e.push([5+t,11+t]),e.push([5+t,13+t]),e.push([7+t,9+t]),e.push([7+t,13+t]),e.push([9+t,13+t]),e.push([11+t,13+t]),e.push([11+t,15+t]),e.push([13+t,15+t]);return new Graph(17,e)}case"folkman":{const e=[];for(let t=0;t<5;t++)for(let n=0;n<4;n++)e.push([4*t+n,4*t+(n+1)%4]);for(let t=0;t<4;t++)e.push([4*t+2,4*(t+1)+1]),e.push([4*t+2,4*(t+1)+3]);for(let t=0;t<3;t++)e.push([4*t,4*(t+2)+1]),e.push([4*t,4*(t+2)+3]);return e.push([1,12],[1,18],[3,12],[3,18],[5,16],[7,16]),new Graph(20,e)}case"foster":{const e=[];for(let t=0;t<15;t++){for(let n=0;n<6;n++)e.push([6*t+n,(6*t+n+1)%90]);e.push([6*t,(t+8)%15*6+5]),e.push([6*t+1,(t+1)%15*6+4]),e.push([6*t+2,(t+12)%15*6+3])}return new Graph(90,e)}case"franklin":{const e=[];for(let t=0;t<12;t++)e.push([t,(t+1)%12]);return e.push([0,7],[1,6],[2,9],[3,8],[4,11],[5,10]),new Graph(12,e)}case"frucht":{const e=[];for(let t=0;t<7;t++)e.push([t,(t+1)%7]);return e.push([0,7],[1,8],[2,8],[3,9],[4,9],[5,10],[6,10],[7,10],[7,11],[8,11],[9,11]),new Graph(12,e)}case"goldner-harary":{const e=[];for(let t=0;t<4;t++)e.push([0,t+1]),e.push([0,t+5]),e.push([t+1,t+5]),e.push([t+1,(t+3)%4+5]),e.push([t+5,(t+3)%4+5]);return e.push([5,9],[9,7],[7,10],[10,5],[5,7],[6,9],[8,10]),new Graph(11,e)}case"golomb":{const e=[];for(let t=0;t<6;t++)e.push([0,t+1]),e.push([t+1,(t+1)%6+1]);for(let t=0;t<3;t++)e.push([t+7,(t+1)%3+7]),e.push([2*t+1,t+7]);return new Graph(10,e)}case"gray":{const e=[];for(let t=0;t<54;t++)e.push([t,(t+1)%54]);for(let t=0;t<9;t++)e.push([6*t,(t+4)%9*6+1]),e.push([6*t+2,(t+2)%9*6+3]),e.push([6*t+4,(t+1)%9*6+5]);return new Graph(54,e)}case"grotzsch":{const e=[];for(let t=0;t<5;t++)e.push([0,t+1]),e.push([t+1,t+6]),e.push([t+6,(t+4)%5+1]),e.push([t+6,(t+2)%5+6]);return new Graph(11,e)}case"harries":{const e=[];for(let t=0;t<10;t++)e.push([t,(t+3)%10]),e.push([t,5*t+20]),t%2==0?(e.push([t+10,(t+1)%10+10]),e.push([t+10,5*t+22])):(e.push([t+10,(t+3)%10+10]),e.push([t+10,5*t+24]));for(let t=0;t<50;t++)e.push([t+20,(t+1)%50+20]);for(let t=0;t<5;t++)e.push([10*t+24,(10*t+13)%50+20]),e.push([10*t+28,(10*t+17)%50+20]),e.push([5*t+21,(5*t+25)%50+21]);return new Graph(70,e)}case"heawood":{const e=[];for(let t=0;t<7;t++)e.push([2*t,2*t+1]),e.push([2*t+1,(2*t+2)%14]),e.push([2*t,(2*t+5)%14]);return new Graph(14,e)}case"herschel":{const e=[];for(let t=0;t<4;t++)e.push([0,t+1]),e.push([t+1,t+5]),e.push([t+1,(t+3)%4+5]);return e.push([5,9],[5,10],[6,9],[7,9],[7,10],[8,10]),new Graph(11,e)}case"hoffman":{const e=[];for(let t=0;t<2;t++)e.push([0,6+t]),e.push([0,10+t]),e.push([1,8+t]),e.push([1,10+t]),e.push([2,6+t]),e.push([2,14+t]),e.push([3,8+t]),e.push([3,14+t]),e.push([4+t,6+t]),e.push([4+t,10+t]),e.push([4+t,9-t]),e.push([4+t,15-t]),e.push([6+t,12+t]),e.push([8+t,12+t]),e.push([10+t,12+t]),e.push([12+t,14+t]);return new Graph(16,e)}case"holt":{const e=[];for(let t=0;t<9;t++)e.push([t,(t+4)%9]),e.push([t,(t+7)%9+9]),e.push([t,(t+1)%9+18]),e.push([t+9,(t+1)%9+9]),e.push([t+9,t+18]),e.push([t+18,(t+2)%9+18]);return new Graph(27,e)}case"kittell":return new Graph(23,[[0,1],[0,2],[0,3],[0,4],[0,15],[0,16],[1,2],[1,4],[1,5],[1,6],[1,7],[1,12],[2,3],[2,7],[2,8],[3,8],[3,14],[3,15],[4,5],[4,9],[4,16],[4,17],[5,6],[5,9],[5,10],[6,10],[6,11],[6,12],[7,8],[7,12],[7,13],[8,13],[8,14],[9,10],[9,17],[9,18],[10,11],[10,18],[10,19],[11,12],[11,19],[11,20],[12,13],[12,20],[12,21],[13,14],[13,21],[14,15],[14,21],[15,16],[15,21],[16,17],[16,21],[16,22],[17,18],[17,22],[18,19],[18,22],[19,20],[19,22],[20,21],[20,22],[21,22]]);case"markstrom":{const e=[];for(let t=0;t<3;t++)e.push([8*t,8*t+1]),e.push([8*t,8*t+4]),e.push([8*t+1,8*t+2]),e.push([8*t+1,8*t+3]),e.push([8*t+2,8*t+3]),e.push([8*t+2,(t+1)%3*8]),e.push([8*t+3,8*t+5]),e.push([8*t+4,8*t+5]),e.push([8*t+4,8*t+6]),e.push([8*t+5,8*t+6]),e.push([8*t+6,8*t+7]),e.push([8*t+7,(t+1)%3*8+7]);return new Graph(24,e)}case"mcgee":{const e=[];for(let t=0;t<24;t++)e.push([t,(t+1)%24]);for(let t=0;t<8;t++)e.push([3*t+1,(3*t+8)%24]);for(let t=0;t<4;t++)e.push([3*t,3*t+12]);return new Graph(24,e)}case"meredith":{const e=[];for(let t=0;t<5;t++){for(let n=0;n<4;n++)for(let s=0;s<3;s++)e.push([14*t+n,14*t+4+s]),e.push([14*t+7+n,14*t+11+s]);e.push([14*t+1,14*t+8]),e.push([14*t+2,14*t+9]),e.push([14*t+3,(t+2)%5*14]),e.push([14*t+10,(t+1)%5*14+7])}return new Graph(70,e)}case"mobius kantor":{const e=[];for(let t=0;t<8;t++)e.push([t,(t+3)%8]),e.push([t,t+8]),e.push([t+8,(t+1)%8+8]);return new Graph(16,e)}case"moser spindle":return new Graph(7,[[0,1],[0,2],[0,3],[0,4],[1,2],[1,5],[2,5],[3,4],[3,6],[4,6],[5,6]]);case"nauru":{const e=[];for(let t=0;t<24;t++)e.push([t,(t+1)%24]);for(let t=0;t<4;t++)e.push([6*t,6*t+5]),e.push([6*t+2,(6*t+9)%24]),e.push([6*t+1,(6*t+16)%24]);return new Graph(24,e)}case"pappus":{const e=[];for(let t=0;t<6;t++)e.push([t,(t+1)%6+6]),e.push([t,(t+5)%6+6]),e.push([t+6,t+12]),e.push([t+12,(t+1)%6+12]);return e.push([0,3],[1,4],[2,5]),new Graph(18,e)}case"petersen":{const e=[];for(let t=0;t<5;t++)e.push([t,(t+1)%5]),e.push([t,t+5]),e.push([t+5,(t+2)%5+5]);return new Graph(10,e)}case"poussin":{const e=[[0,1],[1,2],[3,4],[5,6],[13,14]];for(let t=0;t<2;t++)e.push([0,7+t]),e.push([0,13+t]),e.push([1,7+t]),e.push([1,9+t]),e.push([2,5+t]),e.push([2,9+t]),e.push([3,5+t]),e.push([3,11+t]),e.push([4,11+t]),e.push([4,13+t]),e.push([5+t,9+t]),e.push([5+t,11+t]),e.push([7+t,9+t]),e.push([7+t,13+t]),e.push([9+t,13+t]),e.push([9+t,11+t]),e.push([11+t,13+t]);return new Graph(15,e)}case"robertson":{const e=[[0,2],[1,3]];for(let t=0;t<4;t++)e.push([t,3*t+4]),e.push([(t+3)%4,3*t+5]),e.push([(t+2)%4,3*t+6]),e.push([3*t+4,3*t+5]),e.push([3*t+5,3*t+6]),e.push([3*t+6,(t+1)%4*3+4]);for(let t=0;t<3;t++)for(let n=0;n<4;n++)e.push([t+16,(4*t+3*n)%12+4]);return new Graph(19,e)}case"shrikhande":{const e=[];for(let t=0;t<4;t++)e.push([4*t,(t+1)%4*4]),e.push([4*t,4*t+1]),e.push([4*t,4*t+2]),e.push([4*t,(t+1)%4*4+1]),e.push([4*t,(t+1)%4*4+2]),e.push([4*t+1,(t+1)%4*4+2]),e.push([4*t+1,4*t+3]),e.push([4*t+2,(t+1)%4*4+1]),e.push([4*t+2,(t+1)%4*4+3]),e.push([4*t+2,(t+2)%4*4+3]),e.push([4*t+3,(t+1)%4*4+1]),e.push([4*t+3,(t+1)%4*4+3]);return new Graph(16,e)}case"sousselier":{const e=[];for(let t=0;t<5;t++)e.push([0,3*t+1]),e.push([3*t+2,(3*t+5)%15+1]);for(let t=0;t<15;t++)e.push([t+1,(t+1)%15+1]);return e.push([2,12],[5,15]),new Graph(16,e)}case"sylvester":{const e=[];for(let t=0;t<6;t++)e.push([6*t,6*t+2]),e.push([6*t,6*t+5]),e.push([6*t,(t+1)%6*6+4]),e.push([6*t,(t+3)%6*6+1]),e.push([6*t,(t+3)%6*6+3]),e.push([6*t+1,6*t+2]),e.push([6*t+1,(t+2)%6*6+4]),e.push([6*t+1,(t+3)%6*6+4]),e.push([6*t+1,(t+4)%6*6+2]),e.push([6*t+2,(t+1)%6*6+5]),e.push([6*t+2,(t+2)%6*6+5]),e.push([6*t+3,6*t+4]),e.push([6*t+3,(t+1)%6*6+3]),e.push([6*t+3,(t+1)%6*6+5]),t<3&&(e.push([6*t+4,(t+3)%6*6+4]),e.push([6*t+5,(t+3)%6*6+5]));return new Graph(36,e)}case"tutte":{const e=[];for(let t=0;t<3;t++)e.push([0,15*t+1]),e.push([15*t+1,15*t+2]),e.push([15*t+1,15*t+4]),e.push([15*t+2,15*t+3]),e.push([15*t+2,15*t+5]),e.push([15*t+3,15*t+4]),e.push([15*t+3,15*t+7]),e.push([15*t+4,15*t+9]),e.push([15*t+5,15*t+6]),e.push([15*t+5,15*t+10]),e.push([15*t+6,15*t+7]),e.push([15*t+6,15*t+11]),e.push([15*t+7,15*t+8]),e.push([15*t+8,15*t+9]),e.push([15*t+8,15*t+12]),e.push([15*t+9,15*t+15]),e.push([15*t+10,15*t+11]),e.push([15*t+10,15*t+13]),e.push([15*t+11,15*t+12]),e.push([15*t+12,15*t+14]),e.push([15*t+13,15*t+14]),e.push([15*t+14,15*t+15]),e.push([15*t+15,(t+1)%3*15+13]);return new Graph(46,e)}case"tutte coxeter":{const e=[];for(let t=0;t<30;t++)e.push([t,(t+1)%30]);for(let t=0;t<5;t++)e.push([6*t,(t+1)%5*6+3]),e.push([6*t+1,(t+2)%5*6+2]),e.push([6*t+4,(t+1)%5*6+5]);return new Graph(30,e)}case"wagner":{const e=[];for(let t=0;t<4;t++)e.push([t,t+1]),e.push([t,t+4]),e.push([t+4,(t+5)%8]);return new Graph(8,e)}case"wells":{const e=[];for(let t=0;t<8;t++)e.push([4*t,(t+1)%8*4]),e.push([4*t,(t+2)%8*4+3]),e.push([4*t+1,(t+1)%8*4+3]),e.push([4*t+1,(t+2)%8*4]),e.push([4*t+1,(t+2)%8*4+3]),e.push([4*t+1,(t+3)%8*4+2]),e.push([4*t+2,(t+1)%8*4]),e.push([4*t+2,(t+3)%8*4+2]),e.push([4*t+3,(t+1)%8*4+1]),e.push([4*t+3,(t+3)%8*4+2]);return new Graph(32,e)}case"wiener araya":{const e=[];for(let t=0;t<4;t++)e.push([10*t,10*t+1]),e.push([10*t,10*t+2]),e.push([10*t,(t+1)%4*10]),e.push([10*t+1,10*t+3]),e.push([10*t+1,10*t+5]),e.push([10*t+2,10*t+4]),e.push([10*t+2,(t+1)%4*10+5]),e.push([10*t+3,10*t+4]),e.push([10*t+3,10*t+7]),e.push([10*t+4,10*t+9]),e.push([10*t+5,10*t+6]),e.push([10*t+6,10*t+7]),e.push([10*t+6,(t+3)%4*10+9]),e.push([10*t+7,10*t+8]),e.push([10*t+8,10*t+9]),t%2==1?(e.push([10*t+8,(t+1)%4*10+8]),e.push([10*t+8,1===t?40:41])):e.push([10*t+9,0===t?40:41]);return e.push([40,41]),new Graph(42,e)}}}get order(){return this._nodes.length}get size(){return this._edges.length}get nodes(){return this._nodes}get edges(){return this._edges}toDot(){let e=this.isUndirected()?"graph":"digraph";e+=" g {\n";for(let t=0;t<this._nodes.length;t++)e+=`  ${t} [label="${JSON.stringify(this._nodes[t]??t).replace('"',"'")}"];\n`;for(const t of this._edges)e+=`  ${t[0]} ${t.direct?"->":"--"} ${t[1]}`,t.weighted&&(e+=` [label="${JSON.stringify(t.value).replace('"',"'")}"]`),e+=";\n";return e+"}"}toString(){let e=`Number of nodes: ${this._nodes.length}\n`;this._nodes.some((e=>null!=e))&&(e+=`Node values: ${JSON.stringify(this._nodes)}\n`),e+=`Number of edges: ${this._edges.length}`,this._edges.length>0&&(e+="\nEdges");for(const t of this._edges)e+=`\n  From ${t[0]} to ${t[1]}, value: ${JSON.stringify(t.value)} (${t.direct?"directed":"undirected"})`;return e}copy(){const e=this._edges.map((e=>new Edge(e[0],e[1],e.value0,e.direct))),t=this._nodes.concat();return new Graph(t,e)}degree(e,t=!0,n=!0){"in"!==t&&"out"!==t||(n=t,t=!1);let s=0;for(const h of this._edges)(!t||h.direct||h[0]!==e&&h[1]!==e)&&(!0!==n||!h.direct||h[0]!==e&&h[1]!==e)?("in"===n&&h.direct&&h[1]===e||"out"===n&&h.direct&&h[0]===e)&&s++:s++;return s}adjacencies(e,t=!0,n=!0){"in"!==t&&"out"!==t||(n=t,t=!1);const s=[],h=Array(this._nodes.length).fill(!1);for(const r of this._edges)if(!t||r.direct||r[0]!==e&&r[1]!==e)if(!0!==n||!r.direct||r[0]!==e&&r[1]!==e){if("in"===n&&r.direct&&r[1]===e){if(h[r[0]])continue;s.push(r[0]),h[r[0]]=!0}else if("out"===n&&r.direct&&r[0]===e){if(h[r[1]])continue;s.push(r[1]),h[r[1]]=!0}}else{const t=r[0]===e?r[1]:r[0];if(h[t])continue;s.push(t),h[t]=!0}else{const t=r[0]===e?r[1]:r[0];if(h[t])continue;s.push(t),h[t]=!0}return s.sort(((e,t)=>e-t)),s}components(){const e=Array(this._nodes.length).fill(!1),t=[0],n=[];let s=[];for(;t.length>0||e.some((e=>!e));){0===t.length&&(s.sort(((e,t)=>e-t)),n.push(s),s=[]);const h=t.length>0?t.pop():e.indexOf(!1);if(!e[h]){e[h]=!0,s.push(h);for(const e of this._edges)e[0]===h&&t.push(e[1]),e[1]===h&&t.push(e[0])}}return s.length>0&&(s.sort(((e,t)=>e-t)),n.push(s)),n}diameter(){const e=this.shortestPathFloydWarshall();let t=-1/0;for(let n=0;n<this._nodes.length;n++)for(let s=0;s<this._nodes.length;s++)t<e[n][s].length&&(t=e[n][s].length);return t}eccentricity(e){const t=this.shortestPathBellmanFord(e);let n=-1/0;for(let e=0;e<this._nodes.length;e++)n<t[e].length&&(n=t[e].length);return n}radius(){const e=this.shortestPathFloydWarshall();let t=1/0;for(let n=0;n<this._nodes.length;n++){let s=-1/0;for(let t=0;t<this._nodes.length;t++)s<e[n][t].length&&(s=e[n][t].length);t>s&&(t=s)}return t}center(){const e=this.shortestPathFloydWarshall(),t=Array(this._nodes.length).fill(-1/0);let n=1/0;for(let s=0;s<this._nodes.length;s++){for(let n=0;n<this._nodes.length;n++)t[s]<e[s][n].length&&(t[s]=e[s][n].length);n>t[s]&&(n=t[s])}const s=[];for(let e=0;e<t.length;e++)t[e]===n&&s.push(e);return s}girth(){let e=1/0;for(let t=0;t<this._nodes.length;t++){const n=[[[t],Array(this._edges.length).fill(!1)]];for(;n.length>0;){const[s,h]=n.shift(),r=s[s.length-1];for(let l=0;l<this._edges.length;l++){if(h[l])continue;const o=this._edges[l];if(o[0]===r){if(o[1]===t){s.length<e&&(e=s.length),n.length=0;break}if(s.indexOf(o[1])>=0)continue;const r=h.concat();r[l]=!0,n.push([s.concat(o[1]),r])}if(!o.direct&&o[1]===r){if(o[0]===t){s.length<e&&(e=s.length),n.length=0;break}if(s.indexOf(o[0])>=0)continue;const r=h.concat();r[l]=!0,n.push([s.concat(o[0]),r])}}}}return e}clique(e){const t=this._nodes.length;if(null!=e&&e>t)return[];const n=Array.from({length:t},((e,t)=>[t]));if(1===e)return n;if(1===t)return[n];const s=[],h=[];for(let e=0;e<t;e++){s[e]=[];for(let t=0;t<e;t++)this.getEdges(e,t).length>0&&(s[e][t]=!0,s[t][e]=!0,h.push([t,e]))}if(2===e)return h;const r=e??this._nodes.length,l=[n,h];for(let e=2;e<r;e++){const n=[];for(let h=0;h<l[e-1].length;h++){const r=l[e-1][h];for(let e=r.at(-1)+1;e<t;e++)r.every((t=>s[t][e]))&&n.push(r.concat(e))}l.push(n)}return null==e?l:l[e-1]}chromaticNumber(){if(this._nodes.length<=1)return this._nodes.length;if(0===this._edges.length)return 1;if(this.isBipartite())return 2;if(this.isComplete())return this._nodes.length;throw new GraphException("Not implemented")}chromaticIndex(){if(this._edges.length<=1)return this._edges.length;throw new GraphException("Not implemented")}articulations(){const e=this._nodes.length,t=[];for(let n=0;n<e;n++){const s=this.adjacencies(n);if(s.length<=1)continue;const h=Array(e).fill(!1);h[n]=!0;const r=[s[0]];for(;r.length>0;){const e=r.pop();if(!h[e]){h[e]=!0;for(const t of this._edges)t[0]===e&&r.push(t[1]),t[1]===e&&r.push(t[0])}}s.some((e=>!h[e]))&&t.push(n)}return t}addNode(e){this._nodes[this._nodes.length]=e}getNode(e){if(null==e)return this._nodes;if(Array.isArray(e)){if(e.some((e=>e<0||this._nodes.length<=e)))throw new GraphException("Index out of bounds.");return e.map((e=>this._nodes[e]))}if(e<0||this._nodes.length<=e)throw new GraphException("Index out of bounds.");return this._nodes[e]}removeNode(e){if(e<0||this._nodes.length<=e)throw new GraphException("Index out of bounds.");this._nodes.splice(e,1);for(let t=this._edges.length-1;t>=0;t--){const n=this._edges[t];n[0]===e||n[1]===e?this._edges.splice(t,1):(n[0]>e&&n[0]--,n[1]>e&&n[1]--)}}addEdge(e,t,n=null,s=!1){if(e<0||this._nodes.length<=e||t<0||this._nodes.length<=t)throw new GraphException("Index out of bounds.");this._edges.push(new Edge(e,t,n,s))}getEdges(e,t,n=null){if(e<0||this._nodes.length<=e||t<0||this._nodes.length<=t)throw new GraphException("Index out of bounds.");const s=[];for(const h of this._edges)null!==n&&!n!=!h.direct||(h[0]===e&&h[1]===t||h[1]===e&&h[0]===t)&&s.push(h);return s}removeEdges(e,t,n=null){if(e<0||this._nodes.length<=e||t<0||this._nodes.length<=t)throw new GraphException("Index out of bounds.");for(let s=this._edges.length-1;s>=0;s--){const h=this._edges[s];null!==n&&!n!=!h.direct||(h[0]===e&&h[1]===t||h[1]===e&&h[0]===t)&&this._edges.splice(s,1)}}adjacencyMatrix(){const e=Array.from({length:this._nodes.length},(()=>Array(this._nodes.length).fill(0)));for(const t of this._edges)t.direct?e[t[0]][t[1]]+=t.value:(e[t[0]][t[1]]+=t.value,e[t[1]][t[0]]+=t.value);return e}adjacencyList(e="both"){const t=this._nodes.length,n=Array.from({length:t},(()=>[])),s=Array.from({length:t},(()=>Array(t).fill(!1)));for(const t of this._edges)t[0]===t[1]?s[t[0]][t[1]]||(n[t[0]].push(t[1]),s[t[0]][t[1]]=!0):t.direct&&"both"!==e?"in"===e?s[t[1]][t[0]]||(n[t[1]].push(t[0]),s[t[1]][t[0]]=!0):s[t[0]][t[1]]||(n[t[0]].push(t[1]),s[t[0]][t[1]]=!0):(s[t[0]][t[1]]||n[t[0]].push(t[1]),s[t[1]][t[0]]||n[t[1]].push(t[0]),s[t[0]][t[1]]=s[t[1]][t[0]]=!0);for(let e=0;e<t;e++)n[e].sort(((e,t)=>e-t));return n}degreeMatrix(e="both"){const t=Array.from({length:this._nodes.length},(()=>Array(this._nodes.length).fill(0)));for(const n of this._edges)n.direct&&"both"!==e?"in"===e?t[n[1]][n[1]]+=n.value:t[n[0]][n[0]]+=n.value:(t[n[0]][n[0]]+=n.value,t[n[1]][n[1]]+=n.value);return t}laplacianMatrix(){const e=this.adjacencyMatrix(),t=[];for(let n=0;n<this._nodes.length;n++){t[n]=e[n].map((e=>-e));for(let s=0;s<this._nodes.length;s++)t[n][n]+=e[n][s]}return t}isNull(){return 0===this._nodes.length}isEdgeless(){return 0===this._edges.length}isUndirected(){return this._edges.every((e=>!e.direct))}isDirected(){return this._edges.every((e=>e.direct))}isMixed(){let e=!1,t=!1;for(const n of this._edges)if(n.direct?e=!0:t=!0,e&&t)return!0;return!1}isWeighted(){return this._edges.some((e=>e.weighted))}isSimple(){const e=Array.from({length:this._nodes.length},(()=>[]));for(const t of this._edges){if(t[0]===t[1])return!1;if(e[t[0]].indexOf(t[1])>=0||e[t[1]].indexOf(t[0])>=0)return!1;e[t[0]].push(t[1])}return!0}isConnected(){const e=Array(this._nodes.length).fill(!1),t=[0];for(;t.length>0;){const n=t.pop();if(!e[n]){e[n]=!0;for(const s of this._edges)s[0]!==n||e[s[1]]||t.push(s[1]),s.direct||s[1]!==n||e[s[0]]||t.push(s[0])}}return e.every((e=>e))}isBiconnected(){const e=new Graph(this._nodes.length);for(const t of this._edges)e.addEdge(t[0],t[1]);for(let t=0;t<this._nodes.length;t++){const n=e.copy();if(n.removeNode(t),!n.isConnected())return!1}return!0}isTree(){return this.isConnected()&&!this.hasCycle()}isForest(){return!this.hasCycle()}isBipartite(){const e=Array(this._nodes.length).fill(!1),t=[[0,1]];for(;t.length>0||e.some((e=>!e));){const[n,s]=t.length>0?t.pop():[e.indexOf(!1),1];if(e[n]){if(e[n]===s)continue;return!1}e[n]=s;for(const h of this._edges){if(h[0]===n){if(e[h[1]]===s)return!1;t.push([h[1],s%2+1])}if(!h.direct&&h[1]===n){if(e[h[0]]===s)return!1;t.push([h[0],s%2+1])}}}return!0}isComplete(){for(let e=0;e<this._nodes.length;e++)for(let t=0;t<e;t++)if(0===this.getEdges(e,t).length)return!1;return!0}isRegular(e=null){if(this._nodes.length<=1)return!0;const t=this.degree(0);for(let n=1;n<this._nodes.length;n++){const s=this.degree(n);if(t!==s||null!==e&&s!==e)return!1}return!0}isPlainer(){const e=this._nodes.length,t=new Graph(e),n=Array.from({length:e},(()=>Array(e).fill(!1)));for(const e of this._edges)e[0]===e[1]||n[e[0]][e[1]]||(t.addEdge(e[0],e[1]),n[e[0]][e[1]]=n[e[1]][e[0]]=!0);return t.components().every((e=>{const n=t.inducedSub(e),s=n._nodes.length,h=n._edges.length;if(s<=4||h<=8)return!0;if(h>3*s-6)return!1;if(n.clique(5).length>0)return!1;if(s<=5)return!0;const r=n.girth();if(h>r*(s-2)/(r-2))return!1;let l=[];for(let e=0;e<s;e++){this.adjacencies(e).length<=5&&l.push(e)}return 0!==l.length&&n.isPlainerAddVertex()}))}isPlainerAddEdge(){throw new Error("Not implement")}isPlainerAddVertex(){const e=this._nodes.length,t=new Graph(e),n=Array.from({length:e},(()=>Array(e).fill(!1)));for(const e of this._edges)e[0]===e[1]||n[e[0]][e[1]]||(t.addEdge(e[0],e[1]),n[e[0]][e[1]]=n[e[1]][e[0]]=!0);const s=t.components(),h=[];for(;s.length>0;){const e=s.pop(),n=t.inducedSub(e),r=n.articulations();if(0===r.length){h.push(e);continue}const l=r[0];n.removeNode(l);const o=n.components();for(let t=0;t<o.length;t++){const n=[];for(let s=0;s<o[t].length;s++)o[t][s]>=l?n.push(e[o[t][s]+1]):n.push(e[o[t][s]]);n.push(e[l]),s.push(n)}}return h.every((e=>{const n=t.inducedSub(e),s=n._nodes.length,h=n.adjacencyList();for(let e=0;e<s;e++){const t=h[e].indexOf(e);t>=0&&h[e].splice(t,1)}const r=n._stNumbering().map(((e,t)=>[e,t]));r.sort(((e,t)=>e[0]-t[0]));const l=r.map((e=>e[1])),o={type:"p",children:h[l[0]].map((e=>({value:e})))};o.children.forEach((e=>e.parent=o));const i=(e,t)=>{let n=0,s=0;const h=[],r=[e];for(;r.length>0;){const e=r.pop();e.children&&e.children.length>0?r.push(...e.children):t.indexOf(e.value)>=0&&h.push(e)}for(;h.length+n+s>1;){if(0===h.length)return!1;const e=h.shift();e.mark="blocked";const t=e.parent?.children.indexOf(e)??null,r=[];null!==t&&"q"===e.parent.type&&(t>0&&r.push(e.parent.children[t-1]),t<e.parent.children.length-1&&r.push(e.parent.children[t+1]));const l=r.filter((e=>"blocked"===e.mark));if((r.filter((e=>"unblocked"===e.mark)).length>0||r.length<2)&&(e.mark="unblocked"),"unblocked"===e.mark){const r=e.parent;if(l.length>0){for(let e=t-1;e>=0&&"blocked"===r.children[e].mark;e--)r.children[e].mark="unblocked",r.pertinentChildCount=(r.pertinentChildCount??0)+1;for(let e=t+1;e<r.children.length&&"blocked"===r.children[e].mark;e++)r.children[e].mark="unblocked",r.pertinentChildCount=(r.pertinentChildCount??0)+1}r?(r.pertinentChildCount=(r.pertinentChildCount??0)+1,r.mark||(r.mark="queued",h.push(r))):s=1,n-=l.length}else n+=1-l.length}return!0},u=(e,t)=>{const n=[e];for(;;){const e=[];let s=!1;for(let h=0;h<n.length;h++)n[h].label=null,n[h].pertinentLeafCount=0,n[h].children&&n[h].children.length>0?(e.push(...n[h].children),s=!0):t.indexOf(n[h].value)>=0?(n[h].pertinentLeafCount=1,e.push(n[h])):e.push(n[h]);if(n.splice(0,n.length,...e),!s)break}const s=n.reduce(((e,n)=>e+(t.indexOf(n.value)>=0?1:0)),0);for(;n.length>0;){const e=n.shift();if(e.parent&&(e.parent.pertinentLeafCount+=e.pertinentLeafCount),e.children&&0!==e.children.length){const t=[],n=[],h=[];for(let s=0;s<e.children.length;s++)"empty"===e.children[s].label?t.push(e.children[s]):"full"===e.children[s].label?n.push(e.children[s]):h.push(e.children[s]);if(t.length===e.children.length)e.label="empty";else if(n.length===e.children.length)e.label="full";else if("p"===e.type)if(t.length+n.length===e.children.length)if(e.pertinentLeafCount===s){e.children=t;const s={type:"p",children:n,label:"full",parent:e};s.children.forEach((e=>e.parent=s)),e.children.push(s)}else{if(e.type="q",e.children=[],1===t.length)e.children.push(t[0]);else{const n={type:"p",children:t,label:"empty",parent:e};n.children.forEach((e=>e.parent=n)),e.children.push(n)}if(1===n.length)e.children.push(n[0]);else{const t={type:"p",children:n,label:"full",parent:e};t.children.forEach((e=>e.parent=t)),e.children.push(t)}e.label="partial"}else if(e.pertinentLeafCount===s)if(e.children=t,1===h.length){if(e.children.push(h[0]),n.length>0){const e={type:"p",children:n,label:"full",parent:h[0]};e.children.forEach((t=>t.parent=e)),h[0].children.push(e)}}else{if(2!==h.length)return!1;{const t={type:"q",children:[],label:"partial"};t.children.push(...h[0].children),t.children.push(...n),t.children.push(...h[1].children.reverse()),t.children.forEach((e=>e.parent=t)),e.children.push(t),e.children.forEach((t=>t.parent=e))}}else{if(1!==h.length)return!1;if(e.type="q",e.children=[],t.length>0){const n={type:"p",children:t,label:"empty"};n.children.forEach((e=>e.parent=n)),e.children.push(n)}if(e.children.push(...h[0].children),n.length>0){const t={type:"p",children:n,label:"full"};t.children.forEach((e=>e.parent=t)),e.children.push(t)}e.label="partial",e.children.forEach((t=>t.parent=e))}else if("q"===e.type){if("empty"===e.children.at(-1).label&&e.children.reverse(),e.pertinentLeafCount===s)if(0===h.length){let t="empty",n=0;for(let s=0;s<e.children.length;s++)if(e.children[s].label!==t&&n<2)t="empty"===t?"full":"empty",n++;else if(e.children[s].label!==t)return!1}else if(1===h.length){let t="empty",n=0;const s=[];for(let h=0;h<e.children.length;h++)if("partial"===e.children[h].label)"empty"===t?(s.push(...e.children[h].children),t="full"):(s.push(...e.children[h].children.reverse()),t="empty");else if(e.children[h].label!==t&&n<1)t="empty"===t?"full":"empty",n++,s.push(e.children[h]);else{if(e.children[h].label!==t)return!1;s.push(e.children[h])}e.children=s,e.children.forEach((t=>t.parent=e))}else{if(2!==h.length)return!1;{let t="empty";const n=[];for(let s=0;s<e.children.length;s++)if("partial"===e.children[s].label)"empty"===t?(n.push(...e.children[s].children),t="full"):(n.push(...e.children[s].children.reverse()),t="empty");else{if(e.children[s].label!==t)return!1;n.push(e.children[s])}e.children=n,e.children.forEach((t=>t.parent=e))}}else if(0===h.length){let t="empty";for(let n=0;n<e.children.length;n++)if("full"===e.children[n].label)t="full";else if(e.children[n].label!==t)return!1}else{if(1!==h.length)return!1;{let t="empty";const n=[];for(let s=0;s<e.children.length;s++)if("partial"===e.children[s].label)n.push(...e.children[s].children),t="full";else{if(e.children[s].label!==t)return!1;n.push(e.children[s])}e.children=n,e.children.forEach((t=>t.parent=e))}}e.label="partial"}}else e.label=t.indexOf(e.value)>=0?"full":"empty";if(e.pertinentLeafCount===s)break;e.parent&&e.parent.children.every((e=>e.label))&&n.push(e.parent)}return!0},p=(e,t)=>{const n=[],s=[e];for(;s.length>0;){const e=s.pop();e.children&&e.children.length>0?(e.pertinentLeafCount=0,s.push(...e.children)):t.indexOf(e.value)>=0&&(e.pertinentLeafCount=1,n.push(e))}const h=n.length;for(;n.length>0;){const e=n.pop();if(e.pertinentLeafCount===h)return e;const t=e.parent;t&&(t.pertinentLeafCount++,n.push(t))}return e};for(let e=1;e<s;e++){const t=i(o,[l[e]]),n=u(o,[l[e]]);if(!t||!n)return!1;const s=h[l[e]].filter((t=>l.indexOf(t)>e)).map((e=>({value:e}))),r=p(o,[l[e]]);if("q"===r.type){const e={type:"p",children:s,parent:r};e.children.forEach((t=>t.parent=e));const t=[];let n=!1;for(let s=0;s<r.children.length;s++)"full"===r.children[s].label?n||(t.push(e),n=!0):t.push(r.children[s]);r.children=t,2===r.children.length&&(r.type="p")}else r.type="p",r.value=void 0,r.children=s,r.children.forEach((e=>e.parent=r))}return!0}))}_stNumbering(e=0,t=null){const n=this._nodes.length;if(0===n)return[];if(1===n)return[1];if(this.articulations().length>0)throw new Error("Only biconnected graph can calculate st-numbering");const s=this.adjacencyList();for(let e=0;e<n;e++){const t=s[e].indexOf(e);t>=0&&s[e].splice(t,1)}t??=s[e][0];const h=Array(n).fill("new"),r=Array(n).fill(1/0),l=Array(n).fill(-1),o=Array(n).fill(1/0),i=[];let u=1;const p=e=>{h[e]="old",r[e]=u++,o[e]=r[e];for(const t of s[e])"new"===h[t]?(i.push([e,t,"tree"]),l[t]=e,p(t),o[e]=Math.min(o[e],o[t])):l[e]!==t&&(i.push([e,t,"back"]),o[e]=Math.min(o[e],r[t]))};p(t);const c=[t,e],d=[];h.fill("new");const a=Array(i.length).fill("new");a[0]="old";let f=1;for(;c.length>0;){const e=c.pop();if(e===t){d[t]=f;break}const n=[];for(let t=0;t<i.length;t++){if("new"!==a[t])continue;const s=i[t];if(s[0]===e&&"back"===s[2]){a[t]="old",n.push(e,s[1]);break}if(s[0]===e&&"tree"===s[2]){let l=s[1];for(n.push(e,l),a[t]=h[l]=h[e]="old";l>=0;){const e=o[l];for(let t=0;t<i.length;t++){if(i[t][0]===l&&"back"===i[t][2]&&r[i[t][1]]===e){l=i[t][1],n.push(l),h[l]=a[t]="old",l=-1;break}if(i[t][0]===l&&"tree"===i[t][2]){l=i[t][1],n.push(l),h[l]=a[t]="old";break}}}break}if(s[1]===e&&"back"===s[2]){let r=s[0];for(n.push(e,r),h[e]=a[t]="old";"old"!==h[r];){h[r]="old";for(let e=0;e<i.length;e++)if(i[e][1]===r&&"tree"===i[e][2]){r=i[e][0],n.push(r),a[e]="old";break}}break}}if(0===n.length)d[e]=f++;else for(let e=n.length-2;e>=0;e--)c.push(n[e])}return d}isSymmetric(){if(this._nodes.length<=1)return!0;throw new GraphException("Not implemented")}isDAG(){return this.isDirected()&&!this.hasCycle()}isSeparable(){return!this.isBiconnected()}hasCycle(){return this.isUndirected()?this.hasCycleDFS():this.hasCycleEachNodes()}hasCycleDFS(){if(!this.isUndirected())throw new GraphException("This method only works undirected graph.");const e=Array(this._nodes.length).fill(!1),t=Array(this._edges.length).fill(!1),n=[0];for(;n.length>0||e.some((e=>!e));){const s=n.length>0?n.pop():e.indexOf(!1);if(e[s])return!0;e[s]=!0;for(let h=0;h<this._edges.length;h++){if(t[h])continue;const r=this._edges[h];if(r[0]===s){if(e[r[1]])return!0;t[h]=!0,n.push(r[1])}if(!r.direct&&r[1]===s){if(e[r[0]])return!0;t[h]=!0,n.push(r[0])}}}return!1}hasCycleEachNodes(){for(let e=0;e<this._nodes.length;e++){const t=[[[e],Array(this._edges.length).fill(!1)]];for(;t.length>0;){const[n,s]=t.pop(),h=n[n.length-1];for(let r=0;r<this._edges.length;r++){if(s[r])continue;const l=this._edges[r];if(l[0]===h){if(l[1]===e)return!0;if(n.indexOf(l[1])>=0)continue;const h=s.concat();h[r]=!0,t.push([n.concat(l[1]),h])}if(!l.direct&&l[1]===h){if(l[0]===e)return!0;if(n.indexOf(l[1])>=0)continue;const h=s.concat();h[r]=!0,t.push([n.concat(l[0]),h])}}}}return!1}isomorphism(e){if(e===this)return!0;if(this._nodes.length!==e._nodes.length||this._edges.length!==e._edges.length)return!1;if(0===this._nodes.length||0===this._edges.length)return!0;throw new GraphException("Not implemented")}inducedSub(e){const t=[];for(const n of this._edges){const s=e.indexOf(n[0]),h=e.indexOf(n[1]);s>=0&&h>=0&&t.push(new Edge(s,h,n.value0,n.direct))}const n=e.map((e=>this._nodes[e]));return new Graph(n,t)}complement(){if(0===this._nodes.length)return new Graph(0);const e=[];for(let t=0;t<this._nodes.length;t++)for(let n=0;n<t;n++)0===this.getEdges(t,n).length&&e.push(new Edge(n,t));return new Graph(this._nodes.concat(),e)}contraction(e,t){if(e!==t){t<e&&([e,t]=[t,e]),this._nodes.splice(t,1);for(let n=this._edges.length-1;n>=0;n--){const s=this._edges[n];s[0]===e&&s[1]===t||s[1]===e&&s[0]===t?this._edges.splice(n,1):(s[0]===t?s[0]=e:s[0]>e&&s[0]--,s[1]===t?s[1]=e:s[1]>e&&s[1]--)}}}subdivision(e,t){this._nodes.push(null);const n=this._nodes.length-1;for(let s=this._edges.length-1;s>=0;s--){const h=this._edges[s];(h[0]===e&&h[1]===t||h[1]===e&&h[0]===t)&&(this._edges.splice(s,1),this._edges.push(new Edge(h[0],n,h.value0,h.direct)),this._edges.push(new Edge(n,h[0],h.value0,h.direct)))}}disjointUnion(e){const t=this._nodes.length;this._nodes=this._nodes.concat(e._nodes);for(const n of e._edges)this._edges.push(new Edge(n[0]+t,n[1]+t,n.value0,n.direct))}substitution(e,t){if(0===t._nodes.length)this.removeNode(e);else if(1===t._nodes.length)for(const n of t._edges)this._edges.push(new Edge(n[0]+e,n[1]+e,n.value0,n.direct));else{const n=this._nodes.length;this._nodes[e]=t._nodes[0],this._nodes=this._nodes.concat(t._nodes.slice(1));for(const s of this._edges)if(s[0]===e||s[1]===e)for(let h=0;h<t._nodes.length-1;h++)this._edges.push(new Edge(s[0]===e?n+h:s[0],s[1]===e?n+h:s[1],s.value0,s.direct));for(const s of t._edges)this._edges.push(new Edge(0===s[0]?e:s[0]+n-1,0===s[1]?e:s[1]+n-1,s.value0,s.direct))}}cartesianProduct(e){const t=this._nodes.length,n=e._nodes.length,s=[];for(let h=0;h<t;h++)for(let t=0;t<n;t++)null!=this._nodes[h]||null!=e._nodes[t]?s.push([this._nodes[h],this._nodes[t]]):s.push(null);const h=[];for(const e of this._edges)for(let s=0;s<n;s++)h.push(new Edge(e[0]+t*s,e[1]+t*s,e.value0,e.direct));for(const n of e._edges)for(let e=0;e<t;e++)h.push(new Edge(e+n[0]*t,e+n[1]*t,n.value0,n.direct));return new Graph(s,h)}tensorProduct(e){const t=this._nodes.length,n=e._nodes.length,s=[];for(let h=0;h<t;h++)for(let t=0;t<n;t++)null!=this._nodes[h]||null!=e._nodes[t]?s.push([this._nodes[h],this._nodes[t]]):s.push(null);const h=[];for(const n of this._edges)for(const s of e._edges)n.direct===s.direct&&(h.push(new Edge(n[0]+s[0]*t,n[1]+s[1]*t,n.weighted||s.weighted?[n.value0,s.value0]:null,n.direct)),n.direct||h.push(new Edge(n[1]+s[0]*t,n[0]+s[1]*t,n.weighted||s.weighted?[n.value0,s.value0]:null,n.direct)));return new Graph(s,h)}strongProduct(e){const t=this._nodes.length,n=e._nodes.length,s=[];for(let h=0;h<t;h++)for(let t=0;t<n;t++)null!=this._nodes[h]||null!=e._nodes[t]?s.push([this._nodes[h],this._nodes[t]]):s.push(null);const h=[];for(const e of this._edges)for(let s=0;s<n;s++)h.push(new Edge(e[0]+t*s,e[1]+t*s,e.value0,e.direct));for(const n of e._edges)for(let e=0;e<t;e++)h.push(new Edge(e+n[0]*t,e+n[1]*t,n.value0,n.direct));for(const n of this._edges)for(const s of e._edges)n.direct===s.direct&&(h.push(new Edge(n[0]+s[0]*t,n[1]+s[1]*t,n.weighted||s.weighted?[n.value0,s.value0]:null,n.direct)),n.direct||h.push(new Edge(n[1]+s[0]*t,n[0]+s[1]*t,n.weighted||s.weighted?[n.value0,s.value0]:null,n.direct)));return new Graph(s,h)}lexicographicProduct(e){const t=this._nodes.length,n=e._nodes.length,s=[];for(let h=0;h<t;h++)for(let t=0;t<n;t++)null!=this._nodes[h]||null!=e._nodes[t]?s.push([this._nodes[h],this._nodes[t]]):s.push(null);const h=[];for(const e of this._edges)for(let s=0;s<n;s++)for(let r=0;r<n;r++)h.push(new Edge(e[0]+t*s,e[1]+t*r,e.value0,e.direct));for(const n of e._edges)for(let e=0;e<t;e++)h.push(new Edge(e+n[0]*t,e+n[1]*t,n.value0,n.direct));return new Graph(s,h)}shortestPath(e){return null==e?this.shortestPathFloydWarshall():this.shortestPathDijkstra(e)}shortestPathBreadthFirstSearch(e){const t=Array.from({length:this._nodes.length},(()=>({length:1/0,prev:null,path:[]}))),n=[[e,null]];t[e]={length:0,prev:null,path:[e]};const s=Array(this._nodes.length).fill(!1);for(;n.length>0;){const[e,h]=n.shift();if(!s[e]){s[e]=!0,null!=h&&(t[e].prev=h,t[e].length=t[h].length+1,t[e].path=t[h].path.concat(e));for(const t of this._edges)t.value<=0||(t[0]!==e||s[t[1]]||n.push([t[1],e]),t.direct||t[1]!==e||s[t[0]]||n.push([t[0],e]))}}return t}shortestPathDijkstra(e){const t=Array.from({length:this._nodes.length},(()=>({length:1/0,prev:null,path:[]}))),n=[e];for(t[e]={length:0,prev:null,path:[e]};n.length>0;){const e=n.shift();for(const s of this._edges)s.value<=0||(s[0]===e&&t[s[1]].length>t[e].length+s.value&&(t[s[1]].length=t[e].length+s.value,t[s[1]].prev=e,t[s[1]].path=t[e].path.concat(s[1]),n.push(s[1])),!s.direct&&s[1]===e&&t[s[0]].length>t[e].length+s.value&&(t[s[0]].length=t[e].length+s.value,t[s[0]].prev=e,t[s[0]].path=t[e].path.concat(s[0]),n.push(s[0])))}return t}shortestPathBellmanFord(e){const t=Array.from({length:this._nodes.length},(()=>({length:1/0,prev:null,path:[]})));t[e]={length:0,prev:null,path:[e]};for(let e=0;e<this._nodes.length-1;e++)for(const e of this._edges)t[e[1]].length>t[e[0]].length+e.value&&(t[e[1]].length=t[e[0]].length+e.value,t[e[1]].prev=e[0],t[e[1]].path=t[e[0]].path.concat(e[1])),!e.direct&&t[e[0]].length>t[e[1]].length+e.value&&(t[e[0]].length=t[e[1]].length+e.value,t[e[0]].prev=e[1],t[e[0]].path=t[e[1]].path.concat(e[0]));return t}shortestPathFloydWarshall(){const e=[];for(let t=0;t<this._nodes.length;t++)e[t]=Array.from({length:this._nodes.length},(()=>({length:1/0,path:[]}))),e[t][t]={length:0,path:[t]};for(const t of this._edges)e[t[0]][t[1]].length>t.value&&(e[t[0]][t[1]].length=t.value,e[t[0]][t[1]].path=[t[0],t[1]]),!t.direct&&e[t[1]][t[0]].length>t.value&&(e[t[1]][t[0]].length=t.value,e[t[1]][t[0]].path=[t[1],t[0]]);for(let t=0;t<this._nodes.length;t++)for(let n=0;n<this._nodes.length;n++)for(let s=0;s<this._nodes.length;s++)e[n][s].length>e[n][t].length+e[t][s].length&&(e[n][s].length=e[n][t].length+e[t][s].length,e[n][s].path=e[n][t].path.concat(e[t][s].path.slice(1)));return e}minimumSpanningTree(){return this.minimumSpanningTreePrim()}minimumSpanningTreePrim(){const e=Array(this._nodes.length).fill(!1);e[0]=!0;const t=this._edges.concat(),n=[];for(;e.some((e=>!e));){let s=1/0,h=null;for(let n=t.length-1;n>=0;n--)e[t[n][0]]&&e[t[n][1]]?t.splice(n,1):(e[t[n][0]]&&!e[t[n][1]]||!t[n].direct&&e[t[n][1]]&&!e[t[n][0]])&&s>t[n].value&&(h=t[n],s=t[n].value);n.push(h),e[h[0]]=e[h[1]]=!0}return new Graph(this._nodes.length,n)}minimumSpanningTreeKruskal(){const e=Array.from({length:this._nodes.length},((e,t)=>t)),t=[],n=this._edges.concat();n.sort(((e,t)=>e.value-t.value));for(let s=0;s<n.length;s++){const h=n[s],r=e[h[1]];if(e[h[0]]!==r){t.push(h);for(let t=0;t<this._nodes.length;t++)e[t]===r&&(e[t]=e[h[0]])}}return new Graph(this._nodes.length,t)}minimumSpanningTreeBoruvka(){const e=Array.from({length:this._nodes.length},((e,t)=>t)),t=new Set;for(let n=0;n<this._nodes.length-1;n++){const n=[];for(const t of this._edges)e[t[0]]!==e[t[1]]&&((!n[e[t[0]]]||n[e[t[0]]].value>t.value)&&(n[e[t[0]]]=t),(!n[e[t[1]]]||n[e[t[1]]].value>t.value)&&(n[e[t[1]]]=t));if(0===n.length)break;for(const s of n){t.add(s);const n=e[s[1]];for(let t=0;t<this._nodes.length;t++)e[t]===n&&(e[t]=e[s[0]])}}return new Graph(this._nodes.length,[...t])}cut(e,t){const n=this.adjacencyMatrix();let s=0;for(let h=0;h<e.length;h++)for(let r=0;r<t.length;r++)s+=n[e[h]][t[r]];return s}mincut(e=1){if(e>Math.floor(this._nodes.length/2))throw new Error(`Invalid minv. ${e}, ${this._nodes.length}`);if(this._nodes.length<=6)return this.mincutBruteForce(e);let[t,n]=this.mincutStoerWagner(e);for(let s=1;s<this._nodes.length&&t!==1/0;s++)[t,n]=this.mincutStoerWagner(e,s);return t===1/0&&([t,n]=this.mincutKargersStein(e)),[t,n]}mincutBruteForce(e=1){const t=this.adjacencyMatrix(),n=Array(this._nodes.length).fill(!1);let s=null,h=1/0;do{const r=[],l=[];for(let e=0;e<this._nodes.length;e++)n[e]?r.push(e):l.push(e);if(r.length>=e&&l.length>=e){let e=0;for(let n=0;n<r.length;n++)for(let s=0;s<l.length;s++)t[r[n]][l[s]]&&(e+=t[r[n]][l[s]]);e<h&&(h=e,s=[r,l])}if(0===h)return[0,s];for(let e=0;e<this._nodes.length;e++){if(!n[e]){n[e]=!0;break}n[e]=!1}}while(n.some((e=>e)));return[h,s]}mincutStoerWagner(e=1,t=0){const n=this.adjacencyMatrix(),s=Array.from({length:this._nodes.length},((e,t)=>[t]));let h=null,r=1/0;const l=n.map((e=>e.concat()));for(let n=1;n<this._nodes.length;n++){const o=l[t].concat();let i=0,u=t;for(let e=0;e<this._nodes.length-n;e++){o[u]=-1/0,i=u;let e=-1/0;for(let t=0;t<o.length;t++)o[t]>e&&(e=o[t],u=t);for(let e=0;e<this._nodes.length;e++)o[e]+=l[u][e]}o[u]-l[u][u]<r&&s[u].length>=e&&this._nodes.length-s[u].length>=e&&(r=o[u]-l[u][u],h=s[u].concat()),s[i].push(...s[u]);for(let e=0;e<this._nodes.length;e++)l[e][i]=l[i][e]+=l[u][e];l[t][u]=-1/0}if(!h)return[r,[Array.from({length:this._nodes.length},((e,t)=>t))]];const o=[];for(let e=0;e<this._nodes.length;e++)h.indexOf(e)<0&&o.push(e);return[r,[h,o]]}mincutKargers(e=1,t=null){const n=this.adjacencyMatrix();let s=null,h=1/0;null==t&&(t=this._nodes.length**2*Math.log(this._nodes.length));const r=[];let l=0;for(let e=0;e<this._nodes.length;e++){r[e]=new Set;for(let t=0;t<this._nodes.length;t++)n[e][t]&&(r[e].add(t),l++)}for(let o=0;o<t;o++){const t=Array.from({length:this._nodes.length},((e,t)=>[t])),o=n.map((e=>e.concat())),i=r.map((e=>new Set(e)));let u=l,p=0;for(let e=0;e<this._nodes.length-2&&u>0;e++){let e=Math.floor(Math.random()*u);for(p=0;p<this._nodes.length&&i[p].size<=e;p++)e-=i[p].size;let n=0;for(const t of i[p]){if(0===e){n=t;break}e--}for(const e of i[n])i[e].delete(n),u-=1,e!==p&&(o[p][e]||(i[p].add(e),i[e].add(p),u+=2),o[p][e]+=o[n][e],o[e][p]+=o[e][n]);t[p].push(...t[n]),t[n]=null,u-=i[n].size,i[n].clear()}if(0===u)return[0,t.filter((e=>null!==e))];const c=i[p].values().next().value;t[p].length<e||t[c].length<e||o[p][c]<h&&(h=o[p][c],s=[t[p],t[c]])}return s?[h,s]:[h,[Array.from({length:this._nodes.length},((e,t)=>t))]]}mincutKargersStein(e=1,t=null){const n=this.adjacencyMatrix(),s=Array.from({length:this._nodes.length},((e,t)=>[t]));null===t&&(t=Math.log(this._nodes.length)**2);let h=null,r=1/0;for(let l=0;l<t;l++){const[t,l]=this._mincutKargersStein0(n,s,e);t<r&&(r=t,h=l)}return[r,h]}_mincutKargersStein0(e,t,n){const s=e.length;if(s<=6){const h=Array(s).fill(!1);let r=null,l=1/0;do{const o=[],i=[];for(let e=0;e<s;e++)h[e]?o.push(e):i.push(e);const u=o.reduce(((e,n)=>e+t[n].length),0),p=i.reduce(((e,n)=>e+t[n].length),0);if(u>=n&&p>=n){let n=0;for(let t=0;t<o.length;t++)for(let s=0;s<i.length;s++)e[o[t]][i[s]]&&(n+=e[o[t]][i[s]]);n<l&&(l=n,r=[o.reduce(((e,n)=>e.concat(t[n])),[]),i.reduce(((e,n)=>e.concat(t[n])),[])])}if(0===l)return[0,r];for(let e=0;e<s;e++){if(!h[e]){h[e]=!0;break}h[e]=!1}}while(h.some((e=>e)));return[l,r]}const h=[];let r=0;for(let t=0;t<s;t++){h[t]=new Set;for(let n=0;n<s;n++)e[t][n]&&(h[t].add(n),r++)}const l=s/Math.sqrt(2)+1;let o=null,i=1/0;for(let u=0;u<2;u++){const u=t.map((e=>e.concat())),p=e.map((e=>e.concat())),c=h.map((e=>new Set(e)));let d=r,a=0;const f=[];for(let e=0;e<s-l;e++){let e=Math.floor(Math.random()*d);for(a=0;a<this._nodes.length&&c[a].size<=e;a++)e-=c[a].size;let t=0;for(const n of c[a]){if(0===e){t=n;break}e--}for(const e of c[t])c[e].delete(t),d-=1,e!==a&&(p[a][e]||(c[a].add(e),c[e].add(a),d+=2),p[a][e]+=p[t][e],p[e][a]+=p[e][t]);u[a].push(...u[t]),u[t]=null,d-=c[t].size,c[t].clear(),f.push(t)}f.sort(((e,t)=>t-e));for(let e=s-1;e>=0;e--)if(null===u[e])p.splice(e,1),u.splice(e,1);else for(let t=0;t<f.length;t++)p[e].splice(f[t],1);const[g,_]=this._mincutKargersStein0(p,u,n);g<i&&(i=g,o=_)}return[i,o]}bisectionSpectral(){const e=Matrix.fromArray(this.laplacianMatrix()).tridiagLanczos(),t=e.eigenValuesQR(),[,n]=e.eigenInverseIteration(t[1]),s=n.median(),h=[],r=[];for(let e=0;e<this._nodes.length;e++)n.at(e,0)>s?h.push(e):r.push(e);return[this.cut(h,r),[h,r]]}}