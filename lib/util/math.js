const normal_random=function(t=0,s=1){const e=Math.sqrt(s),i=Math.random(),r=Math.random();return[Math.sqrt(-2*Math.log(i))*Math.cos(2*Math.PI*r)*e+t,Math.sqrt(-2*Math.log(i))*Math.sin(2*Math.PI*r)*e+t]};export class Tree{constructor(t,s){this.value=t,this.childs=s||[],this.childs.forEach((t=>t.parent=this)),this.parent=null}get length(){return this.childs.length}get depth(){return this.isLeaf()?1:1+Math.max.apply(null,this.childs.map((t=>t.depth)))}*[Symbol.iterator](){yield*this.childs}at(t){return this.childs[t]}push(t){t=t instanceof Tree?t:new Tree(t),this.childs.push(t),t.parent=this}set(t,s){t<0||this.childs.length<=t||(s=s instanceof Tree?s:new Tree(s),this.childs[t].parent=null,this.childs[t]=s,s.parent=this)}removeAt(t){if(!(t<0||this.childs.length<=t))return this.childs[t].parent=null,this.childs.splice(t,1)[0]}clear(){this.childs.forEach((t=>t.parent=null)),this.childs.length=0}isLeaf(){return 0===this.childs.length}isRoot(){return null===this.parent}root(){return this.isRoot()?this:this.parent.root()}leafs(){let t=[];return this.scanLeaf((s=>t.push(s))),t}leafValues(){let t=[];return this.scanLeaf((s=>t.push(s.value))),t}leafCount(){return this.isLeaf()?1:this.childs.reduce(((t,s)=>t+s.leafCount()),0)}forEach(t,s){this.childs.forEach(t,s)}scan(t){t(this),this.childs.forEach((s=>s.scan(t)))}scanLeaf(t){this.isLeaf()?t(this):this.childs.forEach((s=>s.scanLeaf(t)))}}export class Tensor{constructor(t,s){this._size=t.concat(),this._length=t.reduce(((t,s)=>t*s),1),s?Array.isArray(s)?this._value=s.flat(t.length):this._value=Array(this._length).fill(s):this._value=Array(this._length).fill(0),this._offset=0}static zeros(t){return new Tensor(t)}static ones(t){return new Tensor(t,1)}static random(t,s=0,e=1){const i=new Tensor(t);for(let t=0;t<i.length;t++)i._value[t]=Math.random()*(e-s)+s;return i}static randn(t,s=0,e=1){const i=new Tensor(t);for(let t=0;t<i.length;t+=2){const r=normal_random(s,e);i._value[t]=r[0],t+1<i.length&&(i._value[t+1]=r[1])}return i}static fromArray(t){if(t instanceof Tensor)return t;if(t instanceof Matrix)return new Tensor(t.sizes,t._value);if(!Array.isArray(t))return new Tensor([1],t);if(0===t.length)return new Tensor([0]);const s=[];let e=t;for(;Array.isArray(e);)s.push(e.length),e=e[0];return new Tensor(s,t)}get dimension(){return this._size.length}get sizes(){return this._size}get length(){return this._length}get value(){return this._value}*[Symbol.iterator](){yield*this._value}toArray(){const t=[];let s=[t],e=0;for(let t=0;t<this._size.length;t++){const i=[];for(const r of s)if(t===this._size.length-1)r.push(...this._value.slice(e,e+this._size[t])),e+=this._size[t];else for(let s=0;s<this._size[t];s++)i.push(r[s]=[]);s=i}return t}toString(){let t=this.dimension,s="";for(let e=0;e<this.length;){for(let e=0;e<t;e++)s+="[";s+=this._value[e],t=0;let i=++e;for(let s=this.dimension-1;s>=0&&i%this._size[s]==0;s--)t++,i/=this._size[s];for(let e=0;e<t;e++)s+="]";e!==this.length&&(s+=",")}return s}toMatrix(){if(2!==this.dimension)throw new MatrixException("Only 2D tensor can convert to matrix.");return new Matrix(...this._size,this._value)}_to_position(...t){let s=0;for(let e=0;e<this.dimension;e++)s=s*this._size[e]+t[e];return s+this._offset}_to_index(t){const s=Array(this.dimension);for(let e=this.dimension-1;e>=0;e--)s[e]=t%this._size[e],t=Math.floor(t/this._size[e]);return s}copy(){return new Tensor(this._size,this.value.slice(this._offset,this._offset+this._length))}at(...t){if(t.length===this.dimension)return this._value[this._to_position(...t)];let s=0;for(let e=0;e<t.length;e++)s=s*this._size[e]+t[e];let e=s+1;for(let i=t.length;i<this.dimension;i++)s*=this._size[i],e*=this._size[i];const i=new Tensor(this._size.slice(t.length));return i._value=this._value,i._offset=s,i}slice(t,s,e=0){if(e>0)throw"Invalid axis. Only 0 is accepted.";let i=1;for(let t=1;t<this.dimension;t++)i*=this._size[t];const r=new Tensor([s-t,...this._size.slice(1)]);return r._value=this._value.slice(t*i,s*i),r}set(t,s){Array.isArray(t)||(t=[t]),this._value[this._to_position(...t)]=s}select(t,s=0){if(s>0)throw"Invalid axis. Only 0 is accepted.";Array.isArray(t)||(t=[t]);let e=1;for(let t=1;t<this.dimension;t++)e*=this._size[t];const i=new Tensor([t.length,...this._size.slice(1)]);for(let s=0;s<t.length;s++)for(let r=0;r<e;r++)i._value[s*e+r]=this._value[t[s]*e+r];return i}fill(t){this._value=Array(this.length).fill(t)}map(t){for(let s=this.length-1;s>=0;s--)this._value[s]=t(this._value[s]||0,this._to_index(s))}forEach(t){for(let s=this.length-1;s>=0;s--)t(this._value[s]||0,this._to_index(s),this._value)}shuffle(t=0){const s=[];for(let e=0;e<this._size[t];e++)s[e]=e;for(let t=s.length-1;t>0;t--){let e=Math.floor(Math.random()*(t+1));[s[t],s[e]]=[s[e],s[t]]}this._value=this.select(s,t)._value}transpose(...t){const s=new Tensor(t.map((t=>this._size[t])));for(let e=0;e<this.length;e++){const i=this._to_index(e);s._value[s._to_position(...t.map((t=>i[t])))]=this._value[e]}return s}reshape(...t){if(t.reduce(((t,s)=>t*s),1)!==this.length)throw new MatrixException("Length is different.");this._size=t.concat()}}function MatrixException(t,s){this.message=t,this.value=s,this.name=MatrixException}export class Matrix{constructor(t,s,e){e?Array.isArray(e)?Array.isArray(e[0])?this._value=e.flat():this._value=e:this._value=Array(t*s).fill(e):this._value=Array(t*s),this._size=[t,s]}static zeros(t,s){return new Matrix(t,s,Array(t*s).fill(0))}static ones(t,s){return new Matrix(t,s,Array(t*s).fill(1))}static eye(t,s,e=1){const i=new Matrix(t,s),r=Math.min(t,s);for(let t=0;t<r;t++)i._value[t*s+t]=e;return i}static random(t,s,e=0,i=1){const r=new Matrix(t,s);for(let t=0;t<r.length;t++)r._value[t]=Math.random()*(i-e)+e;return r}static randn(t,s,e=0,i=1){const r=new Matrix(t,s);if(Array.isArray(e)&&(e=new Matrix(1,e.length,e)),Array.isArray(i)&&(i=Matrix.fromArray(i)),!(e instanceof Matrix||i instanceof Matrix)){for(let t=0;t<r.length;t+=2){const s=normal_random(e,i);r._value[t]=s[0],t+1<r.length&&(r._value[t+1]=s[1])}return r}if(e instanceof Matrix){if(e.rows===s||1===e.cols)e=e.t;else if(e.cols!==s||1!==e.rows)throw new MatrixException("'myu' cols must be same as 'cols' and rows must be 1.")}else e=new Matrix(1,s,e);if(i instanceof Matrix){if(i.rows!==s||i.cols!==s)throw new MatrixException("'sigma' cols and rows must be same as 'cols'.")}else i=Matrix.eye(s,s,i);const o=i.cholesky();for(let t=0;t<r.length;t+=2){const s=normal_random(0,1);r._value[t]=s[0],t+1<r.length&&(r._value[t+1]=s[1])}const l=r.dot(o.t);return l.add(e),l}static diag(t){const s=t.length,e=new Matrix(s,s);for(let i=0;i<s;i++)e._value[i*s+i]=t[i];return e}static fromArray(t){return t instanceof Matrix?t:Array.isArray(t)?0===t.length?new Matrix(0,0):Array.isArray(t[0])?new Matrix(t.length,t[0].length,t):new Matrix(t.length,1,t):new Matrix(1,1,t)}get dimension(){return this._size.length}get sizes(){return this._size}get length(){return this._size[0]*this._size[1]}get rows(){return this._size[0]}get cols(){return this._size[1]}get value(){return this._value}get t(){return this.transpose()}toArray(){const t=[],s=this.cols;for(let e=0;e<this.length;e+=s)t.push(this._value.slice(e,e+s));return t}toString(){let t="[";for(let s=0;s<this.rows;s++){s>0&&(t+=",\n "),t+="[";for(let e=0;e<this.cols;e++)e>0&&(t+=", "),t+=this._value[s*this.cols+e]||0;t+="]"}return t+"]"}transpose(t){const s=t||new Matrix(this.cols,this.rows);for(let t=0;t<this.rows;t++)for(let e=0;e<this.cols;e++)s._value[e*this.rows+t]=this._value[t*this.cols+e];return s}copy(t){return t===this?this:t?(t._size=[].concat(this._size),this._value.forEach(((s,e)=>t._value[e]=s)),t):new Matrix(this.rows,this.cols,[].concat(this._value))}at(t,s){if(t<0||this.rows<=t||s<0||this.cols<=s)throw new MatrixException("Index out of bounds.");return this._value[t*this.cols+s]||0}set(t,s,e){if(e instanceof Matrix){if(t<0||this.rows<=t+e.rows-1||s<0||this.cols<=s+e.cols-1)throw new MatrixException("Index out of bounds.");for(let i=0;i<e.rows;i++)for(let r=0;r<e.cols;r++)this._value[(i+t)*this.cols+r+s]=e._value[i*e.cols+r];return null}{if(t<0||this.rows<=t||s<0||this.cols<=s)throw new MatrixException("Index out of bounds.");const i=this._value[t*this.cols+s]||0;return this._value[t*this.cols+s]=e,i}}row(t){if(Array.isArray(t)){if(t.some((t=>t<0||this.rows<=t)))throw new MatrixException("Index out of bounds.");const s=new Matrix(t.length,this.cols);for(let e=0;e<t.length;e++)for(let i=0;i<this.cols;i++)s._value[e*this.cols+i]=this._value[t[e]*this.cols+i];return s}if(t<0||this.rows<=t)throw new MatrixException("Index out of bounds.");return new Matrix(1,this.cols,this._value.slice(t*this.cols,(t+1)*this.cols))}col(t){if(Array.isArray(t)){if(t.some((t=>t<0||this.cols<=t)))throw new MatrixException("Index out of bounds.");const s=new Matrix(this.rows,t.length);for(let e=0;e<this.rows;e++)for(let i=0;i<t.length;i++)s._value[e*t.length+i]=this._value[e*this.cols+t[i]];return s}{if(t<0||this.cols<=t)throw new MatrixException("Index out of bounds.");const s=new Matrix(this.rows,1);for(let e=0;e<this.rows;e++)s._value[e]=this._value[e*this.cols+t];return s}}slice(t,s,e,i,r){const o=(t,s)=>{let e=new Int32Array(s-t);for(let i=0;i<s-t;i++)e[i]=i+t;return e};t=Array.isArray(t)?t:o(t||0,e||this.rows),s=Array.isArray(s)?s:o(s||0,i||this.cols);const l=new Matrix(t.length,s.length,r);for(let e=0;e<t.length;e++)for(let i=0;i<s.length;i++)l._value[e*s.length+i]=this._value[t[e]*this.cols+s[i]];return l}sliceRow(t,s){return this.slice(t,null,s,null)}sliceCol(t,s){return this.slice(null,t,null,s)}removeRow(t){if(Array.isArray(t)){if(t.some((t=>t<0||this.rows<=t)))throw new MatrixException("Index out of bounds.");(t=[...new Set(t)]).sort(((t,s)=>s-t));for(let s=0;s<t.length;s++)this._value.splice(t[s]*this.cols,this.cols);this._size[0]-=t.length}else{if(t<0||this.rows<=t)throw new MatrixException("Index out of bounds.");this._value.splice(t*this.cols,this.cols),this._size[0]--}}removeCol(t){if(Array.isArray(t)){if(t.some((t=>t<0||this.cols<=t)))throw new MatrixException("Index out of bounds.");(t=[...new Set(t)]).sort(((t,s)=>t-s));let s=0,e=0;for(let i=0;i<this.rows;i++)for(let i=0,r=0;i<this.cols;i++,s++)t[r]!==i?this._value[e++]=this._value[s]:r++;this._size[1]-=t.length,this._value.length=this.length}else{if(t<0||this.cols<=t)throw new MatrixException("Index out of bounds.");let s=0,e=0;for(let i=0;i<this.rows;i++)for(let i=0;i<this.cols;i++,s++)t!==i&&(this._value[e++]=this._value[s]);this._size[1]--,this._value.length=this.length}}removeRowIf(t){const s=[];for(let e=0;e<this.rows;e++)t(this.row(e))&&s.push(e);this.removeRow(s)}removeColIf(t){const s=[];for(let e=0;e<this.cols;e++)t(this.col(e))&&s.push(e);this.removeCol(s)}sampleRow(t,s=!1){const e=this.rows,i=[];for(let s=0;s<t;s++)i.push(Math.floor(Math.random()*(e-s)));for(let s=t-1;s>=0;s--)for(let e=t-1;e>s;e--)i[s]<=i[e]&&i[e]++;return s?[this.row(i),i]:this.row(i)}sampleCol(t,s=!1){const e=this.cols,i=[];for(let s=0;s<t;s++)i.push(Math.floor(Math.random()*(e-s)));for(let s=t-1;s>=0;s--)for(let e=t-1;e>s;e--)i[s]<=i[e]&&i[e]++;return s?[this.row(i),i]:this.col(i)}fill(t){this._value=0===t?[]:Array(this.length).fill(t)}map(t){for(let s=this.length-1;s>=0;s--)this._value[s]=t(this._value[s]||0,s)}copyMap(t,s){if(s)return s._size=[].concat(this._size),this._value.forEach(((e,i)=>s._value[i]=t(e))),s;const e=new Matrix(this.rows,this.cols);for(let s=this.length-1;s>=0;s--)e._value[s]=t(this._value[s]||0,s);return e}forEach(t){for(let s=this.length-1;s>=0;s--)t(this._value[s]||0,s,this._value)}flip(t=0){if(0===t)for(let t=0;t<this.rows/2;t++){const s=(this.rows-t-1)*this.cols;for(let e=0;e<this.cols;e++){let i=this._value[t*this.cols+e];this._value[t*this.cols+e]=this._value[s+e],this._value[s+e]=i}}else if(1===t)for(let t=0;t<this.cols/2;t++){const s=this.cols-t-1;for(let e=0;e<this.rows;e++){let i=this._value[e*this.cols+t];this._value[e*this.cols+t]=this._value[e*this.cols+s],this._value[e*this.cols+s]=i}}}swap(t,s,e=0){if(0===e){if(t<0||s<0||this.rows<=t||this.rows<=s)throw new MatrixException("Index out of bounds.");const e=(s-t)*this.cols;for(let s=t*this.cols;s<(t+1)*this.cols;s++)[this._value[s],this._value[s+e]]=[this._value[s+e],this._value[s]]}else if(1===e){if(t<0||s<0||this.cols<=t||this.cols<=s)throw new MatrixException("Index out of bounds.");const e=s-t;for(let s=t;s<this.length;s+=this.cols)[this._value[s],this._value[s+e]]=[this._value[s+e],this._value[s]]}}sort(t=0){if(0===t){const t=[];for(let s=0;s<this.rows;t.push(s++));return t.sort(((t,s)=>{const e=t*this.cols,i=s*this.cols;for(let t=0;t<this.cols;t++){const s=this._value[e+t]-this._value[i+t];if(0!==s)return s}return 0})),this._value=this.row(t)._value,t}if(1===t){const t=[];for(let s=0;s<this.cols;t.push(s++));return t.sort(((t,s)=>{for(let e=0;e<this.rows;e++){const i=this._value[t+e*this.cols]-this._value[s+e*this.cols];if(0!==i)return i}return 0})),this._value=this.col(t)._value,t}}shuffle(t=0){const s=[];for(let e=0;e<this._size[t];e++)s[e]=e;for(let t=s.length-1;t>0;t--){let e=Math.floor(Math.random()*(t+1));[s[t],s[e]]=[s[e],s[t]]}0===t?this._value=this.row(s)._value:1===t&&(this._value=this.col(s)._value)}resize(t,s,e=0){const i=new Matrix(t,s);i.fill(e);const r=Math.min(this.rows,t),o=Math.min(this.cols,s);for(let t=0;t<r;t++)for(let e=0;e<o;e++)i._value[t*s+e]=this._value[t*this.cols+e];return i}reshape(t,s){if(this.length!==t*s)throw new MatrixException("Length is different.");this._size=[t,s]}repeat(t,s=0){if(Array.isArray(t)){if(t.length<this._size.length)for(let s=t.length;s<this._size.length;s++)t[s]=1}else{const e=Array(this._size.length).fill(1);e[s]=t,t=e}const e=t.reduce(((t,s)=>t*s),1);if(1===e)return;const i=Array(this.length*e),r=this._size.map(((s,e)=>s*t[e]));for(let t=0;t<r[0];t++)for(let s=0;s<r[1];s++)i[t*r[1]+s]=this._value[t%this.rows*this.cols+s%this.cols];this._value=i,this._size=r}copyRepeat(t,s=0,e){let i=this.copy(e);return i.repeat(t,s),i}concat(t,s=0){let e=null;if(0===s){if(this.cols!==t.cols)throw new MatrixException("Size is different.");return new Matrix(this.rows+t.rows,this.cols,[].concat(this._value,t._value))}if(1===s){if(this.rows!==t.rows)throw new MatrixException("Size is different.");e=this.resize(this.rows,this.cols+t.cols);for(let s=0;s<this.rows;s++)for(let i=0;i<t.cols;i++)e._value[s*e.cols+i+this.cols]=t._value[s*t.cols+i];return e}throw new MatrixException("Invalid axis.")}reduce(t,s,e=-1){if(e<0)return this._value.reduce(t,s);let i=0===e?1:this.cols,r=0===e?this.cols:1;const o=[].concat(this._size);o[e]=1;const l=Matrix.zeros(...o);for(let o=0,h=0;o<l.length;o++,h+=i){let i=s??(this._value[h]||0);for(let o=i===s?0:1;o<this._size[e];o++)i=t(i,this._value[o*r+h]||0,o);l._value[o]=i}return l}every(t,s=-1){return this.reduce(((s,e)=>s&&t(e)),!0,s)}some(t,s=-1){return this.reduce(((s,e)=>s||t(e)),!1,s)}max(t=-1){if(t<0){let t=-1/0;for(let s=this.length-1;s>=0;s--)t=Math.max(t,this._value[s]);return t}const s=this.argmax(t);let e=0===t?1:this.cols,i=0===t?this.cols:1;return s._value=s._value.map(((t,s)=>this._value[t*i+s*e])),s}min(t=-1){if(t<0){let t=1/0;for(let s=this.length-1;s>=0;s--)t=Math.min(t,this._value[s]);return t}const s=this.argmin(t);let e=0===t?1:this.cols,i=0===t?this.cols:1;return s._value=s._value.map(((t,s)=>this._value[t*i+s*e])),s}quantile(t,s=-1){if(0===t)return this.min(s);if(1===t)return this.max(s);const e=(t,s)=>{if(1===t.length)return t[0];const e=s*(t.length-1),i=Math.floor(e);return e===i?t[i]:(t[i]||0)*(e-i)+(t[i+1]||0)*(1-e+i)};if(s<0){const s=this._value.concat();return s.sort(((t,s)=>(t||0)-(s||0))),e(s,t)}const i=0===s?1:this.cols,r=0===s?this.cols:1,o=Matrix.zeros(...this._size.map(((t,e)=>e===s?1:t)));for(let l=0,h=0;l<o.length;l++,h+=i){const i=[];for(let t=1;t<this._size[s];t++)i.push(this._value[t*r+h]||0);i.sort(((t,s)=>t-s)),o._value[l]=e(i,t)}return o}argmax(t){let s=0===t?1:this.cols,e=0===t?this.cols:1;const i=[].concat(this._size);i[t]=1;const r=Matrix.zeros(...i);for(let i=0,o=0;i<r.length;i++,o+=s){let s=this._value[o]||0,l=0;for(let i=1;i<this._size[t];i++){let t=this._value[i*e+o]||0;t>s&&(s=t,l=i)}r._value[i]=l}return r}argmin(t){let s=0===t?1:this.cols,e=0===t?this.cols:1;const i=[].concat(this._size);i[t]=1;const r=Matrix.zeros(...i);for(let i=0,o=0;i<r.length;i++,o+=s){let s=this._value[o]||0,l=0;for(let i=1;i<this._size[t];i++){let t=this._value[i*e+o]||0;t<s&&(s=t,l=i)}r._value[i]=l}return r}sum(t=-1){if(t<0)return this._value.reduce(((t,s)=>t+(s||0)),0);let s=0===t?1:this.cols,e=0===t?this.cols:1;const i=[].concat(this._size);i[t]=1;const r=Matrix.zeros(...i);for(let i=0,o=0;i<r.length;i++,o+=s){let s=0;for(let i=0;i<this._size[t];i++)s+=this._value[i*e+o]||0;r._value[i]=s}return r}mean(t=-1){if(t<0)return this.sum(t)/this.length;let s=this.sum(t);return s.div(this._size[t]),s}prod(t=-1){if(t<0)return this._value.reduce(((t,s)=>t*(s||0)),1);let s=0===t?1:this.cols,e=0===t?this.cols:1;const i=[].concat(this._size);i[t]=1;const r=Matrix.zeros(...i);for(let i=0,o=0;i<r.length;i++,o+=s){let s=1;for(let i=0;i<this._size[t];i++)s*=this._value[i*e+o]||0;r._value[i]=s}return r}variance(t=-1){const s=this.mean(t);if(t<0)return this._value.reduce(((t,e)=>t+((e||0)-s)**2),0)/this.length;let e=0===t?1:this.cols,i=0===t?this.cols:1;const r=[].concat(this._size);r[t]=1;const o=Matrix.zeros(...r);for(let r=0,l=0;r<o.length;r++,l+=e){let e=0;for(let o=0;o<this._size[t];o++)e+=((this._value[o*i+l]||0)-s._value[r])**2;o._value[r]=e/this._size[t]}return o}std(t=-1){if(t<0)return Math.sqrt(this.variance(t));let s=this.variance(t);for(let t=0;t<s.length;t++)s._value[t]=Math.sqrt(s._value[t]);return s}median(t=-1){if(t<0){const t=this._value.concat();return t.sort(((t,s)=>(t||0)-(s||0))),t.length%2==1?t[(t.length-1)/2]||0:((t[t.length/2]||0)+(t[t.length/2-1]||0))/2}let s=0===t?1:this.cols,e=0===t?this.cols:1;const i=[].concat(this._size);i[t]=1;const r=Matrix.zeros(...i);for(let i=0,o=0;i<r.length;i++,o+=s){const s=[];for(let i=0;i<this._size[t];i++)s.push(this._value[i*e+o]||0);s.sort(((t,s)=>t-s)),s.length%2==1?r._value[i]=s[(s.length-1)/2]:r._value[i]=(s[s.length/2]+s[s.length/2-1])/2}return r}diag(){let t=[];const s=Math.min(this.rows,this.cols);for(let e=0;e<s;e++)t.push(this._value[e*this.cols+e]);return t}trace(){let t=0;const s=Math.min(this.rows,this.cols);for(let e=0;e<s;e++)t+=this._value[e*this.cols+e]||0;return t}norm(t=2){let s=0;for(let e=0;e<this.length;e++)s+=(this._value[e]||0)**t;if(2===t)return Math.sqrt(s);throw new MatrixException("Not implemented norm p != 2")}isSquare(){return this.rows===this.cols}isDiag(t=0){const s=this.cols;for(let e=0;e<this.rows;e++)for(let i=0;i<s;i++)if(e!==i&&Math.abs(this._value[e*s+i])>t)return!1;return!0}isTriangular(){return this.isLowerTriangular()||this.isUpperTriangular()}isLowerTriangular(t=0){const s=this.cols;for(let e=0;e<this.rows;e++)for(let i=e+1;i<s;i++)if(Math.abs(this._value[e*s+i])>t)return!1;return!0}isUpperTriangular(t=0){for(let s=0;s<this.rows;s++)for(let e=0;e<Math.min(s,this.cols);e++)if(Math.abs(this._value[s*this.cols+e])>t)return!1;return!0}isSymmetric(t=0){if(!this.isSquare())return!1;const s=this.cols;for(let e=0;e<this.rows;e++)for(let i=0;i<e;i++)if(t>0){if(Math.abs(this._value[e*s+i]-this._value[i*s+e])>t)return!1}else if(this._value[e*s+i]!==this._value[i*s+e])return!1;return!0}negative(){this.map((t=>t?-t:null))}abs(){this.map(Math.abs)}add(t){if(t instanceof Matrix)if(this.rows===t.rows&&this.cols===t.cols)for(let s=this.length-1;s>=0;s--)this._value[s]=(this._value[s]||0)+(t._value[s]||0);else if(this.rows>=t.rows&&this.cols>=t.cols){if(this.rows%t.rows!=0||this.cols%t.cols!=0)throw new MatrixException("Addition size invalid.",[this,t]);for(let s=0,e=0,i=0;s<this.length;s++,i++)i>=this.cols&&(e+=t.cols,i=0),e>=t.length&&(e=0),this._value[s]=(this._value[s]||0)+(t._value[e+i%t.cols]||0)}else{if(!(this.rows<=t.rows&&this.cols<=t.cols))throw new MatrixException("Addition size invalid.",[this,t]);if(t.rows%this.rows!=0||t.cols%this.cols!=0)throw new MatrixException("Addition size invalid.",[this,t]);this.repeat([t.rows/this.rows,t.cols/this.cols]);for(let s=this.length-1;s>=0;s--)this._value[s]=(this._value[s]||0)+(t._value[s]||0)}else this.map((s=>s+t))}addAt(t,s,e){if(t<0||this.rows<=t||s<0||this.cols<=s)throw new MatrixException("Index out of bounds.");const i=this._value[t*this.cols+s]||0;return this._value[t*this.cols+s]=i+e,i}copyAdd(t,s){let e=this.copy(s);return e.add(t),e}sub(t){if(t instanceof Matrix)if(this.rows===t.rows&&this.cols===t.cols)for(let s=this.length-1;s>=0;s--)this._value[s]=(this._value[s]||0)-(t._value[s]||0);else if(this.rows>=t.rows&&this.cols>=t.cols){if(this.rows%t.rows!=0||this.cols%t.cols!=0)throw new MatrixException("Subtract size invalid.",[this,t]);for(let s=0,e=0,i=0;s<this.length;s++,i++)i>=this.cols&&(e+=t.cols,i=0),e>=t.length&&(e=0),this._value[s]=(this._value[s]||0)-(t._value[e+i%t.cols]||0)}else{if(!(this.rows<=t.rows&&this.cols<=t.cols))throw new MatrixException("Subtract size invalid.",[this,t]);if(t.rows%this.rows!=0||t.cols%this.cols!=0)throw new MatrixException("Subtract size invalid.",[this,t]);this.repeat([t.rows/this.rows,t.cols/this.cols]);for(let s=this.length-1;s>=0;s--)this._value[s]=(this._value[s]||0)-(t._value[s]||0)}else this.map((s=>s-t))}isub(t){this.negative(),this.add(t)}subAt(t,s,e){if(t<0||this.rows<=t||s<0||this.cols<=s)throw new MatrixException("Index out of bounds.");const i=this._value[t*this.cols+s]||0;return this._value[t*this.cols+s]=i-e,i}isubAt(t,s,e){if(t<0||this.rows<=t||s<0||this.cols<=s)throw new MatrixException("Index out of bounds.");const i=this._value[t*this.cols+s]||0;return this._value[t*this.cols+s]=e-i,i}copySub(t,s){let e=this.copy(s);return e.sub(t),e}copyIsub(t,s){let e=this.copy(s);return e.isub(t),e}mult(t){if(t instanceof Matrix)if(this.rows===t.rows&&this.cols===t.cols)for(let s=this.length-1;s>=0;s--)this._value[s]=(this._value[s]||0)*(t._value[s]||0);else if(this.rows>=t.rows&&this.cols>=t.cols){if(this.rows%t.rows!=0||this.cols%t.cols!=0)throw new MatrixException("Multiple size invalid.",[this,t]);for(let s=0,e=0,i=0;s<this.length;s++,i++)i>=this.cols&&(e+=t.cols,i=0),e>=t.length&&(e=0),this._value[s]=(this._value[s]||0)*(t._value[e+i%t.cols]||0)}else{if(!(this.rows<=t.rows&&this.cols<=t.cols))throw new MatrixException("Multiple size invalid.",[this,t]);if(t.rows%this.rows!=0||t.cols%this.cols!=0)throw new MatrixException("Multiple size invalid.",[this,t]);this.repeat([t.rows/this.rows,t.cols/this.cols]);for(let s=this.length-1;s>=0;s--)this._value[s]=(this._value[s]||0)*(t._value[s]||0)}else this.map((s=>s*t))}multAt(t,s,e){if(t<0||this.rows<=t||s<0||this.cols<=s)throw new MatrixException("Index out of bounds.");const i=this._value[t*this.cols+s]||0;return this._value[t*this.cols+s]=i*e,i}copyMult(t,s){let e=this.copy(s);return e.mult(t),e}div(t){if(t instanceof Matrix)if(this.rows===t.rows&&this.cols===t.cols)for(let s=this.length-1;s>=0;s--)this._value[s]=(this._value[s]||0)/(t._value[s]||0);else if(this.rows>=t.rows&&this.cols>=t.cols){if(this.rows%t.rows!=0||this.cols%t.cols!=0)throw new MatrixException("Divide size invalid.",[this,t]);for(let s=0,e=0,i=0;s<this.length;s++,i++)i>=this.cols&&(e+=t.cols,i=0),e>=t.length&&(e=0),this._value[s]=(this._value[s]||0)/(t._value[e+i%t.cols]||0)}else{if(!(this.rows<=t.rows&&this.cols<=t.cols))throw new MatrixException("Divide size invalid.",[this,t]);if(t.rows%this.rows!=0||t.cols%this.cols!=0)throw new MatrixException("Divide size invalid.",[this,t]);this.repeat([t.rows/this.rows,t.cols/this.cols]);for(let s=this.length-1;s>=0;s--)this._value[s]=(this._value[s]||0)/(t._value[s]||0)}else this.map((s=>s/t))}idiv(t){if(t instanceof Matrix)if(this.rows===t.rows&&this.cols===t.cols)for(let s=this.length-1;s>=0;s--)this._value[s]=(t._value[s]||0)/(this._value[s]||0);else if(this.rows>=t.rows&&this.cols>=t.cols){if(this.rows%t.rows!=0||this.cols%t.cols!=0)throw new MatrixException("Divide size invalid.",[this,t]);for(let s=0,e=0,i=0;s<this.length;s++,i++)i>=this.cols&&(e+=t.cols,i=0),e>=t.length&&(e=0),this._value[s]=(t._value[e+i%t.cols]||0)/(this._value[s]||0)}else{if(!(this.rows<=t.rows&&this.cols<=t.cols))throw new MatrixException("Divide size invalid.",[this,t]);if(t.rows%this.rows!=0||t.cols%this.cols!=0)throw new MatrixException("Divide size invalid.",[this,t]);this.repeat([t.rows/this.rows,t.cols/this.cols]);for(let s=this.length-1;s>=0;s--)this._value[s]=(t._value[s]||0)/(this._value[s]||0)}else this.map((s=>t/s))}divAt(t,s,e){if(t<0||this.rows<=t||s<0||this.cols<=s)throw new MatrixException("Index out of bounds.");const i=this._value[t*this.cols+s]||0;return this._value[t*this.cols+s]=i/e,i}idivAt(t,s,e){if(t<0||this.rows<=t||s<0||this.cols<=s)throw new MatrixException("Index out of bounds.");const i=this._value[t*this.cols+s]||0;return this._value[t*this.cols+s]=e/i,i}copyDiv(t,s){let e=this.copy(s);return e.div(t),e}copyIdiv(t,s){let e=this.copy(s);return e.idiv(t),e}dot(t,s){if(this.cols!==t.rows)throw new MatrixException("Dot size invalid. left = ["+this.rows+", "+this.cols+"], right = ["+t.rows+", "+t.cols+"]");const e=t.cols,i=s||new Matrix(this.rows,e);let r=0;const o=this.length,l=t.length,h=this.cols,n=this._value,a=t._value,c=i._value;for(let t=0;t<o;t+=h){let s=0,i=t,o=0;for(let t=0;t<l;t+=e)n[i]&&o++,s+=n[i++]*a[t]||0;if(c[r++]=s,0!==o)if(o/h<.1){let i=[],o=[];for(let s=0;s<h;s++)n[t+s]&&(i.push(n[t+s]),o.push(s));for(let t=1;t<e;t++){s=0;for(let r=0;r<i.length;r++)s+=i[r]*a[o[r]*e+t]||0;c[r++]=s}}else for(let o=1;o<e;o++){s=0,i=t;for(let t=o;t<l;t+=e)s+=n[i++]*a[t]||0;c[r++]=s}else r+=e-1}return i}tDot(t,s){if(this.rows!==t.rows)throw new MatrixException("Dot size invalid. left = ["+this.cols+", "+this.rows+"], right = ["+t.rows+", "+t.cols+"]");const e=s||new Matrix(this.cols,t.cols);let i=0;for(let s=0;s<this.cols;s++)for(let r=0;r<t.cols;r++){let o=0,l=s;for(let s=r;s<t.length;s+=t.cols,l+=this.cols)o+=this._value[l]*t._value[s]||0;e._value[i++]=o}return e}convolute(t,s=!0){Array.isArray(t[0])||(t=[t]);const e=Math.floor((t.length-1)/2),i=this._value.concat();for(let r=0;r<this.rows;r++)for(let o=0;o<this.cols;o++){let l=0,h=0;for(let s=0;s<t.length;s++){const n=r+s-e;if(!(n<0||this.rows<=n))for(let r=0;r<t[s].length;r++){const a=o+r-e;a<0||this.cols<=a||(l+=t[s][r]*i[n*this.cols+a],h+=t[s][r])}}s&&(l/=h),this._value[r*this.cols+o]=l}}reducedRowEchelonForm(){for(let t=0,s=0;t<this.rows&&s<this.cols;s++,t++){if(0===this._value[t*this.cols+s])for(let e=t+1;e<this.rows;e++)if(0!==this._value[e*this.cols+s]){this.swap(t,e,0);break}if(0===this._value[t*this.cols+s]){t--;continue}const e=this._value[t*this.cols+s];this._value[t*this.cols+s]=1;for(let i=s+1;i<this.cols;i++)this._value[t*this.cols+i]/=e;for(let e=0;e<this.rows;e++){if(e===t)continue;const i=this._value[e*this.cols+s];this._value[e*this.cols+s]=0;for(let r=s+1;r<this.cols;r++)this._value[e*this.cols+r]-=i*this._value[t*this.cols+r]}}}rank(){throw new MatrixException("Not implemented.")}det(){if(!this.isSquare())throw new MatrixException("Determine only define square matrix.",this);const t=this._value;switch(this.rows){case 0:return 0;case 1:return t[0]||0;case 2:return(t[0]*t[3]||0)-(t[1]*t[2]||0);case 3:return(t[0]*t[4]*t[8]||0)+(t[1]*t[5]*t[6]||0)+(t[2]*t[3]*t[7]||0)-(t[0]*t[5]*t[7]||0)-(t[1]*t[3]*t[8]||0)-(t[2]*t[4]*t[6]||0)}const[s,e]=this.lu();let i=1;for(let t=0;t<this.rows;t++){const r=t*this.cols+t;i*=s._value[r]*e._value[r]}return i||0}inv(){if(!this.isSquare())throw new MatrixException("Inverse matrix only define square matrix.",this);const t=this._value;switch(this.rows){case 0:return new Matrix(0,0);case 1:return new Matrix(1,1,[1/(t[0]||0)]);case 2:const s=this.det();return new Matrix(2,2,[(t[3]||0)/s,-(t[1]||0)/s,-(t[2]||0)/s,(t[0]||0)/s]);case 3:const e=this.det();return new Matrix(3,3,[((t[4]*t[8]||0)-(t[5]*t[7]||0))/e,((t[2]*t[7]||0)-(t[1]*t[8]||0))/e,((t[1]*t[5]||0)-(t[2]*t[4]||0))/e,((t[5]*t[6]||0)-(t[3]*t[8]||0))/e,((t[0]*t[8]||0)-(t[2]*t[6]||0))/e,((t[2]*t[3]||0)-(t[0]*t[5]||0))/e,((t[3]*t[7]||0)-(t[4]*t[6]||0))/e,((t[1]*t[6]||0)-(t[0]*t[7]||0))/e,((t[0]*t[4]||0)-(t[1]*t[3]||0))/e])}return this.isLowerTriangular()?this.invLowerTriangular():this.isUpperTriangular()?this.invUpperTriangular():this.invLU()}invLowerTriangular(){if(!this.isSquare())throw new MatrixException("Inverse matrix only define square matrix.",this);const t=this._value,s=new Matrix(this.rows,this.cols);for(let e=0;e<this.rows;e++){const i=t[e*this.cols+e]||0;s._value[e*this.cols+e]=1/i;for(let r=0;r<e;r++){let o=0;for(let i=r;i<e;i++)o+=t[e*this.cols+i]*s._value[i*this.cols+r]||0;s._value[e*this.cols+r]=-o/i}}return s}invUpperTriangular(){if(!this.isSquare())throw new MatrixException("Inverse matrix only define square matrix.",this);const t=this._value,s=new Matrix(this.rows,this.cols);for(let e=this.cols-1;e>=0;e--){const i=t[e*this.cols+e]||0;s._value[e*this.cols+e]=1/i;for(let r=e+1;r<this.cols;r++){let o=0;for(let i=e+1;i<=r;i++)o+=t[e*this.cols+i]*s._value[i*this.cols+r]||0;s._value[e*this.cols+r]=-o/i}}return s}invRowReduction(){if(!this.isSquare())throw new MatrixException("Inverse matrix only define square matrix.",this);const t=this.copy(),s=this.rows,e=Matrix.eye(s,s);for(let i=0;i<s;i++){const r=i*s;if(0===t._value[r+i]){let o=i+1;for(;o<s&&0===t._value[o*s+i];o++);if(o===s)throw new MatrixException("",this);for(let e=i;e<s;e++)[t._value[r+e],t._value[o*s+e]]=[t._value[o*s+e],t._value[r+e]];e.swap(i,o)}const o=t._value[r+i]||0;t._value[r+i]=1;for(let e=i+1;e<s;e++)t._value[r+e]/=o;for(let t=0;t<s;t++)e._value[r+t]=(e._value[r+t]||0)/o;for(let o=0;o<s;o++){if(i===o)continue;const l=t._value[o*s+i]||0;t._value[o*s+i]=0;for(let e=i+1;e<s;e++)t._value[o*s+e]-=l*(t._value[r+e]||0);for(let t=0;t<s;t++)e._value[o*s+t]=(e._value[o*s+t]||0)-l*(e._value[r+t]||0)}}return e}invLU(){if(!this.isSquare())throw new MatrixException("Inverse matrix only define square matrix.",this);const[t,s]=this.lu();return s.invUpperTriangular().dot(t.invLowerTriangular())}sqrt(){if(!this.isSquare())throw new MatrixException("sqrt only define square matrix.",this);switch(this.rows){case 0:return this;case 1:return new Matrix(1,1,[Math.sqrt(this._value[0])])}const[t,s]=this.eigen(),e=new Matrix(this.rows,this.cols);for(let s=0;s<this.rows;s++)e._value[s*this.cols+s]=Math.sqrt(t[s]);return s.dot(e).dot(s.transpose())}power(t){if(!this.isSquare())throw new MatrixException("Only square matrix can power.",this);const s=this.rows;if(this.isDiag(1e-12))return Matrix.diag(this.diag().map((s=>Math.pow(s,t))));if(Number.isInteger(t)){if(0===t)return Matrix.eye(s,s);if(1===t)return this.copy();if(2===t)return this.dot(this);if(-1===t)return this.inv();if(t<0)return this.inv().power(-t);if(!this.isSymmetric(1e-12)){let s=this.dot(this);for(let e=2;e<t;e++)s=s.dot(this);return s}const[e,i]=this.eigen(),r=Matrix.diag(e.map((s=>Math.pow(s,t))));return i.dot(r).dot(i.t)}if(t<0)return this.inv().power(-t);if(.5===t)return this.sqrt();throw new MatrixException("Power only defined integer.")}solve(t){if(this.rows>this.cols)throw new MatrixException("Only square matrix or matrix with more columns than rows can be solved.",this);const s=this.rows;if(s!==t.rows)throw new MatrixException("b size is invalid.",[this,t]);let e,i=this;switch(s<this.cols&&(i=this.resize(this.rows,this.rows)),s){case 0:e=i;break;case 1:e=t.copyMap((t=>t/i._value[0]));break;default:const[s,r]=i.lu(),o=s.solveLowerTriangular(t);e=r.solveUpperTriangular(o)}return s<this.cols&&(e=e.resize(this.cols,e.cols)),e}solveLowerTriangular(t){if(!this.isSquare())throw new MatrixException("Only square matrix can solve.",this);const s=this.rows,e=t.cols;if(s!==t.rows)throw new MatrixException("b size is invalid.",[this,t]);const i=new Matrix(s,e);for(let r=0;r<e;r++)for(let o=0;o<s;o++){let l=t._value[o*e+r]||0;for(let t=0;t<o;t++)l-=i._value[t*e+r]*this._value[o*s+t]||0;i._value[o*e+r]=l/this._value[o*s+o]}return i}solveUpperTriangular(t){if(!this.isSquare())throw new MatrixException("Only square matrix can solve.",this);const s=this.rows,e=t.cols;if(s!==t.rows)throw new MatrixException("b size is invalid.",[this,t]);const i=new Matrix(s,e);for(let r=0;r<e;r++)for(let o=s-1;o>=0;o--){let l=t._value[o*e+r]||0;for(let t=s-1;t>o;t--)l-=i._value[t*e+r]*this._value[o*s+t]||0;i._value[o*e+r]=l/this._value[o*s+o]}return i}cov(t=0){const s=new Matrix(this.cols,this.cols),e=[];for(let i=0;i<this.cols;i++){let r=0;for(let t=i;t<this.length;t+=this.cols)r+=this._value[t];e[i]=r/this.rows;for(let r=0;r<=i;r++){let o=0;for(let t=0;t<this.length;t+=this.cols)o+=(this._value[i+t]-e[i])*(this._value[r+t]-e[r]);s._value[i*this.cols+r]=s._value[r*this.cols+i]=o/(this.rows-t)}}return s}gram(){return this.tDot(this)}bidiag(){let t=this.copy();const[s,e]=[this.rows,this.cols];for(let i=0;i<Math.min(s,e);i++){let r=t.slice(i,i),o=r.col(0),l=o.norm()*(o._value[0]<0?1:-1);o._value[0]-=l,o.div(o.norm());let h=o.dot(o.t);h.mult(2);let n=Matrix.eye(s-i,s-i);n.sub(h),r=n.tDot(r),o=r.row(0),o._value[0]=0,l=o.norm()*(o._value[1]<0?1:-1),o._value[1]-=l,o.div(o.norm()),h=o.tDot(o),h.mult(2),n=Matrix.eye(e-i,e-i),n.sub(h),r=r.dot(n),t.set(i,i,r)}return t}tridiag(){if(!this.isSymmetric())throw new MatrixException("Tridiagonal only define symmetric matrix.",this);let t=this.copy(),s=this.cols;for(let e=0;e<s-2;e++){let i=t.slice(e+1,e,s,e+1),r=i.norm()*(i._value[0]<0?1:-1);i._value[0]-=r,i.div(i.norm());let o=t.slice(e+1,e+1),l=o.dot(i),h=i.copyMult(i.tDot(l));h.isub(l),h.mult(2),o.sub(h.dot(i.t)),o.sub(i.dot(h.t)),t.set(e+1,e+1,o),t._value[e*s+e+1]=t._value[(e+1)*s+e]=r;for(let i=e+2;i<s;i++)t._value[e*s+i]=t._value[i*s+e]=0}return t}lu(){if(!this.isSquare())throw new MatrixException("LU decomposition only define square matrix.",this);const t=this.rows;switch(t){case 0:return[this,this];case 1:return[Matrix.ones(1,1),new Matrix(1,1,[this._value[0]])];case 2:return[new Matrix(2,2,[1,0,this._value[2]/this._value[0],1]),new Matrix(2,2,[this._value[0],this._value[1],0,this._value[3]-this._value[1]*this._value[2]/this._value[0]])]}let s=this.copy();for(let e=0;e<t;e++){const i=s._value[e*t+e];for(let r=e+1;r<t;r++){const o=s._value[r*t+e]/=i;for(let i=e+1;i<t;i++)s._value[r*t+i]-=o*s._value[e*t+i]}}let e=Matrix.eye(t,t);for(let i=0;i<t;i++)for(let r=0;r<i;r++)e._value[i*t+r]=s._value[i*t+r],s._value[i*t+r]=0;return[e,s]}qr(){const t=this.rows,s=this.cols;return 0===t||0===s?[this,this]:1===t?[Matrix.ones(1,1),this]:1===s?[this,Matrix.ones(1,1)]:this.qrHouseholder()}qrGramSchmidt(){const t=this.cols,s=this.copy(),e=Matrix.eye(t,t),i=[];for(let r=0;r<t;r++){for(let o=0;o<r;o++){let l=0;for(let e=0;e<this.rows;e++)l+=this._value[e*t+r]*s._value[e*t+o];const h=e._value[o*t+r]=l/i[o]**2;for(let e=0;e<this.rows;e++)s._value[e*t+r]-=s._value[e*t+o]*h}i.push(s.col(r).norm())}return s.mult(new Matrix(1,t,i.map((t=>1/t)))),e.mult(new Matrix(t,1,i)),[s,e]}qrHouseholder(){const t=this.rows,s=this.cols,e=this.copy(),i=Matrix.eye(t,t);for(let r=0;r<Math.min(t,s)-1;r++){const s=t-r,o=e.slice(r,r,t,r+1),l=o.norm()*Math.sign(o._value[0]);o._value[0]-=l,o.div(o.norm());let h=new Matrix(s,s);for(let t=0;t<s;t++){const e=o._value[t];if(h._value[t*s+t]=1-2*e**2,e)for(let i=0;i<t;i++)h._value[t*s+i]=h._value[i*s+t]=-2*e*o._value[i]}e.set(r,r,h.dot(e.slice(r,r))),i.set(r,0,h.dot(i.slice(r,0)))}return[i.t,e]}svd(){return this.svdEigen()}svdEigen(){const t=Math.min(this.cols,this.rows);if(this.cols<=this.rows){const s=this.tDot(this),[e,i]=s.eigenJacobi();for(let s=0;s<t;s++)e[s]=Math.sqrt(e[s]);const r=this.dot(i);for(let s=0;s<this.rows;s++)for(let i=0;i<t;i++)r._value[s*t+i]/=e[i];return[r,e,i]}{const s=this.dot(this.t),[e,i]=s.eigenJacobi();for(let s=0;s<t;s++)e[s]=Math.sqrt(e[s]);const r=i.tDot(this);for(let s=0;s<t;s++)for(let t=0;t<this.cols;t++)r._value[s*this.cols+t]/=e[s];return[i,e,r.t]}}svdGolubKahan(){}cholesky(){return this.choleskyBanachiewicz()}choleskyBanachiewicz(){if(!this.isSymmetric(1e-15))throw new MatrixException("Cholesky decomposition only define symmetric matrix.",this);const t=this.rows,s=new Matrix(t,t);for(let e=0;e<t;e++){let i=0;for(let r=0;r<e;r++){let o=0;for(let i=0;i<r;i++)o+=s._value[e*t+i]*s._value[r*t+i]||0;s._value[e*t+r]=((this._value[e*t+r]||0)-o)/s._value[r*t+r],i+=s._value[e*t+r]**2}s._value[e*t+e]=Math.sqrt((this._value[e*t+e]||0)-i)}return s}choleskyLDL(){if(!this.isSymmetric(1e-15))throw new MatrixException("Cholesky decomposition only define symmetric matrix.",this);const t=this.rows,s=[],e=Matrix.eye(t,t);for(let i=0;i<t;i++){s[i]=this._value[i*t+i]||0;for(let r=0;r<i;r++){let o=0;for(let l=0;l<r;l++)o+=e._value[i*t+l]*e._value[r*t+l]*s[l];e._value[i*t+r]=((this._value[i*t+r]||0)-o)/s[r],s[i]-=e._value[i*t+r]**2*s[r]}}return[e,s]}eigen(){if(!this.isSquare())throw new MatrixException("Eigen values only define square matrix.",this);if(this.rows<=2)return[this.eigenValues(),this.eigenVectors()];if(this.isSymmetric(1e-15))return this.eigenJacobi();{const t=this.eigenValues(),s=this.rows;let e=new Matrix(s,s);for(let i=0;i<s;i++){const[r,o]=this.eigenInverseIteration(t[i]);for(let t=0;t<s;t++)e._value[t*s+i]=o._value[t]}return[t,e]}}eigenValues(){if(!this.isSquare())throw new MatrixException("Eigen values only define square matrix.",this);switch(this.rows){case 0:return[];case 1:return[this._value[0]];case 2:let t=this._value[0]+this._value[3],s=Math.sqrt(t**2-4*this.det());return[(t+s)/2,(t-s)/2]}return this.isSymmetric(1e-15)?this.eigenJacobi()[0]:this.eigenValuesQR()}eigenVectors(){if(!this.isSquare())throw new MatrixException("Eigen vectors only define square matrix.",this);switch(this.rows){case 0:return this;case 1:return new Matrix(1,1,[1]);case 2:const t=this.eigenValues(),s=[-this._value[1],this._value[0]-t[0]],e=Math.sqrt(s[0]**2+s[1]**2),i=[-this._value[1],this._value[0]-t[1]],r=Math.sqrt(i[0]**2+i[1]**2);return new Matrix(2,2,[s[0]/e,i[0]/r,s[1]/e,i[1]/r])}return this.eigen()[1]}eigenValuesLR(){if(!this.isSquare())throw new MatrixException("Eigen values only define square matrix.",this);let t=this;const s=t.rows;let e=1e5;for(;e-- >0;){const[e,i]=t.lu();t=i.dot(e);let r=0;for(let e=0;e<s;e++)for(let i=0;i<e;i++)r+=t._value[e*s+i]**2;if(r<1e-15){const s=t.diag();return s.sort(((t,s)=>s-t)),s}}throw new MatrixException("eigenVectors not converged.",this)}eigenValuesQR(){if(!this.isSquare())throw new MatrixException("Eigen values only define square matrix.",this);let t=this.copy();const s=[];this.rows>10&&this.isSymmetric()&&(t=t.tridiag());for(let e=t.rows;e>2;e--){let i=1e6;for(;;){let r=t.slice(e-2,e-2).eigenValues();if(isNaN(r[0])){s.sort(((t,s)=>s-t));for(let t=0;t<e;t++,s.push(NaN));return s}const o=t._value[t._value.length-1],l=Math.abs(r[0]-o)<Math.abs(r[1]-o)?r[0]:r[1];for(let s=0;s<e;s++)t._value[s*e+s]-=l;const[h,n]=t.qr();t=n.dot(h);for(let s=0;s<e;s++)t._value[s*e+s]=(t._value[s*e+s]||0)+l;let a=0;for(let s=(e-1)*e;s<t.length-1;s++)a+=Math.abs(t._value[s]||0);if(a<1e-15)break;if(i--<0)throw new MatrixException("eigenValues not converged.",this)}s.push(t._value[t._value.length-1]),t=t.resize(e-1,e-1)}const e=t.eigenValues();return s.push(e[0],e[1]),s.sort(((t,s)=>s-t)),s}eigenJacobi(t=1e6){if(!this.isSymmetric(1e-15))throw new MatrixException("Jacobi method can only use symmetric matrix.",this);const s=this._value.concat(),e=Matrix.eye(this.rows,this.cols);e.add(0);let i=0;const r=this.rows;let o=t;for(;;){let t=0,l=0,h=0;for(let e=0;e<r;e++)for(let i=e+1;i<r;i++){const o=Math.abs(s[e*r+i]);o>t&&(t=o,l=e,h=i)}if(t<1e-15)break;if(t===i)break;if(o--<0){console.log(new MatrixException("eigenJacobi not converged.",[this,t]));break}i=t;const n=s[l*r+l],a=s[l*r+h],c=s[h*r+h],u=(n-c)/2,f=-a,v=Math.abs(u)/Math.sqrt(u**2+f**2);let _=Math.sqrt((1-v)/2);const w=Math.sqrt((1+v)/2);u*f<0&&(_=-_);for(let t=0;t<r;t++){const e=s[l*r+t],i=s[h*r+t];s[t*r+h]=s[h*r+t]=_*e+w*i,s[t*r+l]=s[l*r+t]=w*e-_*i}s[l*r+l]=w**2*n+_**2*c-2*_*w*a,s[l*r+h]=s[h*r+l]=_*w*(n-c)+(w**2-_**2)*a,s[h*r+h]=_**2*n+w**2*c+2*_*w*a;for(let t=0;t<r;t++){const s=e._value[t*r+l],i=e._value[t*r+h];e._value[t*r+h]=_*s+w*i,e._value[t*r+l]=w*s-_*i}}const l=[];for(let t=0;t<r;t++)l.push([t,s[t*r+t]]);l.sort(((t,s)=>s[1]-t[1]));const h=e.col(l.map((t=>t[0])));return[l.map((t=>t[1])),h]}eigenPowerIteration(){if(!this.isSquare())throw new MatrixException("Eigen vectors only define square matrix.",this);const t=this.rows;let s=Matrix.randn(t,1);s.div(s.norm());let e=1/0,i=1e4;for(;i-- >0;){const i=this.dot(s);let r=0,o=0;for(let e=0;e<t;e++)r+=i._value[e]**2,o+=i._value[e]*s._value[e];const l=r/o;i.div(i.norm());const h=Math.abs(l-e);if(h<1e-15||isNaN(h))return[l,i];s=i,e=l}throw new MatrixException("eigenPowerIteration not converged.",this)}eigenInverseIteration(t=0){if(!this.isSquare())throw new MatrixException("Eigen vectors only define square matrix.",this);const s=this.rows;let e=this.copy();for(let i=0;i<s;i++)e._value[i*s+i]=(e._value[i*s+i]||0)-t+1e-15;e=e.inv();let i=Matrix.randn(s,1);i.div(i.norm());let r=1/0,o=1e4;for(;o-- >0;){const o=e.dot(i);let l=0,h=0;for(let t=0;t<s;t++)l+=o._value[t]**2,h+=i._value[t]*o._value[t];const n=h/l;o.div(o.norm());const a=Math.abs(n-r);if(a<1e-15||isNaN(a))return[n+t,o];i=o,r=n}throw new MatrixException("eigenInverseIteration not converged.",this)}}