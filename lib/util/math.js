const normal_random=function(t=0,s=1){const e=Math.sqrt(s),i=Math.random(),r=Math.random();return[Math.sqrt(-2*Math.log(i))*Math.cos(2*Math.PI*r)*e+t,Math.sqrt(-2*Math.log(i))*Math.sin(2*Math.PI*r)*e+t]};export class Complex{constructor(t=0,s=0){this._real=t,this._imaginary=s}get real(){return this._real}get imaginary(){return this._imaginary}abs(){return Math.sqrt(this._real**2+this._imaginary**2)}conjugate(){return new Complex(this._real,-this._imaginary)}add(t){return"number"==typeof t?new Complex(this._real+t,this._imaginary):new Complex(this._real+t._real,this._imaginary+t._imaginary)}sub(t){return"number"==typeof t?new Complex(this._real-t,this._imaginary):new Complex(this._real-t._real,this._imaginary-t._imaginary)}mult(t){return"number"==typeof t?new Complex(this._real*t,this._imaginary*t):new Complex(this._real*t._real-this._imaginary*t._imaginary,this._imaginary*t._real+this._real*t._imaginary)}div(t){if("number"==typeof t)return new Complex(this._real/t,this._imaginary/t);const s=t._real**2+t._imaginary**2;return new Complex((this._real*t._real+this._imaginary*t._imaginary)/s,(this._imaginary*t._real-this._real*t._imaginary)/s)}sqrt(){const t=Math.atan2(this._imaginary,this._real)/2,s=Math.sqrt(this.abs()),e=[];for(let i=0;i<2;i++){const r=Math.cos(t+i*Math.PI),o=Math.sin(t+i*Math.PI);e.push(new Complex(r*s,o*s))}return e}cbrt(){const t=Math.atan2(this._imaginary,this._real)/3,s=Math.cbrt(this.abs()),e=[];for(let i=0;i<3;i++){const r=Math.cos(t+i*Math.PI*2/3),o=Math.sin(t+i*Math.PI*2/3);e.push(new Complex(r*s,o*s))}return e}}export class Tree{constructor(t,s){this.value=t,this.childs=s?.concat()||[],this.childs.forEach((t=>t.parent=this)),this.parent=null}get length(){return this.childs.length}get depth(){return this.isLeaf()?1:1+Math.max.apply(null,this.childs.map((t=>t.depth)))}*[Symbol.iterator](){yield*this.childs}at(t){return this.childs[t]}push(t){t=t instanceof Tree?t:new Tree(t),this.childs.push(t),t.parent=this}set(t,s){t<0||this.childs.length<=t||(s=s instanceof Tree?s:new Tree(s),this.childs[t].parent=null,this.childs[t]=s,s.parent=this)}removeAt(t){if(!(t<0||this.childs.length<=t))return this.childs[t].parent=null,this.childs.splice(t,1)[0]}clear(){this.childs.forEach((t=>t.parent=null)),this.childs.length=0}isLeaf(){return 0===this.childs.length}isRoot(){return null===this.parent}root(){return this.isRoot()?this:this.parent.root()}leafs(){let t=[];return this.scanLeaf((s=>t.push(s))),t}leafValues(){let t=[];return this.scanLeaf((s=>t.push(s.value))),t}leafCount(){return this.isLeaf()?1:this.childs.reduce(((t,s)=>t+s.leafCount()),0)}forEach(t,s){this.childs.forEach(t,s)}scan(t){t(this),this.childs.forEach((s=>s.scan(t)))}scanLeaf(t){this.isLeaf()?t(this):this.childs.forEach((s=>s.scanLeaf(t)))}}export class Tensor{constructor(t,s){this._size=t.concat(),this._length=t.reduce(((t,s)=>t*s),1),s?Array.isArray(s)?this._value=s.flat(t.length):this._value=Array(this._length).fill(s):this._value=Array(this._length).fill(0),this._offset=0}static zeros(t){return new Tensor(t)}static ones(t){return new Tensor(t,1)}static random(t,s=0,e=1){const i=new Tensor(t);for(let t=0;t<i.length;t++)i._value[t]=Math.random()*(e-s)+s;return i}static randn(t,s=0,e=1){const i=new Tensor(t);for(let t=0;t<i.length;t+=2){const r=normal_random(s,e);i._value[t]=r[0],t+1<i.length&&(i._value[t+1]=r[1])}return i}static fromArray(t){if(t instanceof Tensor)return t;if(t instanceof Matrix)return new Tensor(t.sizes,t._value);if(!Array.isArray(t))return new Tensor([1],t);if(0===t.length)return new Tensor([0]);const s=[];let e=t;for(;Array.isArray(e);)s.push(e.length),e=e[0];return new Tensor(s,t)}get dimension(){return this._size.length}get sizes(){return this._size}get length(){return this._length}get value(){return this._value}*[Symbol.iterator](){yield*this._value}toArray(){const t=[];let s=[t],e=0;for(let t=0;t<this._size.length;t++){const i=[];for(const r of s)if(t===this._size.length-1)r.push(...this._value.slice(e,e+this._size[t])),e+=this._size[t];else for(let s=0;s<this._size[t];s++)i.push(r[s]=[]);s=i}return t}toString(){let t=this.dimension,s="";for(let e=0;e<this.length;){for(let e=0;e<t;e++)s+="[";s+=this._value[e],t=0;let i=++e;for(let s=this.dimension-1;s>=0&&i%this._size[s]==0;s--)t++,i/=this._size[s];for(let e=0;e<t;e++)s+="]";e!==this.length&&(s+=", ")}return s}toMatrix(){if(2!==this.dimension)throw new MatrixException("Only 2D tensor can convert to matrix.");return new Matrix(...this._size,this._value)}_to_position(...t){let s=0;for(let e=0;e<this.dimension;e++){if(t[e]<0||this._size[e]<=t[e])throw new MatrixException("Index out of bounds.");s=s*this._size[e]+t[e]}return s+this._offset}_to_index(t){const s=Array(this.dimension);for(let e=this.dimension-1;e>=0;e--)s[e]=t%this._size[e],t=Math.floor(t/this._size[e]);return s}copy(){return new Tensor(this._size,this.value.slice(this._offset,this._offset+this._length))}equals(t){if(t instanceof Tensor){if(this.dimension!==t.dimension)return!1;if(this._size.some(((s,e)=>s!==t._size[e])))return!1;for(let s=this.length-1;s>=0;s--)if(this._value[s]!==t._value[s])return!1;return!0}return!1}at(...t){if(Array.isArray(t[0])&&(t=t[0]),t.length===this.dimension)return this._value[this._to_position(...t)];let s=0;for(let e=0;e<t.length;e++){if(t[e]<0||this._size[e]<=t[e])throw new MatrixException("Index out of bounds.");s=s*this._size[e]+t[e]}let e=s+1;for(let i=t.length;i<this.dimension;i++)s*=this._size[i],e*=this._size[i];const i=new Tensor(this._size.slice(t.length));return i._value=this._value,i._offset=s,i}slice(t,s,e=0){if(e>0)throw"Invalid axis. Only 0 is accepted.";let i=1;for(let t=1;t<this.dimension;t++)i*=this._size[t];const r=new Tensor([s-t,...this._size.slice(1)]);return r._value=this._value.slice(t*i,s*i),r}set(t,s){Array.isArray(t)||(t=[t]),this._value[this._to_position(...t)]=s}select(t,s=0){if(s>0)throw"Invalid axis. Only 0 is accepted.";Array.isArray(t)||(t=[t]);let e=1;for(let t=1;t<this.dimension;t++)e*=this._size[t];const i=new Tensor([t.length,...this._size.slice(1)]);for(let s=0;s<t.length;s++)for(let r=0;r<e;r++)i._value[s*e+r]=this._value[t[s]*e+r];return i}fill(t){this._value=Array(this.length).fill(t)}map(t){for(let s=this.length-1;s>=0;s--)this._value[s]=t(this._value[s],this._to_index(s),this)}forEach(t){for(let s=0;s<this.length;s++)t(this._value[s],this._to_index(s),this)}shuffle(t=0){const s=[];for(let e=0;e<this._size[t];e++)s[e]=e;for(let t=s.length-1;t>0;t--){let e=Math.floor(Math.random()*(t+1));[s[t],s[e]]=[s[e],s[t]]}this._value=this.select(s,t)._value}transpose(...t){const s=new Tensor(t.map((t=>this._size[t])));for(let e=0;e<this.length;e++){const i=this._to_index(e);s._value[s._to_position(...t.map((t=>i[t])))]=this._value[e]}return s}reshape(...t){if(t.reduce(((t,s)=>t*s),1)!==this.length)throw new MatrixException("Length is different.");this._size=t.concat()}}function MatrixException(t,s){this.message=t,this.value=s,this.name=MatrixException}export class Matrix{constructor(t,s,e){e?Array.isArray(e)?Array.isArray(e[0])?this._value=e.flat():this._value=e:this._value=Array(t*s).fill(e):this._value=Array(t*s).fill(0),this._size=[t,s]}static zeros(t,s){return new Matrix(t,s,Array(t*s).fill(0))}static ones(t,s){return new Matrix(t,s,Array(t*s).fill(1))}static eye(t,s,e=1){const i=new Matrix(t,s),r=Math.min(t,s);for(let t=0;t<r;t++)i._value[t*s+t]=e;return i}static random(t,s,e=0,i=1){const r=new Matrix(t,s);for(let t=0;t<r.length;t++)r._value[t]=Math.random()*(i-e)+e;return r}static randn(t,s,e=0,i=1){const r=new Matrix(t,s);if(Array.isArray(e)&&(e=new Matrix(1,e.length,e)),Array.isArray(i)&&(i=Matrix.fromArray(i)),!(e instanceof Matrix||i instanceof Matrix)){for(let t=0;t<r.length;t+=2){const s=normal_random(e,i);r._value[t]=s[0],t+1<r.length&&(r._value[t+1]=s[1])}return r}if(e instanceof Matrix?e.rows!==s&&1!==e.cols||(e=e.t):e=new Matrix(1,s,e),e.cols!==s||1!==e.rows)throw new MatrixException("'myu' cols must be same as 'cols' and rows must be 1.");if(i instanceof Matrix){if(i.rows!==s||i.cols!==s)throw new MatrixException("'sigma' cols and rows must be same as 'cols'.")}else i=Matrix.eye(s,s,i);const o=i.cholesky();for(let t=0;t<r.length;t+=2){const s=normal_random(0,1);r._value[t]=s[0],t+1<r.length&&(r._value[t+1]=s[1])}const l=r.dot(o.t);return l.add(e),l}static diag(t){let s=0,e=0;for(const i of t)"number"==typeof i?(s++,e++):(s+=i.rows,e+=i.cols);const i=new Matrix(s,e);for(let r=0,o=0,l=0;o<s;r++)"number"==typeof t[r]?(i._value[o*e+l]=t[r],o++,l++):(i.set(o,l,t[r]),o+=t[r].rows,l+=t[r].cols);return i}static fromArray(t){return t instanceof Matrix?t:Array.isArray(t)?0===t.length?new Matrix(0,0):Array.isArray(t[0])?new Matrix(t.length,t[0].length,t):new Matrix(t.length,1,t):new Matrix(1,1,t)}get dimension(){return this._size.length}get sizes(){return this._size}get length(){return this._size[0]*this._size[1]}get rows(){return this._size[0]}get cols(){return this._size[1]}get value(){return this._value}get t(){return this.transpose()}toArray(){const t=[],s=this.cols;for(let e=0;e<this.length;e+=s)t.push(this._value.slice(e,e+s));return t}toString(){let t="[";for(let s=0;s<this.rows;s++){s>0&&(t+=",\n "),t+="[";for(let e=0;e<this.cols;e++)e>0&&(t+=", "),t+=this._value[s*this.cols+e];t+="]"}return t+"]"}copy(t){return t===this?this:t?(t._size=[].concat(this._size),this._value.forEach(((s,e)=>t._value[e]=s)),t):new Matrix(this.rows,this.cols,[].concat(this._value))}equals(t,s=0){if(t instanceof Matrix){if(this._size[0]!==t._size[0]||this._size[1]!==t._size[1])return!1;for(let e=this.length-1;e>=0;e--)if(Math.abs(this._value[e]-t._value[e])>s)return!1;return!0}return!1}at(t,s){if(Array.isArray(t)&&([t,s]=t),t<0||this.rows<=t||s<0||this.cols<=s)throw new MatrixException("Index out of bounds.");return this._value[t*this.cols+s]}set(t,s,e){if(Array.isArray(t)&&(e=s,[t,s]=t),e instanceof Matrix){if(t<0||this.rows<=t+e.rows-1||s<0||this.cols<=s+e.cols-1)throw new MatrixException("Index out of bounds.");for(let i=0;i<e.rows;i++)for(let r=0;r<e.cols;r++)this._value[(i+t)*this.cols+r+s]=e._value[i*e.cols+r];return null}{if(t<0||this.rows<=t||s<0||this.cols<=s)throw new MatrixException("Index out of bounds.");const i=this._value[t*this.cols+s];return this._value[t*this.cols+s]=e,i}}row(t){if(Array.isArray(t)){if(t.some((t=>t<0||this.rows<=t)))throw new MatrixException("Index out of bounds.");const s=new Matrix(t.length,this.cols);for(let e=0;e<t.length;e++)for(let i=0;i<this.cols;i++)s._value[e*this.cols+i]=this._value[t[e]*this.cols+i];return s}if(t<0||this.rows<=t)throw new MatrixException("Index out of bounds.");return new Matrix(1,this.cols,this._value.slice(t*this.cols,(t+1)*this.cols))}col(t){if(Array.isArray(t)){if(t.some((t=>t<0||this.cols<=t)))throw new MatrixException("Index out of bounds.");const s=new Matrix(this.rows,t.length);for(let e=0;e<this.rows;e++)for(let i=0;i<t.length;i++)s._value[e*t.length+i]=this._value[e*this.cols+t[i]];return s}{if(t<0||this.cols<=t)throw new MatrixException("Index out of bounds.");const s=new Matrix(this.rows,1);for(let e=0;e<this.rows;e++)s._value[e]=this._value[e*this.cols+t];return s}}slice(t,s,e=0){if("number"!=typeof t&&(t=0),"number"!=typeof s&&(s=this._size[e]),0===e){const e=new Matrix(s-t,this.cols);for(let s=0;s<e.rows;s++)for(let i=0;i<e.cols;i++)e._value[s*e.cols+i]=this._value[(s+t)*this.cols+i];return e}{const e=new Matrix(this.rows,s-t);for(let s=0;s<e.rows;s++)for(let i=0;i<e.cols;i++)e._value[s*e.cols+i]=this._value[s*this.cols+i+t];return e}}block(t,s,e,i){"number"!=typeof t&&(t=0),"number"!=typeof s&&(s=0);const r=new Matrix((e||this.rows)-t,(i||this.cols)-s);for(let e=0;e<r.rows;e++)for(let i=0;i<r.cols;i++)r._value[e*r.cols+i]=this._value[(e+t)*this.cols+i+s];return r}remove(t,s=0){if(0===s)if(Array.isArray(t)){if(t.some((t=>t<0||this.rows<=t)))throw new MatrixException("Index out of bounds.");(t=[...new Set(t)]).sort(((t,s)=>s-t));for(let s=0;s<t.length;s++)this._value.splice(t[s]*this.cols,this.cols);this._size[0]-=t.length}else{if(t<0||this.rows<=t)throw new MatrixException("Index out of bounds.");this._value.splice(t*this.cols,this.cols),this._size[0]--}else if(Array.isArray(t)){if(t.some((t=>t<0||this.cols<=t)))throw new MatrixException("Index out of bounds.");(t=[...new Set(t)]).sort(((t,s)=>t-s));let s=0,e=0;for(let i=0;i<this.rows;i++)for(let i=0,r=0;i<this.cols;i++,s++)t[r]!==i?this._value[e++]=this._value[s]:r++;this._size[1]-=t.length,this._value.length=this.length}else{if(t<0||this.cols<=t)throw new MatrixException("Index out of bounds.");let s=0,e=0;for(let i=0;i<this.rows;i++)for(let i=0;i<this.cols;i++,s++)t!==i&&(this._value[e++]=this._value[s]);this._size[1]--,this._value.length=this.length}}removeIf(t,s=0){const e=[];if(0===s)for(let s=0;s<this.rows;s++)t(this.row(s))&&e.push(s);else for(let s=0;s<this.cols;s++)t(this.col(s))&&e.push(s);this.remove(e,s)}sample(t,s=0,e=!1){const i=this.sizes[s],r=[];for(let s=0;s<t;s++)r.push(Math.floor(Math.random()*(i-s)));for(let s=t-1;s>=0;s--)for(let e=t-1;e>s;e--)r[s]<=r[e]&&r[e]++;return 0===s?e?[this.row(r),r]:this.row(r):e?[this.col(r),r]:this.col(r)}fill(t){this._value.fill(t)}map(t){for(let s=0,e=0;s<this._size[0];s++)for(let i=0;i<this._size[1];i++,e++)this._value[e]=t(this._value[e],[s,i],this)}copyMap(t){const s=new Matrix(this.rows,this.cols);for(let e=0,i=0;e<this._size[0];e++)for(let r=0;r<this._size[1];r++,i++)s._value[i]=t(this._value[i],[e,r],this);return s}forEach(t){for(let s=0,e=0;s<this._size[0];s++)for(let i=0;i<this._size[1];i++,e++)t(this._value[e],[s,i],this)}transpose(){const t=new Matrix(this.cols,this.rows);for(let s=0;s<this.rows;s++)for(let e=0;e<this.cols;e++)t._value[e*this.rows+s]=this._value[s*this.cols+e];return t}adjoint(){return this.transpose()}flip(t=0){if(0===t)for(let t=0;t<this.rows/2;t++){const s=(this.rows-t-1)*this.cols;for(let e=0;e<this.cols;e++){const i=this._value[t*this.cols+e];this._value[t*this.cols+e]=this._value[s+e],this._value[s+e]=i}}else if(1===t)for(let t=0;t<this.cols/2;t++){const s=this.cols-t-1;for(let e=0;e<this.rows;e++){const i=this._value[e*this.cols+t];this._value[e*this.cols+t]=this._value[e*this.cols+s],this._value[e*this.cols+s]=i}}}swap(t,s,e=0){if(0===e){if(t<0||s<0||this.rows<=t||this.rows<=s)throw new MatrixException("Index out of bounds.");const e=(s-t)*this.cols;for(let s=t*this.cols;s<(t+1)*this.cols;s++)[this._value[s],this._value[s+e]]=[this._value[s+e],this._value[s]]}else if(1===e){if(t<0||s<0||this.cols<=t||this.cols<=s)throw new MatrixException("Index out of bounds.");const e=s-t;for(let s=t;s<this.length;s+=this.cols)[this._value[s],this._value[s+e]]=[this._value[s+e],this._value[s]]}}sort(t=0){if(0===t){const t=[];for(let s=0;s<this.rows;t.push(s++));return t.sort(((t,s)=>{const e=t*this.cols,i=s*this.cols;for(let t=0;t<this.cols;t++){const s=this._value[e+t]-this._value[i+t];if(0!==s)return s}return 0})),this._value=this.row(t)._value,t}if(1===t){const t=[];for(let s=0;s<this.cols;t.push(s++));return t.sort(((t,s)=>{for(let e=0;e<this.rows;e++){const i=this._value[t+e*this.cols]-this._value[s+e*this.cols];if(0!==i)return i}return 0})),this._value=this.col(t)._value,t}}shuffle(t=0){const s=[];for(let e=0;e<this._size[t];e++)s[e]=e;for(let t=s.length-1;t>0;t--){let e=Math.floor(Math.random()*(t+1));[s[t],s[e]]=[s[e],s[t]]}0===t?this._value=this.row(s)._value:1===t&&(this._value=this.col(s)._value)}resize(t,s,e=0){const i=new Matrix(t,s);i.fill(e);const r=Math.min(this.rows,t),o=Math.min(this.cols,s);for(let t=0;t<r;t++)for(let e=0;e<o;e++)i._value[t*s+e]=this._value[t*this.cols+e];return i}reshape(t,s){if(this.length!==t*s)throw new MatrixException("Length is different.");this._size=[t,s]}repeat(t,s=0){if(Array.isArray(t)){if(t.length<this._size.length)for(let s=t.length;s<this._size.length;s++)t[s]=1}else{const e=Array(this._size.length).fill(1);e[s]=t,t=e}const e=t.reduce(((t,s)=>t*s),1);if(1===e)return;const i=Array(this.length*e),r=this._size.map(((s,e)=>s*t[e]));for(let t=0;t<r[0];t++)for(let s=0;s<r[1];s++)i[t*r[1]+s]=this._value[t%this.rows*this.cols+s%this.cols];this._value=i,this._size=r}copyRepeat(t,s=0){let e=this.copy();return e.repeat(t,s),e}concat(t,s=0){let e=null;if(0===s){if(this.cols!==t.cols)throw new MatrixException("Size is different.");return new Matrix(this.rows+t.rows,this.cols,[].concat(this._value,t._value))}if(1===s){if(this.rows!==t.rows)throw new MatrixException("Size is different.");e=this.resize(this.rows,this.cols+t.cols);for(let s=0;s<this.rows;s++)for(let i=0;i<t.cols;i++)e._value[s*e.cols+i+this.cols]=t._value[s*t.cols+i];return e}throw new MatrixException("Invalid axis.")}reduce(t,s,e=-1){if(e<0)return this._value.reduce(t,s);let i=0===e?1:this.cols,r=0===e?this.cols:1;const o=[].concat(this._size);o[e]=1;const l=Matrix.zeros(...o);for(let o=0,h=0;o<l.length;o++,h+=i){let i=s??this._value[h];for(let o=i===s?0:1;o<this._size[e];o++)i=t(i,this._value[o*r+h],o);l._value[o]=i}return l}every(t,s=-1){return this.reduce(((s,e)=>s&&t(e)),!0,s)}some(t,s=-1){return this.reduce(((s,e)=>s||t(e)),!1,s)}max(t=-1){if(t<0){let t=-1/0;for(let s=this.length-1;s>=0;s--)t=Math.max(t,this._value[s]);return t}const s=this.argmax(t);let e=0===t?1:this.cols,i=0===t?this.cols:1;return s._value=s._value.map(((t,s)=>this._value[t*i+s*e])),s}min(t=-1){if(t<0){let t=1/0;for(let s=this.length-1;s>=0;s--)t=Math.min(t,this._value[s]);return t}const s=this.argmin(t);let e=0===t?1:this.cols,i=0===t?this.cols:1;return s._value=s._value.map(((t,s)=>this._value[t*i+s*e])),s}median(t=-1){if(t<0){const t=this._value.concat();return t.sort(((t,s)=>t-s)),t.length%2==1?t[(t.length-1)/2]:(t[t.length/2]+t[t.length/2-1])/2}let s=0===t?1:this.cols,e=0===t?this.cols:1;const i=[].concat(this._size);i[t]=1;const r=Matrix.zeros(...i);for(let i=0,o=0;i<r.length;i++,o+=s){const s=[];for(let i=0;i<this._size[t];i++)s.push(this._value[i*e+o]);s.sort(((t,s)=>t-s)),s.length%2==1?r._value[i]=s[(s.length-1)/2]:r._value[i]=(s[s.length/2]+s[s.length/2-1])/2}return r}quantile(t,s=-1){if(0===t)return this.min(s);if(1===t)return this.max(s);const e=(t,s)=>{if(t.sort(((t,s)=>t-s)),1===t.length)return t[0];const e=s*(t.length-1),i=Math.floor(e);return e===i?t[i]:t[i]*(1-e+i)+t[i+1]*(e-i)};if(s<0){return e(this._value.concat(),t)}const i=0===s?1:this.cols,r=0===s?this.cols:1,o=Matrix.zeros(...this._size.map(((t,e)=>e===s?1:t)));for(let l=0,h=0;l<o.length;l++,h+=i){const i=[];for(let t=0;t<this._size[s];t++)i.push(this._value[t*r+h]);o._value[l]=e(i,t)}return o}argmax(t){let s=0===t?1:this.cols,e=0===t?this.cols:1;const i=[].concat(this._size);i[t]=1;const r=Matrix.zeros(...i);for(let i=0,o=0;i<r.length;i++,o+=s){let s=this._value[o],l=0;for(let i=1;i<this._size[t];i++){let t=this._value[i*e+o];t>s&&(s=t,l=i)}r._value[i]=l}return r}argmin(t){let s=0===t?1:this.cols,e=0===t?this.cols:1;const i=[].concat(this._size);i[t]=1;const r=Matrix.zeros(...i);for(let i=0,o=0;i<r.length;i++,o+=s){let s=this._value[o],l=0;for(let i=1;i<this._size[t];i++){let t=this._value[i*e+o];t<s&&(s=t,l=i)}r._value[i]=l}return r}sum(t=-1){if(t<0)return this._value.reduce(((t,s)=>t+s),0);let s=0===t?1:this.cols,e=0===t?this.cols:1;const i=[].concat(this._size);i[t]=1;const r=Matrix.zeros(...i);for(let i=0,o=0;i<r.length;i++,o+=s){let s=0;for(let i=0;i<this._size[t];i++)s+=this._value[i*e+o];r._value[i]=s}return r}mean(t=-1){if(t<0)return this.sum(t)/this.length;let s=this.sum(t);return s.div(this._size[t]),s}prod(t=-1){if(t<0)return this._value.reduce(((t,s)=>t*s),1);let s=0===t?1:this.cols,e=0===t?this.cols:1;const i=[].concat(this._size);i[t]=1;const r=Matrix.zeros(...i);for(let i=0,o=0;i<r.length;i++,o+=s){let s=1;for(let i=0;i<this._size[t];i++)s*=this._value[i*e+o];r._value[i]=s}return r}variance(t=-1){const s=this.mean(t);if(t<0)return this._value.reduce(((t,e)=>t+(e-s)**2),0)/this.length;let e=0===t?1:this.cols,i=0===t?this.cols:1;const r=[].concat(this._size);r[t]=1;const o=Matrix.zeros(...r);for(let r=0,l=0;r<o.length;r++,l+=e){let e=0;for(let o=0;o<this._size[t];o++)e+=(this._value[o*i+l]-s._value[r])**2;o._value[r]=e/this._size[t]}return o}std(t=-1){if(t<0)return Math.sqrt(this.variance(t));let s=this.variance(t);for(let t=0;t<s.length;t++)s._value[t]=Math.sqrt(s._value[t]);return s}diag(){let t=[];const s=Math.min(this.rows,this.cols);for(let e=0;e<s;e++)t.push(this._value[e*this.cols+e]);return t}trace(){let t=0;const s=Math.min(this.rows,this.cols);for(let e=0;e<s;e++)t+=this._value[e*this.cols+e];return t}norm(t=2){if(t===1/0){let t=-1/0;for(let s=0;s<this.length;s++)t=Math.max(t,Math.abs(this._value[s]));return t}let s=0;for(let e=0;e<this.length;e++)s+=Math.abs(this._value[e])**t;return 2===t?Math.sqrt(s):s**(1/t)}isSquare(){return this.rows===this.cols}isDiag(t=0){const s=this.cols;for(let e=0;e<this.rows;e++)for(let i=0;i<s;i++)if(e!==i&&Math.abs(this._value[e*s+i])>t)return!1;return!0}isIdentity(t=0){if(!this.isSquare())return!1;const s=this.cols;for(let e=0;e<this.rows;e++)for(let i=0;i<s;i++)if(e!==i){if(Math.abs(this._value[e*s+i])>t)return!1}else if(Math.abs(this._value[e*s+i]-1)>t)return!1;return!0}isTriangular(t=0){return this.isLowerTriangular(t)||this.isUpperTriangular(t)}isLowerTriangular(t=0){const s=this.cols;for(let e=0;e<this.rows;e++)for(let i=e+1;i<s;i++)if(Math.abs(this._value[e*s+i])>t)return!1;return!0}isUpperTriangular(t=0){for(let s=0;s<this.rows;s++)for(let e=0;e<Math.min(s,this.cols);e++)if(Math.abs(this._value[s*this.cols+e])>t)return!1;return!0}isSymmetric(t=0){if(!this.isSquare())return!1;const s=this.cols;for(let e=0;e<this.rows;e++)for(let i=0;i<e;i++)if(t>0){if(Math.abs(this._value[e*s+i]-this._value[i*s+e])>t)return!1}else if(this._value[e*s+i]!==this._value[i*s+e])return!1;return!0}isHermitian(t=0){return this.isSymmetric(t)}isAlternating(t=0){if(!this.isSquare())return!1;const s=this.cols;for(let e=0;e<this.rows;e++)for(let i=0;i<e;i++)if(t>0){if(Math.abs(this._value[e*s+i]+this._value[i*s+e])>t)return!1}else if(this._value[e*s+i]!==-this._value[i*s+e])return!1;return!0}isSkewHermitian(t=0){return this.isAlternating(t)}isRegular(t=0){return!!this.isSquare()&&Math.abs(this.det())<=t}isNormal(t=0){return this.dot(this.t).equals(this.tDot(this),t)}isOrthogonal(t=0){const s=this.tDot(this);for(let e=0;e<this.rows;e++)for(let i=0;i<this.cols;i++){const r=s._value[e*this.cols+i];if(e===i){if(Math.abs(r-1)>t)return!1}else if(Math.abs(r)>t)return!1}return!0}isUnitary(t=0){return this.isOrthogonal(t)}negative(){this.map((t=>-t))}abs(){this.map(Math.abs)}add(t){if(t instanceof Matrix)if(this.rows===t.rows&&this.cols===t.cols)for(let s=this.length-1;s>=0;s--)this._value[s]=this._value[s]+t._value[s];else if(this.rows>=t.rows&&this.cols>=t.cols){if(this.rows%t.rows!=0||this.cols%t.cols!=0)throw new MatrixException("Addition size invalid.",[this,t]);for(let s=0,e=0,i=0;s<this.length;s++,i++)i>=this.cols&&(e+=t.cols,i=0),e>=t.length&&(e=0),this._value[s]=this._value[s]+t._value[e+i%t.cols]}else{if(!(this.rows<=t.rows&&this.cols<=t.cols))throw new MatrixException("Addition size invalid.",[this,t]);if(t.rows%this.rows!=0||t.cols%this.cols!=0)throw new MatrixException("Addition size invalid.",[this,t]);this.repeat([t.rows/this.rows,t.cols/this.cols]);for(let s=this.length-1;s>=0;s--)this._value[s]=this._value[s]+t._value[s]}else this.map((s=>s+t))}addAt(t,s,e){if(t<0||this.rows<=t||s<0||this.cols<=s)throw new MatrixException("Index out of bounds.");const i=this._value[t*this.cols+s];return this._value[t*this.cols+s]=i+e,i}copyAdd(t){let s=this.copy();return s.add(t),s}sub(t){if(t instanceof Matrix)if(this.rows===t.rows&&this.cols===t.cols)for(let s=this.length-1;s>=0;s--)this._value[s]=this._value[s]-t._value[s];else if(this.rows>=t.rows&&this.cols>=t.cols){if(this.rows%t.rows!=0||this.cols%t.cols!=0)throw new MatrixException("Subtract size invalid.",[this,t]);for(let s=0,e=0,i=0;s<this.length;s++,i++)i>=this.cols&&(e+=t.cols,i=0),e>=t.length&&(e=0),this._value[s]=this._value[s]-t._value[e+i%t.cols]}else{if(!(this.rows<=t.rows&&this.cols<=t.cols))throw new MatrixException("Subtract size invalid.",[this,t]);if(t.rows%this.rows!=0||t.cols%this.cols!=0)throw new MatrixException("Subtract size invalid.",[this,t]);this.repeat([t.rows/this.rows,t.cols/this.cols]);for(let s=this.length-1;s>=0;s--)this._value[s]=this._value[s]-t._value[s]}else this.map((s=>s-t))}isub(t){this.negative(),this.add(t)}subAt(t,s,e){if(t<0||this.rows<=t||s<0||this.cols<=s)throw new MatrixException("Index out of bounds.");const i=this._value[t*this.cols+s];return this._value[t*this.cols+s]=i-e,i}isubAt(t,s,e){if(t<0||this.rows<=t||s<0||this.cols<=s)throw new MatrixException("Index out of bounds.");const i=this._value[t*this.cols+s];return this._value[t*this.cols+s]=e-i,i}copySub(t){let s=this.copy();return s.sub(t),s}copyIsub(t){let s=this.copy();return s.isub(t),s}mult(t){if(t instanceof Matrix)if(this.rows===t.rows&&this.cols===t.cols)for(let s=this.length-1;s>=0;s--)this._value[s]=this._value[s]*t._value[s];else if(this.rows>=t.rows&&this.cols>=t.cols){if(this.rows%t.rows!=0||this.cols%t.cols!=0)throw new MatrixException("Multiple size invalid.",[this,t]);for(let s=0,e=0,i=0;s<this.length;s++,i++)i>=this.cols&&(e+=t.cols,i=0),e>=t.length&&(e=0),this._value[s]=this._value[s]*t._value[e+i%t.cols]}else{if(!(this.rows<=t.rows&&this.cols<=t.cols))throw new MatrixException("Multiple size invalid.",[this,t]);if(t.rows%this.rows!=0||t.cols%this.cols!=0)throw new MatrixException("Multiple size invalid.",[this,t]);this.repeat([t.rows/this.rows,t.cols/this.cols]);for(let s=this.length-1;s>=0;s--)this._value[s]=this._value[s]*t._value[s]}else this.map((s=>s*t))}multAt(t,s,e){if(t<0||this.rows<=t||s<0||this.cols<=s)throw new MatrixException("Index out of bounds.");const i=this._value[t*this.cols+s];return this._value[t*this.cols+s]=i*e,i}copyMult(t){let s=this.copy();return s.mult(t),s}div(t){if(t instanceof Matrix)if(this.rows===t.rows&&this.cols===t.cols)for(let s=this.length-1;s>=0;s--)this._value[s]=this._value[s]/t._value[s];else if(this.rows>=t.rows&&this.cols>=t.cols){if(this.rows%t.rows!=0||this.cols%t.cols!=0)throw new MatrixException("Divide size invalid.",[this,t]);for(let s=0,e=0,i=0;s<this.length;s++,i++)i>=this.cols&&(e+=t.cols,i=0),e>=t.length&&(e=0),this._value[s]=this._value[s]/t._value[e+i%t.cols]}else{if(!(this.rows<=t.rows&&this.cols<=t.cols))throw new MatrixException("Divide size invalid.",[this,t]);if(t.rows%this.rows!=0||t.cols%this.cols!=0)throw new MatrixException("Divide size invalid.",[this,t]);this.repeat([t.rows/this.rows,t.cols/this.cols]);for(let s=this.length-1;s>=0;s--)this._value[s]=this._value[s]/t._value[s]}else this.map((s=>s/t))}idiv(t){if(t instanceof Matrix)if(this.rows===t.rows&&this.cols===t.cols)for(let s=this.length-1;s>=0;s--)this._value[s]=t._value[s]/this._value[s];else if(this.rows>=t.rows&&this.cols>=t.cols){if(this.rows%t.rows!=0||this.cols%t.cols!=0)throw new MatrixException("Divide size invalid.",[this,t]);for(let s=0,e=0,i=0;s<this.length;s++,i++)i>=this.cols&&(e+=t.cols,i=0),e>=t.length&&(e=0),this._value[s]=t._value[e+i%t.cols]/this._value[s]}else{if(!(this.rows<=t.rows&&this.cols<=t.cols))throw new MatrixException("Divide size invalid.",[this,t]);if(t.rows%this.rows!=0||t.cols%this.cols!=0)throw new MatrixException("Divide size invalid.",[this,t]);this.repeat([t.rows/this.rows,t.cols/this.cols]);for(let s=this.length-1;s>=0;s--)this._value[s]=t._value[s]/this._value[s]}else this.map((s=>t/s))}divAt(t,s,e){if(t<0||this.rows<=t||s<0||this.cols<=s)throw new MatrixException("Index out of bounds.");const i=this._value[t*this.cols+s];return this._value[t*this.cols+s]=i/e,i}idivAt(t,s,e){if(t<0||this.rows<=t||s<0||this.cols<=s)throw new MatrixException("Index out of bounds.");const i=this._value[t*this.cols+s];return this._value[t*this.cols+s]=e/i,i}copyDiv(t){let s=this.copy();return s.div(t),s}copyIdiv(t){let s=this.copy();return s.idiv(t),s}dot(t){if(this.cols!==t.rows)throw new MatrixException("Dot size invalid. left = ["+this.rows+", "+this.cols+"], right = ["+t.rows+", "+t.cols+"]");const s=t.cols,e=new Matrix(this.rows,s);let i=0;const r=this.length,o=t.length,l=this.cols,h=this._value,n=t._value,a=e._value;for(let t=0;t<r;t+=l){let e=0,r=0;for(let i=0,l=t;i<o;i+=s,l++)h[l]&&r++,e+=h[l]*n[i];if(a[i++]=e,0!==r)if(r/l<.1){let r=[],o=[];for(let s=0;s<l;s++)h[t+s]&&(r.push(h[t+s]),o.push(s));for(let t=1;t<s;t++){e=0;for(let i=0;i<r.length;i++)e+=r[i]*n[o[i]*s+t];a[i++]=e}}else for(let r=1;r<s;r++){e=0;for(let i=r,l=t;i<o;i+=s,l++)e+=h[l]*n[i];a[i++]=e}else i+=s-1}return e}tDot(t){if(this.rows!==t.rows)throw new MatrixException("tDot size invalid. left = ["+this.cols+", "+this.rows+"], right = ["+t.rows+", "+t.cols+"]");const s=new Matrix(this.cols,t.cols);let e=0;for(let i=0;i<this.cols;i++)for(let r=0;r<t.cols;r++){let o=0,l=i;for(let s=r;s<t.length;s+=t.cols,l+=this.cols)o+=this._value[l]*t._value[s];s._value[e++]=o}return s}kron(t){const s=new Matrix(this.rows*t.rows,this.cols*t.cols);for(let e=0;e<this.rows;e++)for(let i=0;i<this.cols;i++)for(let r=0;r<t.rows;r++)for(let o=0;o<t.cols;o++)s._value[(e*t.rows+r)*this.cols*t.cols+i*t.cols+o]=this._value[e*this.cols+i]*t._value[r*t.cols+o];return s}convolute(t,s=!0){Array.isArray(t[0])||(t=[t]);const e=[Math.floor((t.length-1)/2),Math.floor((t[0].length-1)/2)],i=this._value.concat();for(let r=0;r<this.rows;r++)for(let o=0;o<this.cols;o++){let l=0,h=0;for(let s=0;s<t.length;s++){const n=r+s-e[0];if(!(n<0||this.rows<=n))for(let r=0;r<t[s].length;r++){const a=o+r-e[1];a<0||this.cols<=a||(l+=t[s][r]*i[n*this.cols+a],h+=t[s][r])}}s&&(l/=h),this._value[r*this.cols+o]=l}}reducedRowEchelonForm(t=0){for(let s=0,e=0;s<this.rows&&e<this.cols;e++,s++){if(Math.abs(this._value[s*this.cols+e])<=t)for(let i=s+1;i<this.rows;i++)if(Math.abs(this._value[i*this.cols+e])>t){this.swap(s,i,0);break}if(Math.abs(this._value[s*this.cols+e])<=t){s--;continue}const i=this._value[s*this.cols+e];this._value[s*this.cols+e]=1;for(let t=e+1;t<this.cols;t++)this._value[s*this.cols+t]/=i;for(let t=0;t<this.rows;t++){if(t===s)continue;const i=this._value[t*this.cols+e];this._value[t*this.cols+e]=0;for(let r=e+1;r<this.cols;r++)this._value[t*this.cols+r]-=i*this._value[s*this.cols+r]}}}rank(t=0){const s=this.copy();let e=0;for(let i=0;e<s.rows&&i<s.cols;i++,e++){if(Math.abs(s._value[e*s.cols+i])<=t)for(let r=e+1;r<s.rows;r++)if(Math.abs(s._value[r*s.cols+i])>t){s.swap(e,r,0);break}if(Math.abs(s._value[e*s.cols+i])<=t){e--;continue}const r=s._value[e*s.cols+i];for(let t=e+1;t<s.rows;t++){const o=s._value[t*s.cols+i];for(let l=i+1;l<s.cols;l++)s._value[t*s.cols+l]-=o*s._value[e*s.cols+l]/r}}return e}det(){if(!this.isSquare())throw new MatrixException("Determine only define square matrix.",this);const t=this._value;switch(this.rows){case 0:return 0;case 1:return t[0];case 2:return t[0]*t[3]-t[1]*t[2];case 3:return t[0]*t[4]*t[8]+t[1]*t[5]*t[6]+t[2]*t[3]*t[7]-t[0]*t[5]*t[7]-t[1]*t[3]*t[8]-t[2]*t[4]*t[6]}const[s,e]=this.lu();let i=1;for(let t=0;t<this.rows;t++){const r=t*this.cols+t;i*=s._value[r]*e._value[r]}return i}inv(){if(!this.isSquare())throw new MatrixException("Inverse matrix only define square matrix.",this);const t=this._value;switch(this.rows){case 0:return new Matrix(0,0);case 1:return new Matrix(1,1,[1/t[0]]);case 2:const s=this.det();return new Matrix(2,2,[t[3]/s,-t[1]/s,-t[2]/s,t[0]/s]);case 3:const e=this.det();return new Matrix(3,3,[(t[4]*t[8]-t[5]*t[7])/e,(t[2]*t[7]-t[1]*t[8])/e,(t[1]*t[5]-t[2]*t[4])/e,(t[5]*t[6]-t[3]*t[8])/e,(t[0]*t[8]-t[2]*t[6])/e,(t[2]*t[3]-t[0]*t[5])/e,(t[3]*t[7]-t[4]*t[6])/e,(t[1]*t[6]-t[0]*t[7])/e,(t[0]*t[4]-t[1]*t[3])/e])}return this.isLowerTriangular()?this.invLowerTriangular():this.isUpperTriangular()?this.invUpperTriangular():this.invLU()}invLowerTriangular(){if(!this.isSquare())throw new MatrixException("Inverse matrix only define square matrix.",this);const t=this._value,s=new Matrix(this.rows,this.cols);for(let e=0;e<this.rows;e++){const i=t[e*this.cols+e];s._value[e*this.cols+e]=1/i;for(let r=0;r<e;r++){let o=0;for(let i=r;i<e;i++)o+=t[e*this.cols+i]*s._value[i*this.cols+r];s._value[e*this.cols+r]=-o/i}}return s}invUpperTriangular(){if(!this.isSquare())throw new MatrixException("Inverse matrix only define square matrix.",this);const t=this._value,s=new Matrix(this.rows,this.cols);for(let e=this.cols-1;e>=0;e--){const i=t[e*this.cols+e];s._value[e*this.cols+e]=1/i;for(let r=e+1;r<this.cols;r++){let o=0;for(let i=e+1;i<=r;i++)o+=t[e*this.cols+i]*s._value[i*this.cols+r];s._value[e*this.cols+r]=-o/i}}return s}invRowReduction(){if(!this.isSquare())throw new MatrixException("Inverse matrix only define square matrix.",this);const t=this.copy(),s=this.rows,e=Matrix.eye(s,s);for(let i=0;i<s;i++){const r=i*s;if(0===t._value[r+i]){let o=i+1;for(;o<s&&0===t._value[o*s+i];o++);if(o===s)throw new MatrixException("",this);for(let e=i;e<s;e++)[t._value[r+e],t._value[o*s+e]]=[t._value[o*s+e],t._value[r+e]];e.swap(i,o)}const o=t._value[r+i];t._value[r+i]=1;for(let e=i+1;e<s;e++)t._value[r+e]/=o;for(let t=0;t<s;t++)e._value[r+t]=e._value[r+t]/o;for(let o=0;o<s;o++){if(i===o)continue;const l=t._value[o*s+i];t._value[o*s+i]=0;for(let e=i+1;e<s;e++)t._value[o*s+e]-=l*t._value[r+e];for(let t=0;t<s;t++)e._value[o*s+t]=e._value[o*s+t]-l*e._value[r+t]}}return e}invLU(){if(!this.isSquare())throw new MatrixException("Inverse matrix only define square matrix.",this);const[t,s]=this.lu();return s.invUpperTriangular().dot(t.invLowerTriangular())}sqrt(){if(!this.isSquare())throw new MatrixException("sqrt only define square matrix.",this);switch(this.rows){case 0:return this;case 1:return new Matrix(1,1,[Math.sqrt(this._value[0])])}const[t,s]=this.eigen(),e=new Matrix(this.rows,this.cols);for(let s=0;s<this.rows;s++)e._value[s*this.cols+s]=Math.sqrt(t[s]);return s.dot(e).dot(s.transpose())}power(t){if(!this.isSquare())throw new MatrixException("Only square matrix can power.",this);const s=this.rows;if(this.isDiag(1e-12))return Matrix.diag(this.diag().map((s=>Math.pow(s,t))));if(Number.isInteger(t)){if(0===t)return Matrix.eye(s,s);if(1===t)return this.copy();if(2===t)return this.dot(this);if(-1===t)return this.inv();if(t<0)return this.inv().power(-t);if(!this.isSymmetric(1e-12)){let s=this.dot(this);for(let e=2;e<t;e++)s=s.dot(this);return s}const[e,i]=this.eigen(),r=Matrix.diag(e.map((s=>Math.pow(s,t))));return i.dot(r).dot(i.t)}if(t<0)return this.inv().power(-t);if(.5===t)return this.sqrt();throw new MatrixException("Power only defined integer.")}solve(t){if(this.rows>this.cols)throw new MatrixException("Only square matrix or matrix with more columns than rows can be solved.",this);const s=this.rows;if(s!==t.rows)throw new MatrixException("b size is invalid.",[this,t]);let e,i=this;switch(s<this.cols&&(i=this.resize(this.rows,this.rows)),s){case 0:e=i;break;case 1:e=t.copyMap((t=>t/i._value[0]));break;default:const[s,r]=i.lu(),o=s.solveLowerTriangular(t);e=r.solveUpperTriangular(o)}return s<this.cols&&(e=e.resize(this.cols,e.cols)),e}solveLowerTriangular(t){if(!this.isSquare())throw new MatrixException("Only square matrix can solve.",this);const s=this.rows,e=t.cols;if(s!==t.rows)throw new MatrixException("b size is invalid.",[this,t]);const i=new Matrix(s,e);for(let r=0;r<e;r++)for(let o=0;o<s;o++){let l=t._value[o*e+r];for(let t=0;t<o;t++)l-=i._value[t*e+r]*this._value[o*s+t];i._value[o*e+r]=l/this._value[o*s+o]}return i}solveUpperTriangular(t){if(!this.isSquare())throw new MatrixException("Only square matrix can solve.",this);const s=this.rows,e=t.cols;if(s!==t.rows)throw new MatrixException("b size is invalid.",[this,t]);const i=new Matrix(s,e);for(let r=0;r<e;r++)for(let o=s-1;o>=0;o--){let l=t._value[o*e+r];for(let t=s-1;t>o;t--)l-=i._value[t*e+r]*this._value[o*s+t];i._value[o*e+r]=l/this._value[o*s+o]}return i}cov(t=0){const s=new Matrix(this.cols,this.cols),e=[];for(let i=0;i<this.cols;i++){let r=0;for(let t=i;t<this.length;t+=this.cols)r+=this._value[t];e[i]=r/this.rows;for(let r=0;r<=i;r++){let o=0;for(let t=0;t<this.length;t+=this.cols)o+=(this._value[i+t]-e[i])*(this._value[r+t]-e[r]);s._value[i*this.cols+r]=s._value[r*this.cols+i]=o/(this.rows-t)}}return s}gram(){return this.tDot(this)}bidiag(){let t=this.copy();const[s,e]=[this.rows,this.cols];for(let i=0;i<Math.min(s,e);i++){let r=t.block(i,i),o=r.col(0),l=o.norm()*(o._value[0]<0?1:-1);o._value[0]-=l,o.div(o.norm());let h=o.dot(o.t);h.mult(2);let n=Matrix.eye(s-i,s-i);n.sub(h),r=n.tDot(r),o=r.row(0),o._value[0]=0,o.norm()>0&&(l=o.norm()*(o._value[1]<0?1:-1),o._value[1]-=l,o.div(o.norm())),h=o.tDot(o),h.mult(2),n=Matrix.eye(e-i,e-i),n.sub(h),r=r.dot(n),t.set(i,i,r)}return t}tridiag(){return this.tridiagHouseholder()}tridiagHouseholder(){if(!this.isSymmetric())throw new MatrixException("Tridiagonal only define symmetric matrix.",this);const t=this.copy(),s=this.cols;for(let e=0;e<s-2;e++){const i=t.block(e+1,e,s,e+1),r=i.norm()*(i._value[0]<0?1:-1);i._value[0]-=r,i.div(i.norm());const o=t.block(e+1,e+1),l=o.dot(i),h=i.copyMult(i.tDot(l));h.isub(l),h.mult(2),o.sub(h.dot(i.t)),o.sub(i.dot(h.t)),t.set(e+1,e+1,o),t._value[e*s+e+1]=t._value[(e+1)*s+e]=r;for(let i=e+2;i<s;i++)t._value[e*s+i]=t._value[i*s+e]=0}return t}tridiagLanczos(t=0){if(!this.isSymmetric())throw new MatrixException("Tridiagonal only define symmetric matrix.",this);const s=this.cols;t<=0&&(t=s);let e=0,i=Matrix.zeros(s,1),r=Matrix.randn(s,1);r.div(r.norm());const o=Matrix.zeros(t,t);for(let s=0;s<t;s++){const l=this.dot(r),h=r.tDot(l).value[0];l.sub(i.copyMult(e)),l.sub(r.copyMult(h)),e=l.norm(),i=r,l.div(e),r=l,o.set(s,s,h),s<t-1&&(o.set(s,s+1,e),o.set(s+1,s,e))}return o}hessenberg(){return this.hessenbergArnoldi()}hessenbergArnoldi(t=0){if(!this.isSquare())throw new MatrixException("Hessenberg only define square matrix.",this);const s=this.cols;t<=0&&(t=s);const e=Matrix.zeros(t,t);let i=[Matrix.randn(s,1)];i[0].div(i[0].norm());for(let s=0;s<t;s++){const r=this.dot(i[s]);for(let t=0;t<=s;t++){const o=i[t].tDot(r).value[0];r.sub(i[t].copyMult(o)),e.set(t,s,o)}const o=r.norm();r.div(o),i[s+1]=r,s<t-1&&e.set(s+1,s,o)}return e}lu(){if(!this.isSquare())throw new MatrixException("LU decomposition only define square matrix.",this);const t=this.rows;switch(t){case 0:return[this,this];case 1:return[Matrix.ones(1,1),new Matrix(1,1,[this._value[0]])];case 2:return[new Matrix(2,2,[1,0,this._value[2]/this._value[0],1]),new Matrix(2,2,[this._value[0],this._value[1],0,this._value[3]-this._value[1]*this._value[2]/this._value[0]])]}let s=this.copy();for(let e=0;e<t;e++){const i=s._value[e*t+e];for(let r=e+1;r<t;r++){const o=s._value[r*t+e]/=i;for(let i=e+1;i<t;i++)s._value[r*t+i]-=o*s._value[e*t+i]}}let e=Matrix.eye(t,t);for(let i=0;i<t;i++)for(let r=0;r<i;r++)e._value[i*t+r]=s._value[i*t+r],s._value[i*t+r]=0;return[e,s]}qr(){const t=this.rows,s=this.cols;if(0===t||0===s)return[this,this];if(1===t)return[Matrix.ones(1,1),this];if(1===s){const t=Math.sqrt(this.tDot(this).value[0]);return[this.copyDiv(t),new Matrix(1,1,t)]}return this.qrHouseholder()}qrGramSchmidt(){const t=this.cols,s=this.copy(),e=Matrix.eye(t,t),i=[];for(let r=0;r<t;r++){for(let o=0;o<r;o++){let l=0;for(let e=0;e<this.rows;e++)l+=this._value[e*t+r]*s._value[e*t+o];const h=e._value[o*t+r]=l/i[o]**2;for(let e=0;e<this.rows;e++)s._value[e*t+r]-=s._value[e*t+o]*h}i.push(s.col(r).norm())}return s.mult(new Matrix(1,t,i.map((t=>1/t)))),e.mult(new Matrix(t,1,i)),[s,e]}qrHouseholder(){const t=this.rows,s=this.cols,e=this.copy(),i=Matrix.eye(t,t);for(let r=0;r<Math.min(t,s)-1;r++){const s=t-r,o=e.block(r,r,t,r+1),l=o.norm()*Math.sign(o._value[0]);o._value[0]-=l,o.div(o.norm()+1e-12);let h=new Matrix(s,s);for(let t=0;t<s;t++){const e=o._value[t];if(h._value[t*s+t]=1-2*e**2,e)for(let i=0;i<t;i++)h._value[t*s+i]=h._value[i*s+t]=-2*e*o._value[i]}e.set(r,r,h.dot(e.block(r,r))),i.set(r,0,h.dot(i.block(r,0)))}return[i.t,e]}singularValues(){const t=this.dot(this.adjoint()).eigenJacobi()[0];for(let s=0;s<t.length;s++)-1e-12<t[s]&&t[s]<0&&(t[s]=0),t[s]=Math.sqrt(t[s]);return t}svd(){return this.svdEigen()}svdEigen(){const t=Math.min(this.cols,this.rows);if(this.cols<=this.rows){const s=this.tDot(this),[e,i]=s.eigenJacobi();for(let s=0;s<t;s++)e[s]=Math.sqrt(e[s]);const r=this.dot(i);for(let s=0;s<this.rows;s++)for(let i=0;i<t;i++)r._value[s*t+i]/=e[i];return[r,e,i]}{const s=this.dot(this.t),[e,i]=s.eigenJacobi();for(let s=0;s<t;s++)e[s]=Math.sqrt(e[s]);const r=i.tDot(this);for(let s=0;s<t;s++)for(let t=0;t<this.cols;t++)r._value[s*this.cols+t]/=e[s];return[i,e,r.t]}}svdGolubKahan(){}cholesky(){return this.choleskyBanachiewicz()}choleskyBanachiewicz(){if(!this.isSymmetric(1e-15))throw new MatrixException("Cholesky decomposition only define symmetric matrix.",this);const t=this.rows,s=new Matrix(t,t);for(let e=0;e<t;e++){let i=0;for(let r=0;r<e;r++){let o=0;for(let i=0;i<r;i++)o+=s._value[e*t+i]*s._value[r*t+i];s._value[e*t+r]=(this._value[e*t+r]-o)/s._value[r*t+r],i+=s._value[e*t+r]**2}s._value[e*t+e]=Math.sqrt(this._value[e*t+e]-i)}return s}choleskyLDL(){if(!this.isSymmetric(1e-15))throw new MatrixException("Cholesky decomposition only define symmetric matrix.",this);const t=this.rows,s=[],e=Matrix.eye(t,t);for(let i=0;i<t;i++){s[i]=this._value[i*t+i];for(let r=0;r<i;r++){let o=0;for(let l=0;l<r;l++)o+=e._value[i*t+l]*e._value[r*t+l]*s[l];e._value[i*t+r]=(this._value[i*t+r]-o)/s[r],s[i]-=e._value[i*t+r]**2*s[r]}}return[e,s]}schur(){throw new MatrixException("Not implemented.")}eigen(){if(!this.isSquare())throw new MatrixException("Eigen values only define square matrix.",this);if(this.rows<=2)return[this.eigenValues(),this.eigenVectors()];if(this.isSymmetric(1e-15))return this.eigenJacobi();{const t=this.eigenValues(),s=this.rows;let e=new Matrix(s,s);for(let i=0;i<s;i++){const[r,o]=this.eigenInverseIteration(t[i]);for(let t=0;t<s;t++)e._value[t*s+i]=o._value[t]}return[t,e]}}eigenValues(){if(!this.isSquare())throw new MatrixException("Eigen values only define square matrix.",this);switch(this.rows){case 0:return[];case 1:return[this._value[0]];case 2:let t=this._value[0]+this._value[3],s=Math.sqrt(t**2-4*this.det());return[(t+s)/2,(t-s)/2];case 3:{const t=-this.det(),s=this._value[0]*this._value[4]+this._value[0]*this._value[8]+this._value[4]*this._value[8]-this._value[5]*this._value[7]-this._value[2]*this._value[6]-this._value[1]*this._value[3],e=-this._value[0]-this._value[4]-this._value[8],i=t-s*e/3+e**3*2/27,r=(i/2)**2+((s-e**2/3)/3)**3;let[o,l]=new Complex(r).sqrt();o=o.add(-i/2),l=l.add(-i/2);const[h,n,a]=o.cbrt(),[u,c,f]=l.cbrt(),_=[h.add(u),n.add(f),a.add(c)].map((t=>Math.abs(t.imaginary)<1e-12?t.real-e/3:Number.NaN));return _.sort(((t,s)=>s-t)),_}}return this.isSymmetric(1e-15)?this.eigenJacobi()[0]:this.eigenValuesQR()}eigenVectors(){if(!this.isSquare())throw new MatrixException("Eigen vectors only define square matrix.",this);switch(this.rows){case 0:return this;case 1:return new Matrix(1,1,[1]);case 2:const t=this.eigenValues(),s=[-this._value[1],this._value[0]-t[0]],e=Math.sqrt(s[0]**2+s[1]**2),i=[-this._value[1],this._value[0]-t[1]],r=Math.sqrt(i[0]**2+i[1]**2);return new Matrix(2,2,[s[0]/e,i[0]/r,s[1]/e,i[1]/r])}return this.eigen()[1]}eigenValuesLR(){if(!this.isSquare())throw new MatrixException("Eigen values only define square matrix.",this);let t=this;const s=t.rows;let e=1e5;for(;e-- >0;){const[e,i]=t.lu();t=i.dot(e);let r=0;for(let e=0;e<s;e++)for(let i=0;i<e;i++)r+=t._value[e*s+i]**2;if(r<1e-15){const s=t.diag();return s.sort(((t,s)=>s-t)),s}}throw new MatrixException("eigenVectors not converged.",this)}eigenValuesQR(){if(!this.isSquare())throw new MatrixException("Eigen values only define square matrix.",this);let t=this.copy();const s=[];this.rows>2&&(t=this.isSymmetric()?t.tridiag():t.hessenberg());for(let e=t.rows;e>2;e--){let i=1e6;for(;;){let r=t.block(e-2,e-2).eigenValues();if(isNaN(r[0])){s.sort(((t,s)=>s-t));for(let t=0;t<e;t++,s.push(NaN));return s}const o=t._value[t._value.length-1],l=Math.abs(r[0]-o)<Math.abs(r[1]-o)?r[0]:r[1];for(let s=0;s<e;s++)t._value[s*e+s]-=l;const[h,n]=t.qr();t=n.dot(h);for(let s=0;s<e;s++)t._value[s*e+s]=t._value[s*e+s]+l;let a=0;for(let s=(e-1)*e;s<t.length-1;s++)a+=Math.abs(t._value[s]);if(a<1e-8)break;if(i--<0)throw new MatrixException("eigenValues not converged.",this)}s.push(t._value[t._value.length-1]),t=t.resize(e-1,e-1)}const e=t.eigenValues();return s.push(...e),s.sort(((t,s)=>s-t)),s}eigenJacobi(t=1e6){if(!this.isSymmetric(1e-15))throw new MatrixException("Jacobi method can only use symmetric matrix.",this);const s=this._value.concat(),e=Matrix.eye(this.rows,this.cols);e.add(0);let i=0;const r=this.rows;let o=t;for(;;){let t=0,l=0,h=0;for(let e=0;e<r;e++)for(let i=e+1;i<r;i++){const o=Math.abs(s[e*r+i]);o>t&&(t=o,l=e,h=i)}if(t<1e-15)break;if(t===i)break;if(o--<0){console.log(new MatrixException("eigenJacobi not converged.",[this,t]));break}i=t;const n=s[l*r+l],a=s[l*r+h],u=s[h*r+h],c=(n-u)/2,f=-a,_=Math.abs(c)/Math.sqrt(c**2+f**2);let v=Math.sqrt((1-_)/2);const w=Math.sqrt((1+_)/2);c*f<0&&(v=-v);for(let t=0;t<r;t++){const e=s[l*r+t],i=s[h*r+t];s[t*r+h]=s[h*r+t]=v*e+w*i,s[t*r+l]=s[l*r+t]=w*e-v*i}s[l*r+l]=w**2*n+v**2*u-2*v*w*a,s[l*r+h]=s[h*r+l]=v*w*(n-u)+(w**2-v**2)*a,s[h*r+h]=v**2*n+w**2*u+2*v*w*a;for(let t=0;t<r;t++){const s=e._value[t*r+l],i=e._value[t*r+h];e._value[t*r+h]=v*s+w*i,e._value[t*r+l]=w*s-v*i}}const l=[];for(let t=0;t<r;t++)l.push([t,s[t*r+t]]);l.sort(((t,s)=>s[1]-t[1]));const h=e.col(l.map((t=>t[0])));return[l.map((t=>t[1])),h]}eigenPowerIteration(){if(!this.isSquare())throw new MatrixException("Eigen vectors only define square matrix.",this);const t=this.rows;let s=Matrix.randn(t,1);s.div(s.norm());let e=1/0,i=1e4;for(;i-- >0;){const i=this.dot(s);let r=0,o=0;for(let e=0;e<t;e++)r+=i._value[e]**2,o+=i._value[e]*s._value[e];const l=r/o;i.div(i.norm());const h=Math.abs(l-e);if(h<1e-15||isNaN(h))return[l,i];s=i,e=l}throw new MatrixException("eigenPowerIteration not converged.",this)}eigenInverseIteration(t=0){if(!this.isSquare())throw new MatrixException("Eigen vectors only define square matrix.",this);const s=this.rows;let e=this.copy();for(let i=0;i<s;i++)e._value[i*s+i]=e._value[i*s+i]-t+1e-15;e=e.inv();let i=Matrix.randn(s,1);i.div(i.norm());let r=1/0,o=1e4;for(;o-- >0;){const o=e.dot(i);let l=0,h=0;for(let t=0;t<s;t++)l+=o._value[t]**2,h+=i._value[t]*o._value[t];const n=h/l;o.div(o.norm());const a=Math.abs(n-r);if(a<1e-15||isNaN(a))return[n+t,o];i=o,r=n}throw new MatrixException("eigenInverseIteration not converged.",this)}}