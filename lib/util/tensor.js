import Matrix,{MatrixException}from"./matrix.js";const normal_random=function(t=0,e=1){const i=Math.sqrt(e),s=Math.random(),n=Math.random();return[Math.sqrt(-2*Math.log(s))*Math.cos(2*Math.PI*n)*i+t,Math.sqrt(-2*Math.log(s))*Math.sin(2*Math.PI*n)*i+t]};export default class Tensor{constructor(t,e){this._size=t.concat(),this._length=t.reduce(((t,e)=>t*e),1),e?Array.isArray(e)?this._value=e.flat(t.length):this._value=Array(this._length).fill(e):this._value=Array(this._length).fill(0),this._offset=0}static zeros(t){return new Tensor(t)}static ones(t){return new Tensor(t,1)}static random(t,e=0,i=1){const s=new Tensor(t);for(let t=0;t<s.length;t++)s._value[t]=Math.random()*(i-e)+e;return s}static randn(t,e=0,i=1){const s=new Tensor(t);for(let t=0;t<s.length;t+=2){const n=normal_random(e,i);s._value[t]=n[0],t+1<s.length&&(s._value[t+1]=n[1])}return s}static fromArray(t){if(t instanceof Tensor)return t;if(t instanceof Matrix)return new Tensor(t.sizes,t._value);if(!Array.isArray(t))return new Tensor([1],t);if(0===t.length)return new Tensor([0]);const e=[];let i=t;for(;Array.isArray(i);)e.push(i.length),i=i[0];return new Tensor(e,t)}get dimension(){return this._size.length}get sizes(){return this._size}get length(){return this._length}get value(){return this._value}*[Symbol.iterator](){yield*this._value}toArray(){const t=[];let e=[t],i=0;for(let t=0;t<this._size.length;t++){const s=[];for(const n of e)if(t===this._size.length-1)n.push(...this._value.slice(i,i+this._size[t])),i+=this._size[t];else for(let e=0;e<this._size[t];e++)s.push(n[e]=[]);e=s}return t}toString(){let t=this.dimension,e="";for(let i=0;i<this.length;){for(let i=0;i<t;i++)e+="[";e+=this._value[i],t=0;let s=++i;for(let e=this.dimension-1;e>=0&&s%this._size[e]==0;e--)t++,s/=this._size[e];for(let i=0;i<t;i++)e+="]";i!==this.length&&(e+=", ")}return e}toMatrix(){if(2!==this.dimension)throw new MatrixException("Only 2D tensor can convert to matrix.");return new Matrix(...this._size,this._value)}_to_position(...t){let e=0;for(let i=0;i<this.dimension;i++){if(t[i]<0||this._size[i]<=t[i])throw new MatrixException("Index out of bounds.");e=e*this._size[i]+t[i]}return e+this._offset}_to_index(t){const e=Array(this.dimension);for(let i=this.dimension-1;i>=0;i--)e[i]=t%this._size[i],t=Math.floor(t/this._size[i]);return e}copy(){return new Tensor(this._size,this.value.slice(this._offset,this._offset+this._length))}equals(t){if(t instanceof Tensor){if(this.dimension!==t.dimension)return!1;if(this._size.some(((e,i)=>e!==t._size[i])))return!1;for(let e=this.length-1;e>=0;e--)if(this._value[e]!==t._value[e])return!1;return!0}return!1}at(...t){if(Array.isArray(t[0])&&(t=t[0]),t.length===this.dimension)return this._value[this._to_position(...t)];let e=0;for(let i=0;i<t.length;i++){if(t[i]<0||this._size[i]<=t[i])throw new MatrixException("Index out of bounds.");e=e*this._size[i]+t[i]}let i=e+1;for(let s=t.length;s<this.dimension;s++)e*=this._size[s],i*=this._size[s];const s=new Tensor(this._size.slice(t.length));return s._value=this._value,s._offset=e,s}slice(t,e,i=0){if(0!==i)throw new MatrixException("Invalid axis. Only 0 is accepted.");let s=1;for(let t=1;t<this.dimension;t++)s*=this._size[t];const n=new Tensor([e-t,...this._size.slice(1)]);return n._value=this._value.slice(t*s,e*s),n}set(t,e){Array.isArray(t)||(t=[t]),this._value[this._to_position(...t)]=e}select(t,e=0){if(0!==e)throw new MatrixException("Invalid axis. Only 0 is accepted.");Array.isArray(t)||(t=[t]);let i=1;for(let t=1;t<this.dimension;t++)i*=this._size[t];const s=new Tensor([t.length,...this._size.slice(1)]);for(let e=0;e<t.length;e++)for(let n=0;n<i;n++)s._value[e*i+n]=this._value[t[e]*i+n];return s}fill(t){this._value=Array(this.length).fill(t)}map(t){for(let e=this.length-1;e>=0;e--)this._value[e]=t(this._value[e],this._to_index(e),this)}forEach(t){for(let e=0;e<this.length;e++)t(this._value[e],this._to_index(e),this)}shuffle(t=0){const e=[];for(let i=0;i<this._size[t];i++)e[i]=i;for(let t=e.length-1;t>0;t--){let i=Math.floor(Math.random()*(t+1));[e[t],e[i]]=[e[i],e[t]]}this._value=this.select(e,t)._value}transpose(...t){const e=new Tensor(t.map((t=>this._size[t])));for(let i=0;i<this.length;i++){const s=this._to_index(i);e._value[e._to_position(...t.map((t=>s[t])))]=this._value[i]}return e}reshape(...t){if(t.reduce(((t,e)=>t*e),1)!==this.length)throw new MatrixException("Length is different.");this._size=t.concat()}}