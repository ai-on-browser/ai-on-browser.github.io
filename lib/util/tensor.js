import Matrix,{MatrixException}from"./matrix.js";const normal_random=function(t=0,i=1){const e=Math.sqrt(i),s=Math.random(),n=Math.random();return[Math.sqrt(-2*Math.log(s))*Math.cos(2*Math.PI*n)*e+t,Math.sqrt(-2*Math.log(s))*Math.sin(2*Math.PI*n)*e+t]};export default class Tensor{constructor(t,i){this._size=t.concat(),this._length=t.reduce(((t,i)=>t*i),1),i?Array.isArray(i)?this._value=i.flat(t.length):this._value=Array(this._length).fill(i):this._value=Array(this._length).fill(0),this._offset=0}static zeros(t){return new Tensor(t)}static ones(t){return new Tensor(t,1)}static random(t,i=0,e=1){const s=new Tensor(t);for(let t=0;t<s.length;t++)s._value[t]=Math.random()*(e-i)+i;return s}static randn(t,i=0,e=1){const s=new Tensor(t);for(let t=0;t<s.length;t+=2){const n=normal_random(i,e);s._value[t]=n[0],t+1<s.length&&(s._value[t+1]=n[1])}return s}static fromArray(t){if(t instanceof Tensor)return t;if(t instanceof Matrix)return new Tensor(t.sizes,t._value);if(!Array.isArray(t))return new Tensor([1],t);if(0===t.length)return new Tensor([0]);const i=[];let e=t;for(;Array.isArray(e);)i.push(e.length),e=e[0];return new Tensor(i,t)}get dimension(){return this._size.length}get sizes(){return this._size}get length(){return this._length}get value(){return this._value}*[Symbol.iterator](){yield*this._value}toArray(){const t=[];let i=[t],e=0;for(let t=0;t<this._size.length;t++){const s=[];for(const n of i)if(t===this._size.length-1)n.push(...this._value.slice(e,e+this._size[t])),e+=this._size[t];else for(let i=0;i<this._size[t];i++)s.push(n[i]=[]);i=s}return t}toString(){let t=this.dimension,i="";for(let e=0;e<this.length;){for(let e=0;e<t;e++)i+="[";i+=this._value[e],t=0;let s=++e;for(let i=this.dimension-1;i>=0&&s%this._size[i]==0;i--)t++,s/=this._size[i];for(let e=0;e<t;e++)i+="]";e!==this.length&&(i+=", ")}return i}toMatrix(){if(2!==this.dimension)throw new MatrixException("Only 2D tensor can convert to matrix.");return new Matrix(...this._size,this._value)}_to_position(...t){let i=0;for(let e=0;e<this.dimension;e++){if(t[e]<0||this._size[e]<=t[e])throw new MatrixException("Index out of bounds.");i=i*this._size[e]+t[e]}return i+this._offset}_to_index(t){const i=Array(this.dimension);for(let e=this.dimension-1;e>=0;e--)i[e]=t%this._size[e],t=Math.floor(t/this._size[e]);return i}copy(){return new Tensor(this._size,this.value.slice(this._offset,this._offset+this._length))}equals(t){if(t instanceof Tensor){if(this.dimension!==t.dimension)return!1;if(this._size.some(((i,e)=>i!==t._size[e])))return!1;for(let i=this.length-1;i>=0;i--)if(this._value[i]!==t._value[i])return!1;return!0}return!1}at(...t){if(Array.isArray(t[0])&&(t=t[0]),t.length===this.dimension)return this._value[this._to_position(...t)];let i=0;for(let e=0;e<t.length;e++){if(t[e]<0||this._size[e]<=t[e])throw new MatrixException("Index out of bounds.");i=i*this._size[e]+t[e]}let e=i+1;for(let s=t.length;s<this.dimension;s++)i*=this._size[s],e*=this._size[s];const s=new Tensor(this._size.slice(t.length));return s._value=this._value,s._offset=i,s}set(t,i){Array.isArray(t)||(t=[t]),this._value[this._to_position(...t)]=i}select(t,i=0){if(0!==i)throw new MatrixException("Invalid axis. Only 0 is accepted.");Array.isArray(t)||(t=[t]);let e=1;for(let t=1;t<this.dimension;t++)e*=this._size[t];const s=new Tensor([t.length,...this._size.slice(1)]);for(let i=0;i<t.length;i++)for(let n=0;n<e;n++)s._value[i*e+n]=this._value[t[i]*e+n];return s}slice(t,i,e=0){if(e<0||this.dimension<=e)throw new MatrixException("Invalid axis.");if(t<0||this._size[e]<i)throw new MatrixException("Index out of bounds.");if(i<t)throw new MatrixException("Invalid index.");let s=1;for(let t=0;t<this.dimension;t++)t!==e&&(s*=this._size[t]);const n=this._size.concat();n[e]=i-t;const r=new Tensor(n);if(0===e)r._value=this._value.slice(t*s,i*s);else for(let i=0;i<r.length;i++){const s=r._to_index(i);s[e]+=t,r._value[i]=this.at(s)}return r}fill(t){this._value=Array(this.length).fill(t)}map(t){for(let i=this.length-1;i>=0;i--)this._value[i]=t(this._value[i],this._to_index(i),this)}forEach(t){for(let i=0;i<this.length;i++)t(this._value[i],this._to_index(i),this)}transpose(...t){const i=new Tensor(t.map((t=>this._size[t])));for(let e=0;e<this.length;e++){const s=this._to_index(e);i._value[i._to_position(...t.map((t=>s[t])))]=this._value[e]}return i}flip(t=0){if(t<0||this.dimension<=t)throw new MatrixException("Invalid axis.");for(let i=0;i<this.length;i++){const e=this._to_index(i);if(e[t]<this._size[t]/2){e[t]=this._size[t]-e[t]-1;const s=this._to_position(...e),n=this._value[s];this._value[s]=this._value[i],this._value[i]=n}}}shuffle(t=0){if(t<0||this.dimension<=t)throw new MatrixException("Invalid axis.");const i=Array.from({length:this._size[t]},((t,i)=>i));for(let t=i.length-1;t>0;t--){let e=Math.floor(Math.random()*(t+1));[i[t],i[e]]=[i[e],i[t]]}this._value=this.select(i,t)._value}resize(t,i=0){const e=Array(t.reduce(((t,i)=>t*i),1)).fill(i),s=this._size.map(((i,e)=>Math.min(i,t[e])));for(let i=0;i<this.length;i++){const n=this._to_index(i);if(n.some(((t,i)=>t>=s[i])))continue;let r=0;for(let i=0;i<n.length;i++)r=r*t[i]+n[i];e[r]=this._value[i]}this._value=e,this._size=t.concat()}reshape(...t){const i=t.indexOf(-1);if(i>=0){const e=t.reduce(((t,i)=>t*(-1===i?1:i)),1);if(this.length%e!=0)throw new MatrixException("Length is different.");t[i]=this.length/e}else if(t.reduce(((t,i)=>t*i),1)!==this.length)throw new MatrixException("Length is different.");this._size=t.concat()}repeat(t,i=0){if(Array.isArray(t)){if(t.length<this._size.length)for(let i=t.length;i<this._size.length;i++)t[i]=1}else{const e=Array(this._size.length).fill(1);e[i]=t,t=e}const e=t.reduce(((t,i)=>t*i),1);if(1===e)return;const s=Array(this.length*e),n=this._size.map(((i,e)=>i*t[e]));for(let t=0;t<s.length;t++){const i=Array(n.length);let e=t;for(let t=n.length-1;t>=0;t--)i[t]=e%n[t]%this._size[t],e=Math.floor(e/n[t]);s[t]=this.at(i)}this._value=s,this._size=n,this._length*=e}concat(t,i=0){if(this.dimension!==t.dimension)throw new MatrixException("Size is different.");if(i<0||this.dimension<=i)throw new MatrixException("Invalid axis.");for(let e=0;e<this.dimension;e++)if(i!==e&&this._size[e]!==t._size[e])throw new MatrixException("Size is different.");if(0===i)this._value=[].concat(this._value,t._value),this._size[0]+=t._size[0];else{const e=this._size.concat(),s=this._size[i];e[i]+=t._size[i],this.resize(e);for(let e=0;e<t.length;e++){const n=t._to_index(e);n[i]+=s,this.set(n,t._value[e])}}}reduce(t,i,e=-1,s=!1){if(e<0){let e=i??this._value[0];for(let s=0;s<this.length;s++)0===s&&null==i||(e=t(e,this._value[s],this._to_index(s),this));return s?new Tensor(Array(this.dimension).fill(1),e):e}if(this.dimension<=e)throw new MatrixException("Invalid axis.");const n=[];s?(n.push(...this._size),n[e]=1):n.push(...this._size.filter(((t,i)=>i!==e)));const r=Tensor.zeros(n);for(let n=0;n<r.length;n++){const o=r._to_index(n);s||o.splice(e,0,0);let h=i??this.at(o);for(let s=h===i?0:1;s<this._size[e];s++)o[e]=s,h=t(h,this.at(o),o,this);r._value[n]=h}return r}broadcastOperate(t,i){if(t instanceof Tensor||t instanceof Matrix){if(this.dimension<t.dimension){const i=t.dimension-this.dimension,e=Array(t.dimension).fill(1);for(let s=0;s<i;s++)e[s]=t.sizes[s];for(let s=0;s<this.dimension;s++)if(this._size[s]<t.sizes[s+i]){if(t.sizes[s+i]%this._size[s]!=0)throw new MatrixException(`Broadcasting size invalid. this: ${this.sizes}, other: ${t.sizes}`,[this,t]);e[s+i]=t.sizes[s+i]/this._size[s]}else if(this._size[s]%t.sizes[s+i]!=0)throw new MatrixException(`Broadcasting size invalid. this: ${this.sizes}, other: ${t.sizes}`,[this,t]);this.reshape(...Array(i).fill(1),...this._size),this.repeat(e)}else{const i=this.dimension-t.dimension,e=Array(this.dimension).fill(1);for(let s=0;s<t.dimension;s++)if(this._size[s+i]<t.sizes[s]){if(t.sizes[s]%this._size[s+i]!=0)throw new MatrixException(`Broadcasting size invalid. this: ${this.sizes}, other: ${t.sizes}`,[this,t]);e[s+i]=t.sizes[s]/this._size[s+i]}else if(this._size[s+i]%t.sizes[s]!=0)throw new MatrixException(`Broadcasting size invalid. this: ${this.sizes}, other: ${t.sizes}`,[this,t]);this.repeat(e)}const e=this.dimension-t.dimension;for(let s=0;s<this.length;s++){const n=Array(t.dimension);let r=s;for(let i=t.dimension-1;i>=0;i--)n[i]=r%this._size[i+e]%t.sizes[i],r=Math.floor(r/this._size[i+e]);this._value[s]=i(this._value[s],t.at(n))}}else this.map((e=>i(e,t)))}operateAt(t,i){Array.isArray(t)||(t=[t]);const e=this._to_position(...t),s=this._value[e];return this._value[e]=i(s),s}dot(t){if(this._size[this._size.length-1]!==t.rows)throw new MatrixException(`Dot size invalid. left = [${this.sizes}], right = [${t.rows}, ${t.cols}]`);const i=new Tensor([...this._size.slice(0,-1),t.cols]),e=Array(this._size.length-1).fill(0);do{for(let s=0;s<t.cols;s++){let n=0;for(let i=0;i<t.rows;i++)n+=this.at(...e,i)*t.at(i,s);i.set([...e,s],n)}for(let t=0;t<e.length&&(e[t]++,!(e[t]<this._size[t]));t++)e[t]=0}while(e.some((t=>t>0)));return i}}