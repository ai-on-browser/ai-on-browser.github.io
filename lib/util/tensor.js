var g=Object.defineProperty;var d=(u,t)=>g(u,"name",{value:t,configurable:!0});import z,{MatrixException as f}from"./matrix.js";const w=d((u,t)=>{const i=Math.sqrt(t),e=Math.random(),s=Math.random(),n=Math.sqrt(-2*Math.log(e))*Math.cos(2*Math.PI*s),h=Math.sqrt(-2*Math.log(e))*Math.sin(2*Math.PI*s);return[n*i+u,h*i+u]},"normal_random");export default class a{static{d(this,"Tensor")}constructor(t,i){this._size=t.concat(),this._length=t.reduce((e,s)=>e*s,1),i?Array.isArray(i)?this._value=i.flat(t.length):this._value=Array(this._length).fill(i):this._value=Array(this._length).fill(0),this._offset=0}static zeros(...t){return new a(Array.isArray(t[0])?t[0]:t)}static ones(...t){return new a(Array.isArray(t[0])?t[0]:t,1)}static random(t,i=0,e=1){const s=new a(t);for(let n=0;n<s.length;n++)s._value[n]=Math.random()*(e-i)+i;return s}static randn(t,i=0,e=1){const s=new a(t);for(let n=0;n<s.length;n+=2){const h=w(i,e);s._value[n]=h[0],n+1<s.length&&(s._value[n+1]=h[1])}return s}static fromArray(t){if(t instanceof a)return t;if(t instanceof z)return new a(t.sizes,t._value);if(Array.isArray(t)){if(t.length===0)return new a([0])}else return new a([1],t);const i=[];let e=t;for(;Array.isArray(e);)i.push(e.length),e=e[0];return new a(i,t)}get dimension(){return this._size.length}get sizes(){return this._size}get length(){return this._length}get value(){return this._value}*[Symbol.iterator](){yield*this._value}toArray(){const t=[];let i=[t],e=0;for(let s=0;s<this._size.length;s++){const n=[];for(const h of i)if(s===this._size.length-1)h.push(...this._value.slice(e,e+this._size[s])),e+=this._size[s];else for(let l=0;l<this._size[s];l++)h[l]=[],n.push(h[l]);i=n}return t}toString(){let t=this.dimension,i="";for(let e=0;e<this.length;){for(let n=0;n<t;n++)i+="[";i+=this._value[e],t=0;let s=++e;for(let n=this.dimension-1;n>=0&&s%this._size[n]===0;n--)t++,s/=this._size[n];for(let n=0;n<t;n++)i+="]";e!==this.length&&(i+=", ")}return i}toMatrix(){if(this.dimension!==2)throw new f("Only 2D tensor can convert to matrix.");return new z(...this._size,this._value)}toScaler(){if(this._value.length!==1)throw new f("The tensor cannot convert to scaler.");return this._value[0]}_to_position(...t){let i=0;for(let e=0;e<this.dimension;e++){if(t[e]<0||this._size[e]<=t[e])throw new f("Index out of bounds.");i=i*this._size[e]+t[e]}return i+this._offset}_to_index(t){const i=Array(this.dimension);for(let e=this.dimension-1;e>=0;e--)i[e]=t%this._size[e],t=Math.floor(t/this._size[e]);return i}copy(){return new a(this._size,this.value.slice(this._offset,this._offset+this._length))}equals(t){if(t instanceof a){if(this.dimension!==t.dimension||this._size.some((i,e)=>i!==t._size[e]))return!1;for(let i=this.length-1;i>=0;i--)if(this._value[i]!==t._value[i])return!1;return!0}return!1}at(...t){if(Array.isArray(t[0])&&(t=t[0]),t.length!==this.dimension)throw new f("Length is invalid.");return this._value[this._to_position(...t)]}index(...t){Array.isArray(t[0])&&(t=t[0]);let i=0;for(let n=0;n<t.length;n++){if(t[n]<0||this._size[n]<=t[n])throw new f("Index out of bounds.");i=i*this._size[n]+t[n]}let e=i+1;for(let n=t.length;n<this.dimension;n++)i=i*this._size[n],e=e*this._size[n];const s=new a(this._size.slice(t.length));return s._value=this._value,s._offset=i,s}set(t,i){Array.isArray(t)||(t=[t]),this._value[this._to_position(...t)]=i}select(t,i=0){if(i<0||this.dimension<=i)throw new f("Invalid axis.");Array.isArray(t)||(t=[t]);let e=1,s=1;for(let l=0;l<i;l++)e*=this._size[l];for(let l=i+1;l<this.dimension;l++)s*=this._size[l];const n=this._size.concat();n[i]=t.length;const h=new a(n);for(let l=0;l<t.length;l++)for(let r=0;r<e;r++){const _=r*t.length*s+l*s,c=r*this._size[i]*s+t[l]*s;for(let o=0;o<s;o++)h._value[_+o]=this._value[c+o]}return h}slice(t,i,e=0){if(e<0||this.dimension<=e)throw new f("Invalid axis.");if(t<0||this._size[e]<i)throw new f("Index out of bounds.");if(i<t)throw new f("Invalid index.");const s=this._size.concat();s[e]=i-t;const n=new a(s);if(e===0){let h=1;for(let l=1;l<this.dimension;l++)h*=this._size[l];n._value=this._value.slice(t*h,i*h)}else for(let h=0;h<n.length;h++){const l=n._to_index(h);l[e]+=t,n._value[h]=this.at(l)}return n}fill(t){this._value=Array(this.length).fill(t)}map(t){for(let i=this.length-1;i>=0;i--)this._value[i]=t(this._value[i],this._to_index(i),this)}forEach(t){for(let i=0;i<this.length;i++)t(this._value[i],this._to_index(i),this)}transpose(...t){Array.isArray(t[0])&&(t=t[0]);const i=new a(t.map(e=>this._size[e]));for(let e=0;e<this.length;e++){const s=this._to_index(e);i._value[i._to_position(...t.map(n=>s[n]))]=this._value[e]}return i}flip(t=0){if(t<0||this.dimension<=t)throw new f("Invalid axis.");for(let i=0;i<this.length;i++){const e=this._to_index(i);if(e[t]<this._size[t]/2){e[t]=this._size[t]-e[t]-1;const s=this._to_position(...e),n=this._value[s];this._value[s]=this._value[i],this._value[i]=n}}}shuffle(t=0){if(t<0||this.dimension<=t)throw new f("Invalid axis.");const i=Array.from({length:this._size[t]},(e,s)=>s);for(let e=i.length-1;e>0;e--){const s=Math.floor(Math.random()*(e+1));[i[e],i[s]]=[i[s],i[e]]}this._value=this.select(i,t)._value}resize(t,i=0){const e=Array(t.reduce((n,h)=>n*h,1)).fill(i),s=this._size.map((n,h)=>Math.min(n,t[h]));for(let n=0;n<this.length;n++){const h=this._to_index(n);if(h.some((r,_)=>r>=s[_]))continue;let l=0;for(let r=0;r<h.length;r++)l=l*t[r]+h[r];e[l]=this._value[n]}this._value=e,this._size=t.concat()}reshape(...t){Array.isArray(t[0])&&(t=t[0]);const i=t.indexOf(-1);if(i>=0){const e=t.reduce((s,n)=>s*(n===-1?1:n),1);if(this.length%e!==0)throw new f("Length is different.");t[i]=this.length/e}else if(t.reduce((e,s)=>e*s,1)!==this.length)throw new f("Length is different.");this._size=t.concat()}repeat(t,i=0){if(Array.isArray(t)){if(t.length<this._size.length)for(let h=t.length;h<this._size.length;h++)t[h]=1}else{const h=Array(this._size.length).fill(1);h[i]=t,t=h}const e=t.reduce((h,l)=>h*l,1);if(e===1)return;const s=Array(this.length*e),n=this._size.map((h,l)=>h*t[l]);for(let h=0;h<s.length;h++){const l=Array(n.length);let r=h;for(let _=n.length-1;_>=0;_--)l[_]=r%n[_]%this._size[_],r=Math.floor(r/n[_]);s[h]=this.at(l)}this._value=s,this._size=n,this._length*=e}concat(t,i=0){if(this.dimension!==t.dimension)throw new f("Size is different.");if(i<0||this.dimension<=i)throw new f("Invalid axis.");for(let e=0;e<this.dimension;e++)if(i!==e&&this._size[e]!==t._size[e])throw new f("Size is different.");if(i===0)this._value=[].concat(this._value,t._value),this._size[0]+=t._size[0];else{const e=this._size.concat(),s=this._size[i];e[i]+=t._size[i],this.resize(e);for(let n=0;n<t.length;n++){const h=t._to_index(n);h[i]+=s,this.set(h,t._value[n])}}}reduce(t,i,e=-1,s=!1){if(typeof e=="number"&&(e=[e]),e.includes(-1)){let l=i??this._value[0];for(let r=0;r<this.length;r++)r===0&&i==null||(l=t(l,this._value[r],this._to_index(r),this));return s?new a(Array(this.dimension).fill(1),l):l}if(e.some(l=>this.dimension<=l))throw new f("Invalid axis.");e.sort((l,r)=>l-r);const n=[];if(s){n.push(...this._size);for(let l=0;l<e.length;l++)n[e[l]]=1}else n.push(...this._size.filter((l,r)=>!e.includes(r)));const h=a.zeros(n);for(let l=0;l<h.length;l++){const r=h._to_index(l);if(!s)for(let o=0;o<e.length;o++)r.splice(e[o],0,0);let _=i??this.at(r);const c=Array(e.length).fill(0);i==null&&(c[0]=1);do{for(let o=0;o<e.length;o++)r[e[o]]=c[o];_=t(_,this.at(r),r,this);for(let o=0;o<c.length&&(c[o]++,!(c[o]<this._size[e[o]]));o++)c[o]=0}while(c.some(o=>o>0));h._value[l]=_}return h}broadcastOperate(t,i){if(t instanceof a||t instanceof z){if(this.dimension<t.dimension){const s=t.dimension-this.dimension,n=Array(t.dimension).fill(1);for(let h=0;h<s;h++)n[h]=t.sizes[h];for(let h=0;h<this.dimension;h++)if(this._size[h]<t.sizes[h+s]){if(t.sizes[h+s]%this._size[h]!==0)throw new f(`Broadcasting size invalid. this: ${this.sizes}, other: ${t.sizes}`,[this,t]);n[h+s]=t.sizes[h+s]/this._size[h]}else if(this._size[h]%t.sizes[h+s]!==0)throw new f(`Broadcasting size invalid. this: ${this.sizes}, other: ${t.sizes}`,[this,t]);this.reshape(...Array(s).fill(1),...this._size),this.repeat(n)}else{const s=this.dimension-t.dimension,n=Array(this.dimension).fill(1);for(let h=0;h<t.dimension;h++)if(this._size[h+s]<t.sizes[h]){if(t.sizes[h]%this._size[h+s]!==0)throw new f(`Broadcasting size invalid. this: ${this.sizes}, other: ${t.sizes}`,[this,t]);n[h+s]=t.sizes[h]/this._size[h+s]}else if(this._size[h+s]%t.sizes[h]!==0)throw new f(`Broadcasting size invalid. this: ${this.sizes}, other: ${t.sizes}`,[this,t]);this.repeat(n)}const e=this.dimension-t.dimension;for(let s=0;s<this.length;s++){const n=Array(t.dimension);let h=s;for(let l=t.dimension-1;l>=0;l--)n[l]=h%this._size[l+e]%t.sizes[l],h=Math.floor(h/this._size[l+e]);this._value[s]=i(this._value[s],t.at(n))}}else this.map(e=>i(e,t))}operateAt(t,i){Array.isArray(t)||(t=[t]);const e=this._to_position(...t),s=this._value[e];return this._value[e]=i(s),s}dot(t){if(this._size[this._size.length-1]!==t.rows)throw new f(`Dot size invalid. left = [${this.sizes}], right = [${t.rows}, ${t.cols}]`);const i=new a([...this._size.slice(0,-1),t.cols]),e=Array(this._size.length-1).fill(0);do{for(let s=0;s<t.cols;s++){let n=0;for(let h=0;h<t.rows;h++)n+=this.at(...e,h)*t.at(h,s);i.set([...e,s],n)}for(let s=0;s<e.length&&(e[s]++,!(e[s]<this._size[s]));s++)e[s]=0}while(e.some(s=>s>0));return i}}
