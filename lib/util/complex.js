export default class Complex{constructor(t=0,a=0){this._real=t,this._imag=a}get real(){return this._real}get imaginary(){return this._imag}abs(){return Math.sqrt(this._real**2+this._imag**2)}conjugate(){return new Complex(this._real,-this._imag)}add(t){return"number"==typeof t?new Complex(this._real+t,this._imag):new Complex(this._real+t._real,this._imag+t._imag)}sub(t){return"number"==typeof t?new Complex(this._real-t,this._imag):new Complex(this._real-t._real,this._imag-t._imag)}mult(t){return"number"==typeof t?new Complex(this._real*t,this._imag*t):new Complex(this._real*t._real-this._imag*t._imag,this._imag*t._real+this._real*t._imag)}div(t){if("number"==typeof t)return new Complex(this._real/t,this._imag/t);const a=t._real**2+t._imag**2;return new Complex((this._real*t._real+this._imag*t._imag)/a,(this._imag*t._real-this._real*t._imag)/a)}sqrt(){const t=Math.atan2(this._imag,this._real)/2,a=Math.sqrt(this.abs());return[new Complex(Math.cos(t)*a,Math.sin(t)*a),new Complex(Math.cos(t+Math.PI)*a,Math.sin(t+Math.PI)*a)]}cbrt(){const t=Math.atan2(this._imag,this._real)/3,a=Math.cbrt(this.abs());return[new Complex(Math.cos(t)*a,Math.sin(t)*a),new Complex(Math.cos(t+2*Math.PI/3)*a,Math.sin(t+2*Math.PI/3)*a),new Complex(Math.cos(t+4*Math.PI/3)*a,Math.sin(t+4*Math.PI/3)*a)]}exp(){const t=Math.exp(this._real);return new Complex(t*Math.cos(this._imag),t*Math.sin(this._imag))}log(){return new Complex(Math.log(this.abs()),Math.atan2(this._imag,this._real))}}