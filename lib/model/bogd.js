var m=Object.defineProperty;var f=(o,e)=>m(o,"name",{value:e,configurable:!0});const u={gaussian:f(({s:o=1})=>(e,l)=>Math.exp(-(e.reduce((s,n,a)=>s+(n-l[a])**2,0)**2)/o**2),"gaussian"),polynomial:f(({d:o=2})=>(e,l)=>(1+e.reduce((s,n,a)=>s+n*l[a]))**o,"polynomial")};export default class v{static{f(this,"BOGD")}constructor(e=10,l=1,s=.1,n=.1,a="nonuniform",t="gaussian",_="hinge"){this._b=e,this._eta=l,this._lambda=s,this._gamma=n,this._sampling=a,typeof t=="function"?this._kernel=t:(typeof t=="string"&&(t={name:t}),this._kernel=u[t.name](t)),_==="zero_one"?this._gloss=(p,i)=>p*(i<=0?-1:1)<=0?-1:0:_==="hinge"&&(this._gloss=(p,i)=>p*(i<=0?-1:1)<=1?-1:0),this._sv=[],this._alpha=[]}fit(e,l){for(let s=0;s<e.length;s++){let n=0;for(let t=0;t<this._sv.length;t++){const _=this._sv[t];n+=this._alpha[t]*_.y*this._kernel(e[s],_.x)}const a=this._gloss(l[s],n);if(a===0)this._alpha=this._alpha.map(t=>(1-this._eta*this._lambda)*t);else if(this._sv.length<this._b)this._alpha=this._alpha.map(t=>(1-this._eta*this._lambda)*t),this._alpha.push(-this._eta*a),this._sv.push({x:e[s],y:l[s]});else{let t=-1;const _=[];if(this._sampling==="uniform"){for(let i=0;i<this._sv.length;i++)_[i]=1/this._sv.length;t=Math.floor(Math.random()*this._sv.length)}else{const i=[];for(let h=0;h<this._sv.length;h++){const r=this._sv[h];i[h]=this._alpha[h]*Math.sqrt(this._kernel(r.x,r.x))}const c=(this._b-1)/i.reduce((h,r)=>h+r,0);for(let h=0;h<this._sv.length;h++)_[h]=1-c*i[h];let g=Math.random()*_.reduce((h,r)=>h+r,0);for(let h=0;h<_.length;h++)if(g-=_[h],g<0){t=h;break}}const p=this._lambda*this._eta;for(let i=0;i<this._sv.length;i++)this._alpha[i]*=(1-p)/(1-_[i]);this._sv.splice(t,1),this._alpha.splice(t,1),this._sv.push({x:e[s],y:l[s]}),this._alpha.push(-this._eta*a)}for(let t=0;t<this._sv.length;t++)this._alpha[t]=Math.min(this._alpha[t],this._gamma*this._eta)}}predict(e){const l=[];for(let s=0;s<e.length;s++){let n=0;for(let a=0;a<this._sv.length;a++){const t=this._sv[a];n+=this._alpha[a]*t.y*this._kernel(e[s],t.x)}l[s]=n<0?-1:1}return l}}
