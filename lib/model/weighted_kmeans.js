var u=Object.defineProperty;var g=(d,t)=>u(d,"name",{value:t,configurable:!0});export default class p{static{g(this,"WeightedKMeans")}constructor(t){this._beta=t,this._centroids=[],this._w=null}get centroids(){return this._centroids}get size(){return this._centroids.length}_distance(t,l){let i=0;for(let r=t.length-1;r>=0;r--)i+=this._w[r]**this._beta*(t[r]-l[r])**2;return i}add(t){for(this._w||(this._w=Array(t[0].length).fill(1/t[0].length));;){const l=t[Math.floor(Math.random()*t.length)];if(Math.min(...this._centroids.map(i=>i.reduce((r,e,c)=>r+(e-l[c])**2,0)))>1e-8){const i=l.concat();return this._centroids.push(i),i}}}clear(){this._centroids=[],this._w=null}predict(t){if(this._centroids.length===0)throw new Error("Call fit before predict.");return t.map(l=>{let i=1/0,r=-1;for(let e=0;e<this._centroids.length;e++){const c=this._distance(l,this._centroids[e]);c<i&&(i=c,r=e)}return r})}fit(t){if(this._centroids.length===0||t.length===0)return 0;this._w||(this._w=Array(t[0].length).fill(1/t[0].length));const l=this._centroids,i=this.predict(t);this._centroids=this._centroids.map((n,h)=>{const s=Array(t[0].length).fill(0);let f=0;for(let o=0;o<t.length;o++)if(i[o]===h){for(let _=0;_<s.length;_++)s[_]+=t[o][_];f++}return s.map(o=>o/f)});const r=this.predict(t),e=Array(this._w.length).fill(0);for(let n=0;n<t.length;n++)for(let h=0;h<e.length;h++)e[h]+=(t[n][h]-this._centroids[r[n]][h])**2;for(let n=0;n<e.length;n++){let h=0;for(let s=0;s<e.length;s++)h+=(e[n]/e[s])**(1/(this._beta-1));this._w[n]=1/h}return l.reduce((n,h,s)=>n+this._distance(h,this._centroids[s]),0)}}
