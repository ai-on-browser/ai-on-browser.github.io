export default class WeightedKMeans{constructor(t){this._beta=t,this._centroids=[],this._w=null}get centroids(){return this._centroids}get size(){return this._centroids.length}_distance(t,e){let i=0;for(let r=t.length-1;r>=0;r--)i+=this._w[r]**this._beta*(t[r]-e[r])**2;return i}add(t){for(this._w||(this._w=Array(t[0].length).fill(1/t[0].length));;){const e=t[Math.floor(Math.random()*t.length)];if(Math.min(...this._centroids.map((t=>t.reduce(((t,i,r)=>t+(i-e[r])**2),0))))>1e-8){const t=e.concat();return this._centroids.push(t),t}}}clear(){this._centroids=[],this._w=null}predict(t){if(0!==this._centroids.length)return t.map((t=>{let e=1/0,i=-1;for(let r=0;r<this._centroids.length;r++){const s=this._distance(t,this._centroids[r]);s<e&&(e=s,i=r)}return i}))}fit(t){if(0===this._centroids.length||0===t.length)return 0;this._w||(this._w=Array(t[0].length).fill(1/t[0].length));const e=this._centroids,i=this.predict(t);this._centroids=this._centroids.map(((e,r)=>{const s=Array(t[0].length).fill(0);let n=0;for(let e=0;e<t.length;e++)if(i[e]===r){for(let i=0;i<s.length;i++)s[i]+=t[e][i];n++}return s.map((t=>t/n))}));const r=this.predict(t),s=Array(this._w.length).fill(0);for(let e=0;e<t.length;e++)for(let i=0;i<s.length;i++)s[i]+=(t[e][i]-this._centroids[r[e]][i])**2;for(let t=0;t<s.length;t++){let e=0;for(let i=0;i<s.length;i++)e+=(s[t]/s[i])**(1/(this._beta-1));this._w[t]=1/e}return e.reduce(((t,e,i)=>t+this._distance(e,this._centroids[i])),0)}}