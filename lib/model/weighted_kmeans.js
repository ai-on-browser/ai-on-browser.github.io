export default class WeightedKMeans{constructor(t){this._beta=t,this._centroids=[],this._w=null}get centroids(){return this._centroids}get size(){return this._centroids.length}_distance(t,e){let r=0;for(let i=t.length-1;i>=0;i--)r+=this._w[i]**this._beta*(t[i]-e[i])**2;return r}add(t){for(this._w||(this._w=Array(t[0].length).fill(1/t[0].length));;){const e=t[Math.floor(Math.random()*t.length)];if(Math.min(...this._centroids.map((t=>t.reduce(((t,r,i)=>t+(r-e[i])**2),0))))>1e-8){const t=e.concat();return this._centroids.push(t),t}}}clear(){this._centroids=[],this._w=null}predict(t){if(0===this._centroids.length)throw new Error("Call fit before predict.");return t.map((t=>{let e=1/0,r=-1;for(let i=0;i<this._centroids.length;i++){const s=this._distance(t,this._centroids[i]);s<e&&(e=s,r=i)}return r}))}fit(t){if(0===this._centroids.length||0===t.length)return 0;this._w||(this._w=Array(t[0].length).fill(1/t[0].length));const e=this._centroids,r=this.predict(t);this._centroids=this._centroids.map(((e,i)=>{const s=Array(t[0].length).fill(0);let n=0;for(let e=0;e<t.length;e++)if(r[e]===i){for(let r=0;r<s.length;r++)s[r]+=t[e][r];n++}return s.map((t=>t/n))}));const i=this.predict(t),s=Array(this._w.length).fill(0);for(let e=0;e<t.length;e++)for(let r=0;r<s.length;r++)s[r]+=(t[e][r]-this._centroids[i[e]][r])**2;for(let t=0;t<s.length;t++){let e=0;for(let r=0;r<s.length;r++)e+=(s[t]/s[r])**(1/(this._beta-1));this._w[t]=1/e}return e.reduce(((t,e,r)=>t+this._distance(e,this._centroids[r])),0)}}