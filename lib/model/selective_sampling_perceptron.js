export class SelectiveSamplingPerceptron{constructor(t,s){this._b=t,this._r=s,this._w=null,this._c=0}fit(t,s){this._w||(this._w=Array(t[0].length).fill(0));for(let h=0;h<t.length;h++){const i=t[h].reduce(((t,s,h)=>t+s*this._w[h]),this._c),e=i<=0?-1:1;if(Math.random()<this._b/(this._b+Math.abs(i))&&s[h]!==e){for(let i=0;i<t[h].length;i++)this._w[i]+=this._r*s[h]*t[h][i];this._c+=this._r*s[h]}}}predict(t){const s=[];for(let h=0;h<t.length;h++){const i=t[h].reduce(((t,s,h)=>t+s*this._w[h]),this._c);s.push(i<=0?-1:1)}return s}}export class SelectiveSamplingAdaptivePerceptron{constructor(t,s){this._beta=t,this._r=s,this._w=null,this._c=0,this._k=0,this._X=0}fit(t,s){this._w||(this._w=Array(t[0].length).fill(0));for(let h=0;h<t.length;h++){const i=t[h].reduce(((t,s,h)=>t+s*this._w[h]),this._c),e=i<=0?-1:1,r=Math.max(this._X,Math.sqrt(t[h].reduce(((t,s)=>t+s**2),0))),_=this._beta*r**2*Math.sqrt(1+this._k);if(Math.random()<_/(_+Math.abs(i))&&s[h]!==e){for(let i=0;i<t[h].length;i++)this._w[i]+=this._r*s[h]*t[h][i];this._c+=this._r*s[h],this._k+=1,this._X=r}}}predict(t){const s=[];for(let h=0;h<t.length;h++){const i=t[h].reduce(((t,s,h)=>t+s*this._w[h]),this._c);s.push(i<=0?-1:1)}return s}}