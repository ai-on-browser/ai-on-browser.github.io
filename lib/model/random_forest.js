export default class RandomForest{constructor(t,e=.8,r=DecisionTreeClassifierSub){this._trees=[],this._treenum=t,this._samplingRate=e,this._treeclass=r}get depth(){return Math.max(...this._trees.map((t=>t.depth)))}_sample(t){const e=[];for(let r=0;r<t;r++)e[r]=r;for(let r=t-1;r>0;r--){const t=Math.floor(Math.random()*(r+1));[e[r],e[t]]=[e[t],e[r]]}return e.slice(0,Math.ceil(t*this._samplingRate))}init(t,e){this._trees=[];for(let r=0;r<this._treenum;r++){const r=this._sample(t.length),s=[],h=[];for(let i=0;i<r.length;i++)s.push(t[r[i]]),h.push(e[r[i]]);const i=new this._treeclass;i.init(s,h),this._trees.push(i)}}fit(t=1){this._trees.forEach((e=>e.fit(t)))}predict_prob(t){const e=this._trees.map((e=>e.predict_prob(t))),r=[];for(let s=0;s<t.length;s++){const t=new Map;for(let r=0;r<e.length;r++)e[r][s].forEach(((e,r)=>{t.set(r,(t.get(r)||0)+e)}));t.forEach(((r,s)=>{t.set(s,r/e.length)})),r.push(t)}return r}predict(t){if(this._trees[0].predict_prob){return this.predict_prob(t).map((t=>{let e=0,r=-1;return t.forEach(((t,s)=>{t>e&&(e=t,r=s)})),r}))}{const e=this._trees.map((e=>e.predict(t))),r=[];for(let s=0;s<t.length;s++)r.push(e.reduce(((t,e)=>t+e[s]),0)/e.length);return r}}}