import{KMeanspp}from"./kmeans.js";class CFTree{constructor(t=10,s=.2,e=1/0){this._b=t,this._l=e,this._t=s,this._datas=[],this._children=[],this._parent=null}get size(){return this._datas.length}get length(){return this._children.length}get depth(){return this.isLeaf()?1:this._children.reduce(((t,s)=>Math.max(t,s.depth+1)),-1/0)}get cf(){if(this._cf)return this._cf;if(this.isLeaf()){const t=this._datas.length;if(0===t)this._cf={n:0,ls:null,ss:0};else{const s=Array(this._datas[0].length).fill(0);let e=0;for(let i=0;i<t;i++)for(let t=0;t<this._datas[i].length;t++)s[t]+=this._datas[i][t],e+=this._datas[i][t]**2;this._cf={n:t,ls:s,ss:e}}}else{this._cf={n:this._children[0].cf.n,ls:this._children[0].cf.ls.concat(),ss:this._children[0].cf.ss};for(let t=1;t<this.length;t++){const s=this._children[t].cf;this._cf.n+=s.n,this._cf.ss+=s.ss;for(let t=0;t<s.ls.length;t++)this._cf.ls[t]+=s.ls[t]}}return this._cf}get r(){if(this._r)return this._r;if(this.isLeaf()){const t=this._datas.length;if(t<=1)this._r=1/0;else{let s=0;for(let e=0;e<t;e++){const t=this._datas[e];for(let i=0;i<e;i++)s+=2*this._datas[i].reduce(((s,e,i)=>s+(e-t[i])**2),0)}this._r=Math.sqrt(s/(t*(t-1)))}}else this._r=this._children.reduce(((t,s)=>Math.max(t,s.r)),-1/0);return this._r}get c(){return this.cf.ls.map((t=>t/this.cf.n))}at(t){return this._children[t]}isRoot(){return null===this._parent}isLeaf(){return 0===this._children.length}push(t){if(this._cf=null,this._r=null,!this.isLeaf()){let s=1/0,e=-1;for(let i=0;i<this.length;i++){const h=this._children[i].c,r=t.reduce(((t,s,e)=>t+(s-h[e])**2),0);r<s&&(s=r,e=i)}return this._children[e].push(t),void(this._children.length>=this._b&&this._separate())}this._datas.push(t),this._datas.length<=2||(this._datas.length>=this._l||this.r>this._t)&&this._separate()}_separate(){const t=this.isLeaf()?this._datas:this._children.map((t=>t.c)),s=new KMeanspp;for(s.add(t),s.add(t);s.fit(t)>0;);const e=s.predict(t);if(this.isLeaf())if(this.isRoot()){const s=new CFTree(this._b,this._t,this._l);s._datas=t.filter(((t,s)=>0===e[s])),s._parent=this;const i=new CFTree(this._b,this._t,this._l);i._datas=t.filter(((t,s)=>1===e[s])),i._parent=this,this._children=[s,i],this._datas=null}else{const s=new CFTree(this._b,this._t,this._l);s._datas=t.filter(((t,s)=>1===e[s])),s._parent=this._parent,this._parent._children.push(s),this._datas=t.filter(((t,s)=>0===e[s]))}else if(this.isRoot()){const t=new CFTree(this._b,this._t,this._l);t._children=this._children.filter(((t,s)=>0===e[s])),t._children.forEach((s=>s._parent=t)),t._parent=this;const s=new CFTree(this._b,this._t,this._l);s._children=this._children.filter(((t,s)=>1===e[s])),s._children.forEach((t=>t._parent=s)),s._parent=this,this._children=[t,s]}else{const t=new CFTree(this._b,this._t,this._l);t._children=this._children.filter(((t,s)=>1===e[s])),t._children.forEach((s=>s._parent=t)),t._parent=this._parent,this._parent._children.push(t),this._children=this._children.filter(((t,s)=>0===e[s]))}}}export default class BIRCH{constructor(t,s=10,e=.2,i=1/0){this._k=t,this._tree=new CFTree(s,e,i)}fit(t){for(let s=0;s<t.length;s++)this._tree.push(t[s])}predict(t){if(this._tree.isLeaf())return Array(t.length).fill(0);const s=this._tree._children.map((t=>t.c));return t.map((t=>{let e=1/0,i=-1;for(let h=0;h<s.length;h++){const r=t.reduce(((t,e,i)=>t+(e-s[h][i])**2),0);r<e&&(e=r,i=h)}return i}))}}