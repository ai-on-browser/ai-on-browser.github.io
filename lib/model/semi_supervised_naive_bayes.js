var b=Object.defineProperty;var r=(n,a)=>b(n,"name",{value:a,configurable:!0});export default class c{static{r(this,"SemiSupervisedNaiveBayes")}constructor(a=1){this._lambda=a,this._alpha=2}init(a,o){const h=new Set;this._labels=[];for(let t=0;t<a.length;t++)for(let l=0;l<a[t].length;l++)h.add(a[t][l]);this._vocabulary=[...h],this._labeled_data={w:[],i:[]},this._unlabeled_data={w:[],i:[]};for(let t=0;t<a.length;t++){const l=a[t].map(e=>this._vocabulary.indexOf(e));o[t]!==null?(this._labeled_data.w.push(a[t]),this._labeled_data.i.push(l),this._labels.push(o[t])):(this._unlabeled_data.w.push(a[t]),this._unlabeled_data.i.push(l))}this._classes=[...new Set(this._labels)],this._prob_wc=[],this._prob_c=[];for(let t=0;t<this._classes.length;t++){const l=Array(this._vocabulary.length).fill(0);let e=0;for(let s=0;s<this._labeled_data.i.length;s++)if(this._labels[s]===this._classes[t]){for(let _=0;_<this._labeled_data.i[s].length;_++)l[this._labeled_data.i[s][_]]++;e++}const i=l.reduce((s,_)=>s+_,0);this._prob_wc[t]=l.map(s=>(1+s)/(this._vocabulary.length+i)),this._prob_c[t]=(1+e)/(this._classes.length+a.length)}}fit(){const a=this.probability(this._unlabeled_data.w),o=[],h=[];for(let t=0;t<this._classes.length;t++){const l=Array(this._vocabulary.length).fill(0);let e=0;for(let s=0;s<this._labeled_data.i.length;s++)if(this._labels[s]===this._classes[t]){for(let _=0;_<this._labeled_data.i[s].length;_++)l[this._labeled_data.i[s][_]]++;e++}for(let s=0;s<this._unlabeled_data.i.length;s++){for(let _=0;_<this._unlabeled_data.i[s].length;_++)l[this._unlabeled_data.i[s][_]]+=this._lambda*a[s][t];e+=this._lambda*a[s][t]}const i=l.reduce((s,_)=>s+_,0);o[t]=l.map(s=>(1+s)/(this._vocabulary.length+i)),h[t]=(1+e)/(this._classes.length+this._labeled_data.i.length+this._lambda*this._unlabeled_data.i.length)}this._prob_wc=o,this._prob_c=h}probability(a){return a.map(o=>{const h=o.map(e=>this._vocabulary.indexOf(e)),t=Array(this._classes.length).fill(0);for(let e=0;e<this._classes.length;e++){t[e]=this._prob_c[e];for(let i=0;i<o.length;i++)t[e]*=this._prob_wc[e][h[i]]}const l=t.reduce((e,i)=>e+i,0);return t.map(e=>e/l)})}logLikelihood(){const a=this.probability(this._labeled_data.w),o=this.probability(this._unlabeled_data.w);let h=0;for(let t=0;t<this._classes.length;t++){h+=(this._alpha-1)*Math.log(this._prob_c[t]);for(let l=0;l<this._vocabulary.length;l++)h+=(this._alpha-1)*Math.log(this._prob_wc[t][l])}for(let t=0;t<this._labeled_data.i.length;t++)for(let l=0;l<this._classes.length;l++){let e=Math.log(this._prob_c[l]);for(let i=0;i<this._labeled_data.i[t].length;i++)e+=Math.log(this._prob_wc[l][this._labeled_data.i[t][i]]);h+=a[t][l]*e}for(let t=0;t<this._unlabeled_data.i.length;t++)for(let l=0;l<this._classes.length;l++){let e=Math.log(this._prob_c[l]);for(let i=0;i<this._unlabeled_data.i[t].length;i++)e+=Math.log(this._prob_wc[l][this._unlabeled_data.i[t][i]]);h+=this._lambda*o[t][l]*e}return h}predict(a){return this.probability(a).map(h=>{let t=0,l=-1;for(let e=0;e<this._classes.length;e++)h[e]>t&&(t=h[e],l=e);return l<0?null:this._classes[l]})}}
