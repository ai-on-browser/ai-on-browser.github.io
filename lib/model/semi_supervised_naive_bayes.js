export default class SemiSupervisedNaiveBayes{constructor(t=1){this._lambda=t,this._alpha=2}init(t,l){const e=new Set;this._labels=[];for(let l=0;l<t.length;l++)for(let a=0;a<t[l].length;a++)e.add(t[l][a]);this._vocabulary=[...e],this._labeled_data={w:[],i:[]},this._unlabeled_data={w:[],i:[]};for(let e=0;e<t.length;e++){const a=t[e].map((t=>this._vocabulary.indexOf(t)));null!==l[e]?(this._labeled_data.w.push(t[e]),this._labeled_data.i.push(a),this._labels.push(l[e])):(this._unlabeled_data.w.push(t[e]),this._unlabeled_data.i.push(a))}this._classes=[...new Set(this._labels)],this._prob_wc=[],this._prob_c=[];for(let l=0;l<this._classes.length;l++){const e=Array(this._vocabulary.length).fill(0);let a=0;for(let t=0;t<this._labeled_data.i.length;t++)if(this._labels[t]===this._classes[l]){for(let l=0;l<this._labeled_data.i[t].length;l++)e[this._labeled_data.i[t][l]]++;a++}const s=e.reduce(((t,l)=>t+l),0);this._prob_wc[l]=e.map((t=>(1+t)/(this._vocabulary.length+s))),this._prob_c[l]=(1+a)/(this._classes.length+t.length)}}fit(){const t=this.probability(this._unlabeled_data.w),l=[],e=[];for(let a=0;a<this._classes.length;a++){const s=Array(this._vocabulary.length).fill(0);let h=0;for(let t=0;t<this._labeled_data.i.length;t++)if(this._labels[t]===this._classes[a]){for(let l=0;l<this._labeled_data.i[t].length;l++)s[this._labeled_data.i[t][l]]++;h++}for(let l=0;l<this._unlabeled_data.i.length;l++){for(let e=0;e<this._unlabeled_data.i[l].length;e++)s[this._unlabeled_data.i[l][e]]+=this._lambda*t[l][a];h+=this._lambda*t[l][a]}const i=s.reduce(((t,l)=>t+l),0);l[a]=s.map((t=>(1+t)/(this._vocabulary.length+i))),e[a]=(1+h)/(this._classes.length+this._labeled_data.i.length+this._lambda*this._unlabeled_data.i.length)}this._prob_wc=l,this._prob_c=e}probability(t){return t.map((t=>{const l=t.map((t=>this._vocabulary.indexOf(t))),e=Array(this._classes.length).fill(0);for(let a=0;a<this._classes.length;a++){e[a]=this._prob_c[a];for(let s=0;s<t.length;s++)e[a]*=this._prob_wc[a][l[s]]}const a=e.reduce(((t,l)=>t+l),0);return e.map((t=>t/a))}))}logLikelihood(){const t=this.probability(this._labeled_data.w),l=this.probability(this._unlabeled_data.w);let e=0;for(let t=0;t<this._classes.length;t++){e+=(this._alpha-1)*Math.log(this._prob_c[t]);for(let l=0;l<this._vocabulary.length;l++)e+=(this._alpha-1)*Math.log(this._prob_wc[t][l])}for(let l=0;l<this._labeled_data.i.length;l++)for(let a=0;a<this._classes.length;a++){let s=Math.log(this._prob_c[a]);for(let t=0;t<this._labeled_data.i[l].length;t++)s+=Math.log(this._prob_wc[a][this._labeled_data.i[l][t]]);e+=t[l][a]*s}for(let t=0;t<this._unlabeled_data.i.length;t++)for(let a=0;a<this._classes.length;a++){let s=Math.log(this._prob_c[a]);for(let l=0;l<this._unlabeled_data.i[t].length;l++)s+=Math.log(this._prob_wc[a][this._unlabeled_data.i[t][l]]);e+=this._lambda*l[t][a]*s}return e}predict(t){return this.probability(t).map((t=>{let l=0,e=-1;for(let a=0;a<this._classes.length;a++)t[a]>l&&(l=t[a],e=a);return e<0?null:this._classes[e]}))}}