export class ILK{constructor(t=1,s=1,i=1,h="gaussian",e="hinge"){if(this._eta=t,this._lambda=s,this._c=i,"function"==typeof h)this._kernel=h;else switch(h){case"gaussian":this._s=1,this._kernel=(t,s)=>Math.exp(-(t.reduce(((t,i,h)=>t+(i-s[h])**2),0)**2)/this._s**2);break;case"polynomial":this._d=2,this._kernel=(t,s)=>(1+t.reduce(((t,i,h)=>t+i*s[h])))**this._d}if("square"===e)this._loss=(t,s,i)=>{const h=this._eta*this._lambda/(1+this._eta*this._lambda);return this._c*(1-h)*(i-(1-h)*t)/(1+this._c*(1-h)*s)};else if("hinge"===e)this._rho=1,this._loss=(t,s,i)=>{const h=this._eta*this._lambda/(1+this._eta*this._lambda),e=i*(this._rho-(1-h)*i*t)/s;return i*e<0?0:i*e>(1-h)*this._c?i*(1-h)*this._c:e};else{if("graph"===e)throw new Error("Not implemented.");"logistic"===e&&(this._loss=(t,s,i)=>{const h=h=>{const e=this._eta*this._lambda/(1+this._eta*this._lambda);return(1-e)*this._c*i/(1+Math.exp(i*(1-e)*t+h*i*s))-h};let e=[0,h(0)],_=[i*this._c,h(i*this._c)];for(;_[0]-e[0]>=1e-8;){const t=(_[0]+e[0])/2,s=h(t);if(0===s)return t;e[1]*s>0?e=[t,s]:_=[t,s]}return(_[0]+e[0])/2})}this._sv=[],this._a=[]}update(t,s){let i=0;for(let s=0;s<this._sv.length;s++)i+=this._a[s]*this._kernel(t,this._sv[s]);const h=this._kernel(t,t),e=this._loss(i,h,s),_=this._eta*this._lambda/(1+this._eta*this._lambda);for(let t=0;t<this._a.length;t++)this._a[t]*=1-_;0!==e&&(this._sv.push(t),this._a.push(e))}fit(t,s){for(let i=0;i<t.length;i++)this.update(t[i],s[i])}predict(t){const s=[];for(let i=0;i<t.length;i++){let h=0;for(let s=0;s<this._sv.length;s++)h+=this._a[s]*this._kernel(t[i],this._sv[s]);s[i]=h<0?-1:1}return s}}export class SILK extends ILK{constructor(t=1,s=1,i=1,h=10,e="gaussian",_="hinge"){super(t,s,i,e,_),this._w=h}update(t,s){if(super.update(t,s),this._sv.length>this._w){let t=1/0,s=-1;for(let i=0;i<this._sv.length;i++)Math.abs(this._a[i])<t&&(t=Math.abs(this._a[i]),s=i);this._a.splice(s,1),this._sv.splice(s,1)}}}