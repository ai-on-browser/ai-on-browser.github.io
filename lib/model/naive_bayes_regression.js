export default class NaiveBayesRegression{constructor(t){this._iscat=t,this._categories=[],this._hx=[],this._hy=[],this._hk=[],this._c_cand=[.4,.5,.6,.7,.8],this._d=50,this._h=null}_gaussian(t){return Math.exp(-(t**2)/2)/Math.sqrt(2*Math.PI)}fit(t,s){this._x=t,this._y=s;const h=t.length;for(let i=0;i<this._iscat.length;i++){const _=t.map((t=>t[i]));if(this._iscat[i]){this._categories[i]={};for(let t=0;t<h;t++)this._categories[i][_[t]]||(this._categories[i][_[t]]=0),this._categories[i][_[t]]++;this._hk[i]={};for(const t of Object.keys(this._categories[i])){let e=1/0;this._hk[i][t]=1;for(const a of this._c_cand){const o=a/Math.sqrt(this._categories[i][t]);let c=0;for(let i=0;i<h;i++){if(_[i]!==t)continue;let e=0;for(let a=0;a<h;a++)i!==a&&_[a]===t&&(e+=this._gaussian((s[a]-s[i])/o));c+=Math.log(e/((h-1)*o))}-c/h<e&&(e=-c/h,this._hk[i][t]=o)}}}else{let t=1/0;this._hx[i]=0,this._hy[i]=0;for(const e of this._c_cand){const a=e/Math.sqrt(h);for(const e of this._c_cand){const o=e/Math.sqrt(h);let c=0;for(let t=0;t<h;t++){let i=0;for(let e=0;e<h;e++)t!==e&&(i+=this._gaussian((_[e]-_[t])/a)*this._gaussian((s[e]-s[t])/o));c+=Math.log(i/((h-1)*a*o))}-c/h<t&&(t=-c/h,this._hx[i]=a,this._hy[i]=o)}}}}this._ymax=-1/0,this._ymin=1/0;for(let t=0;t<h;t++)this._ymax=Math.max(this._ymax,s[t]),this._ymin=Math.min(this._ymin,s[t]);this._h=(this._ymax-this._ymin)/(this._d-1)}predict(t){const s=[],h=this._x.length;for(let i=0;i<t.length;i++){const _=[],e=[];for(let s=-Math.floor(this._d/2);s<=Math.ceil(1.5*this._d);s++){const a=this._ymin+this._h*s;let o=1;for(let s=0;s<this._iscat.length;s++)if(this._iscat[s]){let _=0;for(let e=0;e<h;e++)t[i][s]===this._x[e][s]&&(_+=this._gaussian((a-this._y[e])/this._hk[s][t[i][s]]));o*=_/(h*this._hk[s][t[i][s]])}else{let _=0;for(let e=0;e<h;e++)_+=this._gaussian((t[i][s]-this._x[e][s])/this._hx[s])*this._gaussian((a-this._y[e])/this._hy[s]);o*=_/(h*this._hx[s]*this._hy[s])}_.push(o),e.push(a)}const a=_.reduce(((t,s)=>t+s),0);s[i]=_.reduce(((t,s,h)=>t+s*e[h]),0)/a}return s}}