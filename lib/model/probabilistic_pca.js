var l=Object.defineProperty;var e=(a,t)=>l(a,"name",{value:t,configurable:!0});import s from"../util/matrix.js";export default class r{static{e(this,"ProbabilisticPCA")}constructor(t="analysis",h){this._method=t,this._rd=h}fit(t){t=s.fromArray(t),this._method==="analysis"?this._analysis(t):this._method==="em"?this._em(t):this._method==="bayes"&&this._bayes(t)}_analysis(t){this._m=t.mean(0);const h=t.cov(),[i,_]=h.eigen();this._sigma=0;for(let m=this._rd;m<i.length;m++)this._sigma+=i[m]/(i.length-this._rd);const o=i.slice(0,this._rd).map(m=>Math.sqrt(m-this._sigma));this._w=_.slice(0,this._rd,1).dot(s.diag(o))}_em(t){this._w||(this._w=s.eye(t.cols,this._rd),this._sigma=0,this._m=t.mean(0)),t=s.sub(t,this._m);const h=this._w.tDot(this._w);h.add(s.eye(this._rd,this._rd,this._sigma));const i=h.inv(),_=t.dot(this._w).dot(i.t),o=s.mult(i,this._sigma*t.rows);o.add(_.tDot(_)),this._w=t.tDot(_).dot(o.inv()),this._sigma=(s.mult(t,t).sum()-2*s.mult(_,t.dot(this._w)).sum()+s.mult(o,this._w.tDot(this._w).t).sum())/(t.rows*t.cols)}_bayes(t){this._w||(this._w=s.eye(t.cols,this._rd),this._sigma=0,this._m=t.mean(0),this._alpha=s.ones(1,this._rd).value),t=s.sub(t,this._m);const h=this._w.tDot(this._w);h.add(s.eye(this._rd,this._rd,this._sigma));const i=h.inv(),_=t.dot(this._w).dot(i.t),o=s.mult(i,this._sigma*t.rows);o.add(_.tDot(_));const m=s.diag(this._alpha);m.mult(this._sigma),this._w=t.tDot(_).dot(s.add(o,m).inv()),this._sigma=(s.mult(t,t).sum()-2*s.mult(_,t.dot(this._w)).sum()+s.mult(o,this._w.tDot(this._w).t).sum())/(t.rows*t.cols),this._alpha=s.mult(this._w,this._w).sum(0).value.map(d=>t.cols/d)}predict(t){t=s.fromArray(t),t.sub(this._m);const h=this._w.tDot(this._w),i=this._w.cols;return h.add(s.eye(i,i,this._sigma)),t.dot(this._w).dot(h.inv()).toArray()}}
