var q=Object.defineProperty;var I=(D,n)=>q(D,"name",{value:n,configurable:!0});class M{static{I(this,"Point")}constructor(n,c=null){this._p=n,this.value=c}get x(){return this._p[0]}get y(){return this._p[1]}}class z{static{I(this,"Circle")}constructor(n,c){this._c=n,this._r=c}get center(){return this._c}contains(n){return(n.x-this._c.x)**2+(n.y-this._c.y)**2<this._r**2}}class N{static{I(this,"Triangle")}constructor(n,c,i){this.p=[n,c,i],this.adjoin=[null,null,null],this._circumcircle=null}get p(){return this._p}set p(n){this._p=n,this._circumcircle=null}get circumcircle(){if(this._circumcircle)return this._circumcircle;const[n,c,i]=this._p,t=2*((c.x-n.x)*(i.y-n.y)-(c.y-n.y)*(i.x-n.x))+1e-12,u=c.x**2-n.x**2+c.y**2-n.y**2,p=i.x**2-n.x**2+i.y**2-n.y**2,o=((i.y-n.y)*u+(n.y-c.y)*p)/t,h=((n.x-i.x)*u+(c.x-n.x)*p)/t;return this._circumcircle=new z(new M([o,h]),Math.sqrt((o-n.x)**2+(h-n.y)**2)),this._circumcircle}contains(n){const c=I((t,u,p)=>(t.x-p.x)*(u.y-p.y)-(u.x-p.x)*(t.y-p.y),"outer"),i=[];for(let t=0;t<3;t++){const u=c(n,this.p[t],this.p[(t+1)%3]);if(u!==0){if(i.length>0&&i[i.length-1]!==u<0)return!1;i.push(u<0)}}return!0}contains_circle(n){return this.circumcircle.contains(n)}}class S{static{I(this,"Delaunay2D")}constructor(n){this._points=n;const c=this._points.length,i=[1/0,1/0],t=[-1/0,-1/0];for(let o=0;o<c;o++)for(let h=0;h<2;h++)i[h]=Math.min(i[h],this._points[o]._p[h]),t[h]=Math.max(t[h],this._points[o]._p[h]);for(let o=0;o<2;o++)i[o]-=1,t[o]+=1;const u=[new M([i[0]-(t[1]-i[1]),i[1]]),new M([t[0]+(t[1]-i[1]),i[1]]),new M([(i[0]+t[0])/2,t[1]+(t[0]-i[0])/2])],p=[new N(...u)];for(let o=0;o<c;o++){const h=this._points[o];let _=0;for(;_<p.length&&!p[_].contains(h);_++);const d=p.splice(_,1)[0],s=new N(h,d.p[1],d.p[2]),r=new N(h,d.p[2],d.p[0]),j=new N(h,d.p[0],d.p[1]);s.adjoin=[d.adjoin[0],r,j],r.adjoin=[d.adjoin[1],j,s],j.adjoin=[d.adjoin[2],s,r];const x=[s,r,j];for(let l=0;l<d.adjoin.length;l++){if(!d.adjoin[l])continue;const m=d.adjoin[l].adjoin.indexOf(d);d.adjoin[l].adjoin[m]=x[l]}p.push(...x);const k=x.map(l=>[l,0]);for(;k.length>0;){const[l,m]=k.pop(),f=l.adjoin[m];if(!f)continue;const P=f.adjoin.indexOf(l);if(!l.contains_circle(f.p[P]))continue;const g=(m+1)%3,O=(m+2)%3;let b=(P+1)%3,w=(P+2)%3;(f.p[b].x!==l.p[g].x||f.p[b].y!==l.p[g].y)&&([b,w]=[w,b]);const T=l.p,e=l.adjoin,a=f.adjoin;l.p=[l.p[m],l.p[g],f.p[P]],l.adjoin=[a[w],f,e[O]],a[w]&&(a[w].adjoin[a[w].adjoin.indexOf(f)]=l),f.p=[T[m],T[O],f.p[P]],f.adjoin=[a[b],l,e[g]],e[g]&&(e[g].adjoin[e[g].adjoin.indexOf(l)]=f),k.push([l,0]),k.push([f,0])}}for(let o=p.length-1;o>=0;o--)p[o].p.some(h=>u.some(_=>h.x===_.x&&h.y===_.y))&&p.splice(o,1);this._triangles=p}}export default class C{static{I(this,"NaturalNeighborInterpolation")}fit(n,c){if(n[0].length===1){const i=n.map((t,u)=>[t[0],c[u]]);i.sort((t,u)=>t[0]-u[0]),this._x=i.map(t=>t[0]),this._y=i.map(t=>t[1])}else if(n[0].length===2){const i=n.map((t,u)=>new M(t,c[u]));this._default_delaunay=new S(i)}}predict(n){if(n[0].length===1)return n.map(c=>{const i=this._x.length;if(c[0]<=this._x[0])return this._y[0];if(c[0]>=this._x[i-1])return this._y[i-1];let t=1;for(;t<i&&c[0]>this._x[t];t++);if(c[0]===this._x[t])return this._y[t];const u=(this._x[t-1]+this._x[t])/2,p=(this._x[t-1]+c[0])/2,o=(c[0]+this._x[t])/2,h=u-p,_=o-u;return(h*this._y[t-1]+_*this._y[t])/(h+_)});if(n[0].length===2)return n.map(c=>{const i=new M(c);for(const s of this._default_delaunay._points)if(i.x===s.x&&i.y===s.y)return s.value;const t=new Set;for(const s of this._default_delaunay._triangles)if(s.contains_circle(i))for(let r=0;r<s.p.length;r++)t.add(s.p[r]);if(t.size===0)return null;const p=new S([i,...t])._triangles.filter(s=>s.p.includes(i)),o=new Set;for(const s of p)for(const r of s.p)o.add(r);o.delete(i);for(const s of o)if(p.filter(r=>r.p.includes(s)).length<2)return null;const h=this._default_delaunay._triangles.filter(s=>s.p.every(r=>o.has(r))),_=[];for(const s of o){const r=p.filter(e=>e.p.includes(s)),j=[],x=[];for(let e=0;e<r.length;e++){for(let a=0;a<r[e].p.length;a++)if(r[e].p[a]!==i&&r[e].p[a]!==s){j[e]=r[e].p[a];break}r[e].contains(r[e].circumcircle.center)?x[e]=new M([(j[e].x+s.x)/2,(j[e].y+s.y)/2]):x[e]=r[e].circumcircle.center}const k=[x[1],s,x[0]],l=k.slice(1).reduce((e,a,y)=>e+k[y].x*a.y-a.x*k[y].y,0)/2,m=r.map(e=>e.circumcircle.center),f=[x[0],m[0],m[1],x[1]],P=f.slice(1).reduce((e,a,y)=>e+f[y].x*a.y-a.x*f[y].y,0)/2,g=h.filter(e=>e.p.includes(s)),O=[];let b=j[0];for(;g.length>0;){let e=0;for(;e<g.length&&!g[e].p.includes(b);e++);const a=g.splice(e,1)[0];if(!a)break;O.push(a.circumcircle.center);for(let y=0;y<a.p.length;y++)if(a.p[y]!==b&&a.p[y]!==s){b=a.p[y];break}}const w=[x[0],...O,x[1]],T=w.slice(1).reduce((e,a,y)=>e+w[y].x*a.y-a.x*w[y].y,0)/2;_.push([Math.abs(T+l)-Math.abs(P+l),s.value])}const d=_.reduce((s,r)=>s+r[0],0);return _.reduce((s,r)=>s+r[0]*r[1],0)/d});throw new Error("Invalid data dimension.")}}
