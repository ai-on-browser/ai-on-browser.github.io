class Point{constructor(t,n=null){this._p=t,this.value=n}get x(){return this._p[0]}get y(){return this._p[1]}}class Circle{constructor(t,n){this._c=t,this._r=n}get center(){return this._c}contains(t){return(t.x-this._c.x)**2+(t.y-this._c.y)**2<this._r**2}}class Triangle{constructor(t,n,e){this.p=[t,n,e],this.adjoin=[null,null,null],this._circumcircle=null}get p(){return this._p}set p(t){const[n,e,i]=this._p=t;this._circumcircle=null,this._h=[(e.y-n.y)*(i.value-n.value)-(e.value-n.value)*(i.y-n.y),(e.value-n.value)*(i.x-n.x)-(e.x-n.x)*(i.value-n.value),(e.x-n.x)*(i.y-n.y)-(e.y-n.y)*(i.x-n.x)],this._h[3]=-(this._h[0]*n.x+this._h[1]*n.y+this._h[2]*n.value)}get circumcircle(){if(this._circumcircle)return this._circumcircle;const[t,n,e]=this._p,i=2*((n.x-t.x)*(e.y-t.y)-(n.y-t.y)*(e.x-t.x))+1e-12,s=n.x**2-t.x**2+n.y**2-t.y**2,r=e.x**2-t.x**2+e.y**2-t.y**2,c=((e.y-t.y)*s+(t.y-n.y)*r)/i,o=((t.x-e.x)*s+(n.x-t.x)*r)/i;return this._circumcircle=new Circle(new Point([c,o]),Math.sqrt((c-t.x)**2+(o-t.y)**2)),this._circumcircle}contains(t){const n=[];for(let r=0;r<3;r++){const c=(e=t,i=this.p[r],s=this.p[(r+1)%3],(e.x-s.x)*(i.y-s.y)-(i.x-s.x)*(e.y-s.y));if(0!==c){if(n.length>0&&n[n.length-1]!==c<0)return!1;n.push(c<0)}}var e,i,s;return!0}contains_circle(t){return this.circumcircle.contains(t)}value(t){return-(this._h[0]*t.x+this._h[1]*t.y+this._h[3])/this._h[2]}}class Delaunay2D{constructor(t){this._points=t;const n=this._points.length,e=[1/0,1/0],i=[-1/0,-1/0];for(let t=0;t<n;t++)for(let n=0;n<2;n++)e[n]=Math.min(e[n],this._points[t]._p[n]),i[n]=Math.max(i[n],this._points[t]._p[n]);for(let t=0;t<2;t++)e[t]-=1,i[t]+=1;const s=[new Point([e[0]-(i[1]-e[1]),e[1]]),new Point([i[0]+(i[1]-e[1]),e[1]]),new Point([(e[0]+i[0])/2,i[1]+(i[0]-e[0])/2])],r=[new Triangle(...s)];for(let t=0;t<n;t++){const n=this._points[t];let e=0;for(;e<r.length&&!r[e].contains(n);e++);const i=r.splice(e,1)[0],s=new Triangle(n,i.p[1],i.p[2]),c=new Triangle(n,i.p[2],i.p[0]),o=new Triangle(n,i.p[0],i.p[1]);s.adjoin=[i.adjoin[0],c,o],c.adjoin=[i.adjoin[1],o,s],o.adjoin=[i.adjoin[2],s,c];const l=[s,c,o];for(let t=0;t<i.adjoin.length;t++){if(!i.adjoin[t])continue;const n=i.adjoin[t].adjoin.indexOf(i);i.adjoin[t].adjoin[n]=l[t]}r.push(...l);const a=l.map((t=>[t,0]));for(;a.length>0;){const[t,n]=a.pop(),e=t.adjoin[n];if(!e)continue;const i=e.adjoin.indexOf(t);if(!t.contains_circle(e.p[i]))continue;const s=(n+1)%3,r=(n+2)%3;let c=(i+1)%3,o=(i+2)%3;e.p[c].x===t.p[s].x&&e.p[c].y===t.p[s].y||([c,o]=[o,c]);const l=t.p,h=t.adjoin,u=e.adjoin;t.p=[t.p[n],t.p[s],e.p[i]],t.adjoin=[u[o],e,h[r]],u[o]&&(u[o].adjoin[u[o].adjoin.indexOf(e)]=t),e.p=[l[n],l[r],e.p[i]],e.adjoin=[u[c],t,h[s]],h[s]&&(h[s].adjoin[h[s].adjoin.indexOf(t)]=e),a.push([t,0]),a.push([e,0])}}for(let t=r.length-1;t>=0;t--)r[t].p.some((t=>s.some((n=>t.x===n.x&&t.y===n.y))))&&r.splice(t,1);this._triangles=r}}export default class NaturalNeighborInterpolation{fit(t,n){if(1===t[0].length){const e=t.map(((t,e)=>[t[0],n[e]]));e.sort(((t,n)=>t[0]-n[0])),this._x=e.map((t=>t[0])),this._y=e.map((t=>t[1]))}else if(2===t[0].length){const e=t.map(((t,e)=>new Point(t,n[e])));this._default_delaunay=new Delaunay2D(e)}}predict(t){return 1===t[0].length?t.map((t=>{const n=this._x.length;if(t[0]<=this._x[0])return this._y[0];if(t[0]>=this._x[n-1])return this._y[n-1];let e=1;for(;e<n&&t[0]>this._x[e];e++);if(t[0]===this._x[e])return this._y[e];const i=(this._x[e-1]+this._x[e])/2,s=i-(this._x[e-1]+t[0])/2,r=(t[0]+this._x[e])/2-i;return(s*this._y[e-1]+r*this._y[e])/(s+r)})):2===t[0].length?t.map((t=>{const n=new Point(t);for(const t of this._default_delaunay._points)if(n.x===t.x&&n.y===t.y)return t.value;const e=new Set;for(const t of this._default_delaunay._triangles)if(t.contains_circle(n))for(let n=0;n<t.p.length;n++)e.add(t.p[n]);if(0===e.size)return null;const i=new Delaunay2D([n,...e])._triangles.filter((t=>t.p.indexOf(n)>=0)),s=new Set;for(const t of i)for(const n of t.p)s.add(n);s.delete(n);for(const t of s)if(i.filter((n=>n.p.indexOf(t)>=0)).length<2)return null;const r=this._default_delaunay._triangles.filter((t=>t.p.every((t=>s.has(t))))),c=[];for(const t of s){const e=i.filter((n=>n.p.indexOf(t)>=0)),s=[],o=[];for(let i=0;i<e.length;i++){for(let r=0;r<e[i].p.length;r++)if(e[i].p[r]!==n&&e[i].p[r]!==t){s[i]=e[i].p[r];break}e[i].contains(e[i].circumcircle.center)?o[i]=new Point([(s[i].x+t.x)/2,(s[i].y+t.y)/2]):o[i]=e[i].circumcircle.center}const l=[o[1],t,o[0]],a=l.slice(1).reduce(((t,n,e)=>t+l[e].x*n.y-n.x*l[e].y),0)/2,h=e.map((t=>t.circumcircle.center)),u=[o[0],h[0],h[1],o[1]],p=u.slice(1).reduce(((t,n,e)=>t+u[e].x*n.y-n.x*u[e].y),0)/2,f=r.filter((n=>n.p.indexOf(t)>=0)),_=[];let x=s[0];for(;f.length>0;){let n=0;for(;n<f.length&&!(f[n].p.indexOf(x)>=0);n++);const e=f.splice(n,1)[0];if(!e)break;_.push(e.circumcircle.center);for(let n=0;n<e.p.length;n++)if(e.p[n]!==x&&e.p[n]!==t){x=e.p[n];break}}const y=[o[0],..._,o[1]],d=y.slice(1).reduce(((t,n,e)=>t+y[e].x*n.y-n.x*y[e].y),0)/2;c.push([Math.abs(d+a)-Math.abs(p+a),t.value])}const o=c.reduce(((t,n)=>t+n[0]),0);return c.reduce(((t,n)=>t+n[0]*n[1]),0)/o})):void 0}}