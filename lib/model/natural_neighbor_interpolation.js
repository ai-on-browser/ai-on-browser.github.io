class Point{constructor(t,n=null){this._p=t,this.value=n}get x(){return this._p[0]}get y(){return this._p[1]}}class Circle{constructor(t,n){this._c=t,this._r=n}get center(){return this._c}contains(t){return(t.x-this._c.x)**2+(t.y-this._c.y)**2<this._r**2}}class Triangle{constructor(t,n,i){this.p=[t,n,i],this.adjoin=[null,null,null],this._circumcircle=null}get p(){return this._p}set p(t){this._p=t,this._circumcircle=null}get circumcircle(){if(this._circumcircle)return this._circumcircle;const[t,n,i]=this._p,e=2*((n.x-t.x)*(i.y-t.y)-(n.y-t.y)*(i.x-t.x))+1e-12,r=n.x**2-t.x**2+n.y**2-t.y**2,s=i.x**2-t.x**2+i.y**2-t.y**2,c=((i.y-t.y)*r+(t.y-n.y)*s)/e,o=((t.x-i.x)*r+(n.x-t.x)*s)/e;return this._circumcircle=new Circle(new Point([c,o]),Math.sqrt((c-t.x)**2+(o-t.y)**2)),this._circumcircle}contains(t){const n=[];for(let s=0;s<3;s++){const c=(i=t,e=this.p[s],r=this.p[(s+1)%3],(i.x-r.x)*(e.y-r.y)-(e.x-r.x)*(i.y-r.y));if(0!==c){if(n.length>0&&n[n.length-1]!==c<0)return!1;n.push(c<0)}}var i,e,r;return!0}contains_circle(t){return this.circumcircle.contains(t)}}class Delaunay2D{constructor(t){this._points=t;const n=this._points.length,i=[1/0,1/0],e=[-1/0,-1/0];for(let t=0;t<n;t++)for(let n=0;n<2;n++)i[n]=Math.min(i[n],this._points[t]._p[n]),e[n]=Math.max(e[n],this._points[t]._p[n]);for(let t=0;t<2;t++)i[t]-=1,e[t]+=1;const r=[new Point([i[0]-(e[1]-i[1]),i[1]]),new Point([e[0]+(e[1]-i[1]),i[1]]),new Point([(i[0]+e[0])/2,e[1]+(e[0]-i[0])/2])],s=[new Triangle(...r)];for(let t=0;t<n;t++){const n=this._points[t];let i=0;for(;i<s.length&&!s[i].contains(n);i++);const e=s.splice(i,1)[0],r=new Triangle(n,e.p[1],e.p[2]),c=new Triangle(n,e.p[2],e.p[0]),o=new Triangle(n,e.p[0],e.p[1]);r.adjoin=[e.adjoin[0],c,o],c.adjoin=[e.adjoin[1],o,r],o.adjoin=[e.adjoin[2],r,c];const l=[r,c,o];for(let t=0;t<e.adjoin.length;t++){if(!e.adjoin[t])continue;const n=e.adjoin[t].adjoin.indexOf(e);e.adjoin[t].adjoin[n]=l[t]}s.push(...l);const a=l.map((t=>[t,0]));for(;a.length>0;){const[t,n]=a.pop(),i=t.adjoin[n];if(!i)continue;const e=i.adjoin.indexOf(t);if(!t.contains_circle(i.p[e]))continue;const r=(n+1)%3,s=(n+2)%3;let c=(e+1)%3,o=(e+2)%3;i.p[c].x===t.p[r].x&&i.p[c].y===t.p[r].y||([c,o]=[o,c]);const l=t.p,h=t.adjoin,p=i.adjoin;t.p=[t.p[n],t.p[r],i.p[e]],t.adjoin=[p[o],i,h[s]],p[o]&&(p[o].adjoin[p[o].adjoin.indexOf(i)]=t),i.p=[l[n],l[s],i.p[e]],i.adjoin=[p[c],t,h[r]],h[r]&&(h[r].adjoin[h[r].adjoin.indexOf(t)]=i),a.push([t,0]),a.push([i,0])}}for(let t=s.length-1;t>=0;t--)s[t].p.some((t=>r.some((n=>t.x===n.x&&t.y===n.y))))&&s.splice(t,1);this._triangles=s}}export default class NaturalNeighborInterpolation{fit(t,n){if(1===t[0].length){const i=t.map(((t,i)=>[t[0],n[i]]));i.sort(((t,n)=>t[0]-n[0])),this._x=i.map((t=>t[0])),this._y=i.map((t=>t[1]))}else if(2===t[0].length){const i=t.map(((t,i)=>new Point(t,n[i])));this._default_delaunay=new Delaunay2D(i)}}predict(t){if(1===t[0].length)return t.map((t=>{const n=this._x.length;if(t[0]<=this._x[0])return this._y[0];if(t[0]>=this._x[n-1])return this._y[n-1];let i=1;for(;i<n&&t[0]>this._x[i];i++);if(t[0]===this._x[i])return this._y[i];const e=(this._x[i-1]+this._x[i])/2,r=e-(this._x[i-1]+t[0])/2,s=(t[0]+this._x[i])/2-e;return(r*this._y[i-1]+s*this._y[i])/(r+s)}));if(2===t[0].length)return t.map((t=>{const n=new Point(t);for(const t of this._default_delaunay._points)if(n.x===t.x&&n.y===t.y)return t.value;const i=new Set;for(const t of this._default_delaunay._triangles)if(t.contains_circle(n))for(let n=0;n<t.p.length;n++)i.add(t.p[n]);if(0===i.size)return null;const e=new Delaunay2D([n,...i])._triangles.filter((t=>t.p.indexOf(n)>=0)),r=new Set;for(const t of e)for(const n of t.p)r.add(n);r.delete(n);for(const t of r)if(e.filter((n=>n.p.indexOf(t)>=0)).length<2)return null;const s=this._default_delaunay._triangles.filter((t=>t.p.every((t=>r.has(t))))),c=[];for(const t of r){const i=e.filter((n=>n.p.indexOf(t)>=0)),r=[],o=[];for(let e=0;e<i.length;e++){for(let s=0;s<i[e].p.length;s++)if(i[e].p[s]!==n&&i[e].p[s]!==t){r[e]=i[e].p[s];break}i[e].contains(i[e].circumcircle.center)?o[e]=new Point([(r[e].x+t.x)/2,(r[e].y+t.y)/2]):o[e]=i[e].circumcircle.center}const l=[o[1],t,o[0]],a=l.slice(1).reduce(((t,n,i)=>t+l[i].x*n.y-n.x*l[i].y),0)/2,h=i.map((t=>t.circumcircle.center)),p=[o[0],h[0],h[1],o[1]],u=p.slice(1).reduce(((t,n,i)=>t+p[i].x*n.y-n.x*p[i].y),0)/2,f=s.filter((n=>n.p.indexOf(t)>=0)),_=[];let d=r[0];for(;f.length>0;){let n=0;for(;n<f.length&&!(f[n].p.indexOf(d)>=0);n++);const i=f.splice(n,1)[0];if(!i)break;_.push(i.circumcircle.center);for(let n=0;n<i.p.length;n++)if(i.p[n]!==d&&i.p[n]!==t){d=i.p[n];break}}const x=[o[0],..._,o[1]],y=x.slice(1).reduce(((t,n,i)=>t+x[i].x*n.y-n.x*x[i].y),0)/2;c.push([Math.abs(y+a)-Math.abs(u+a),t.value])}const o=c.reduce(((t,n)=>t+n[0]),0);return c.reduce(((t,n)=>t+n[0]*n[1]),0)/o}));throw new Error("Invalid data dimension.")}}