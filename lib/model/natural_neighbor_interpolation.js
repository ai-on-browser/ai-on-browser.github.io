class Point{constructor(t,n=null){this._p=t,this.value=n}get x(){return this._p[0]}get y(){return this._p[1]}}class Circle{constructor(t,n){this._c=t,this._r=n}get center(){return this._c}contains(t){return(t.x-this._c.x)**2+(t.y-this._c.y)**2<this._r**2}}class Triangle{constructor(t,n,i){this.p=[t,n,i],this.adjoin=[null,null,null],this._circumcircle=null}get p(){return this._p}set p(t){this._p=t,this._circumcircle=null}get circumcircle(){if(this._circumcircle)return this._circumcircle;const[t,n,i]=this._p,e=2*((n.x-t.x)*(i.y-t.y)-(n.y-t.y)*(i.x-t.x))+1e-12,s=n.x**2-t.x**2+n.y**2-t.y**2,r=i.x**2-t.x**2+i.y**2-t.y**2,c=((i.y-t.y)*s+(t.y-n.y)*r)/e,o=((t.x-i.x)*s+(n.x-t.x)*r)/e;return this._circumcircle=new Circle(new Point([c,o]),Math.sqrt((c-t.x)**2+(o-t.y)**2)),this._circumcircle}contains(t){const n=[];for(let r=0;r<3;r++){const c=(i=t,e=this.p[r],s=this.p[(r+1)%3],(i.x-s.x)*(e.y-s.y)-(e.x-s.x)*(i.y-s.y));if(0!==c){if(n.length>0&&n[n.length-1]!==c<0)return!1;n.push(c<0)}}var i,e,s;return!0}contains_circle(t){return this.circumcircle.contains(t)}}class Delaunay2D{constructor(t){this._points=t;const n=this._points.length,i=[1/0,1/0],e=[-1/0,-1/0];for(let t=0;t<n;t++)for(let n=0;n<2;n++)i[n]=Math.min(i[n],this._points[t]._p[n]),e[n]=Math.max(e[n],this._points[t]._p[n]);for(let t=0;t<2;t++)i[t]-=1,e[t]+=1;const s=[new Point([i[0]-(e[1]-i[1]),i[1]]),new Point([e[0]+(e[1]-i[1]),i[1]]),new Point([(i[0]+e[0])/2,e[1]+(e[0]-i[0])/2])],r=[new Triangle(...s)];for(let t=0;t<n;t++){const n=this._points[t];let i=0;for(;i<r.length&&!r[i].contains(n);i++);const e=r.splice(i,1)[0],s=new Triangle(n,e.p[1],e.p[2]),c=new Triangle(n,e.p[2],e.p[0]),o=new Triangle(n,e.p[0],e.p[1]);s.adjoin=[e.adjoin[0],c,o],c.adjoin=[e.adjoin[1],o,s],o.adjoin=[e.adjoin[2],s,c];const l=[s,c,o];for(let t=0;t<e.adjoin.length;t++){if(!e.adjoin[t])continue;const n=e.adjoin[t].adjoin.indexOf(e);e.adjoin[t].adjoin[n]=l[t]}r.push(...l);const a=l.map((t=>[t,0]));for(;a.length>0;){const[t,n]=a.pop(),i=t.adjoin[n];if(!i)continue;const e=i.adjoin.indexOf(t);if(!t.contains_circle(i.p[e]))continue;const s=(n+1)%3,r=(n+2)%3;let c=(e+1)%3,o=(e+2)%3;i.p[c].x===t.p[s].x&&i.p[c].y===t.p[s].y||([c,o]=[o,c]);const l=t.p,h=t.adjoin,u=i.adjoin;t.p=[t.p[n],t.p[s],i.p[e]],t.adjoin=[u[o],i,h[r]],u[o]&&(u[o].adjoin[u[o].adjoin.indexOf(i)]=t),i.p=[l[n],l[r],i.p[e]],i.adjoin=[u[c],t,h[s]],h[s]&&(h[s].adjoin[h[s].adjoin.indexOf(t)]=i),a.push([t,0]),a.push([i,0])}}for(let t=r.length-1;t>=0;t--)r[t].p.some((t=>s.some((n=>t.x===n.x&&t.y===n.y))))&&r.splice(t,1);this._triangles=r}}export default class NaturalNeighborInterpolation{fit(t,n){if(1===t[0].length){const i=t.map(((t,i)=>[t[0],n[i]]));i.sort(((t,n)=>t[0]-n[0])),this._x=i.map((t=>t[0])),this._y=i.map((t=>t[1]))}else if(2===t[0].length){const i=t.map(((t,i)=>new Point(t,n[i])));this._default_delaunay=new Delaunay2D(i)}}predict(t){if(1===t[0].length)return t.map((t=>{const n=this._x.length;if(t[0]<=this._x[0])return this._y[0];if(t[0]>=this._x[n-1])return this._y[n-1];let i=1;for(;i<n&&t[0]>this._x[i];i++);if(t[0]===this._x[i])return this._y[i];const e=(this._x[i-1]+this._x[i])/2,s=e-(this._x[i-1]+t[0])/2,r=(t[0]+this._x[i])/2-e;return(s*this._y[i-1]+r*this._y[i])/(s+r)}));if(2===t[0].length)return t.map((t=>{const n=new Point(t);for(const t of this._default_delaunay._points)if(n.x===t.x&&n.y===t.y)return t.value;const i=new Set;for(const t of this._default_delaunay._triangles)if(t.contains_circle(n))for(let n=0;n<t.p.length;n++)i.add(t.p[n]);if(0===i.size)return null;const e=new Delaunay2D([n,...i])._triangles.filter((t=>t.p.includes(n))),s=new Set;for(const t of e)for(const n of t.p)s.add(n);s.delete(n);for(const t of s)if(e.filter((n=>n.p.includes(t))).length<2)return null;const r=this._default_delaunay._triangles.filter((t=>t.p.every((t=>s.has(t))))),c=[];for(const t of s){const i=e.filter((n=>n.p.includes(t))),s=[],o=[];for(let e=0;e<i.length;e++){for(let r=0;r<i[e].p.length;r++)if(i[e].p[r]!==n&&i[e].p[r]!==t){s[e]=i[e].p[r];break}i[e].contains(i[e].circumcircle.center)?o[e]=new Point([(s[e].x+t.x)/2,(s[e].y+t.y)/2]):o[e]=i[e].circumcircle.center}const l=[o[1],t,o[0]],a=l.slice(1).reduce(((t,n,i)=>t+l[i].x*n.y-n.x*l[i].y),0)/2,h=i.map((t=>t.circumcircle.center)),u=[o[0],h[0],h[1],o[1]],p=u.slice(1).reduce(((t,n,i)=>t+u[i].x*n.y-n.x*u[i].y),0)/2,f=r.filter((n=>n.p.includes(t))),_=[];let d=s[0];for(;f.length>0;){let n=0;for(;n<f.length&&!f[n].p.includes(d);n++);const i=f.splice(n,1)[0];if(!i)break;_.push(i.circumcircle.center);for(let n=0;n<i.p.length;n++)if(i.p[n]!==d&&i.p[n]!==t){d=i.p[n];break}}const x=[o[0],..._,o[1]],y=x.slice(1).reduce(((t,n,i)=>t+x[i].x*n.y-n.x*x[i].y),0)/2;c.push([Math.abs(y+a)-Math.abs(p+a),t.value])}const o=c.reduce(((t,n)=>t+n[0]),0);return c.reduce(((t,n)=>t+n[0]*n[1]),0)/o}));throw new Error("Invalid data dimension.")}}