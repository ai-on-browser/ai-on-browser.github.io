var m=Object.defineProperty;var n=(h,t)=>m(h,"name",{value:t,configurable:!0});import l from"../util/matrix.js";class c{static{n(this,"Gaussian")}constructor(){this._means=null,this._vars=null}_estimate_prob(t){this._means=t.mean(0),this._vars=t.variance(0)}_data_prob(t){const a=l.sub(t,this._means);return a.mult(a),a.div(this._vars),a.map(s=>Math.exp(-s/2)),a.div(l.map(this._vars,s=>Math.sqrt(2*Math.PI*s))),a.prod(1)}}export default class u{static{n(this,"NegationNaiveBayes")}constructor(t="gaussian"){this._labels=[],this._rate=[],t==="gaussian"&&(this._p_class=c),this._p=[]}fit(t,a){this._labels=[...new Set(a)],this._p=[],this._rate=[];for(let s=0;s<this._labels.length;s++){const e=l.fromArray(t.filter((r,i)=>a[i]!==this._labels[s]));this._p[s]=new this._p_class,this._p[s]._estimate_prob(e),this._rate[s]=1-e.rows/t.length}}predict(t){const a=l.fromArray(t),s=[];for(let e=0;e<this._labels.length;e++){const r=this._p[e]._data_prob(a);r.map(i=>1/(1-this._rate[e])/i),s.push(r)}return t.map((e,r)=>{let i=0,o=-1;for(let _=0;_<this._labels.length;_++){let p=s[_].value[r];p>i&&(i=p,o=_)}return this._labels[o]})}}
