var c=Object.defineProperty;var n=(l,t)=>c(l,"name",{value:t,configurable:!0});import h from"../util/matrix.js";class m{static{n(this,"Gaussian")}constructor(){this._means=null,this._vars=null}_estimate_prob(t){this._means=t.mean(0),this._vars=t.variance(0)}_data_prob(t){const a=h.sub(t,this._means);return a.mult(a),a.div(this._vars),a.map(s=>Math.exp(-s/2)),a.div(h.map(this._vars,s=>Math.sqrt(2*Math.PI*s))),a.prod(1)}}export default class u{static{n(this,"NegationNaiveBayes")}constructor(t="gaussian"){this._labels=[],this._rate=[],t==="gaussian"&&(this._p_class=m),this._p=[]}fit(t,a){this._labels=[...new Set(a)],this._p=[],this._rate=[];for(let s=0;s<this._labels.length;s++){const i=h.fromArray(t.filter((r,e)=>a[e]!==this._labels[s]));this._p[s]=new this._p_class,this._p[s]._estimate_prob(i),this._rate[s]=1-i.rows/t.length}}predict(t){const a=h.fromArray(t),s=[];for(let i=0;i<this._labels.length;i++){const r=this._p[i]._data_prob(a);r.map(e=>1/(1-this._rate[i])/e),s.push(r)}return t.map((i,r)=>{let e=0,o=-1;for(let _=0;_<this._labels.length;_++){const p=s[_].value[r];p>e&&(e=p,o=_)}return this._labels[o]})}}
