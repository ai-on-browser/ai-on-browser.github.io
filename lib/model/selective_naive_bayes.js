var u=Object.defineProperty;var c=(p,e)=>u(p,"name",{value:e,configurable:!0});import r from"../util/matrix.js";class f{static{c(this,"Gaussian")}constructor(){this._means=null,this._vars=null}_estimate_prob(e){this._means=e.mean(0),this._vars=e.variance(0)}_data_prob(e){const i=r.sub(e,this._means);return i.mult(i),i.div(this._vars),i.map(t=>Math.exp(-t/2)),i.div(r.map(this._vars,t=>Math.sqrt(2*Math.PI*t))),i.prod(1)}}export default class v{static{c(this,"SelectiveNaiveBayes")}constructor(e="gaussian"){this._labels=[],this._rate=[],this._ratec=[],e==="gaussian"&&(this._p_class=f),this._p=[],this._pc=[]}fit(e,i){this._labels=[...new Set(i)],this._p=[],this._pc=[],this._rate=[],this._ratec=[];for(let t=0;t<this._labels.length;t++){const h=r.fromArray(e.filter((s,a)=>i[a]===this._labels[t])),l=r.fromArray(e.filter((s,a)=>i[a]!==this._labels[t]));this._p[t]=new this._p_class,this._p[t]._estimate_prob(h),this._pc[t]=new this._p_class,this._pc[t]._estimate_prob(l),this._rate[t]=h.rows/e.length,this._ratec[t]=l.rows/e.length}}predict(e){const i=r.fromArray(e),t=[],h=r.zeros(i.rows,1),l=r.zeros(i.rows,1);for(let s=0;s<this._labels.length;s++){const a=this._p[s]._data_prob(i);a.mult(this._rate[s]);const _=this._pc[s]._data_prob(i);_.mult(this._ratec[s]),this._rate[s]>=.5?t.push(a):t.push(_),h.add(a),l.add(_)}for(let s=0;s<this._labels.length;s++)this._rate[s]>=.5?t[s].div(h):(t[s].div(l),t[s].map(a=>1-(this._labels.length-1)*a));return e.map((s,a)=>{let _=0,n=-1;for(let o=0;o<this._labels.length;o++){let m=t[o].value[a];m>_&&(_=m,n=o)}return this._labels[n]})}}
