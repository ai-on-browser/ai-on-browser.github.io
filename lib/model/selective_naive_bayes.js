import Matrix from"../util/matrix.js";class Gaussian{constructor(){this._means=null,this._vars=null}_estimate_prob(t){this._means=t.mean(0),this._vars=t.variance(0)}_data_prob(t){const s=Matrix.sub(t,this._means);return s.mult(s),s.div(this._vars),s.map((t=>Math.exp(-t/2))),s.div(Matrix.map(this._vars,(t=>Math.sqrt(2*Math.PI*t)))),s.prod(1)}}export default class SelectiveNaiveBayes{constructor(t="gaussian"){this._labels=[],this._rate=[],this._ratec=[],"gaussian"===t&&(this._p_class=Gaussian),this._p=[],this._pc=[]}fit(t,s){this._labels=[...new Set(s)],this._p=[],this._pc=[],this._rate=[],this._ratec=[];for(let a=0;a<this._labels.length;a++){const i=Matrix.fromArray(t.filter(((t,i)=>s[i]===this._labels[a]))),r=Matrix.fromArray(t.filter(((t,i)=>s[i]!==this._labels[a])));this._p[a]=new this._p_class,this._p[a]._estimate_prob(i),this._pc[a]=new this._p_class,this._pc[a]._estimate_prob(r),this._rate[a]=i.rows/t.length,this._ratec[a]=r.rows/t.length}}predict(t){const s=Matrix.fromArray(t),a=[],i=Matrix.zeros(s.rows,1),r=Matrix.zeros(s.rows,1);for(let t=0;t<this._labels.length;t++){const e=this._p[t]._data_prob(s);e.mult(this._rate[t]);const _=this._pc[t]._data_prob(s);_.mult(this._ratec[t]),this._rate[t]>=.5?a.push(e):a.push(_),i.add(e),r.add(_)}for(let t=0;t<this._labels.length;t++)this._rate[t]>=.5?a[t].div(i):(a[t].div(r),a[t].map((t=>1-(this._labels.length-1)*t)));return t.map(((t,s)=>{let i=0,r=-1;for(let t=0;t<this._labels.length;t++){let e=a[t].value[s];e>i&&(i=e,r=t)}return this._labels[r]}))}}