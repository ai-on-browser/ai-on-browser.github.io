import Tree from"../util/tree.js";import{Matrix}from"../util/math.js";export default class SplitAndMerge{constructor(t="variance",e=.1){this._method=t,this._threshold=e}_shouldSplit(t){if(t=Matrix.fromArray(t.flat()),"variance"===this._method){if(t.variance(0).mean()>this._threshold)return!0}else if("uniformity"===this._method){const e=t.mean(1);if(e.sub(e.mean()),e.map(Math.abs),e.max()>this._threshold)return!0}return!1}predict(t){this._x=t;let e=0;const o=new Tree({data:t,category:e++,range:[[0,t.length],[0,t[0].length]]}),r=[o];for(;r.length>0;){const t=r.pop(),o=t.value.data;if(o.length<=1||o[0].length<=1)continue;const a=t.value.range;if(this._shouldSplit(o)){const n=a.map((t=>t[1]-t[0])),s=n.map((t=>Math.floor(t/2))),l=[];for(let t=0;t<2**n.length;t++){const e=t.toString(2).padStart(n.length,"0").split("").map((t=>!!+t));l.push(e.map(((t,e)=>t?[0,s[e]]:[s[e],n[e]])))}for(const[n,s]of l){const l=[];for(let t=n[0];t<n[1];t++){const e=[];for(let r=s[0];r<s[1];r++)e.push(o[t][r]);l.push(e)}const h=new Tree({data:l,category:e++,range:[[a[0][0]+n[0],a[0][0]+n[1]],[a[1][0]+s[0],a[1][0]+s[1]]]});t.push(h),r.push(h)}}}const a=o.leafValues();for(let t=0;t<a.length;t++){const e=a[t].range;for(let o=0;o<a.length;o++){if(a[t].category===a[o].category)continue;const r=a[o].range;let n=!1;for(let t=0;t<r.length;t++)r[t][0]!==e[t][1]&&r[t][1]!==e[t][0]||r.every(((o,a)=>a===t||r[a][0]<e[a][1]&&e[a][0]<r[a][1]))&&(n=!0);if(!n)continue;const s=a.filter((e=>e.category===a[t].category||e.category===a[o].category)),l=[];for(const t of s)l.push(...t.data.flat());if(!this._shouldSplit(l)){const e=Math.min(a[t].category,a[o].category);for(const t of s)t.category=e}}}const n=[];for(let t=0;t<this._x.length;n[t++]=[]);return o.scanLeaf((t=>{const e=t.value.range;for(let o=e[0][0];o<e[0][1];o++)for(let r=e[1][0];r<e[1][1];r++)n[o][r]=t.value.category})),n}}