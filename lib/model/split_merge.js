import Matrix from"../util/matrix.js";export default class SplitAndMerge{constructor(t="variance",e=.1){this._method=t,this._threshold=e}_shouldSplit(t){if(t=Matrix.fromArray(t.flat()),"variance"===this._method){if(t.variance(0).mean()>this._threshold)return!0}else if("uniformity"===this._method){const e=t.mean(1);if(e.sub(e.mean()),e.map(Math.abs),e.max()>this._threshold)return!0}return!1}predict(t){this._x=t;let e=0;const r={data:t,category:e++,range:[[0,t.length],[0,t[0].length]],children:[],get leafs(){return 0===this.children.length?[this]:this.children.reduce(((t,e)=>t.concat(e.leafs)),[])}},o=[r];for(;o.length>0;){const t=o.pop(),r=t.data;if(r.length<=1||r[0].length<=1)continue;const n=t.range;if(this._shouldSplit(r)){const a=n.map((t=>t[1]-t[0])),s=a.map((t=>Math.floor(t/2))),h=[];for(let t=0;t<2**a.length;t++){const e=t.toString(2).padStart(a.length,"0").split("").map((t=>!!+t));h.push(e.map(((t,e)=>t?[0,s[e]]:[s[e],a[e]])))}for(const[a,s]of h){const h=[];for(let t=a[0];t<a[1];t++){const e=[];for(let o=s[0];o<s[1];o++)e.push(r[t][o]);h.push(e)}const l={data:h,category:e++,range:[[n[0][0]+a[0],n[0][0]+a[1]],[n[1][0]+s[0],n[1][0]+s[1]]],children:[],get leafs(){return 0===this.children.length?[this]:this.children.reduce(((t,e)=>t.concat(e.leafs)),[])}};t.children.push(l),o.push(l)}}}const n=r.leafs;for(let t=0;t<n.length;t++){const e=n[t].range;for(let r=0;r<n.length;r++){if(n[t].category===n[r].category)continue;const o=n[r].range;let a=!1;for(let t=0;t<o.length;t++)o[t][0]!==e[t][1]&&o[t][1]!==e[t][0]||o.every(((r,n)=>n===t||o[n][0]<e[n][1]&&e[n][0]<o[n][1]))&&(a=!0);if(!a)continue;const s=n.filter((e=>e.category===n[t].category||e.category===n[r].category)),h=[];for(const t of s)h.push(...t.data.flat());if(!this._shouldSplit(h)){const e=Math.min(n[t].category,n[r].category);for(const t of s)t.category=e}}}const a=[];for(let t=0;t<this._x.length;a[t++]=[]);return r.leafs.forEach((t=>{const e=t.range;for(let r=e[0][0];r<e[0][1];r++)for(let o=e[1][0];o<e[1][1];o++)a[r][o]=t.category})),a}}