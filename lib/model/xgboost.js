var g=Object.defineProperty;var n=(_,r)=>g(_,"name",{value:r,configurable:!0});import c from"../util/matrix.js";class d{static{n(this,"XGBoostTree")}constructor(r=.1,t=.8){this._lambda=r,this._fsrate=t,this._g=(e,s)=>-2*s.reduce((i,l,a)=>i+(l-e[a]),0),this._h=(e,s)=>2}_sample(r){const t=Array.from({length:r},(e,s)=>s);for(let e=r-1;e>0;e--){let s=Math.floor(Math.random()*(e+1));[t[e],t[s]]=[t[s],t[e]]}return t.slice(0,Math.ceil(r*this._fsrate))}init(r,t){this._feature=this._sample(r[0].length),this._datas=r.map((e,s)=>({value:this._feature.map(i=>e[i]),target:t[s]})),this._tree={datas:this._datas,value:this._calcValue(this._datas),score:this._calcScore(this._datas)},this._leafs=[this._tree]}fit(){const r=[];this._leafs.forEach(t=>{let e=t.score,s=-1,i=-1;for(let l=0;l<this._feature.length;l++){const a=t.datas.map(h=>h.value[l]);a.sort((h,o)=>h-o);for(let h=0;h<a.length-1;h++){const o=(a[h]+a[h+1])/2,f=t.datas.filter(u=>u.value[l]<o),m=t.datas.filter(u=>u.value[l]>=o),p=(this._calcScore(f)*f.length+this._calcScore(m)*m.length)/a.length;p<e&&(e=p,s=l,i=o)}}if(e<t.score){t.feature=s,t.threshold=i;const l=t.datas.filter(h=>h.value[s]<i),a=t.datas.filter(h=>h.value[s]>=i);t.children=[{datas:l,score:this._calcScore(l),value:this._calcValue(l)},{datas:a,score:this._calcScore(a),value:this._calcValue(a)}],r.push(...t.children)}}),this._leafs=r}_calcValue(r){if(r.length===0)return 0;const t=r[0].target.length,e=Array(t).fill(0);for(let s=0;s<r.length;s++)for(let i=0;i<t;i++)e[i]+=r[s].target[i];return e.map(s=>s/r.length)}_calcScore(r){if(r.length===0)return 0;const t=this._calcValue(r),e=r.reduce((i,l)=>i+this._g(t,l.target),0),s=r.reduce((i,l)=>i+this._h(t,l.target),0);return e*e/(s+this._lambda)/2*r.length}predict(r){return r.map(t=>{t=this._feature.map(s=>t[s]);let e=this._tree;for(;e.children;)e=e.children[t[e.feature]<e.threshold?0:1];return e.value})}}export class XGBoost{static{n(this,"XGBoost")}constructor(r=1,t=1,e=.1,s=.5){this._trees=[],this._r=[],this._maxd=r,this._srate=t,this._lambda=e,this._learning_rate=s}get size(){return this._trees.length}_sample(r){const t=Array.from({length:r},(e,s)=>s);for(let e=r-1;e>0;e--){const s=Math.floor(Math.random()*(e+1));[t[e],t[s]]=[t[s],t[e]]}return t.slice(0,Math.ceil(r*this._srate))}init(r,t){this._x=r,this._y=c.fromArray(t),this._loss=this._y.copy()}fit(){const r=new d(this._lambda),t=this._sample(this._x.length);r.init(t.map(i=>this._x[i]),this._loss.row(t).toArray());for(let i=0;i<this._maxd;i++)r.fit();this._trees.push(r);let e=this._learning_rate;const s=c.fromArray(r.predict(this._x));if(!e){const i=s.tDot(s),l=this._loss.cols;i.add(c.eye(l,l,1e-8)),e=i.solve(s.tDot(this._loss)).diag().reduce((h,o)=>h+o,0)/l}this._r.push(e),s.mult(e),this._loss.sub(s)}predict(r){const t=this._trees.map(s=>c.fromArray(s.predict(r))),e=c.zeros(r.length,this._y.cols);for(let s=0;s<t.length;s++)t[s].mult(this._r[s]),e.add(t[s]);return e.value}}export class XGBoostClassifier extends XGBoost{static{n(this,"XGBoostClassifier")}constructor(r=1,t=1,e=.1,s=0){super(r,t,e,s)}init(r,t){this._x=r,this._cls=[...new Set(t)],this._y=c.zeros(t.length,this._cls.length);for(let e=0;e<this._y.rows;e++)this._y.set(e,this._cls.indexOf(t[e]),1);this._loss=this._y.copy()}predict(r){const t=this._trees.map(s=>c.fromArray(s.predict(r))),e=c.zeros(r.length,this._y.cols);for(let s=0;s<t.length;s++)t[s].mult(this._r[s]),e.add(t[s]);return e.argmax(1).value.map(s=>this._cls[s])}}
