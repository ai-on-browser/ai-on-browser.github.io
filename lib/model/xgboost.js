import{Matrix}from"../util/math.js";import{DecisionTreeRegression}from"./decision_tree.js";class XGBoostTree extends DecisionTreeRegression{constructor(t=.1){super(),this._lambda=t,this._g=(t,s)=>-2*(s-t),this._h=(t,s)=>2}_calcScore(t){if(0===t.length)return 0;const s=this._calcValue(t);if(Array.isArray(t[0].target)){const r=t.reduce(((t,r)=>t+r.target.reduce(((t,r,e)=>t+this._g(s[e],r)),0)),0);return r*r/(t.reduce(((t,r)=>t+this._h(s,r.target)),0)+this._lambda)/2*t.length}{const r=t.reduce(((t,r)=>t+this._g(s,r.target)),0);return r*r/(t.reduce(((t,r)=>t+this._h(s,r.target)),0)+this._lambda)/2*t.length}}}export class XGBoost{constructor(t=1,s=1,r=.1,e=.5){this._trees=[],this._r=[],this._maxd=t,this._srate=s,this._lambda=r,this._learning_rate=e}get size(){return this._trees.length}_sample(t){const s=[];for(let r=0;r<t;r++)s[r]=r;for(let r=t-1;r>0;r--){let t=Math.floor(Math.random()*(r+1));[s[r],s[t]]=[s[t],s[r]]}return s.slice(0,Math.ceil(t*this._srate))}init(t,s){this._x=t,this._y=Matrix.fromArray(s),this._loss=this._y.copy()}fit(){const t=new XGBoostTree(this._lambda),s=this._sample(this._x.length);t.init(s.map((t=>this._x[t])),this._loss.row(s).toArray());for(let s=0;s<this._maxd;s++)t.fit();this._trees.push(t);let r=this._learning_rate;const e=Matrix.fromArray(t.predict(this._x));if(!r){const t=e.tDot(e),s=this._loss.cols;t.add(Matrix.eye(s,s,1e-8));r=t.solve(e.tDot(this._loss)).diag().reduce(((t,s)=>t+s),0)/s}this._r.push(r),e.mult(r),this._loss.sub(e)}predict(t){const s=this._trees.map((s=>Matrix.fromArray(s.predict(t)))),r=Matrix.zeros(this._y.rows,this._y.cols);for(let t=0;t<s.length;t++)s[t].mult(this._r[t]),r.add(s[t]);return r.value}}export class XGBoostClassifier extends XGBoost{constructor(t=1,s=1,r=.1,e=0){super(t,s,r,e)}init(t,s){this._x=t,this._cls=[...new Set(s)],this._y=Matrix.zeros(s.length,this._cls.length);for(let t=0;t<this._y.rows;t++)this._y.set(t,this._cls.indexOf(s[t]),1);this._loss=this._y.copy()}predict(t){const s=this._trees.map((s=>Matrix.fromArray(s.predict(t)))),r=Matrix.zeros(this._y.rows,this._y.cols);for(let t=0;t<s.length;t++)s[t].mult(this._r[t]),r.add(s[t]);return r.argmax(1).value.map((t=>this._cls[t]))}}