import Matrix from"../util/matrix.js";class XGBoostTree{constructor(t=.1,e=.8){this._lambda=t,this._fsrate=e,this._g=(t,e)=>-2*e.reduce(((e,s,r)=>e+(s-t[r])),0),this._h=(t,e)=>2}_sample(t){const e=Array.from({length:t},((t,e)=>e));for(let s=t-1;s>0;s--){let t=Math.floor(Math.random()*(s+1));[e[s],e[t]]=[e[t],e[s]]}return e.slice(0,Math.ceil(t*this._fsrate))}init(t,e){this._feature=this._sample(t[0].length),this._datas=t.map(((t,s)=>({value:this._feature.map((e=>t[e])),target:e[s]}))),this._tree={datas:this._datas,value:this._calcValue(this._datas),score:this._calcScore(this._datas)},this._leafs=[this._tree]}fit(){const t=[];this._leafs.forEach((e=>{let s=e.score,r=-1,a=-1;for(let t=0;t<this._feature.length;t++){const i=e.datas.map((e=>e.value[t]));i.sort(((t,e)=>t-e));for(let l=0;l<i.length-1;l++){const h=(i[l]+i[l+1])/2,o=e.datas.filter((e=>e.value[t]<h)),c=e.datas.filter((e=>e.value[t]>=h)),_=(this._calcScore(o)*o.length+this._calcScore(c)*c.length)/i.length;_<s&&(s=_,r=t,a=h)}}if(s<e.score){e.feature=r,e.threshold=a;const s=e.datas.filter((t=>t.value[r]<a)),i=e.datas.filter((t=>t.value[r]>=a));e.children=[{datas:s,score:this._calcScore(s),value:this._calcValue(s)},{datas:i,score:this._calcScore(i),value:this._calcValue(i)}],t.push(...e.children)}})),this._leafs=t}_calcValue(t){if(0===t.length)return 0;const e=t[0].target.length,s=Array(e).fill(0);for(let r=0;r<t.length;r++)for(let a=0;a<e;a++)s[a]+=t[r].target[a];return s.map((e=>e/t.length))}_calcScore(t){if(0===t.length)return 0;const e=this._calcValue(t),s=t.reduce(((t,s)=>t+this._g(e,s.target)),0);return s*s/(t.reduce(((t,s)=>t+this._h(e,s.target)),0)+this._lambda)/2*t.length}predict(t){return t.map((t=>{t=this._feature.map((e=>t[e]));let e=this._tree;for(;e.children;)e=e.children[t[e.feature]<e.threshold?0:1];return e.value}))}}export class XGBoost{constructor(t=1,e=1,s=.1,r=.5){this._trees=[],this._r=[],this._maxd=t,this._srate=e,this._lambda=s,this._learning_rate=r}get size(){return this._trees.length}_sample(t){const e=Array.from({length:t},((t,e)=>e));for(let s=t-1;s>0;s--){const t=Math.floor(Math.random()*(s+1));[e[s],e[t]]=[e[t],e[s]]}return e.slice(0,Math.ceil(t*this._srate))}init(t,e){this._x=t,this._y=Matrix.fromArray(e),this._loss=this._y.copy()}fit(){const t=new XGBoostTree(this._lambda),e=this._sample(this._x.length);t.init(e.map((t=>this._x[t])),this._loss.row(e).toArray());for(let e=0;e<this._maxd;e++)t.fit();this._trees.push(t);let s=this._learning_rate;const r=Matrix.fromArray(t.predict(this._x));if(!s){const t=r.tDot(r),e=this._loss.cols;t.add(Matrix.eye(e,e,1e-8));s=t.solve(r.tDot(this._loss)).diag().reduce(((t,e)=>t+e),0)/e}this._r.push(s),r.mult(s),this._loss.sub(r)}predict(t){const e=this._trees.map((e=>Matrix.fromArray(e.predict(t)))),s=Matrix.zeros(t.length,this._y.cols);for(let t=0;t<e.length;t++)e[t].mult(this._r[t]),s.add(e[t]);return s.value}}export class XGBoostClassifier extends XGBoost{constructor(t=1,e=1,s=.1,r=0){super(t,e,s,r)}init(t,e){this._x=t,this._cls=[...new Set(e)],this._y=Matrix.zeros(e.length,this._cls.length);for(let t=0;t<this._y.rows;t++)this._y.set(t,this._cls.indexOf(e[t]),1);this._loss=this._y.copy()}predict(t){const e=this._trees.map((e=>Matrix.fromArray(e.predict(t)))),s=Matrix.zeros(t.length,this._y.cols);for(let t=0;t<e.length;t++)e[t].mult(this._r[t]),s.add(e[t]);return s.argmax(1).value.map((t=>this._cls[t]))}}