import Matrix from"../util/matrix.js";import{DecisionTreeRegression}from"./decision_tree.js";class XGBoostTree extends DecisionTreeRegression{constructor(t=.1){super(),this._lambda=t,this._g=(t,s)=>-2*(s-t),this._h=(t,s)=>2}_calcScore(t){if(0===t.length)return 0;const s=this._calcValue(t);if(Array.isArray(t[0].target)){const e=t.reduce(((t,e)=>t+e.target.reduce(((t,e,r)=>t+this._g(s[r],e)),0)),0);return e*e/(t.reduce(((t,e)=>t+this._h(s,e.target)),0)+this._lambda)/2*t.length}{const e=t.reduce(((t,e)=>t+this._g(s,e.target)),0);return e*e/(t.reduce(((t,e)=>t+this._h(s,e.target)),0)+this._lambda)/2*t.length}}}export class XGBoost{constructor(t=1,s=1,e=.1,r=.5){this._trees=[],this._r=[],this._maxd=t,this._srate=s,this._lambda=e,this._learning_rate=r}get size(){return this._trees.length}_sample(t){const s=[];for(let e=0;e<t;e++)s[e]=e;for(let e=t-1;e>0;e--){let t=Math.floor(Math.random()*(e+1));[s[e],s[t]]=[s[t],s[e]]}return s.slice(0,Math.ceil(t*this._srate))}init(t,s){this._x=t,this._y=Matrix.fromArray(s),this._loss=this._y.copy()}fit(){const t=new XGBoostTree(this._lambda),s=this._sample(this._x.length);t.init(s.map((t=>this._x[t])),this._loss.row(s).toArray());for(let s=0;s<this._maxd;s++)t.fit();this._trees.push(t);let e=this._learning_rate;const r=Matrix.fromArray(t.predict(this._x));if(!e){const t=r.tDot(r),s=this._loss.cols;t.add(Matrix.eye(s,s,1e-8));e=t.solve(r.tDot(this._loss)).diag().reduce(((t,s)=>t+s),0)/s}this._r.push(e),r.mult(e),this._loss.sub(r)}predict(t){const s=this._trees.map((s=>Matrix.fromArray(s.predict(t)))),e=Matrix.zeros(t.length,this._y.cols);for(let t=0;t<s.length;t++)s[t].mult(this._r[t]),e.add(s[t]);return e.value}}export class XGBoostClassifier extends XGBoost{constructor(t=1,s=1,e=.1,r=0){super(t,s,e,r)}init(t,s){this._x=t,this._cls=[...new Set(s)],this._y=Matrix.zeros(s.length,this._cls.length);for(let t=0;t<this._y.rows;t++)this._y.set(t,this._cls.indexOf(s[t]),1);this._loss=this._y.copy()}predict(t){const s=this._trees.map((s=>Matrix.fromArray(s.predict(t)))),e=Matrix.zeros(t.length,this._y.cols);for(let t=0;t<s.length;t++)s[t].mult(this._r[t]),e.add(s[t]);return e.argmax(1).value.map((t=>this._cls[t]))}}