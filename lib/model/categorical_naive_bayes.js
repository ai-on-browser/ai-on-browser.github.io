export default class CategoricalNaiveBayes{constructor(t=1){this._alpha=t}fit(t,l){if(!this._cand){this._d=t[0].length,this._cand=[];for(let l=0;l<this._d;l++)this._cand[l]=[...new Set(t.map((t=>t[l])))]}this._labels=[...new Set(l)],this._prob=[];for(let e=0;e<this._labels.length;e++){const s=[];for(let i=0;i<this._d;i++){s[i]=Array(this._cand[i].length).fill(0);for(let h=0;h<t.length;h++){if(l[h]!==this._labels[e])continue;const a=this._cand[i].indexOf(t[h][i]);s[i][a]++}const h=s[i].reduce(((t,l)=>t+l),0);s[i]=s[i].map((t=>(t+this._alpha)/(h+this._alpha*s[i].length)))}this._prob[e]=s}}probability(t){return t.map((t=>{const l=Array(this._labels.length).fill(1);for(let e=0;e<this._d;e++){const s=this._cand[e].indexOf(t[e]);for(let t=0;t<this._labels.length;t++)l[t]*=this._prob[t][e][s]}return l}))}predict(t){return this.probability(t).map((t=>{let l=0,e=-1;for(let s=0;s<this._labels.length;s++)t[s]>l&&(l=t[s],e=s);return e<0?null:this._labels[e]}))}}