var a=Object.defineProperty;var _=(h,i)=>a(h,"name",{value:i,configurable:!0});import e from"../util/matrix.js";import{DecisionTreeRegression as p}from"./decision_tree.js";export class GBDT{static{_(this,"GBDT")}constructor(i=1,r=1,t=0){this._trees=[],this._r=[],this._maxd=i,this._srate=r,this._lr=t}get size(){return this._trees.length}_sample(i){const r=Array.from({length:i},(t,s)=>s);for(let t=i-1;t>0;t--){let s=Math.floor(Math.random()*(t+1));[r[t],r[s]]=[r[s],r[t]]}return r.slice(0,Math.ceil(i*this._srate))}init(i,r){this._x=i,this._y=e.fromArray(r),this._loss=this._y.copy()}fit(){const i=new p,r=this._sample(this._x.length);i.init(r.map(o=>this._x[o]),this._loss.row(r).toArray());for(let o=0;o<this._maxd;o++)i.fit();this._trees.push(i);const t=e.fromArray(i.predict(this._x));let s=this._lr;if(!s){const o=t.tDot(t),l=this._loss.cols;o.add(e.eye(l,l,1e-8)),s=o.solve(t.tDot(this._loss)).diag().reduce((c,n)=>c+n,0)/l}this._r.push(s),t.mult(s),this._loss.sub(t)}predict(i){const r=this._trees.map(s=>e.fromArray(s.predict(i))),t=e.zeros(i.length,this._y.cols);for(let s=0;s<r.length;s++)r[s].mult(this._r[s]),t.add(r[s]);return t.toArray()}}export class GBDTClassifier extends GBDT{static{_(this,"GBDTClassifier")}constructor(i=1,r=1,t=0){super(i,r,t)}init(i,r){this._x=i,this._cls=[...new Set(r)],this._y=e.zeros(r.length,this._cls.length);for(let t=0;t<this._y.rows;t++)this._y.set(t,this._cls.indexOf(r[t]),1);this._loss=this._y.copy()}predict(i){const r=this._trees.map(s=>e.fromArray(s.predict(i))),t=e.zeros(i.length,this._y.cols);for(let s=0;s<r.length;s++)r[s].mult(this._r[s]),t.add(r[s]);return t.argmax(1).value.map(s=>this._cls[s])}}
