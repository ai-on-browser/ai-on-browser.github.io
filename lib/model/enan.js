export default class ENaN{constructor(t="euclid"){switch(this._p=[],this._c=[],this._metric=t,this._metric){case"euclid":this._d=(t,s)=>Math.sqrt(t.reduce(((t,i,h)=>t+(i-s[h])**2),0));break;case"manhattan":this._d=(t,s)=>t.reduce(((t,i,h)=>t+Math.abs(i-s[h])),0);break;case"chebyshev":this._d=(t,s)=>Math.max(...t.map(((t,i)=>Math.abs(t-s[i]))));break;case"minkowski":this._dp=2,this._d=(t,s)=>Math.pow(t.reduce(((t,i,h)=>t+(i-s[h])**this._dp),0),1/this._dp)}}fit(t,s){this._x=t,this._c=s,this._classes=[...new Set(this._c)],this._nears=[],this._n=Array(this._classes.length).fill(0);for(let t=0;t<this._x.length;t++){const s=this._x.map(((s,i)=>({d:this._d(this._x[t],s),idx:i})));s.sort(((t,s)=>t.d-s.d)),this._nears[t]=s,this._n[this._classes.indexOf(this._c[t])]++}this._k=2;for(let t=2;t<this._x.length;t++){let s=!0;for(let i=0;i<this._nears.length&&s;i++){let h=!1;for(let s=1;s<t&&!h;s++){const e=this._nears[i][s].idx;for(let s=1;s<t&&!h;s++)h=this._nears[e][s].idx===i}s&&=h}if(s){this._k=t;break}}this._t=[];for(let t=0;t<this._classes.length;t++){let s=0;for(let i=0;i<this._nears.length;i++)if(this._c[i]===this._classes[t])for(let h=1;h<=this._k;h++)this._c[this._nears[i][h].idx]===this._classes[t]&&s++;this._t[t]=s/(this._n[t]*this._k)}}predict(t){const s=[];for(let i=0;i<t.length;i++)s[i]=this._predict(t[i]);return s}_predict(t){const s=[{d:0,idx:-1}],i=[];for(let h=0;h<this._x.length;h++){const e=this._d(t,this._x[h]);s.push({d:e,idx:h}),i[h]=e}s.sort(((t,s)=>t.d-s.d));let h=-1/0,e=-1;for(let t=0;t<this._classes.length;t++){let _=0;for(let i=1;i<=this._k;i++)this._c[s[i].idx]===this._classes[t]&&_++;let r=0;for(let t=0;t<this._nears.length;t++)i[t]<this._nears[t][this._k].d&&r++;const l=r+_-this._k*this._t[t];h<l&&(h=l,e=t)}return this._classes[e]}}