import{Matrix}from"../util/math.js";class ComplementNaiveBayes{constructor(){this._k=0,this._labels=[],this._rate=[]}fit(t,s){this._labels=[...new Set(s)],this._init(),this._rate=[];for(let e=0;e<this._labels.length;e++){const a=Matrix.fromArray(t.filter(((t,a)=>s[a]!==this._labels[e])));this._estimate_prob(a,e),this._rate[e]=1-a.rows/t.length}}predict(t){const s=Matrix.fromArray(t),e=[];for(let t=0;t<this._labels.length;t++){const a=this._data_prob(s,t);a.idiv(this._rate[t]),e.push(a)}return t.map(((t,s)=>{let a=0,i=-1;for(let t=0;t<this._labels.length;t++){let r=e[t].value[s];r>a&&(a=r,i=t)}return this._labels[i]}))}}export class GaussianComplementNaiveBayes extends ComplementNaiveBayes{constructor(){super(),this._means=[],this._vars=[]}_init(){this._means=[],this._vars=[]}_estimate_prob(t,s){this._means[s]=t.mean(0),this._vars[s]=t.variance(0)}_data_prob(t,s){const e=this._means[s],a=this._vars[s],i=t.copySub(e);return i.mult(i),i.div(a),i.map((t=>Math.exp(-t/2))),i.div(a.copyMap((t=>Math.sqrt(2*Math.PI*t)))),i.prod(1)}}