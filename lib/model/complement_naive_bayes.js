var m=Object.defineProperty;var n=(h,t)=>m(h,"name",{value:t,configurable:!0});import l from"../util/matrix.js";class c{static{n(this,"Gaussian")}constructor(){this._means=null,this._vars=null}_estimate_prob(t){this._means=t.mean(0),this._vars=t.variance(0)}_data_prob(t){const a=l.sub(t,this._means);return a.mult(a),a.div(this._vars),a.map(s=>Math.exp(-s/2)),a.div(l.map(this._vars,s=>Math.sqrt(2*Math.PI*s))),a.prod(1)}}export default class u{static{n(this,"ComplementNaiveBayes")}constructor(t="gaussian"){this._labels=[],this._rate=[],t==="gaussian"&&(this._p_class=c),this._p=[]}fit(t,a){this._labels=[...new Set(a)],this._p=[],this._rate=[];for(let s=0;s<this._labels.length;s++){const i=l.fromArray(t.filter((e,r)=>a[r]!==this._labels[s]));this._p[s]=new this._p_class,this._p[s]._estimate_prob(i),this._rate[s]=1-i.rows/t.length}}predict(t){const a=l.fromArray(t),s=[];for(let i=0;i<this._labels.length;i++){const e=this._p[i]._data_prob(a);e.idiv(this._rate[i]),s.push(e)}return t.map((i,e)=>{let r=0,o=-1;for(let _=0;_<this._labels.length;_++){const p=s[_].value[e];p>r&&(r=p,o=_)}return this._labels[o]})}}
