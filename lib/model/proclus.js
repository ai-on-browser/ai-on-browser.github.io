var u=Object.defineProperty;var a=(m,_)=>u(m,"name",{value:_,configurable:!0});export default class d{static{a(this,"PROCLUS")}constructor(_,n,i,s,h=.1){this._k=_,this._a=n,this._b=i,this._l=s,this._minDeviation=h,this._d=(l,t)=>Math.sqrt(l.reduce((e,r,f)=>e+(r-t[f])**2,0))}_sample(_,n){const i=[];for(let s=0;s<n&&s<_;s++)i.push(Math.floor(Math.random()*(_-s)));for(let s=i.length-1;s>=0;s--)for(let h=i.length-1;h>s;h--)i[s]<=i[h]&&i[h]++;return i}init(_){this._x=_,this._dists=[];for(let s=0;s<this._x.length;s++){this._dists[s]=[],this._dists[s][s]=0;for(let h=0;h<s;h++)this._dists[s][h]=this._dists[h][s]=this._d(this._x[s],this._x[h])}const n=this._sample(this._x.length,this._k*this._a);this._m=[n[Math.floor(Math.random()*n.length)]];const i=Array(n.length).fill(1/0);for(let s=1;s<this._k*this._b;s++){let h=-1,l=0;const t=this._m[this._m.length-1];for(let e=0;e<n.length;e++)i[e]=Math.min(i[e],this._dists[t][n[e]]),l<i[e]&&(l=i[e],h=n[e]);this._m.push(h)}this._bestObjective=1/0,this._mcurrent=this._sample(this._m.length,this._k).map(s=>this._m[s])}fit(){const _=this._x.length,n=[];for(let t=0;t<this._k;t++){let e=1/0;for(let r=0;r<this._k;r++){if(t===r)continue;const f=this._dists[this._mcurrent[t]][this._mcurrent[r]];f<e&&(e=f)}n[t]=[];for(let r=0;r<_;r++)r!==this._mcurrent[t]&&this._dists[this._mcurrent[t]][r]<e&&n[t].push(r)}const i=this._findDimensions(this._mcurrent,n),s=this._assignPoints(this._mcurrent,i),h=Array(this._k).fill(0);for(let t=0;t<this._k;t++){for(let e=0;e<s[t].length;e++)for(const r of i[t])h[t]+=Math.abs(this._x[s[t][e]][r]-this._x[this._mcurrent[t]][r]);h[t]/=i[t].length}const l=h.reduce((t,e)=>t+e,0)/_;l<this._bestObjective&&(this._bestObjective=l,this._mbest=this._mcurrent,this._clusters=s),this._mcurrent=this._mbest.concat();for(let t=0;t<this._k;t++)if(this._clusters[t].length<_/this._k*this._minDeviation)for(let e=0;e<100;e++){const r=this._m[Math.floor(Math.random()*this._m.length)];if(!this._mcurrent.includes(r)){this._mcurrent[t]=r;break}}}_findDimensions(_,n){const i=this._x[0].length,s=[],h=[];for(let t=0;t<this._k;t++){const e=Array(i).fill(0);for(let o=0;o<n[t].length;o++)for(let c=0;c<i;c++)e[c]+=Math.abs(this._x[_[t]][c]-this._x[n[t][o]][c]);for(let o=0;o<i;o++)e[o]/=n[t].length;const r=e.reduce((o,c)=>o+c,0)/i;s[t]=[];const f=Math.sqrt(e.reduce((o,c)=>o+(c-r)**2,0)/(i-1));for(let o=0;o<i;o++)h.push([t,o,(e[o]-r)/f])}h.sort((t,e)=>t[2]-e[2]);let l=this._k*(this._l-2);for(let t=0;t<h.length;t++)s[h[t][0]].length<2?s[h[t][0]].push(h[t][1]):l>0&&(s[h[t][0]].push(h[t][1]),l--);return s}_assignPoints(_,n){const i=Array.from({length:this._k},()=>[]);for(let s=0;s<this._x.length;s++){let h=1/0,l=-1;for(let t=0;t<this._k;t++){const e=n[t].reduce((r,f)=>r+Math.abs(this._x[s][f]-this._x[_[t]][f]),0);e<h&&(h=e,l=t)}i[l].push(s)}return i}predict(){this._D=this._findDimensions(this._mbest,this._clusters);const _=this._assignPoints(this._mbest,this._D),n=[];for(let i=0;i<_.length;i++)for(let s=0;s<_[i].length;s++)n[_[i][s]]=i;return n}outliers(){this._D=this._findDimensions(this._mbest,this._clusters);const _=this._assignPoints(this._mbest,this._D),n=Array(this._x.length).fill(!1);for(let i=0;i<this._k;i++){let s=1/0;for(let h=0;h<this._k;h++){if(i===h)continue;const l=this._D[i].reduce((t,e)=>t+Math.abs(this._x[this._mbest[i]][e]-this._x[this._mbest[h]][e]),0);l<s&&(s=l)}for(let h=0;h<_[i].length;h++)this._D[i].reduce((t,e)=>t+Math.abs(this._x[this._mbest[i]][e]-this._x[_[i][h]][e]),0)>s&&(n[_[i][h]]=!0)}return n}}
