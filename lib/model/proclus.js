export default class PROCLUS{constructor(t,s,i,h,e=.1){this._k=t,this._a=s,this._b=i,this._l=h,this._minDeviation=e,this._d=(t,s)=>Math.sqrt(t.reduce(((t,i,h)=>t+(i-s[h])**2),0))}_sample(t,s){const i=[];for(let h=0;h<s&&h<t;h++)i.push(Math.floor(Math.random()*(t-h)));for(let t=i.length-1;t>=0;t--)for(let s=i.length-1;s>t;s--)i[t]<=i[s]&&i[s]++;return i}init(t){this._x=t,this._dists=[];for(let t=0;t<this._x.length;t++){this._dists[t]=[],this._dists[t][t]=0;for(let s=0;s<t;s++)this._dists[t][s]=this._dists[s][t]=this._d(this._x[t],this._x[s])}const s=this._sample(this._x.length,this._k*this._a);this._m=[s[Math.floor(Math.random()*s.length)]];const i=Array(s.length).fill(1/0);for(let t=1;t<this._k*this._b;t++){let t=-1,h=0;const e=this._m[this._m.length-1];for(let _=0;_<s.length;_++)i[_]=Math.min(i[_],this._dists[e][s[_]]),h<i[_]&&(h=i[_],t=s[_]);this._m.push(t)}this._bestObjective=1/0,this._mcurrent=this._sample(this._m.length,this._k).map((t=>this._m[t]))}fit(){const t=this._x.length,s=[];for(let i=0;i<this._k;i++){let h=1/0;for(let t=0;t<this._k;t++){if(i===t)continue;const s=this._dists[this._mcurrent[i]][this._mcurrent[t]];s<h&&(h=s)}s[i]=[];for(let e=0;e<t;e++)e!==this._mcurrent[i]&&this._dists[this._mcurrent[i]][e]<h&&s[i].push(e)}const i=this._findDimensions(this._mcurrent,s),h=this._assignPoints(this._mcurrent,i),e=Array(this._k).fill(0);for(let t=0;t<this._k;t++){for(let s=0;s<h[t].length;s++)for(const _ of i[t])e[t]+=Math.abs(this._x[h[t][s]][_]-this._x[this._mcurrent[t]][_]);e[t]/=i[t].length}const _=e.reduce(((t,s)=>t+s),0)/t;_<this._bestObjective&&(this._bestObjective=_,this._mbest=this._mcurrent,this._clusters=h),this._mcurrent=this._mbest.concat();for(let s=0;s<this._k;s++)if(this._clusters[s].length<t/this._k*this._minDeviation)for(let t=0;t<100;t++){const t=this._m[Math.floor(Math.random()*this._m.length)];if(this._mcurrent.indexOf(t)<0){this._mcurrent[s]=t;break}}}_findDimensions(t,s){const i=this._x[0].length,h=[],e=[];for(let _=0;_<this._k;_++){const r=Array(i).fill(0);for(let h=0;h<s[_].length;h++)for(let e=0;e<i;e++)r[e]+=Math.abs(this._x[t[_]][e]-this._x[s[_][h]][e]);for(let t=0;t<i;t++)r[t]/=s[_].length;const n=r.reduce(((t,s)=>t+s),0)/i;h[_]=[];const l=Math.sqrt(r.reduce(((t,s)=>t+(s-n)**2),0)/(i-1));for(let t=0;t<i;t++)e.push([_,t,(r[t]-n)/l])}e.sort(((t,s)=>t[2]-s[2]));let _=this._k*(this._l-2);for(let t=0;t<e.length;t++)h[e[t][0]].length<2?h[e[t][0]].push(e[t][1]):_>0&&(h[e[t][0]].push(e[t][1]),_--);return h}_assignPoints(t,s){const i=Array.from({length:this._k},(()=>[]));for(let h=0;h<this._x.length;h++){let e=1/0,_=-1;for(let i=0;i<this._k;i++){const r=s[i].reduce(((s,e)=>s+Math.abs(this._x[h][e]-this._x[t[i]][e])),0);r<e&&(e=r,_=i)}i[_].push(h)}return i}predict(){this._D=this._findDimensions(this._mbest,this._clusters);const t=this._assignPoints(this._mbest,this._D),s=[];for(let i=0;i<t.length;i++)for(let h=0;h<t[i].length;h++)s[t[i][h]]=i;return s}outliers(){this._D=this._findDimensions(this._mbest,this._clusters);const t=this._assignPoints(this._mbest,this._D),s=Array(this._x.length).fill(!1);for(let i=0;i<this._k;i++){let h=1/0;for(let t=0;t<this._k;t++){if(i===t)continue;const s=this._D[i].reduce(((s,h)=>s+Math.abs(this._x[this._mbest[i]][h]-this._x[this._mbest[t]][h])),0);s<h&&(h=s)}for(let e=0;e<t[i].length;e++){this._D[i].reduce(((s,h)=>s+Math.abs(this._x[this._mbest[i]][h]-this._x[t[i][e]][h])),0)>h&&(s[t[i][e]]=!0)}}return s}}