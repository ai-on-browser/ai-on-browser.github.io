import{Matrix}from"../util/math.js";const nelderMead=(t,s,r=1,o=1,i=2,e=.5,l=.5,a=null)=>{const h=t.length,c=[t.copy()];for(let s=0;s<h;s++){const o=Matrix.zeros(t.rows,t.cols);o.value[s]=r,o.add(t),c.push(o)}a||(a=5*h);const n=c.map((t=>[s(t),t]));for(let t=0;t<a&&(n.sort(((t,s)=>t[0]-s[0])),0!==n[0][0]);t++){const t=n[0][1].copy();for(let s=1;s<h;s++)t.add(n[s][1]);t.div(h);const r=t.copy();r.sub(n[h][1]),r.mult(o),r.add(t);const a=s(r);if(n[0][0]<=a&&a<n[h-1][0])n[h]=[a,r];else if(a<n[0][0]){const o=r.copy();o.sub(t),o.mult(i),o.add(t);const e=s(o);n[h]=e<a?[e,o]:[a,r]}else{const r=n[h][1].copy();r.sub(t),r.mult(e),r.add(t);const o=s(r);if(o<n[h][0])n[h]=[o,r];else for(let t=1;t<=h;t++){const r=n[t][1];r.sub(n[0][1]),r.mult(l),r.add(n[0][1]),n[t]=[s(r),r]}}}return n.sort(((t,s)=>t[0]-s[0])),n[0][1]};export class Probit{constructor(){this._w=null}init(t,s){const r=Matrix.fromArray(t);this._x=r.resize(r.rows,r.cols+1,1),this._y=s,this._d=this._x.cols,this._w=Matrix.randn(this._d,1)}_cdf(t){const s=t<0?-1:1,r=Math.abs(t)/Math.sqrt(2),o=1/(1+.3275911*r);return.5*(1+s*(1-((((1.061405429*o-1.453152027)*o+1.421413741)*o-.284496736)*o+.254829592)*o*Math.exp(-r*r)))}_llh(t){const s=Matrix.fromArray(this._x).dot(t);s.map((t=>this._cdf(t)));let r=0;for(let t=0;t<s.rows;t++)1===this._y[t]?r+=Math.log(s.value[t]):r+=Math.log(1-s.value[t]);return r}fit(){this._w=nelderMead(this._w,(t=>-this._llh(t)))}predict(t){const s=Matrix.fromArray(t),r=s.resize(s.rows,s.cols+1,1).dot(this._w);return r.map((t=>this._cdf(t)-.5)),r.value}}export class MultinomialProbit extends Probit{constructor(){super(),this._w=null,this._classes=null}_llh(t){const s=Matrix.fromArray(this._x).dot(t);s.map((t=>this._cdf(t))),s.div(s.sum(1));let r=0;for(let t=0;t<s.rows;t++)for(let o=0;o<this._y.cols;o++)r+=this._y.at(t,o)*Math.log(s.at(t,o));return r}fit(t,s){this._classes||(this._classes=[...new Set(s.map((t=>t[0])))]),t=Matrix.fromArray(t),this._x=t.resize(t.rows,t.cols+1,1),this._y=new Matrix(t.rows,this._classes.length),s.forEach(((t,s)=>this._y.set(s,this._classes.indexOf(t[0]),1))),this._w||(this._w=Matrix.randn(this._x.cols,this._classes.length)),this._w=nelderMead(this._w,(t=>-this._llh(t)))}predict(t){const s=Matrix.fromArray(t),r=s.resize(s.rows,s.cols+1,1).dot(this._w);return r.map((t=>this._cdf(t))),r.argmax(1).value.map((t=>this._classes[t]))}}