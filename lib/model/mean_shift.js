export default class MeanShift{constructor(t,e){this._x=null,this._centroids=null,this._h=t,this._threshold=e,this._categories=0}get categories(){return this._categories}get h(){return this._h}set h(t){this._h=t}set threshold(t){this._threshold=t}_distance(t,e){return Math.sqrt(t.reduce(((t,s,h)=>t+(s-e[h])**2),0))}init(t){this._x=t,this._centroids=this._x.map((t=>[].concat(t)))}predict(){this._categories=0;const t=[];for(let e=0;e<this._centroids.length;e++){let s=e;for(let h=0;h<e;h++)if(this._distance(this._centroids[e],this._centroids[h])<this._threshold){s=t[h];break}s===e&&this._categories++,t[e]=s}return t}fit(){if(0===this._centroids.length||0===this._x.length)return;this._centroids[0].length,Math.PI,this._h;const t=(t,e)=>t.reduce(((t,s,h)=>t+((s-e[h])/this._h)**2),0)<=1?1:0,e=t=>{let e=0,s=Array(this._x[0].length).fill(0);for(let h=0;h<this._x.length;h++)if(t[h]){e+=t[h];for(let e=0;e<s.length;e++)s[e]+=this._x[h][e]*t[h]}return s.map((t=>t/e))},s=s=>{let h=this._x.map((e=>t(s,e)));return((t,s)=>e(s).map(((e,s)=>e-t[s])))(s,h)};let h=!1;return this._centroids=this._centroids.map(((t,e)=>{let i=t;const r=s(t),n=t.map(((t,e)=>t+r[e]));return h|=i.some(((t,e)=>t!==n[e])),n})),h}}