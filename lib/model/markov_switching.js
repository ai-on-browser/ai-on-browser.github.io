import Matrix from"../util/matrix.js";export default class MarkovSwitching{constructor(t,s){this._regime=t,this._d=s,this._mu=[],this._sigma=[];for(let t=0;t<this._regime;t++)this._mu[t]=Matrix.randn(1,s),this._sigma[t]=Matrix.random(s,s,0,.1),this._sigma[t]=this._sigma[t].tDot(this._sigma[t])}_stationary_prob(t){const s=this._regime,i=Matrix.ones(s+1,s);return i.set(0,0,Matrix.sub(Matrix.eye(s,s),t)),i.tDot(i).solve(i.t).col(s)}_lh(t,s,i){const r=t.rows,a=new Matrix(r,this._regime);for(let o=0;o<this._regime;o++){const e=Math.pow(2*Math.PI,this._d/2)*Math.sqrt(i[o].det()),h=i[o].inv(),m=Matrix.sub(t,s[o]);for(let t=0;t<r;t++){const s=m.row(t);a.set(t,o,Math.exp(-s.dot(h).dot(s.t).toScaler()/2)/e)}}return a}_logL(t,s,i,r){const a=t.rows,o=this._lh(t,s,i);let e=this._stationary_prob(r),h=0;for(let t=0;t<a;t++){const s=o.row(t).t;s.mult(e);const i=s.sum();h+=Math.log(i),s.div(i),e=r.dot(s)}return h}_prob(t){const s=t.rows,i=this._lh(t,this._mu,this._sigma);let r=this._stationary_prob(this._last_prob);const a=[];for(let t=0;t<s;t++){const s=i.row(t).t;s.mult(r),s.div(s.sum()),a.push(s),r=this._last_prob.dot(s)}return a}_nextParam(t,s){const i=this._mu.map((t=>t.copy())),r=this._sigma.map((t=>t.copy())),a=t.copy();for(let t=0;t<this._regime;t++){i[t].add(Math.random(1,this._d,-s,s));for(let i=0;i<this._d;i++)for(let a=0;a<=i;a++){let o=r[t].at(i,a);o=Math.exp(Math.log(o)+(2*Math.random()-1)*s),r[t].set(i,a,o),r[t].set(a,i,o)}}a.add(Matrix.map(Matrix.random(this._regime,this._regime),(t=>(2*t-1)*s*.1)));for(let t=0;t<this._regime;t++)a.set(t,t,0);const o=Matrix.map(t,(t=>Math.exp(t)/(1+t)));return o.add(Matrix.diag(Matrix.sub(1,o.sum(0).t).value)),[i,r,a,o]}_mcmc(t,s,i){let r=new Matrix(this._regime,this._regime,-3);for(let t=0;t<this._regime;t++)r.set(t,t,0);let a=Matrix.map(r,(t=>Math.exp(t)/(1+t)));a.add(Matrix.diag(Matrix.sub(1,a.sum(0).t).value));const o=[this._mu.concat()],e=[this._sigma.concat()],h=[a],m=[];for(let _=0;_<i;_++){const[i,_,n,l]=this._nextParam(r,s),c=this._logL(t,this._mu,this._sigma,a),u=this._logL(t,i,_,l),M=Math.exp(u-c);m.push(c),(M>1||M>Math.random())&&(this._mu=i,this._sigma=_,r=n,a=l),o.push(this._mu.concat()),e.push(this._sigma.concat()),h.push(a)}return this._last_prob=a,[o,e,h,m]}fit(t,s,i){const r=Matrix.fromArray(t),[a,o,e,h]=this._mcmc(r,s,i)}predict(t){const s=Matrix.fromArray(t),i=this._prob(s),r=[];for(let t=0;t<i.length-1;t++)r.push(1-Matrix.mult(i[t],i[t+1]).sum()/(i[t].norm()*i[t+1].norm()));return r}}