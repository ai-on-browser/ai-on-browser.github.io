var x=Object.defineProperty;var f=(p,i)=>x(p,"name",{value:i,configurable:!0});import a from"../util/matrix.js";export default class y{static{f(this,"MarkovSwitching")}constructor(i){this._regime=i,this._mu=[],this._sigma=[]}_stationary_prob(i){const n=this._regime,r=a.ones(n+1,n);return r.set(0,0,a.sub(a.eye(n,n),i)),r.tDot(r).solve(r.t).col(n)}_lh(i,n,r){const o=i.rows,e=new a(o,this._regime);for(let s=0;s<this._regime;s++){const t=Math.pow(2*Math.PI,n[s].cols/2)*Math.sqrt(r[s].det()),c=r[s].inv(),m=a.sub(i,n[s]),h=m.dot(c);h.mult(m);const l=h.sum(1);l.map(_=>Math.exp(-_/2)/t),e.set(0,s,l)}return e}_logL(i,n,r,o){const e=i.rows,s=this._lh(i,n,r);let t=this._stationary_prob(o),c=0;for(let m=0;m<e;m++){const h=s.row(m).t;h.mult(t);const l=h.sum();c+=Math.log(l),h.div(l),t=o.dot(h)}return c}_prob(i){const n=i.rows,r=this._lh(i,this._mu,this._sigma);let o=this._stationary_prob(this._last_prob);const e=[];for(let s=0;s<n;s++){const t=r.row(s).t;t.mult(o),t.div(t.sum()),e.push(t),o=this._last_prob.dot(t)}return e}_nextParam(i,n){const r=this._mu.map(t=>t.copy()),o=this._sigma.map(t=>t.copy()),e=i.copy();for(let t=0;t<this._regime;t++){r[t].add(a.random(1,r[t].cols,-n,n));for(let c=0;c<r[t].cols;c++){let m=o[t].at(c,c);m=Math.exp(Math.log(m)+(2*Math.random()-1)*n),o[t].set(c,c,m)}}e.add(a.map(a.random(this._regime,this._regime),t=>(2*t-1)*n*.1));for(let t=0;t<this._regime;t++)e.set(t,t,0);const s=a.map(i,t=>Math.exp(t)/(1+Math.exp(t)));return s.add(a.diag(a.sub(1,s.sum(0).t).value)),[r,o,e,s]}_mcmc(i,n,r){let o=new a(this._regime,this._regime,-this._regime);for(let h=0;h<this._regime;h++)o.set(h,h,0);let e=a.map(o,h=>Math.exp(h)/(1+Math.exp(h)));e.add(a.diag(a.sub(1,e.sum(0).t).value));const s=[this._mu.concat()],t=[this._sigma.concat()],c=[e],m=[];for(let h=0;h<r;h++){const[l,_,b,u]=this._nextParam(o,n),g=this._logL(i,this._mu,this._sigma,e),M=this._logL(i,l,_,u),d=Math.exp(M-g);m.push(g),(d>1||d>Math.random())&&(this._mu=l,this._sigma=_,o=b,e=u),s.push(this._mu.concat()),t.push(this._sigma.concat()),c.push(e)}return this._last_prob=e,[s,t,c,m]}fit(i,n,r){const o=a.fromArray(i);if(this._mu.length===0)for(let m=0;m<this._regime;m++){this._mu[m]=a.randn(1,o.cols,0,.1),this._sigma[m]=a.zeros(o.cols,o.cols);for(let h=0;h<o.cols;h++)this._sigma[m].set(h,h,Math.random())}const[e,s,t,c]=this._mcmc(o,n,r)}probability(i){const n=a.fromArray(i);return this._prob(n).map(o=>o.value)}predict(i){const n=a.fromArray(i),r=this._prob(n),o=r.map(s=>s.norm()),e=[];for(let s=0;s<r.length-1;s++)e.push(1-a.mult(r[s],r[s+1]).sum()/(o[s]*o[s+1]));return e}}
