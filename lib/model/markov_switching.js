var x=Object.defineProperty;var f=(p,r)=>x(p,"name",{value:r,configurable:!0});import h from"../util/matrix.js";export default class y{static{f(this,"MarkovSwitching")}constructor(r){this._regime=r,this._mu=[],this._sigma=[]}_stationary_prob(r){const e=this._regime,n=h.ones(e+1,e);return n.set(0,0,h.sub(h.eye(e,e),r)),n.tDot(n).solve(n.t).col(e)}_lh(r,e,n){const i=r.rows,o=new h(i,this._regime);for(let s=0;s<this._regime;s++){const t=(2*Math.PI)**(e[s].cols/2)*Math.sqrt(n[s].det()),m=n[s].inv(),c=h.sub(r,e[s]),a=c.dot(m);a.mult(c);const l=a.sum(1);l.map(_=>Math.exp(-_/2)/t),o.set(0,s,l)}return o}_logL(r,e,n,i){const o=r.rows,s=this._lh(r,e,n);let t=this._stationary_prob(i),m=0;for(let c=0;c<o;c++){const a=s.row(c).t;a.mult(t);const l=a.sum();m+=Math.log(l),a.div(l),t=i.dot(a)}return m}_prob(r){const e=r.rows,n=this._lh(r,this._mu,this._sigma);let i=this._stationary_prob(this._last_prob);const o=[];for(let s=0;s<e;s++){const t=n.row(s).t;t.mult(i),t.div(t.sum()),o.push(t),i=this._last_prob.dot(t)}return o}_nextParam(r,e){const n=this._mu.map(t=>t.copy()),i=this._sigma.map(t=>t.copy()),o=r.copy();for(let t=0;t<this._regime;t++){n[t].add(h.random(1,n[t].cols,-e,e));for(let m=0;m<n[t].cols;m++){let c=i[t].at(m,m);c=Math.exp(Math.log(c)+(2*Math.random()-1)*e),i[t].set(m,m,c)}}o.add(h.map(h.random(this._regime,this._regime),t=>(2*t-1)*e*.1));for(let t=0;t<this._regime;t++)o.set(t,t,0);const s=h.map(r,t=>Math.exp(t)/(1+Math.exp(t)));return s.add(h.diag(h.sub(1,s.sum(0).t).value)),[n,i,o,s]}_mcmc(r,e,n){let i=new h(this._regime,this._regime,-this._regime);for(let a=0;a<this._regime;a++)i.set(a,a,0);let o=h.map(i,a=>Math.exp(a)/(1+Math.exp(a)));o.add(h.diag(h.sub(1,o.sum(0).t).value));const s=[this._mu.concat()],t=[this._sigma.concat()],m=[o],c=[];for(let a=0;a<n;a++){const[l,_,b,u]=this._nextParam(i,e),g=this._logL(r,this._mu,this._sigma,o),M=this._logL(r,l,_,u),d=Math.exp(M-g);c.push(g),(d>1||d>Math.random())&&(this._mu=l,this._sigma=_,i=b,o=u),s.push(this._mu.concat()),t.push(this._sigma.concat()),m.push(o)}return this._last_prob=o,[s,t,m,c]}fit(r,e,n){const i=h.fromArray(r);if(this._mu.length===0)for(let o=0;o<this._regime;o++){this._mu[o]=h.randn(1,i.cols,0,.1),this._sigma[o]=h.zeros(i.cols,i.cols);for(let s=0;s<i.cols;s++)this._sigma[o].set(s,s,Math.random())}this._mcmc(i,e,n)}probability(r){const e=h.fromArray(r);return this._prob(e).map(i=>i.value)}predict(r){const e=h.fromArray(r),n=this._prob(e),i=n.map(s=>s.norm()),o=[];for(let s=0;s<n.length-1;s++)o.push(1-h.mult(n[s],n[s+1]).sum()/(i[s]*i[s+1]));return o}}
