import Matrix from"../util/matrix.js";export default class MarkovSwitching{constructor(t,s){this._regime=t,this._d=s,this._mu=[],this._sigma=[];for(let t=0;t<this._regime;t++)this._mu[t]=Matrix.randn(1,s),this._sigma[t]=Matrix.random(s,s,0,.1),this._sigma[t]=this._sigma[t].tDot(this._sigma[t])}_stationary_prob(t){const s=this._regime,i=Matrix.ones(s+1,s);return i.set(0,0,Matrix.eye(s,s).copySub(t)),i.tDot(i).solve(i.t).col(s)}_lh(t,s,i){const r=t.rows,o=new Matrix(r,this._regime);for(let a=0;a<this._regime;a++){const e=Math.pow(2*Math.PI,this._d/2)*Math.sqrt(i[a].det()),h=i[a].inv(),_=t.copySub(s[a]);for(let t=0;t<r;t++){const s=_.row(t);o.set(t,a,Math.exp(-s.dot(h).dot(s.t).toScaler()/2)/e)}}return o}_logL(t,s,i,r){const o=t.rows,a=this._lh(t,s,i);let e=this._stationary_prob(r),h=0;for(let t=0;t<o;t++){const s=a.row(t).t;s.mult(e);const i=s.sum();h+=Math.log(i),s.div(i),e=r.dot(s)}return h}_prob(t){const s=t.rows,i=this._lh(t,this._mu,this._sigma);let r=this._stationary_prob(this._last_prob);const o=[];for(let t=0;t<s;t++){const s=i.row(t).t;s.mult(r),s.div(s.sum()),o.push(s),r=this._last_prob.dot(s)}return o}_nextParam(t,s){const i=this._mu.map((t=>t.copy())),r=this._sigma.map((t=>t.copy())),o=t.copy();for(let t=0;t<this._regime;t++){i[t].add(Math.random(1,this._d,-s,s));for(let i=0;i<this._d;i++)for(let o=0;o<=i;o++){let a=r[t].at(i,o);a=Math.exp(Math.log(a)+(2*Math.random()-1)*s),r[t].set(i,o,a),r[t].set(o,i,a)}}o.add(Matrix.random(this._regime,this._regime).copyMap((t=>(2*t-1)*s*.1)));for(let t=0;t<this._regime;t++)o.set(t,t,0);const a=t.copyMap((t=>Math.exp(t)/(1+t)));return a.add(Matrix.diag(a.sum(0).t.copyIsub(1).value)),[i,r,o,a]}_mcmc(t,s,i){let r=new Matrix(this._regime,this._regime,-3);for(let t=0;t<this._regime;t++)r.set(t,t,0);let o=r.copyMap((t=>Math.exp(t)/(1+t)));o.add(Matrix.diag(o.sum(0).t.copyIsub(1).value));const a=[this._mu.concat()],e=[this._sigma.concat()],h=[o],_=[];for(let m=0;m<i;m++){const[i,m,n,c]=this._nextParam(r,s),l=this._logL(t,this._mu,this._sigma,o),p=this._logL(t,i,m,c),u=Math.exp(p-l);_.push(l),(u>1||u>Math.random())&&(this._mu=i,this._sigma=m,r=n,o=c),a.push(this._mu.concat()),e.push(this._sigma.concat()),h.push(o)}return this._last_prob=o,[a,e,h,_]}fit(t,s,i){const r=Matrix.fromArray(t),[o,a,e,h]=this._mcmc(r,s,i)}predict(t){const s=Matrix.fromArray(t),i=this._prob(s),r=[];for(let t=0;t<i.length-1;t++)r.push(1-i[t].copyMult(i[t+1]).sum()/(i[t].norm()*i[t+1].norm()));return r}}