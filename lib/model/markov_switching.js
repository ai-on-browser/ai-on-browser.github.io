import Matrix from"../util/matrix.js";export default class MarkovSwitching{constructor(t){this._regime=t,this._mu=[],this._sigma=[]}_stationary_prob(t){const s=this._regime,r=Matrix.ones(s+1,s);return r.set(0,0,Matrix.sub(Matrix.eye(s,s),t)),r.tDot(r).solve(r.t).col(s)}_lh(t,s,r){const i=t.rows,a=new Matrix(i,this._regime);for(let i=0;i<this._regime;i++){const o=Math.pow(2*Math.PI,s[i].cols/2)*Math.sqrt(r[i].det()),e=r[i].inv(),h=Matrix.sub(t,s[i]),m=h.dot(e);m.mult(h);const _=m.sum(1);_.map((t=>Math.exp(-t/2)/o)),a.set(0,i,_)}return a}_logL(t,s,r,i){const a=t.rows,o=this._lh(t,s,r);let e=this._stationary_prob(i),h=0;for(let t=0;t<a;t++){const s=o.row(t).t;s.mult(e);const r=s.sum();h+=Math.log(r),s.div(r),e=i.dot(s)}return h}_prob(t){const s=t.rows,r=this._lh(t,this._mu,this._sigma);let i=this._stationary_prob(this._last_prob);const a=[];for(let t=0;t<s;t++){const s=r.row(t).t;s.mult(i),s.div(s.sum()),a.push(s),i=this._last_prob.dot(s)}return a}_nextParam(t,s){const r=this._mu.map((t=>t.copy())),i=this._sigma.map((t=>t.copy())),a=t.copy();for(let t=0;t<this._regime;t++){r[t].add(Matrix.random(1,r[t].cols,-s,s));for(let a=0;a<r[t].cols;a++){let r=i[t].at(a,a);r=Math.exp(Math.log(r)+(2*Math.random()-1)*s),i[t].set(a,a,r)}}a.add(Matrix.map(Matrix.random(this._regime,this._regime),(t=>(2*t-1)*s*.1)));for(let t=0;t<this._regime;t++)a.set(t,t,0);const o=Matrix.map(t,(t=>Math.exp(t)/(1+Math.exp(t))));return o.add(Matrix.diag(Matrix.sub(1,o.sum(0).t).value)),[r,i,a,o]}_mcmc(t,s,r){let i=new Matrix(this._regime,this._regime,-this._regime);for(let t=0;t<this._regime;t++)i.set(t,t,0);let a=Matrix.map(i,(t=>Math.exp(t)/(1+Math.exp(t))));a.add(Matrix.diag(Matrix.sub(1,a.sum(0).t).value));const o=[this._mu.concat()],e=[this._sigma.concat()],h=[a],m=[];for(let _=0;_<r;_++){const[r,_,n,l]=this._nextParam(i,s),c=this._logL(t,this._mu,this._sigma,a),u=this._logL(t,r,_,l),p=Math.exp(u-c);m.push(c),(p>1||p>Math.random())&&(this._mu=r,this._sigma=_,i=n,a=l),o.push(this._mu.concat()),e.push(this._sigma.concat()),h.push(a)}return this._last_prob=a,[o,e,h,m]}fit(t,s,r){const i=Matrix.fromArray(t);if(0===this._mu.length)for(let t=0;t<this._regime;t++){this._mu[t]=Matrix.randn(1,i.cols,0,.1),this._sigma[t]=Matrix.zeros(i.cols,i.cols);for(let s=0;s<i.cols;s++)this._sigma[t].set(s,s,Math.random())}const[a,o,e,h]=this._mcmc(i,s,r)}probability(t){const s=Matrix.fromArray(t);return this._prob(s).map((t=>t.value))}predict(t){const s=Matrix.fromArray(t),r=this._prob(s),i=r.map((t=>t.norm())),a=[];for(let t=0;t<r.length-1;t++)a.push(1-Matrix.mult(r[t],r[t+1]).sum()/(i[t]*i[t+1]));return a}}