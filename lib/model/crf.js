import{Matrix}from"../util/math.js";export default class CRF{constructor(){this._xn=0,this._yn=0,this._w=null,this._e=.1,this._x_cand=[],this._y_cand=[],this._phi=(t,h,n)=>{t=this._x_cand.indexOf(t),h=void 0===h?this._yn-1:this._y_cand.indexOf(h),n=void 0===n?this._yn-1:this._y_cand.indexOf(n);const i=Array(this._xn*this._yn*this._yn).fill(0);t>=0&&h>=0&&n>=0&&(i[t*this._yn*this._yn+h*this._yn+n]=1);const s=Array(this._xn*this._yn).fill(0);t>=0&&h>=0&&(s[t*this._yn+h]=1);const _=Array(this._yn*this._yn).fill(0);return h>=0&&n>=0&&(_[h*this._yn+n]=1),[].concat(_,s,i)}}_psi(t,h,n){const i=this._phi(t,h,n);let s=0;for(let t=0;t<i.length;t++)s+=this._w[t]*i[t];return Math.exp(s)}_alpha(t,h=!1){const n=[Array(this._yn).fill(1)],i=h&&[1];for(let h=0;h<t.length;h++){const s=[];for(let i=0;i<this._yn;i++){s[i]=0;for(let _=0;_<this._yn;_++)s[i]+=n[h][_]*this._psi(t[h],this._y_cand[i],this._y_cand[_])}n[h+1]=s,i&&(i[h]=s.reduce(((t,h)=>t+h),0),n[h+1]=s.map((t=>t/i[h])))}return h?[n,i]:n}_beta(t,h=!1){const n=[];n[t.length]=Array(this._yn).fill(1);const i=h&&[];h&&(i[t.length]=1);for(let h=t.length-1;h>=0;h--){const s=[];for(let i=0;i<this._yn;i++){s[i]=0;for(let _=0;_<this._yn;_++)s[i]+=n[h+1][_]*this._psi(t[h],this._y_cand[_],this._y_cand[i])}n[h]=s,i&&(i[h]=s.reduce(((t,h)=>t+h),0),n[h]=s.map((t=>t/i[h])))}return h?[n,i]:n}_z(t){const h=this._alpha(t);return h[h.length-1].reduce(((t,h)=>t+h),0)}_p(t,h=!1){let n,i,s,_,e;h?[n,i]=this._alpha(t,!0):n=this._alpha(t),h?[s,_]=this._beta(t,!0):s=this._beta(t),e=h?1:1/this._z(t);const l=[];for(let r=t.length-1;r>=0;r--){l[r]=[],h&&(e*=_[r]/i[r]);for(let h=0;h<this._yn;h++){l[r][h]=[];for(let i=0;i<this._yn;i++)l[r][h][i]=this._psi(t[r],this._y_cand[h],this._y_cand[i])*n[r][i]*s[r][h]*e}}return l}fit(t,h){if(!this._w){const n=new Set,i=new Set;for(let s=0;s<t.length;s++)for(let _=0;_<t[s].length;_++)n.add(t[s][_]),i.add(h[s][_]);this._x_cand=[...n],this._y_cand=[...i],this._xn=this._x_cand.length,this._yn=this._y_cand.length+1;const s=this._phi(t[0][1],h[0][1],h[0][0]);this._w=Matrix.randn(s.length,1).value}const n=this._w.length,i=Array(n).fill(0);for(let s=0;s<t.length;s++){const _=this._p(t[s],!0);for(let e=0;e<t[s].length;e++){const l=this._phi(t[s][e],h[s][e],h[s][e-1]);for(let h=0;h<this._yn;h++)for(let i=0;i<this._yn;i++){const r=this._phi(t[s][e],this._y_cand[h],this._y_cand[i]);for(let t=0;t<n;t++)l[t]-=_[e][h][i]*r[t]}for(let t=0;t<n;t++)i[t]+=l[t]}}for(let h=0;h<n;h++)this._w[h]+=this._e*i[h]/t.length}probability(t,h){const n=this._z(t),i=this._phi(t[0],h[0],void 0);for(let n=1;n<t.length;n++){const s=this._phi(t[n],h[n],h[n-1]);for(let t=0;t<s.length;t++)i[t]+=s[t]}return Math.exp(i.reduce(((t,h,n)=>t+h*this._w[n]),0))/n}predict(t){const h=[];for(let n=0;n<t.length;n++){const i=[Array(this._yn).fill(0)],s=[];for(let h=0;h<t[n].length;h++){i[h+1]=[],s[h]=[];for(let _=0;_<this._yn;_++){i[h+1][_]=-1/0,s[h][_]=null;for(let e=0;e<this._yn;e++){const l=this._phi(t[n][h],this._y_cand[_],this._y_cand[e]),r=i[h][e]+l.reduce(((t,h,n)=>t+h*this._w[n]),0);i[h+1][_]<r&&(i[h+1][_]=r,s[h][_]=e)}}}h[n]=[];let _=-1/0;for(let s=0;s<this._yn;s++)_<i[t[n].length][s]&&(_=i[t[n].length][s],h[n][t[n].length-1]=s);for(let i=t[n].length-2;i>=0;i--)h[n][i]=s[i+1][h[n][i+1]];h[n]=h[n].map((t=>this._y_cand[t]))}return h}}