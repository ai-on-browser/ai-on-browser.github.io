var d=Object.defineProperty;var u=(n,t)=>d(n,"name",{value:t,configurable:!0});import i from"../util/matrix.js";const m={gaussian:(n=1)=>(t,s)=>{const e=i.sub(t,s).reduce((r,o)=>r+o*o,0);return Math.exp(-e/n**2)},polynomial:(n=2)=>(t,s)=>t.dot(s.t).toScaler()**n};export class PCA{static{u(this,"PCA")}constructor(t=null){this._rd=t??0}fit(t){t=i.fromArray(t);const s=t.cov();[this._e,this._w]=s.eigen();const e=this._e.reduce((r,o)=>r+o,0);this._e=this._e.map(r=>r/e)}predict(t){t=i.fromArray(t);const s=this._w;return this._rd>0&&this._rd<s.cols&&s.resize(s.rows,this._rd),t.dot(s).toArray()}}export class DualPCA{static{u(this,"DualPCA")}constructor(t=null){this._rd=t??0}fit(t){this._x=i.fromArray(t),this._x.sub(this._x.mean(0));const s=this._x.dot(this._x.t);[this._e,this._w]=s.eigen(),this._w.div(i.map(new i(1,this._e.length,this._e),Math.sqrt));const e=this._e.reduce((r,o)=>r+o,0);this._e=this._e.map(r=>r/e)}predict(t){t=i.fromArray(t);const s=this._w;return this._rd>0&&this._rd<s.cols&&s.resize(s.rows,this._rd),t.dot(this._x.tDot(s)).toArray()}}export class KernelPCA{static{u(this,"KernelPCA")}constructor(t,s=null){typeof t=="function"?this._kernel=(e,r)=>t(e.value,r.value):(typeof t=="string"&&(t={name:t}),t.name==="gaussian"?this._kernel=m.gaussian(t.sigma):this._kernel=m.polynomial(t.n)),this._rd=s??0}fit(t){this._x=i.fromArray(t);const s=this._x.rows,e=new i(s,s),r=[];for(let h=0;h<s;h++)r.push(this._x.row(h));for(let h=0;h<s;h++)for(let c=h;c<s;c++){const l=this._kernel(r[h],r[c]);e.set(h,c,l),e.set(c,h,l)}const _=i.sub(i.eye(s,s),1/s).dot(e).cov();[this._e,this._w]=_.eigen();const a=this._e.reduce((h,c)=>h+c,0);this._e=this._e.map(h=>h/a)}_gram(t){t=i.fromArray(t);const s=t.rows,e=this._x.rows,r=new i(s,e);for(let o=0;o<s;o++)for(let _=0;_<e;_++){const a=this._kernel(t.row(o),this._x.row(_));r.set(o,_,a)}return r}predict(t){const s=this._w;return this._rd>0&&this._rd<s.cols&&s.resize(s.rows,this._rd),t=this._gram(t),t.dot(s).toArray()}}export class AnomalyPCA extends PCA{static{u(this,"AnomalyPCA")}constructor(){super()}fit(t){t=i.fromArray(t),this._m=t.mean(0),t.sub(this._m),super.fit(t)}predict(t){t=i.fromArray(t),t.sub(this._m);const s=this._w.rows;let e=.99,r=0;for(;r<this._e.length-1&&e>=0;r++)e-=this._e[r];r=Math.max(1,r);const o=this._w.slice(0,r,1),_=i.eye(s,s);_.sub(o.dot(o.t));const a=t.dot(_);return a.mult(t),a.sum(1).value}}
