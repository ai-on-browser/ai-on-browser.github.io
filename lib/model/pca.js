import Matrix from"../util/matrix.js";const Kernel={gaussian:(t=1)=>(r,s)=>{const e=Matrix.sub(r,s).reduce(((t,r)=>t+r*r),0);return Math.exp(-e/t**2)},polynomial:(t=2)=>(r,s)=>r.dot(s.t).toScaler()**t};export class PCA{fit(t){const r=(t=Matrix.fromArray(t)).cov();[this._e,this._w]=r.eigen();const s=this._e.reduce(((t,r)=>t+r),0);this._e=this._e.map((t=>t/s))}predict(t,r=0){t=Matrix.fromArray(t);const s=this._w;return r>0&&r<s.cols&&s.resize(s.rows,r),t.dot(s).toArray()}}export class DualPCA{fit(t){this._x=Matrix.fromArray(t),this._x.sub(this._x.mean(0));const r=this._x.dot(this._x.t);[this._e,this._w]=r.eigen(),this._w.div(Matrix.map(new Matrix(1,this._e.length,this._e),Math.sqrt));const s=this._e.reduce(((t,r)=>t+r),0);this._e=this._e.map((t=>t/s))}predict(t,r=0){t=Matrix.fromArray(t);const s=this._w;return r>0&&r<s.cols&&s.resize(s.rows,r),t.dot(this._x.tDot(s)).toArray()}}export class KernelPCA{constructor(t,r=[]){this._kernel=Kernel[t](...r)}fit(t){this._x=Matrix.fromArray(t);const r=this._x.rows,s=new Matrix(r,r),e=[];for(let t=0;t<r;t++)e.push(this._x.row(t));for(let t=0;t<r;t++)for(let i=t;i<r;i++){const r=this._kernel(e[t],e[i]);s.set(t,i,r),s.set(i,t,r)}const i=Matrix.sub(Matrix.eye(r,r),1/r).dot(s).cov();[this._e,this._w]=i.eigen();const o=this._e.reduce(((t,r)=>t+r),0);this._e=this._e.map((t=>t/o))}_gram(t){const r=(t=Matrix.fromArray(t)).rows,s=this._x.rows,e=new Matrix(r,s);for(let i=0;i<r;i++)for(let r=0;r<s;r++){const s=this._kernel(t.row(i),this._x.row(r));e.set(i,r,s)}return e}predict(t,r=0){const s=this._w;return r>0&&r<s.cols&&s.resize(s.rows,r),(t=this._gram(t)).dot(s).toArray()}}export class AnomalyPCA extends PCA{constructor(){super()}fit(t){t=Matrix.fromArray(t),this._m=t.mean(0),t.sub(this._m),super.fit(t)}predict(t){(t=Matrix.fromArray(t)).sub(this._m);const r=this._w.rows;let s=.99,e=0;for(;e<this._e.length-1&&s>=0;e++)s-=this._e[e];e=Math.max(1,e);const i=this._w.slice(0,e,1),o=Matrix.eye(r,r);o.sub(i.dot(i.t));const a=t.dot(o);return a.mult(t),a.sum(1).value}}