import{Matrix}from"../util/math.js";export default class GaussianProcess{constructor(t="gaussian",s=1){"gaussian"===t&&(this._kernel=new GaussianKernel),this._beta=s}init(t,s){const e=t.length;this._x=[];for(let s=0;s<e;s++)this._x.push(t[s]);this._t=new Matrix(s.length,1,s),this._k=new Matrix(e,e)}fit(t=.1){const s=this._x.length;for(let t=0;t<s;t++){this._k.set(t,t,this._kernel.calc(this._x[t],this._x[t])+1/this._beta);for(let s=0;s<t;s++){const e=this._kernel.calc(this._x[t],this._x[s]);this._k.set(t,s,e),this._k.set(s,t,e)}}this._prec_t=this._k.solve(this._t);const e=[new Matrix(s,s),new Matrix(s,s)];for(let t=0;t<s;t++)for(let s=0;s<=t;s++){const i=this._kernel.derivatives(this._x[t],this._x[s]);for(let h=0;h<i.length;h++)e[h].set(t,s,i[h]),e[h].set(s,t,i[h])}const i=this._prec_t.t,h=e.map((s=>(-this._k.solve(s).trace()+i.dot(s).dot(this._prec_t).trace())*t));this._kernel.update(...h)}predict(t){const s=this._t.cols,e=Matrix.zeros(t.length,s);for(let i=0;i<t.length;i++){const h=t[i];for(let t=0;t<this._x.length;t++){const r=this._kernel.calc(h,this._x[t]);for(let h=0;h<s;h++)e.addAt(i,h,r*this._prec_t.at(t,h))}}return e.toArray()}}class GaussianKernel{constructor(){this._a=0,this._b=1}calc(t,s){let e=0;for(let i=0;i<t.length;i++)e+=(t[i]-s[i])**2;return Math.exp(-this._b/2*e)*this._a}derivatives(t,s){let e=0;for(let i=0;i<t.length;i++)e+=(t[i]-s[i])**2;const i=Math.exp(-this._b/2*e);return[i,-.5*e*i*this._a]}update(t,s){this._a+=t,this._b+=s}}