var d=Object.defineProperty;var a=(l,s)=>d(l,"name",{value:s,configurable:!0});import c from"../util/matrix.js";export default class f{static{a(this,"GaussianProcess")}constructor(s="gaussian",e=1){s==="gaussian"&&(this._kernel=new p),this._beta=e}init(s,e){const h=s.length;this._x=[];for(let i=0;i<h;i++)this._x.push(s[i]);this._t=new c(e.length,1,e),this._k=new c(h,h)}fit(s=.1){const e=this._x.length;for(let t=0;t<e;t++){this._k.set(t,t,this._kernel.calc(this._x[t],this._x[t])+1/this._beta);for(let r=0;r<t;r++){const n=this._kernel.calc(this._x[t],this._x[r]);this._k.set(t,r,n),this._k.set(r,t,n)}}this._prec_t=this._k.solve(this._t);const h=[new c(e,e),new c(e,e)];for(let t=0;t<e;t++)for(let r=0;r<=t;r++){const n=this._kernel.derivatives(this._x[t],this._x[r]);for(let _=0;_<n.length;_++)h[_].set(t,r,n[_]),h[_].set(r,t,n[_])}const i=this._prec_t.t,o=h.map(t=>(-this._k.solve(t).trace()+i.dot(t).dot(this._prec_t).trace())*s);this._kernel.update(...o)}predict(s){const e=this._t.cols,h=c.zeros(s.length,e);for(let i=0;i<s.length;i++){const o=s[i];for(let t=0;t<this._x.length;t++){const r=this._kernel.calc(o,this._x[t]);for(let n=0;n<e;n++)h.addAt(i,n,r*this._prec_t.at(t,n))}}return h.toArray()}}class p{static{a(this,"GaussianKernel")}constructor(){this._a=0,this._b=1}calc(s,e){let h=0;for(let i=0;i<s.length;i++)h+=(s[i]-e[i])**2;return Math.exp(-this._b/2*h)*this._a}derivatives(s,e){let h=0;for(let t=0;t<s.length;t++)h+=(s[t]-e[t])**2;const i=Math.exp(-this._b/2*h),o=-1/2*h*i*this._a;return[i,o]}update(s,e){this._a+=s,this._b+=e}}
