import Graph from"../util/graph.js";export default class CHAMELEON{constructor(t=5){this._k=t,this._minSize=.05,this._t_ri=0,this._t_rc=0,this._alpha=1}_sim(t,e){return Math.exp(-(this._d(t,e)**2)/2)}_d(t,e){return Math.sqrt(t.reduce(((t,l,r)=>t+(l-e[r])**2),0))}fit(t){const e=t.length,l=this._minSize<1?e*this._minSize:this._minSize,r=[];for(let l=0;l<e;l++){r[l]=[],r[l][l]=0;for(let e=0;e<l;e++)r[l][e]=r[e][l]=this._d(t[l],t[e])}const i=[],n=[];for(let l=0;l<e;l++){const s=r[l].map(((t,e)=>[t,e]));s.sort(((t,e)=>t[0]-e[0]));const o=s.slice(1,this._k+1);i[l]=Array(e).fill(!1);for(let t=0;t<o.length;t++)i[l][o[t][1]]=!0;n[l]=Array(e).fill(0);for(let e=0;e<l;e++)(i[l][e]||i[e][l])&&(n[l][e]=n[e][l]=this._sim(t[l],t[e]))}let s=[Array.from({length:e},((t,e)=>e))];for(;;){const t=[];for(let e=0;e<s.length;e++){const r=s[e];if(r.length<l){t.push(r);continue}const i=[];for(let t=0;t<r.length;t++){i[t]=[];for(let e=0;e<r.length;e++)i[t][e]=n[r[t]][r[e]]}const o=Graph.fromAdjacency(i);let[,h]=o.mincut(Math.ceil(o.order/4));h.every((t=>t.length<l))?t.push(r):t.push(...h.map((t=>t.map((t=>r[t])))))}if(s.length===t.length)break;s=t}const o=[],h=[];for(let t=0;t<s.length;t++){const e=s[t];o[t]=[],h[t]=[];const[l,r]=this._roughly_bisect(n,e);o[t][t]=l,h[t][t]=r;for(let l=0;l<t;l++){o[t][l]=0;let r=0;for(let i=0;i<e.length;i++)for(let h=0;h<s[l].length;h++)n[e[i]][s[l][h]]&&(o[t][l]+=n[e[i]][s[l][h]],r++);o[l][t]=o[t][l],h[t][l]=h[l][t]=r}}const c=s.map((t=>({idx:t})));for(;c.length>1;){let t=-1/0,e=-1,l=-1;for(let r=0;r<c.length;r++)for(let i=r+1;i<c.length;i++){const n=Math.abs(o[r][i])/((Math.abs(o[r][r])+Math.abs(o[i][i]))/2),s=c[r].idx.length,f=c[i].idx.length;if(0===h[r][i]||0===h[r][r]||0===h[i][i])continue;const g=o[r][i]/h[r][i]/(s/(s+f)*(o[r][r]/h[r][r])+f/(s+f)*(o[i][i]/h[i][i]));if(n<this._t_ri||g<this._t_rc)continue;const a=n*g**this._alpha;a>t&&(t=a,e=r,l=i)}if(t===-1/0)break;c[e]={idx:[...c[e].idx,...c[l].idx],children:[c[e],c[l]],t:t},c.splice(l,1);for(let t=0;t<o.length;t++)if(t!==l){if(t===e){const[l,r]=this._roughly_bisect(n,c[e].idx);o[t][t]=l,h[t][t]=r}else o[t][e]+=o[t][l],h[t][e]+=h[t][l],o[e][t]+=o[l][t],h[e][t]+=h[l][t];h[t].splice(l,1),o[t].splice(l,1)}o.splice(l,1),h.splice(l,1)}this._root=c}_roughly_bisect(t,e){if(e.length<=1)return[0,[e]];const l=[];for(let r=0;r<e.length;r++){l[r]=[];for(let i=0;i<e.length;i++)l[r][i]=t[e[r]][e[i]]}const r=Graph.fromAdjacency(l),[i,n]=r.bisectionSpectral();let s=0;for(let t=0;t<n[0].length;t++)for(let e=0;e<n[1].length;e++)l[n[0][t]][n[1][e]]&&(s+=l[n[0][t]][n[1][e]]);return[i,s]}getClusters(t){const e=[...this._root];for(;e.length<t;){let t=1/0,l=-1;for(let r=0;r<e.length;r++){const i=e[r];i.children&&i.t<t&&(l=r,t=i.t)}if(-1===l)break;const r=e[l];e.splice(l,1,r.children[0],r.children[1])}return e}predict(t){const e=[],l=this.getClusters(t);for(let t=0;t<l.length;t++)for(const r of l[t].idx)e[r]=t;return e}}