var S=Object.defineProperty;var b=(x,h)=>S(x,"name",{value:h,configurable:!0});import k from"../util/graph.js";export default class w{static{b(this,"CHAMELEON")}constructor(h=5){this._k=h,this._minSize=.05,this._t_ri=0,this._t_rc=0,this._alpha=1}_sim(h,l){return Math.exp(-(this._d(h,l)**2)/2)}_d(h,l){return Math.sqrt(h.reduce((a,f,d)=>a+(f-l[d])**2,0))}fit(h){const l=h.length,a=this._minSize<1?l*this._minSize:this._minSize,f=[];for(let e=0;e<l;e++){f[e]=[],f[e][e]=0;for(let s=0;s<e;s++)f[e][s]=f[s][e]=this._d(h[e],h[s])}const d=[],r=[];for(let e=0;e<l;e++){const s=f[e].map((t,i)=>[t,i]);s.sort((t,i)=>t[0]-i[0]);const o=s.slice(1,this._k+1);d[e]=Array(l).fill(!1);for(let t=0;t<o.length;t++)d[e][o[t][1]]=!0;r[e]=Array(l).fill(0);for(let t=0;t<e;t++)(d[e][t]||d[t][e])&&(r[e][t]=r[t][e]=this._sim(h[e],h[t]))}let _=[Array.from({length:l},(e,s)=>s)];for(;;){const e=[];for(let s=0;s<_.length;s++){const o=_[s];if(o.length<a){e.push(o);continue}const t=[];for(let g=0;g<o.length;g++){t[g]=[];for(let u=0;u<o.length;u++)t[g][u]=r[o[g]][o[u]]}const i=k.fromAdjacency(t);let[,p]=i.mincut(Math.ceil(i.order/4));p.every(g=>g.length<a)?e.push(o):e.push(...p.map(g=>g.map(u=>o[u])))}if(_.length===e.length)break;_=e}const n=[],c=[];for(let e=0;e<_.length;e++){const s=_[e];n[e]=[],c[e]=[];const[o,t]=this._roughly_bisect(r,s);n[e][e]=o,c[e][e]=t;for(let i=0;i<e;i++){n[e][i]=0;let p=0;for(let g=0;g<s.length;g++)for(let u=0;u<_[i].length;u++)r[s[g]][_[i][u]]&&(n[e][i]+=r[s[g]][_[i][u]],p++);n[i][e]=n[e][i],c[e][i]=c[i][e]=p}}const m=_.map(e=>({idx:e}));for(;m.length>1;){let e=-1/0,s=-1,o=-1;for(let t=0;t<m.length;t++)for(let i=t+1;i<m.length;i++){const p=Math.abs(n[t][i])/((Math.abs(n[t][t])+Math.abs(n[i][i]))/2),g=m[t].idx.length,u=m[i].idx.length;if(c[t][i]===0||c[t][t]===0||c[i][i]===0)continue;const M=n[t][i]/c[t][i],z=n[t][t]/c[t][t],A=n[i][i]/c[i][i],j=M/(g/(g+u)*z+u/(g+u)*A);if(p<this._t_ri||j<this._t_rc)continue;const y=p*j**this._alpha;y>e&&(e=y,s=t,o=i)}if(e===-1/0)break;m[s]={idx:[...m[s].idx,...m[o].idx],children:[m[s],m[o]],t:e},m.splice(o,1);for(let t=0;t<n.length;t++)if(t!==o){if(t===s){const[i,p]=this._roughly_bisect(r,m[s].idx);n[t][t]=i,c[t][t]=p}else n[t][s]+=n[t][o],c[t][s]+=c[t][o],n[s][t]+=n[o][t],c[s][t]+=c[o][t];c[t].splice(o,1),n[t].splice(o,1)}n.splice(o,1),c.splice(o,1)}this._root=m}_roughly_bisect(h,l){if(l.length<=1)return[0,[l]];const a=[];for(let n=0;n<l.length;n++){a[n]=[];for(let c=0;c<l.length;c++)a[n][c]=h[l[n]][l[c]]}const f=k.fromAdjacency(a),[d,r]=f.bisectionSpectral();let _=0;for(let n=0;n<r[0].length;n++)for(let c=0;c<r[1].length;c++)a[r[0][n]][r[1][c]]&&(_+=a[r[0][n]][r[1][c]]);return[d,_]}getClusters(h){const l=[...this._root];for(;l.length<h;){let a=1/0,f=-1;for(let r=0;r<l.length;r++){const _=l[r];_.children&&_.t<a&&(f=r,a=_.t)}if(f===-1)break;const d=l[f];l.splice(f,1,d.children[0],d.children[1])}return l}predict(h){const l=[],a=this.getClusters(h);for(let f=0;f<a.length;f++)for(const d of a[f].idx)l[d]=f;return l}}
