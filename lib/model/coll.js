import Matrix from"../util/matrix.js";export default class COLL{constructor(t,s=1,i="gaussian"){if(this._c=t,this._eta=s,"function"==typeof i)this._kernel=i;else switch(i){case"gaussian":this._s=1,this._kernel=(t,s)=>Math.exp(-(t.reduce(((t,i,h)=>t+(i-s[h])**2),0)**2)/this._s**2);break;case"polynomial":this._d=2,this._kernel=(t,s)=>(1+t.reduce(((t,i,h)=>t+i*s[h])))**this._d}}init(t){this._datas=t;const s=t.length;this._k=[],this._nu=[],this._t=0,this._nk=Array(this._c).fill(0);for(let i=0;i<s;i++){this._nu[i]=Math.floor(Math.random()*this._c),this._nk[this._nu[i]]++,this._k[i]=[],this._k[i][i]=this._kernel(t[i],t[i]);for(let s=0;s<i;s++)this._k[i][s]=this._k[s][i]=this._kernel(t[i],t[s])}this._f=this._nk.map((t=>t/s));const i=Matrix.zeros(this._c,s);for(let t=0;t<s;t++)i.set(this._nu[t],t,1/this._nk[this._nu[t]]);const h=Matrix.fromArray(this._k),e=i.dot(h);this._w=new Matrix(this._c,s+1),this._w.set(0,0,e);for(let t=0;t<this._c;t++){let h=0;for(let _=0;_<s;_++)h+=e.at(t,_)*i.at(t,_);this._w.set(t,s,h)}}fit(){const t=this._datas.length,s=Array.from({length:this._c},(()=>[])),i=Array.from({length:t},((t,s)=>s));for(let t=i.length-1;t>0;t--){const s=Math.floor(Math.random()*(t+1));[i[t],i[s]]=[i[s],i[t]]}this._t++;const h=this._eta/this._t;for(let e=0;e<t;e++){const _=i[e];let r=-1,n=1/0;for(let s=0;s<this._c;s++){const i=this._f[s]*(this._k[_][_]+this._w.at(s,t)-2*this._w.at(s,_));i<n&&(n=i,r=s)}this._nu[_]=r,s[r].push(_);for(let s=0;s<t;s++)this._w.set(r,s,(1-h)*this._w.at(r,s)+h*this._k[_][s]);this._w.set(r,t,(1-h)**2*this._w.at(r,t)+h**2*this._k[_][_]+2*(1-h)*h*this._w.at(r,_)),this._nk[r]+=1;const a=this._nk.reduce(((t,s)=>t+s),0);this._f=this._nk.map((t=>t/a))}if(1===h)return 1/0;let e=0;for(let i=0;i<this._c;i++){e+=(1-1/(1-h)**s[i].length)**2*this._w.at(i,t);for(let t=0;t<s[i].length;t++)for(let _=0;_<s[i].length;_++)e+=h**2*this._k[s[i][t]][s[i][_]]/(1-h)**(t+_);const _=2*h*(1-1/(1-h)**s[i].length);for(let t=0;t<s[i].length;t++)e+=_*this._w.at(i,s[i][t])/(1-h)**t}return e}predict(){return this._nu}}