var G=Object.defineProperty;var S=(q,u)=>G(q,"name",{value:u,configurable:!0});export default class N{static{S(this,"STING")}constructor(u){this._c=u,this._cells=null,this._t=.05}fit(u){const h=u,d=h.length,r=h[0].length,x=h.reduce((s,t)=>s.map((e,a)=>Math.min(e,t[a])),Array(r).fill(1/0)),k=h.reduce((s,t)=>s.map((e,a)=>Math.max(e,t[a])),Array(r).fill(-1/0)),A=x.map((s,t)=>[s,k[t]]);this._cells={ranges:A,children:[]};let _=[this._cells];const b=2**r,z=Math.log(d/5)/Math.log(b),o=[_];for(let s=0;s<z;s++){const t=[];for(const e of _){const a=e.ranges;for(let c=0;c<b;c++){let i=c;const l=[];for(let p=0;p<r;p++){const M=(a[p][1]+a[p][0])/2;i%2===0?l.push([a[p][0],M]):l.push([M,a[p][1]]),i=Math.floor(i/2)}const m={ranges:l,children:[]};t.push(m),e.children.push(m)}}_=t,o.push(_)}let w=1;for(let s=0;s<r;s++){const t=_[0].ranges[s];w*=t[1]-t[0]}for(let s=0;s<_.length;s++){const t=_[s],e=h.filter(i=>t.ranges.every((l,m)=>l[0]<=i[m]&&(l[1]===k[m]?i[m]<=l[1]:i[m]<l[1])));t.n=e.length,t.min=Array(r).fill(1/0),t.max=Array(r).fill(-1/0);const a=Array(r).fill(0);for(let i=0;i<t.n;i++)for(let l=0;l<r;l++)a[l]+=e[i][l],t.min[l]=Math.min(t.min[l],e[i][l]),t.max[l]=Math.max(t.max[l],e[i][l]);t.m=a.map(i=>t.n>0?i/t.n:0);const c=Array(r).fill(0);for(let i=0;i<t.n;i++)for(let l=0;l<r;l++)c[l]+=(e[i][l]-t.m[l])**2;t.s=c.map(i=>t.n>0?Math.sqrt(i/t.n):0),t.dist=Array(r).fill("normal"),t.area=w}for(let s=o.length-2;s>=0;s--)for(let t=0;t<o[s].length;t++){let e=0,a=0;const c=Array(r).fill(0),i=o[s][t].min=Array(r).fill(1/0),l=o[s][t].max=Array(r).fill(-1/0),m=Array(r).fill(0),p=o[s+1].slice(t*b,(t+1)*b);for(const n of p){e+=n.n,a+=n.area;for(let f=0;f<r;f++)c[f]+=n.m[f]*n.n,i[f]=Math.min(i[f],n.min[f]),l[f]=Math.max(l[f],n.max[f]),m[f]+=(n.s[f]**2+n.m[f]**2)*n.n}o[s][t].n=e,o[s][t].m=c.map(n=>e>0?n/e:0),o[s][t].s=m.map((n,f)=>e>0?Math.sqrt(n/e-(c[f]/e)**2):0);const M=.1;o[s][t].dist=Array(r).fill("normal"),o[s][t].area=a;for(let n=0;n<r;n++){let f=0,C="normal";for(const g of p){let j=0,v=0;o[s][t].m[n]!==0?j+=Math.abs((o[s][t].m[n]-g.m[n])/o[s][t].m[n]):g.m[n]!==0&&(j+=Math.abs((o[s][t].m[n]-g.m[n])/g.m[n])),o[s][t].s[n]!==0?v+=Math.abs((o[s][t].s[n]-g.s[n])/o[s][t].s[n]):g.s[n]!==0&&(v+=Math.abs((o[s][t].s[n]-g.s[n])/g.s[n])),C!==g.dist&&j<M&&v<M?f+=g.n:(j>=M||v>=M)&&(f=e)}e>0&&f/e>this._t&&(C="none"),o[s][t].dist[n]=C}}let y=[this._cells];for(let s=1;s<o.length;s++){const t=[];for(let e=0;e<y.length;e++)for(const a of y[e].children)a.n<a.area*this._c||t.push(a);y=t}this._clusters=[];const I=[];for(;;){if(I.length===0){if(y.length===0)break;I.push(y.pop()),this._clusters.push([])}const s=I.pop();this._clusters[this._clusters.length-1].push(s);for(let t=y.length-1;t>=0;t--){const e=y[t];let a=0;for(let c=0;c<r&&a<2;c++)s.ranges[c][0]===e.ranges[c][0]&&s.ranges[c][1]===e.ranges[c][1]||(s.ranges[c][0]===e.ranges[c][1]||s.ranges[c][1]===e.ranges[c][0]?a++:a=1/0);a===1&&(I.push(e),y.splice(t,1))}}}predict(u){const h=[];for(let d=0;d<u.length;d++){h[d]=-1;for(let r=0;r<this._clusters.length&&h[d]<0;r++)for(const x of this._clusters[r])if(u[d].every((k,A)=>x.ranges[A][0]<=k&&k<=x.ranges[A][1])){h[d]=r;break}}return h}}
