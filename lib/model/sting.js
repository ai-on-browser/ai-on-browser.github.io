import{Tree}from"../util/math.js";export default class STING{constructor(){this._cells=null}fit(l){const e=l,t=e.length,a=e[0].length,r=e.reduce(((l,e)=>l.map(((l,t)=>Math.min(l,e[t])))),Array(a).fill(1/0)),n=e.reduce(((l,e)=>l.map(((l,t)=>Math.max(l,e[t])))),Array(a).fill(-1/0)),s=r.map(((l,e)=>[l,n[e]]));this._cells=new Tree({ranges:s});let o=[this._cells];const f=2**a,h=Math.log(t/20)/Math.log(f),m=[o];for(let l=0;l<h;l++){const l=[];for(const e of o){const t=e.value.ranges;for(let r=0;r<f;r++){let n=r;const s=[];for(let l=0;l<a;l++){const e=(t[l][1]+t[l][0])/2;n%2==0?s.push([t[l][0],e]):s.push([e,t[l][1]]),n=Math.floor(n/2)}const o=new Tree({ranges:s});l.push(o),e.push(o)}}o=l,m.push(o)}for(let l=0;l<o.length;l++){const t=o[l],r=e.filter((l=>t.value.ranges.every(((e,t)=>e[0]<=l[t]&&(e[1]===n[t]?l[t]<=e[1]:l[t]<e[1]))))),s=t.value.n=r.length,f=Array(a).fill(0),h=t.value.min=Array(a).fill(1/0),m=t.value.max=Array(a).fill(-1/0);for(let l=0;l<s;l++)for(let e=0;e<a;e++)f[e]+=r[l][e],h[e]=Math.min(h[e],r[l][e]),m[e]=Math.max(m[e],r[l][e]);t.value.m=f.map((l=>s>0?l/s:0));const i=Array(a).fill(0);for(let l=0;l<s;l++)for(let e=0;e<a;e++)i[e]+=(r[l][e]-f[e])**2;t.value.s=i.map((l=>s>0?Math.sqrt(l/s):0))}for(let l=m.length-2;l>=0;l--)for(let e=0;e<m[l].length;e++){let t=0;const r=Array(a).fill(0),n=m[l][e].value.min=Array(a).fill(1/0),s=m[l][e].value.max=Array(a).fill(-1/0),o=Array(a).fill(0);for(const h of m[l+1].slice(e*f,(e+1)*f)){const l=h.value;t+=l.n;for(let e=0;e<a;e++)r[e]+=l.m[e]*l.n,n[e]=Math.min(n[e],l.min[e]),s[e]=Math.max(s[e],l.max[e]),o[e]+=(l.s[e]**2+l.m[e]**2)*l.n}m[l][e].value.n=t,m[l][e].value.m=r=r.map((l=>t>0?l/t:0)),m[l][e].value.s=o.map(((l,e)=>t>0?Math.sqrt(l/t-r[e]**2):0))}}predict(l){}}