import Matrix from"../util/matrix.js";export default class DiscriminantAdaptiveNearestNeighbor{constructor(t=null){this._k=t,this._e=1,this._phi=(t,s)=>t<s?(1-(t/s)**3)**3:0}fit(t,s){this._x=Matrix.fromArray(t),this._y=s,this._c=[...new Set(s)],this._mean=this._x.mean(0),this._cmean=[];for(let s=0;s<this._c.length;s++){const i=t.filter(((t,i)=>this._y[i]===this._c[s]));this._cmean[s]=Matrix.fromArray(i).mean(0)}}predict(t,s=1){const i=this._x.rows,o=this._x.cols,n=this._k??Math.min(i/5,50),r=[];for(let t=0;t<i;t++)r[t]=this._x.row(t);return t.map((t=>{const e=new Matrix(1,t.length,t);let a=Matrix.eye(o,o);const c=Matrix.sub(e,this._x);let h=Matrix.concat(this._x,e,0);for(let t=0;t<s;t++){const t=a.sqrt();h=h.dot(t);const s=c.dot(t);s.map((t=>t**2));const n=s.sum(1);n.map(Math.sqrt);const e=n.max(),_=n.value.map((t=>this._phi(t,e)));let m=0;const l=Array(this._c.length).fill(0),d=Matrix.zeros(o,o);for(let t=0;t<i;t++){if(0===_[t])continue;const s=this._c.indexOf(this._y[t]),i=Matrix.sub(r[t],this._cmean[s]),o=i.tDot(i);o.mult(_[t]),d.add(o),l[s]+=_[t],m+=_[t]}d.div(m);const u=Matrix.zeros(o,o);for(let t=0;t<this._c.length;t++){if(0===l[t])continue;const s=Matrix.sub(this._cmean[t],this._mean),i=s.tDot(s);i.mult(l[t]/m),u.add(i)}const x=d.sqrt(),f=x.dot(u).dot(x);f.add(Matrix.eye(o,o,this._e)),a=x.dot(f).dot(x)}const _=a.sqrt();h=h.dot(_);const m=h.row(h.rows-1);h=h.slice(0,h.rows-1,0),h.sub(m),h.map((t=>t**2));const l=h.sum(1),d=l.sort(0),u={};for(let t=0;t<n;t++){const s=d[t];u[this._y[s]]?(u[this._y[s]].count++,u[this._y[s]].min_d=Math.min(u[this._y[s]].min_d,l.at(t,0))):u[this._y[s]]={category:this._y[s],count:1,min_d:l.at(t,0)}}let x=0,f=-1,y=null;for(const t of Object.keys(u))(x<u[t].count||x===u[t].count&&u[t].min_d<f)&&(x=u[t].count,f=u[t].min_d,y=u[t].category);return y}))}}