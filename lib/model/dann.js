import Matrix from"../util/matrix.js";export default class DiscriminantAdaptiveNearestNeighbor{constructor(t=null){this._k=t,this._e=1,this._phi=(t,s)=>t<s?(1-(t/s)**3)**3:0}fit(t,s){this._x=Matrix.fromArray(t),this._y=s,this._c=[...new Set(s)],this._mean=this._x.mean(0),this._cmean=[];for(let s=0;s<this._c.length;s++){const i=t.filter(((t,i)=>this._y[i]===this._c[s]));this._cmean[s]=Matrix.fromArray(i).mean(0)}}predict(t,s=1){const i=this._x.rows,o=this._x.cols,n=this._k??Math.min(i/5,50),e=[];for(let t=0;t<i;t++)e[t]=this._x.row(t);return t.map((t=>{const r=new Matrix(1,t.length,t);let c=Matrix.eye(o,o);const h=r.copySub(this._x);let a=this._x.concat(r,0);for(let t=0;t<s;t++){const t=c.sqrt();a=a.dot(t);const s=h.dot(t);s.map((t=>t**2));const n=s.sum(1);n.map(Math.sqrt);const r=n.max(),_=n.value.map((t=>this._phi(t,r)));let m=0;const l=Array(this._c.length).fill(0),d=Matrix.zeros(o,o);for(let t=0;t<i;t++){if(0===_[t])continue;const s=this._c.indexOf(this._y[t]),i=e[t].copySub(this._cmean[s]),o=i.tDot(i);o.mult(_[t]),d.add(o),l[s]+=_[t],m+=_[t]}d.div(m);const u=Matrix.zeros(o,o);for(let t=0;t<this._c.length;t++){if(0===l[t])continue;const s=this._cmean[t].copySub(this._mean),i=s.tDot(s);i.mult(l[t]/m),u.add(i)}const y=d.sqrt(),x=y.dot(u).dot(y);x.add(Matrix.eye(o,o,this._e)),c=y.dot(x).dot(y)}const _=c.sqrt();a=a.dot(_);const m=a.row(a.rows-1);a=a.slice(0,a.rows-1,0),a.sub(m),a.map((t=>t**2));const l=a.sum(1),d=l.sort(0),u={};for(let t=0;t<n;t++){const s=d[t];u[this._y[s]]?(u[this._y[s]].count++,u[this._y[s]].min_d=Math.min(u[this._y[s]].min_d,l.at(t,0))):u[this._y[s]]={category:this._y[s],count:1,min_d:l.at(t,0)}}let y=0,x=-1,f=null;for(const t of Object.keys(u))(y<u[t].count||y===u[t].count&&u[t].min_d<x)&&(y=u[t].count,x=u[t].min_d,f=u[t].category);return f}))}}