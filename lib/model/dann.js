var F=Object.defineProperty;var O=(q,h)=>F(q,"name",{value:h,configurable:!0});import c from"../util/matrix.js";export default class G{static{O(this,"DiscriminantAdaptiveNearestNeighbor")}constructor(h=null,_=1){this._k=h,this._iteration=_,this._e=1,this._phi=(i,a)=>i<a?(1-(i/a)**3)**3:0}fit(h,_){this._x=c.fromArray(h),this._y=_,this._c=[...new Set(_)],this._mean=this._x.mean(0),this._cmean=[];for(let i=0;i<this._c.length;i++){const a=h.filter((f,e)=>this._y[e]===this._c[i]);this._cmean[i]=c.fromArray(a).mean(0)}}predict(h){const _=this._x.rows,i=this._x.cols,a=this._k??Math.min(_/5,50),f=[];for(let e=0;e<_;e++)f[e]=this._x.row(e);return h.map(e=>{const A=new c(1,e.length,e);let x=c.eye(i,i);const W=c.sub(A,this._x);let n=c.concat(this._x,A,0);for(let s=0;s<this._iteration;s++){const r=x.sqrt();n=n.dot(r);const D=W.dot(r);D.map(t=>t**2);const w=D.sum(1);w.map(Math.sqrt);const E=w.max(),d=w.value.map(t=>this._phi(t,E));let g=0;const k=Array(this._c.length).fill(0),b=c.zeros(i,i);for(let t=0;t<_;t++){if(d[t]===0)continue;const l=this._c.indexOf(this._y[t]),m=c.sub(f[t],this._cmean[l]),N=m.tDot(m);N.mult(d[t]),b.add(N),k[l]+=d[t],g+=d[t]}b.div(g);const z=c.zeros(i,i);for(let t=0;t<this._c.length;t++){if(k[t]===0)continue;const l=c.sub(this._cmean[t],this._mean),m=l.tDot(l);m.mult(k[t]/g),z.add(m)}const u=b.sqrt(),B=u.dot(z).dot(u);B.add(c.eye(i,i,this._e)),x=u.dot(B).dot(u)}const j=x.sqrt();n=n.dot(j);const S=n.row(n.rows-1);n=n.slice(0,n.rows-1,0),n.sub(S),n.map(s=>s**2);const y=n.sum(1),C=y.sort(0),o={};for(let s=0;s<a;s++){const r=C[s];o[this._y[r]]?(o[this._y[r]].count++,o[this._y[r]].min_d=Math.min(o[this._y[r]].min_d,y.at(s,0))):o[this._y[r]]={category:this._y[r],count:1,min_d:y.at(s,0)}}let p=0,M=-1,v=null;for(const s of Object.keys(o))(p<o[s].count||p===o[s].count&&o[s].min_d<M)&&(p=o[s].count,M=o[s].min_d,v=o[s].category);return v})}}
