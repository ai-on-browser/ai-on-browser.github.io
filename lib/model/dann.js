var G=Object.defineProperty;var W=(q,h)=>G(q,"name",{value:h,configurable:!0});import c from"../util/matrix.js";export default class H{static{W(this,"DiscriminantAdaptiveNearestNeighbor")}constructor(h=null){this._k=h,this._e=1,this._phi=(_,o)=>_<o?(1-(_/o)**3)**3:0}fit(h,_){this._x=c.fromArray(h),this._y=_,this._c=[...new Set(_)],this._mean=this._x.mean(0),this._cmean=[];for(let o=0;o<this._c.length;o++){const e=h.filter((A,d)=>this._y[d]===this._c[o]);this._cmean[o]=c.fromArray(e).mean(0)}}predict(h,_=1){const o=this._x.rows,e=this._x.cols,A=this._k??Math.min(o/5,50),d=[];for(let a=0;a<o;a++)d[a]=this._x.row(a);return h.map(a=>{const M=new c(1,a.length,a);let x=c.eye(e,e);const j=c.sub(M,this._x);let i=c.concat(this._x,M,0);for(let s=0;s<_;s++){const r=x.sqrt();i=i.dot(r);const z=j.dot(r);z.map(t=>t**2);const w=z.sum(1);w.map(Math.sqrt);const F=w.max(),u=w.value.map(t=>this._phi(t,F));let g=0;const k=Array(this._c.length).fill(0),b=c.zeros(e,e);for(let t=0;t<o;t++){if(u[t]===0)continue;const l=this._c.indexOf(this._y[t]),m=c.sub(d[t],this._cmean[l]),O=m.tDot(m);O.mult(u[t]),b.add(O),k[l]+=u[t],g+=u[t]}b.div(g);const B=c.zeros(e,e);for(let t=0;t<this._c.length;t++){if(k[t]===0)continue;const l=c.sub(this._cmean[t],this._mean),m=l.tDot(l);m.mult(k[t]/g),B.add(m)}const f=b.sqrt(),N=f.dot(B).dot(f);N.add(c.eye(e,e,this._e)),x=f.dot(N).dot(f)}const S=x.sqrt();i=i.dot(S);const C=i.row(i.rows-1);i=i.slice(0,i.rows-1,0),i.sub(C),i.map(s=>s**2);const y=i.sum(1),E=y.sort(0),n={};for(let s=0;s<A;s++){const r=E[s];n[this._y[r]]?(n[this._y[r]].count++,n[this._y[r]].min_d=Math.min(n[this._y[r]].min_d,y.at(s,0))):n[this._y[r]]={category:this._y[r],count:1,min_d:y.at(s,0)}}let p=0,v=-1,D=null;for(const s of Object.keys(n))(p<n[s].count||p===n[s].count&&n[s].min_d<v)&&(p=n[s].count,v=n[s].min_d,D=n[s].category);return D})}}
