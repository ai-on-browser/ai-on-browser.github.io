import{Matrix}from"../util/math.js";export class KLIEP{constructor(t,a,s){this._sigma_cand=t,this._fold=a,this._kernelNum=s}_kernel_gaussian(t,a,s){const i=[];for(let o=0;o<a.rows;o++){const e=[];for(let i=0;i<t.rows;i++){const r=a.row(o).copySub(t.row(i));e.push(Math.exp(-r.reduce(((t,a)=>t+a**2),0)/(2*s**2)))}i.push(e)}return Matrix.fromArray(i)}_optimize_alpha(t,a){const s=a.copyDiv(a.norm()**2);let i=Matrix.ones(t.rows,1);i.add(s.copyMult(1-a.tDot(i).value[0])),i.map((t=>t<0?0:t)),i.div(a.tDot(i).value[0]);let o=t.tDot(i);o.map(Math.log),o=o.mean();for(let e=3;e>=-3;e--){const r=10**e,l=t.copyMult(r);for(let e=0;e<100;e++){const e=l.dot(t.tDot(i).copyIdiv(1));e.add(i),e.add(s.copyMult(1-a.tDot(e).value[0])),e.map((t=>t<0?0:t)),e.div(a.tDot(e).value[0]);let r=t.tDot(e);if(r.map(Math.log),r=r.mean(),r<=o)break;i=e,o=r}}return i}fit(t,a){t=Matrix.fromArray(t),a=Matrix.fromArray(a);const s=t.rows,i=Math.min(this._kernelNum,s),o=this._centers=t.sample(i);if(this._sigma=this._sigma_cand[0],this._sigma_cand.length>1){let i=-1/0;const e=[];for(let t=0;t<s;t++)e[t]=t%this._fold;for(const s of this._sigma_cand){const r=this._kernel_gaussian(t,o,s),l=this._kernel_gaussian(a,o,s).mean(1);for(let t=e.length-1;t>0;t--){let a=Math.floor(Math.random()*(t+1));[e[t],e[a]]=[e[a],e[t]]}let h=0;for(let t=0;t<this._fold;t++){const a=e.map(((a,s)=>[a===t,s])).filter((t=>t[0])).map((t=>t[1])),s=e.map(((a,s)=>[a===t,s])).filter((t=>!t[0])).map((t=>t[1])),i=this._optimize_alpha(r.col(a),l),o=r.col(s).tDot(i);o.map(Math.log),h+=o.mean()}h/=this._fold,h>i&&(i=h,this._sigma=s)}}const e=this._kernel_gaussian(t,o,this._sigma),r=this._kernel_gaussian(a,o,this._sigma);this._kw=this._optimize_alpha(e,r.mean(1))}predict(t){t=Matrix.fromArray(t);return this._kernel_gaussian(t,this._centers,this._sigma).tDot(this._kw).value}}export class KLIEPCPD{constructor(t,a,s){this._window=t,this._take=a||Math.max(1,Math.floor(t/2)),this._lag=s||Math.max(1,Math.floor(this._take/2))}predict(t){const a=[];for(let s=0;s<t.length-this._window+1;s++)a.push(t.slice(s,s+this._window).flat());const s=[];for(let t=0;t<a.length-this._take-this._lag+1;t++){const i=Matrix.fromArray(a.slice(t,t+this._take)),o=Matrix.fromArray(a.slice(t+this._lag,t+this._take+this._lag)),e=new KLIEP([100,10,1,.1,.01,.001],5,100);let r=0;e.fit(i,o);let l=e.predict(o);for(let t=0;t<l.length;t++)r+=(l[t]-1)**2/l.length;e.fit(o,i),l=e.predict(i);for(let t=0;t<l.length;t++)r+=(l[t]-1)**2/l.length;s.push(r)}return s}}