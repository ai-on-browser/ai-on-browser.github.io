import Matrix from"../util/matrix.js";export default class KLIEP{constructor(t,a,s){this._sigma_cand=t,this._fold=a,this._kernelNum=s}_kernel_gaussian(t,a,s){const i=[];for(let r=0;r<a.rows;r++){const o=[];for(let i=0;i<t.rows;i++){const e=Matrix.sub(a.row(r),t.row(i));o.push(Math.exp(-e.reduce(((t,a)=>t+a**2),0)/(2*s**2)))}i.push(o)}return Matrix.fromArray(i)}_optimize_alpha(t,a){const s=Matrix.div(a,a.norm()**2);let i=Matrix.ones(t.rows,1);i.add(Matrix.mult(s,1-a.tDot(i).toScaler())),i.map((t=>t<0?0:t)),i.div(a.tDot(i).toScaler());let r=t.tDot(i);r.map(Math.log),r=r.mean();for(let o=3;o>=-3;o--){const e=10**o,l=Matrix.mult(t,e);for(let o=0;o<100;o++){const o=l.dot(Matrix.div(1,t.tDot(i)));o.add(i),o.add(Matrix.mult(s,1-a.tDot(o).toScaler())),o.map((t=>t<0?0:t)),o.div(a.tDot(o).toScaler());let e=t.tDot(o);if(e.map(Math.log),e=e.mean(),e<=r)break;i=o,r=e}}return i}fit(t,a){t=Matrix.fromArray(t),a=Matrix.fromArray(a);const s=t.rows,i=Math.min(this._kernelNum,s),r=this._centers=t.sample(i)[0];if(this._sigma=this._sigma_cand[0],this._sigma_cand.length>1){let i=-1/0;const o=[];for(let t=0;t<s;t++)o[t]=t%this._fold;for(const s of this._sigma_cand){const e=this._kernel_gaussian(t,r,s),l=this._kernel_gaussian(a,r,s).mean(1);for(let t=o.length-1;t>0;t--){let a=Math.floor(Math.random()*(t+1));[o[t],o[a]]=[o[a],o[t]]}let n=0;for(let t=0;t<this._fold;t++){const a=o.map((a=>a===t)),s=o.map((a=>a!==t)),i=this._optimize_alpha(e.col(a),l),r=e.col(s).tDot(i);r.map(Math.log),n+=r.mean()}n/=this._fold,n>i&&(i=n,this._sigma=s)}}const o=this._kernel_gaussian(t,r,this._sigma),e=this._kernel_gaussian(a,r,this._sigma);this._kw=this._optimize_alpha(o,e.mean(1))}predict(t){t=Matrix.fromArray(t);return this._kernel_gaussian(t,this._centers,this._sigma).tDot(this._kw).value}}