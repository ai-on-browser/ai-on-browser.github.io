var S=Object.defineProperty;var w=(u,t)=>S(u,"name",{value:t,configurable:!0});import r from"../util/matrix.js";export default class A{static{w(this,"KLIEP")}constructor(t,s,c){this._sigma_cand=t,this._fold=s,this._kernelNum=c}_kernel_gaussian(t,s,c){const o=[];for(let a=0;a<s.rows;a++){const n=[];for(let _=0;_<t.rows;_++){const m=r.sub(s.row(a),t.row(_));n.push(Math.exp(-m.reduce((e,i)=>e+i**2,0)/(2*c**2)))}o.push(n)}return r.fromArray(o)}_optimize_alpha(t,s){const c=r.div(s,s.norm()**2);let o=r.ones(t.rows,1);o.add(r.mult(c,1-s.tDot(o).toScaler())),o.map(n=>n<0?0:n),o.div(s.tDot(o).toScaler());let a=t.tDot(o);a.map(Math.log),a=a.mean();for(let n=3;n>=-3;n--){const _=10**n,m=r.mult(t,_);for(let e=0;e<100;e++){const i=m.dot(r.div(1,t.tDot(o)));i.add(o),i.add(r.mult(c,1-s.tDot(i).toScaler())),i.map(f=>f<0?0:f),i.div(s.tDot(i).toScaler());let h=t.tDot(i);if(h.map(Math.log),h=h.mean(),h<=a)break;o=i,a=h}}return o}fit(t,s){t=r.fromArray(t),s=r.fromArray(s);const c=t.rows,o=Math.min(this._kernelNum,c),a=this._centers=t.sample(o)[0];if(this._sigma=this._sigma_cand[0],this._sigma_cand.length>1){let m=-1/0;const e=Array.from({length:c},(i,h)=>h%this._fold);for(const i of this._sigma_cand){const h=this._kernel_gaussian(t,a,i),D=this._kernel_gaussian(s,a,i).mean(1);for(let l=e.length-1;l>0;l--){const d=Math.floor(Math.random()*(l+1));[e[l],e[d]]=[e[d],e[l]]}let p=0;for(let l=0;l<this._fold;l++){const d=e.map(g=>g===l),M=e.map(g=>g!==l),y=this._optimize_alpha(h.col(d),D),k=h.col(M).tDot(y);k.map(Math.log),p+=k.mean()}p/=this._fold,p>m&&(m=p,this._sigma=i)}}const n=this._kernel_gaussian(t,a,this._sigma),_=this._kernel_gaussian(s,a,this._sigma);this._kw=this._optimize_alpha(n,_.mean(1))}predict(t){return t=r.fromArray(t),this._kernel_gaussian(t,this._centers,this._sigma).tDot(this._kw).value}}
