var S=Object.defineProperty;var w=(u,t)=>S(u,"name",{value:t,configurable:!0});import n from"../util/matrix.js";export default class A{static{w(this,"KLIEP")}constructor(t,s,c){this._sigma_cand=t,this._fold=s,this._kernelNum=c}_kernel_gaussian(t,s,c){const o=[];for(let a=0;a<s.rows;a++){const r=[];for(let _=0;_<t.rows;_++){const m=n.sub(s.row(a),t.row(_));r.push(Math.exp(-m.reduce((e,i)=>e+i**2,0)/(2*c**2)))}o.push(r)}return n.fromArray(o)}_optimize_alpha(t,s){const c=n.div(s,s.norm()**2);let o=n.ones(t.rows,1);o.add(n.mult(c,1-s.tDot(o).toScaler())),o.map(r=>r<0?0:r),o.div(s.tDot(o).toScaler());let a=t.tDot(o);a.map(Math.log),a=a.mean();for(let r=3;r>=-3;r--){const _=10**r,m=n.mult(t,_);for(let e=0;e<100;e++){const i=m.dot(n.div(1,t.tDot(o)));i.add(o),i.add(n.mult(c,1-s.tDot(i).toScaler())),i.map(f=>f<0?0:f),i.div(s.tDot(i).toScaler());let l=t.tDot(i);if(l.map(Math.log),l=l.mean(),l<=a)break;o=i,a=l}}return o}fit(t,s){t=n.fromArray(t),s=n.fromArray(s);const c=t.rows,o=Math.min(this._kernelNum,c),a=this._centers=t.sample(o)[0];if(this._sigma=this._sigma_cand[0],this._sigma_cand.length>1){let m=-1/0;const e=Array.from({length:c},(i,l)=>l%this._fold);for(const i of this._sigma_cand){const l=this._kernel_gaussian(t,a,i),D=this._kernel_gaussian(s,a,i).mean(1);for(let h=e.length-1;h>0;h--){let d=Math.floor(Math.random()*(h+1));[e[h],e[d]]=[e[d],e[h]]}let p=0;for(let h=0;h<this._fold;h++){const d=e.map(g=>g===h),M=e.map(g=>g!==h),y=this._optimize_alpha(l.col(d),D),k=l.col(M).tDot(y);k.map(Math.log),p+=k.mean()}p/=this._fold,p>m&&(m=p,this._sigma=i)}}const r=this._kernel_gaussian(t,a,this._sigma),_=this._kernel_gaussian(s,a,this._sigma);this._kw=this._optimize_alpha(r,_.mean(1))}predict(t){return t=n.fromArray(t),this._kernel_gaussian(t,this._centers,this._sigma).tDot(this._kw).value}}
