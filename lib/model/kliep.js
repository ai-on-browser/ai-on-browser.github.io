var S=Object.defineProperty;var w=(u,t)=>S(u,"name",{value:t,configurable:!0});import r from"../util/matrix.js";export default class A{static{w(this,"KLIEP")}constructor(t,s,c){this._sigma_cand=t,this._fold=s,this._kernelNum=c}_kernel_gaussian(t,s,c){const o=[];for(let i=0;i<s.rows;i++){const n=[];for(let _=0;_<t.rows;_++){const m=r.sub(s.row(i),t.row(_));n.push(Math.exp(-m.reduce((e,a)=>e+a**2,0)/(2*c**2)))}o.push(n)}return r.fromArray(o)}_optimize_alpha(t,s){const c=r.div(s,s.norm()**2);let o=r.ones(t.rows,1);o.add(r.mult(c,1-s.tDot(o).toScaler())),o.map(n=>n<0?0:n),o.div(s.tDot(o).toScaler());let i=t.tDot(o);i.map(Math.log),i=i.mean();for(let n=3;n>=-3;n--){const _=10**n,m=r.mult(t,_);for(let e=0;e<100;e++){const a=m.dot(r.div(1,t.tDot(o)));a.add(o),a.add(r.mult(c,1-s.tDot(a).toScaler())),a.map(f=>f<0?0:f),a.div(s.tDot(a).toScaler());let h=t.tDot(a);if(h.map(Math.log),h=h.mean(),h<=i)break;o=a,i=h}}return o}fit(t,s){t=r.fromArray(t),s=r.fromArray(s);const c=t.rows,o=Math.min(this._kernelNum,c),i=t.sample(o)[0];if(this._centers=i,this._sigma=this._sigma_cand[0],this._sigma_cand.length>1){let m=-1/0;const e=Array.from({length:c},(a,h)=>h%this._fold);for(const a of this._sigma_cand){const h=this._kernel_gaussian(t,i,a),D=this._kernel_gaussian(s,i,a).mean(1);for(let l=e.length-1;l>0;l--){const d=Math.floor(Math.random()*(l+1));[e[l],e[d]]=[e[d],e[l]]}let p=0;for(let l=0;l<this._fold;l++){const d=e.map(g=>g===l),M=e.map(g=>g!==l),y=this._optimize_alpha(h.col(d),D),k=h.col(M).tDot(y);k.map(Math.log),p+=k.mean()}p/=this._fold,p>m&&(m=p,this._sigma=a)}}const n=this._kernel_gaussian(t,i,this._sigma),_=this._kernel_gaussian(s,i,this._sigma);this._kw=this._optimize_alpha(n,_.mean(1))}predict(t){return t=r.fromArray(t),this._kernel_gaussian(t,this._centers,this._sigma).tDot(this._kw).value}}
