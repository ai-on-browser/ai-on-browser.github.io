import Matrix from"../util/matrix.js";export class KLIEP{constructor(t,s,a){this._sigma_cand=t,this._fold=s,this._kernelNum=a}_kernel_gaussian(t,s,a){const o=[];for(let i=0;i<s.rows;i++){const r=[];for(let o=0;o<t.rows;o++){const e=s.row(i).copySub(t.row(o));r.push(Math.exp(-e.reduce(((t,s)=>t+s**2),0)/(2*a**2)))}o.push(r)}return Matrix.fromArray(o)}_optimize_alpha(t,s){const a=s.copyDiv(s.norm()**2);let o=Matrix.ones(t.rows,1);o.add(a.copyMult(1-s.tDot(o).toScaler())),o.map((t=>t<0?0:t)),o.div(s.tDot(o).toScaler());let i=t.tDot(o);i.map(Math.log),i=i.mean();for(let r=3;r>=-3;r--){const e=10**r,l=t.copyMult(e);for(let r=0;r<100;r++){const r=l.dot(t.tDot(o).copyIdiv(1));r.add(o),r.add(a.copyMult(1-s.tDot(r).toScaler())),r.map((t=>t<0?0:t)),r.div(s.tDot(r).toScaler());let e=t.tDot(r);if(e.map(Math.log),e=e.mean(),e<=i)break;o=r,i=e}}return o}fit(t,s){t=Matrix.fromArray(t),s=Matrix.fromArray(s);const a=t.rows,o=Math.min(this._kernelNum,a),i=this._centers=t.sample(o);if(this._sigma=this._sigma_cand[0],this._sigma_cand.length>1){let o=-1/0;const r=[];for(let t=0;t<a;t++)r[t]=t%this._fold;for(const a of this._sigma_cand){const e=this._kernel_gaussian(t,i,a),l=this._kernel_gaussian(s,i,a).mean(1);for(let t=r.length-1;t>0;t--){let s=Math.floor(Math.random()*(t+1));[r[t],r[s]]=[r[s],r[t]]}let h=0;for(let t=0;t<this._fold;t++){const s=r.map((s=>s===t)),a=r.map((s=>s!==t)),o=this._optimize_alpha(e.col(s),l),i=e.col(a).tDot(o);i.map(Math.log),h+=i.mean()}h/=this._fold,h>o&&(o=h,this._sigma=a)}}const r=this._kernel_gaussian(t,i,this._sigma),e=this._kernel_gaussian(s,i,this._sigma);this._kw=this._optimize_alpha(r,e.mean(1))}predict(t){t=Matrix.fromArray(t);return this._kernel_gaussian(t,this._centers,this._sigma).tDot(this._kw).value}}export class KLIEPCPD{constructor(t,s,a){this._window=t,this._take=s||Math.max(1,Math.floor(t/2)),this._lag=a||Math.max(1,Math.floor(this._take/2))}predict(t){const s=[];for(let a=0;a<t.length-this._window+1;a++)s.push(t.slice(a,a+this._window).flat());const a=[];for(let t=0;t<s.length-this._take-this._lag+1;t++){const o=Matrix.fromArray(s.slice(t,t+this._take)),i=Matrix.fromArray(s.slice(t+this._lag,t+this._take+this._lag)),r=new KLIEP([100,10,1,.1,.01,.001],5,100);let e=0;r.fit(o,i);let l=r.predict(i);for(let t=0;t<l.length;t++)e+=(l[t]-1)**2/l.length;r.fit(i,o),l=r.predict(o);for(let t=0;t<l.length;t++)e+=(l[t]-1)**2/l.length;a.push(e)}return a}}