import Matrix from"../util/matrix.js";export default class KLIEP{constructor(t,a,s){this._sigma_cand=t,this._fold=a,this._kernelNum=s}_kernel_gaussian(t,a,s){const r=[];for(let i=0;i<a.rows;i++){const o=[];for(let r=0;r<t.rows;r++){const e=Matrix.sub(a.row(i),t.row(r));o.push(Math.exp(-e.reduce(((t,a)=>t+a**2),0)/(2*s**2)))}r.push(o)}return Matrix.fromArray(r)}_optimize_alpha(t,a){const s=Matrix.div(a,a.norm()**2);let r=Matrix.ones(t.rows,1);r.add(Matrix.mult(s,1-a.tDot(r).toScaler())),r.map((t=>t<0?0:t)),r.div(a.tDot(r).toScaler());let i=t.tDot(r);i.map(Math.log),i=i.mean();for(let o=3;o>=-3;o--){const e=10**o,l=Matrix.mult(t,e);for(let o=0;o<100;o++){const o=l.dot(Matrix.div(1,t.tDot(r)));o.add(r),o.add(Matrix.mult(s,1-a.tDot(o).toScaler())),o.map((t=>t<0?0:t)),o.div(a.tDot(o).toScaler());let e=t.tDot(o);if(e.map(Math.log),e=e.mean(),e<=i)break;r=o,i=e}}return r}fit(t,a){t=Matrix.fromArray(t),a=Matrix.fromArray(a);const s=t.rows,r=Math.min(this._kernelNum,s),i=this._centers=t.sample(r)[0];if(this._sigma=this._sigma_cand[0],this._sigma_cand.length>1){let r=-1/0;const o=Array.from({length:s},((t,a)=>a%this._fold));for(const s of this._sigma_cand){const e=this._kernel_gaussian(t,i,s),l=this._kernel_gaussian(a,i,s).mean(1);for(let t=o.length-1;t>0;t--){let a=Math.floor(Math.random()*(t+1));[o[t],o[a]]=[o[a],o[t]]}let n=0;for(let t=0;t<this._fold;t++){const a=o.map((a=>a===t)),s=o.map((a=>a!==t)),r=this._optimize_alpha(e.col(a),l),i=e.col(s).tDot(r);i.map(Math.log),n+=i.mean()}n/=this._fold,n>r&&(r=n,this._sigma=s)}}const o=this._kernel_gaussian(t,i,this._sigma),e=this._kernel_gaussian(a,i,this._sigma);this._kw=this._optimize_alpha(o,e.mean(1))}predict(t){t=Matrix.fromArray(t);return this._kernel_gaussian(t,this._centers,this._sigma).tDot(this._kw).value}}