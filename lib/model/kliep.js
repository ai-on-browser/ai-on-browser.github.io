import Matrix from"../util/matrix.js";export class KLIEP{constructor(t,a,s){this._sigma_cand=t,this._fold=a,this._kernelNum=s}_kernel_gaussian(t,a,s){const i=[];for(let r=0;r<a.rows;r++){const o=[];for(let i=0;i<t.rows;i++){const e=Matrix.sub(a.row(r),t.row(i));o.push(Math.exp(-e.reduce(((t,a)=>t+a**2),0)/(2*s**2)))}i.push(o)}return Matrix.fromArray(i)}_optimize_alpha(t,a){const s=Matrix.div(a,a.norm()**2);let i=Matrix.ones(t.rows,1);i.add(Matrix.mult(s,1-a.tDot(i).toScaler())),i.map((t=>t<0?0:t)),i.div(a.tDot(i).toScaler());let r=t.tDot(i);r.map(Math.log),r=r.mean();for(let o=3;o>=-3;o--){const e=10**o,l=Matrix.mult(t,e);for(let o=0;o<100;o++){const o=l.dot(Matrix.div(1,t.tDot(i)));o.add(i),o.add(Matrix.mult(s,1-a.tDot(o).toScaler())),o.map((t=>t<0?0:t)),o.div(a.tDot(o).toScaler());let e=t.tDot(o);if(e.map(Math.log),e=e.mean(),e<=r)break;i=o,r=e}}return i}fit(t,a){t=Matrix.fromArray(t),a=Matrix.fromArray(a);const s=t.rows,i=Math.min(this._kernelNum,s),r=this._centers=t.sample(i)[0];if(this._sigma=this._sigma_cand[0],this._sigma_cand.length>1){let i=-1/0;const o=[];for(let t=0;t<s;t++)o[t]=t%this._fold;for(const s of this._sigma_cand){const e=this._kernel_gaussian(t,r,s),l=this._kernel_gaussian(a,r,s).mean(1);for(let t=o.length-1;t>0;t--){let a=Math.floor(Math.random()*(t+1));[o[t],o[a]]=[o[a],o[t]]}let h=0;for(let t=0;t<this._fold;t++){const a=o.map((a=>a===t)),s=o.map((a=>a!==t)),i=this._optimize_alpha(e.col(a),l),r=e.col(s).tDot(i);r.map(Math.log),h+=r.mean()}h/=this._fold,h>i&&(i=h,this._sigma=s)}}const o=this._kernel_gaussian(t,r,this._sigma),e=this._kernel_gaussian(a,r,this._sigma);this._kw=this._optimize_alpha(o,e.mean(1))}predict(t){t=Matrix.fromArray(t);return this._kernel_gaussian(t,this._centers,this._sigma).tDot(this._kw).value}}export class KLIEPCPD{constructor(t,a,s){this._window=t,this._take=a||Math.max(1,Math.floor(t/2)),this._lag=s||Math.max(1,Math.floor(this._take/2))}predict(t){const a=[];for(let s=0;s<t.length-this._window+1;s++)a.push(t.slice(s,s+this._window).flat());const s=[];for(let t=0;t<a.length-this._take-this._lag+1;t++){const i=Matrix.fromArray(a.slice(t,t+this._take)),r=Matrix.fromArray(a.slice(t+this._lag,t+this._take+this._lag)),o=new KLIEP([100,10,1,.1,.01,.001],5,100);let e=0;o.fit(i,r);let l=o.predict(r);for(let t=0;t<l.length;t++)e+=(l[t]-1)**2/l.length;o.fit(r,i),l=o.predict(i);for(let t=0;t<l.length;t++)e+=(l[t]-1)**2/l.length;s.push(e)}return s}}