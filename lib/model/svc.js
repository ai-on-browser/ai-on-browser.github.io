const Kernel={gaussian:(t=1)=>(s,e)=>{const i=s.reduce(((t,s,i)=>t+(s-e[i])**2),0);return Math.exp(-i/(2*t*t))},linear:()=>(t,s)=>t.reduce(((t,e,i)=>t+e*s[i]),0)};export default class SVC{constructor(t,s=[]){this._kernel="function"==typeof t?t:Kernel[t](...s),this._C=1,this._predicts=null}get size(){const t=this.predict();return new Set(t).size}init(t){this._x=t;const s=this._x.length;this._a=Array(s).fill(0),this._k=[];for(let t=0;t<s;this._k[t++]=[]);for(let t=0;t<s;t++)for(let e=t;e<s;e++)this._k[t][e]=this._k[e][t]=this._kernel(this._x[t],this._x[e])}fit(){this._predicts=null;const t=this._x.length;for(let s=0;s<t;s++){let e=-this._k[s][s];for(let i=0;i<t;i++)e+=this._a[i]*this._k[s][i];this._a[s]=Math.min(this._C,Math.max(0,this._a[s]-e/this._k[s][s]))}this._b_off=0;for(let s=0;s<t;s++)for(let e=0;e<t;e++)this._b_off+=this._k[s][e]*this._a[s]*this._a[e];const s=[];for(let e=0;e<t;e++){s[e]=this._k[e][e];for(let i=0;i<t;i++)s[e]-=2*this._a[i]*this._k[e][i];s[e]=Math.sqrt(s[e]+this._b_off)}this._r=s.reduce(((t,s)=>t+s),0)/s.length}predict(){if(this._predicts)return this._predicts;const t=[.1,.2,.3,.4,.5,.6,.7,.8,.9],s=this._x.length,e=[];for(let t=0;t<s;t++)e[t]=[];for(let i=0;i<s;i++){e[i][i]=0;for(let h=i+1;h<s;h++){let r=!0;for(let e=0;e<t.length&&r;e++){const _=this._x[i].concat();for(let s=0;s<_.length;s++)_[s]+=t[e]*(this._x[h][s]-this._x[i][s]);let l=this._kernel(_,_);for(let t=0;t<s;t++)l-=2*this._a[t]*this._kernel(this._x[t],_);r&&=Math.sqrt(l+this._b_off)<=this._r}e[i][h]=e[h][i]=r?1:0}}let i=0;const h=Array(s).fill(-1);do{let t=0;for(;t<s&&h[t]>=0;t++);const r=[t];for(;r.length>0;){const _=r.pop();if(!(h[_]>=0)){h[_]=i;for(let i=0;i<s;i++)e[t][i]>0&&r.push(i)}}h[t]=i,i++}while(h.some((t=>t<0)));return this._predicts=h,h}}