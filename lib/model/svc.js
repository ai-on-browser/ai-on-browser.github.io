var d=Object.defineProperty;var c=(l,i)=>d(l,"name",{value:i,configurable:!0});const g={gaussian:c((l=1)=>(i,h)=>{const t=i.reduce((s,r,e)=>s+(r-h[e])**2,0);return Math.exp(-t/(2*l*l))},"gaussian"),linear:c(()=>(l,i)=>l.reduce((h,t,s)=>h+t*i[s],0),"linear")};export default class k{static{c(this,"SVC")}constructor(i){typeof i=="function"?this._kernel=i:(typeof i=="string"&&(i={name:i}),i.name==="gaussian"?this._kernel=g.gaussian(i.d):this._kernel=g.linear()),this._C=1,this._predicts=null}get size(){const i=this.predict();return new Set(i).size}init(i){this._x=i;const h=this._x.length;this._a=Array(h).fill(0),this._k=[];for(let t=0;t<h;this._k[t++]=[]);for(let t=0;t<h;t++)for(let s=t;s<h;s++)this._k[t][s]=this._k[s][t]=this._kernel(this._x[t],this._x[s])}fit(){this._predicts=null;const i=this._x.length;for(let t=0;t<i;t++){let s=-this._k[t][t];for(let r=0;r<i;r++)s+=this._a[r]*this._k[t][r];this._a[t]=Math.min(this._C,Math.max(0,this._a[t]-s/this._k[t][t]))}this._b_off=0;for(let t=0;t<i;t++)for(let s=0;s<i;s++)this._b_off+=this._k[t][s]*this._a[t]*this._a[s];const h=[];for(let t=0;t<i;t++){h[t]=this._k[t][t];for(let s=0;s<i;s++)h[t]-=2*this._a[s]*this._k[t][s];h[t]=Math.sqrt(h[t]+this._b_off)}this._r=h.reduce((t,s)=>t+s,0)/h.length}predict(){if(this._predicts)return this._predicts;const i=[.1,.2,.3,.4,.5,.6,.7,.8,.9],h=this._x.length,t=[];for(let e=0;e<h;e++)t[e]=[];for(let e=0;e<h;e++){t[e][e]=0;for(let n=e+1;n<h;n++){let f=!0;for(let o=0;o<i.length&&f;o++){const a=this._x[e].concat();for(let _=0;_<a.length;_++)a[_]+=i[o]*(this._x[n][_]-this._x[e][_]);let u=this._kernel(a,a);for(let _=0;_<h;_++)u-=2*this._a[_]*this._kernel(this._x[_],a);f&&=Math.sqrt(u+this._b_off)<=this._r}t[e][n]=t[n][e]=f?1:0}}let s=0;const r=Array(h).fill(-1);do{let e=0;for(;e<h&&r[e]>=0;e++);const n=[e];for(;n.length>0;){const f=n.pop();if(!(r[f]>=0)){r[f]=s;for(let o=0;o<h;o++)t[e][o]>0&&n.push(o)}}r[e]=s,s++}while(r.some(e=>e<0));return this._predicts=r,r}}
