import{Matrix}from"../util/math.js";export default class ARMA{constructor(t,h){this._p=t,this._q=h,this._rate=.1,this._beta=1e-5,this._phi=[];for(let t=0;t<this._p;this._phi[t++]=0);this._the=[];for(let t=0;t<this._q;this._the[t++]=.3);}fit(t){const h=t,i=h.length,s=Math.max(this._p,this._q);for(let t=0;t<1;t++){this._u=[h[0]];for(let t=1;t<i;t++){let i=h[t];for(let s=0;s<Math.min(t,this._p);s++)i-=this._phi[s]*h[t-s-1];for(let h=0;h<Math.min(t,this._q);h++)i+=this._the[h]*this._u[t-h-1];this._u[t]=i}let t=Matrix.zeros(i,this._p+this._q);for(let s=0;s<i;s++){for(let i=0;i<Math.min(s,this._p);i++)t.set(s,i,-h[s-i-1]);for(let h=0;h<Math.min(s,this._q);h++)t.set(s,h+this._p,this._u[s-h-1])}t=t.slice(s);const e=new Matrix(i-s,1,this._u.slice(s)),_=t.tDot(t);_.add(Matrix.eye(_.rows,_.cols,this._beta));const r=_.solve(t.tDot(e)).value;let l=r.reduce(((t,h,i)=>t+Math.abs(h)),0);if(l/=this._phi.reduce(((t,h)=>t+Math.abs(h)),0)+this._the.reduce(((t,h)=>t+Math.abs(h)),0),isNaN(l)||l<1e-12)break;for(let t=0;t<this._p;t++)this._phi[t]-=this._rate*r[t];for(let t=0;t<this._q;t++)this._the[t]-=this._rate*r[t+this._p]}}predict(t,h){const i=[],s=t.slice(t.length-Math.max(this._p,this._q));s.reverse();for(let t=0;t<h;t++){let t=0;for(let h=0;h<this._p;h++)t+=this._phi[h]*s[h];t+=this._u[this._u.length-1];for(let h=0;h<this._q;h++)t-=this._u[this._u.length-h-2]*this._the[h];i.push(t),s.unshift(t),s.pop()}return i}}