import Matrix from"../util/matrix.js";export default class ARMA{constructor(t,i){this._p=t,this._q=i,this._rate=.1,this._beta=1e-5,this._phi=Array(this._p).fill(0),this._the=Array(this._q).fill(.3)}fit(t){const i=t,h=i.length,s=Math.max(this._p,this._q);for(let t=0;t<1;t++){this._u=[i[0]];for(let t=1;t<h;t++){let h=i[t];for(let s=0;s<Math.min(t,this._p);s++)h-=this._phi[s]*i[t-s-1];for(let i=0;i<Math.min(t,this._q);i++)h+=this._the[i]*this._u[t-i-1];this._u[t]=h}let t=Matrix.zeros(h,this._p+this._q);for(let s=0;s<h;s++){for(let h=0;h<Math.min(s,this._p);h++)t.set(s,h,-i[s-h-1]);for(let i=0;i<Math.min(s,this._q);i++)t.set(s,i+this._p,this._u[s-i-1])}t=t.slice(s);const e=new Matrix(h-s,1,this._u.slice(s)),_=t.tDot(t);_.add(Matrix.eye(_.rows,_.cols,this._beta));const r=_.solve(t.tDot(e)).value;let l=r.reduce(((t,i)=>t+Math.abs(i)),0);if(l/=this._phi.reduce(((t,i)=>t+Math.abs(i)),0)+this._the.reduce(((t,i)=>t+Math.abs(i)),0),isNaN(l)||l<1e-12)break;for(let t=0;t<this._p;t++)this._phi[t]-=this._rate*r[t];for(let t=0;t<this._q;t++)this._the[t]-=this._rate*r[t+this._p]}}predict(t,i){const h=[],s=t.slice(t.length-Math.max(this._p,this._q));s.reverse();for(let t=0;t<i;t++){let t=0;for(let i=0;i<this._p;i++)t+=this._phi[i]*s[i];t+=this._u[this._u.length-1];for(let i=0;i<this._q;i++)t-=this._u[this._u.length-i-2]*this._the[i];h.push(t),s.unshift(t),s.pop()}return h}}