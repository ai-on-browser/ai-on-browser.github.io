var w=Object.defineProperty;var g=(d,t)=>w(d,"name",{value:t,configurable:!0});import n from"../util/matrix.js";export class LSDD{static{g(this,"LSDD")}constructor(t,s){this._sigma_cand=t,this._lambda_cand=s}_kernel_gaussian(t,s,h){const o=[];for(let e=0;e<s.rows;e++){const _=[];for(let a=0;a<t.rows;a++){const l=n.sub(s.row(e),t.row(a));_.push(Math.exp(-l.reduce((i,r)=>i+r**2,0)/(2*h**2)))}o.push(_)}return n.fromArray(o)}fit(t,s){t=n.fromArray(t),s=n.fromArray(s);const h=t.rows,o=s.rows,e=h+o,_=t.cols,a=this._centers=n.concat(t,s,0);this._sigma=this._sigma_cand[0],this._lambda=this._lambda_cand[0];let l=1/0;for(const i of this._sigma_cand){const r=this._kernel_gaussian(a,a,i*Math.SQRT2);r.mult((Math.PI*i**2)**(_/2));const c=this._kernel_gaussian(t,a,i).mean(1),k=this._kernel_gaussian(s,a,i).mean(1),u=n.sub(c,k);for(const f of this._lambda_cand){const m=n.add(r,n.eye(e,e,f)).solve(u),p=m.tDot(r).dot(m).toScaler()-2*u.tDot(m).toScaler()+f*m.norm()**2;p<l&&(l=p,this._sigma=i,this._lambda=f,this._kw=m)}}}predict(t){return t=n.fromArray(t),this._kernel_gaussian(t,this._centers,this._sigma).tDot(this._kw).value}}export class LSDDCPD{static{g(this,"LSDDCPD")}constructor(t,s,h){this._window=t,this._take=s||Math.max(1,Math.floor(t/2)),this._lag=h||Math.max(1,Math.floor(this._take/2))}predict(t){const s=[];for(let o=0;o<t.length-this._window+1;o++)s.push(t.slice(o,o+this._window).flat());const h=[];for(let o=0;o<s.length-this._take-this._lag+1;o++){const e=n.fromArray(s.slice(o,o+this._take)),_=n.fromArray(s.slice(o+this._lag,o+this._take+this._lag)),a=[100,30,10,3,1,.3,.1,.03,.01,.003,.001],l=new LSDD(a,a);let i=0;l.fit(e,_);let r=l.predict(_);for(let c=0;c<r.length;c++)i+=r[c]**2/r.length;r=l.predict(e);for(let c=0;c<r.length;c++)i+=r[c]**2/r.length;h.push(Math.sqrt(i))}return h}}
