import{Matrix}from"../util/math.js";export class LSDD{constructor(t,s){this._sigma_cand=t,this._lambda_cand=s}_kernel_gaussian(t,s,a){const r=[];for(let i=0;i<s.rows;i++){const o=[];for(let r=0;r<t.rows;r++){const e=s.row(i).copySub(t.row(r));o.push(Math.exp(-e.reduce(((t,s)=>t+s**2),0)/(2*a**2)))}r.push(o)}return Matrix.fromArray(r)}fit(t,s){t=Matrix.fromArray(t),s=Matrix.fromArray(s);const a=t.rows+s.rows,r=t.cols,i=this._centers=t.concat(s,0);this._sigma=this._sigma_cand[0],this._lambda=this._lambda_cand[0];let o=1/0;for(const e of this._sigma_cand){const h=this._kernel_gaussian(i,i,e*Math.SQRT2);h.mult((Math.PI*e**2)**(r/2));const n=this._kernel_gaussian(t,i,e).mean(1),l=this._kernel_gaussian(s,i,e).mean(1),_=n.copySub(l);for(const t of this._lambda_cand){const s=h.copyAdd(Matrix.eye(a,a,t)).solve(_),r=s.tDot(h).dot(s).toScaler()-2*_.tDot(s).toScaler()+t*s.norm()**2;r<o&&(o=r,this._sigma=e,this._lambda=t,this._kw=s)}}}predict(t){t=Matrix.fromArray(t);return this._kernel_gaussian(t,this._centers,this._sigma).tDot(this._kw).value}}export class LSDDCPD{constructor(t,s,a){this._window=t,this._take=s||Math.max(1,Math.floor(t/2)),this._lag=a||Math.max(1,Math.floor(this._take/2))}predict(t){const s=[];for(let a=0;a<t.length-this._window+1;a++)s.push(t.slice(a,a+this._window).flat());const a=[];for(let t=0;t<s.length-this._take-this._lag+1;t++){const r=Matrix.fromArray(s.slice(t,t+this._take)),i=Matrix.fromArray(s.slice(t+this._lag,t+this._take+this._lag)),o=[100,30,10,3,1,.3,.1,.03,.01,.003,.001],e=new LSDD(o,o);let h=0;e.fit(r,i);let n=e.predict(i);for(let t=0;t<n.length;t++)h+=n[t]**2/n.length;n=e.predict(r);for(let t=0;t<n.length;t++)h+=n[t]**2/n.length;a.push(Math.sqrt(h))}return a}}