export default class GrowingNeuralGas{constructor(t,s){this._nodes=[],this._edges=[],this._err=[],this._l=t,this._m=s,this._k=0,this._eps=.01,this._err_fact=.99,this._max_age=5,this._inserted_iteration=20}get size(){const t=[],s=new Set;for(let e=0;e<this._nodes.length;e++){if(s.has(e))continue;const i=this._topological_neighbor(e);t.push(e);for(let t=0;t<i.length;t++)s.add(i[t])}return t.length}_init(t){const s=t.length,e=Math.floor(Math.random()*s),i=t[e],h=t[(e+Math.floor(s/2))%s];this._nodes=[i,h],this._edges=[[],[]],this._err=[0,0]}_distance(t,s){return Math.sqrt(t.reduce(((t,e,i)=>t+(e-s[i])**2),0))}_topological_neighbor(t){const s=[],e=[t];for(;e.length>0;){const t=e.pop();if(!(s.indexOf(t)>=0)){s.push(t);for(let s=0;s<this._edges[t].length;s++)Number.isFinite(this._edges[t][s])&&e.push(s)}}return s}update(t){const s=this._nodes.map(((s,e)=>[this._distance(t,s),e]));s.sort(((t,s)=>t[0]-s[0]));const e=s[0][1],i=s[1][1];this._err[e]+=s[0][0];const h=[e];s.sort(((t,s)=>t[1]-s[1]));for(let e=0;e<h.length;e++){const i=this._nodes[h[e]];for(let n=0;n<i.length;n++)i[n]+=(t[n]-i[n])*this._eps*Math.exp(-s[h[e]][0]/this._l)}for(let t=0;t<this._edges[e].length;t++)Number.isFinite(this._edges[e][t])&&(this._edges[e][t]++,this._edges[t][e]++,this._edges[e][t]>=this._max_age&&(this._edges[e][t]=null,this._edges[t][e]=null));this._edges[e][i]=0,this._edges[i][e]=0;for(let t=this._edges.length-1;t>=0;t--)if(!this._edges[t].some(Number.isFinite)){this._edges.splice(t,1);for(let s=0;s<this._edges.length;s++)this._edges[s].splice(t,1);this._nodes.splice(t,1),this._err.splice(t,1)}if(this._k++,this._l*=this._m,this._k%this._inserted_iteration==0){const t=this._err.map(((t,s)=>[t,s]));t.sort(((t,s)=>s[0]-t[0]));const s=t[0][1];let e=-1,i=1/0;for(let t=0;t<this._nodes.length;t++){if(t===s)continue;const h=this._distance(this._nodes[t],this._nodes[s]);h<i&&(i=h,e=t)}const h=this._nodes[e].map(((t,e)=>(t+this._nodes[s][e])/2));this._nodes.push(h),this._edges.push([]),this._err.push(0)}this._err=this._err.map((t=>t*this._err_fact))}fit(t){0===this._nodes.length&&this._init(t);for(let s=0;s<t.length;s++)this.update(t[s])}predict(t){if(0!==this._nodes.length)return t.map((t=>{let s=1/0,e=-1;for(let i=0;i<this._nodes.length;i++){const h=this._distance(this._nodes[i],t);h<s&&(s=h,e=i)}const i=this._topological_neighbor(e);return Math.min(...i)}))}}