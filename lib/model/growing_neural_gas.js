var f=Object.defineProperty;var g=(d,i)=>f(d,"name",{value:i,configurable:!0});export default class p{static{g(this,"GrowingNeuralGas")}constructor(i,e){this._nodes=[],this._edges=[],this._err=[],this._l=i,this._m=e,this._k=0,this._eps=.01,this._err_fact=.99,this._max_age=5,this._inserted_iteration=20}get size(){const i=[],e=new Set;for(let s=0;s<this._nodes.length;s++){if(e.has(s))continue;const o=this._topological_neighbor(s);i.push(s);for(let h=0;h<o.length;h++)e.add(o[h])}return i.length}_init(i){const e=i.length,s=Math.floor(Math.random()*e),o=i[s],h=i[(s+Math.floor(e/2))%e];this._nodes=[o,h],this._edges=[[],[]],this._err=[0,0]}_distance(i,e){return Math.sqrt(i.reduce((s,o,h)=>s+(o-e[h])**2,0))}_topological_neighbor(i){const e=[],s=[i];for(;s.length>0;){const o=s.pop();if(!e.includes(o)){e.push(o);for(let h=0;h<this._edges[o].length;h++)Number.isFinite(this._edges[o][h])&&s.push(h)}}return e}update(i){const e=this._nodes.map((t,n)=>[this._distance(i,t),n]);e.sort((t,n)=>t[0]-n[0]);const s=e[0][1],o=e[1][1];this._err[s]+=e[0][0];const h=[s];e.sort((t,n)=>t[1]-n[1]);for(let t=0;t<h.length;t++){const n=this._nodes[h[t]];for(let r=0;r<n.length;r++)n[r]+=(i[r]-n[r])*this._eps*Math.exp(-e[h[t]][0]/this._l)}for(let t=0;t<this._edges[s].length;t++)Number.isFinite(this._edges[s][t])&&(this._edges[s][t]++,this._edges[t][s]++,this._edges[s][t]>=this._max_age&&(this._edges[s][t]=null,this._edges[t][s]=null));this._edges[s][o]=0,this._edges[o][s]=0;for(let t=this._edges.length-1;t>=0;t--)if(!this._edges[t].some(Number.isFinite)){this._edges.splice(t,1);for(let n=0;n<this._edges.length;n++)this._edges[n].splice(t,1);this._nodes.splice(t,1),this._err.splice(t,1)}if(this._k++,this._l*=this._m,this._k%this._inserted_iteration===0){const t=this._err.map((_,l)=>[_,l]);t.sort((_,l)=>l[0]-_[0]);const n=t[0][1];let r=-1,c=1/0;for(let _=0;_<this._nodes.length;_++){if(_===n)continue;const l=this._distance(this._nodes[_],this._nodes[n]);l<c&&(c=l,r=_)}const a=this._nodes[r].map((_,l)=>(_+this._nodes[n][l])/2);this._nodes.push(a),this._edges.push([]),this._err.push(0)}this._err=this._err.map(t=>t*this._err_fact)}fit(i){this._nodes.length===0&&this._init(i);for(let e=0;e<i.length;e++)this.update(i[e])}predict(i){if(this._nodes.length===0)throw new Error("Call fit before predict.");return i.map(e=>{let s=1/0,o=-1;for(let t=0;t<this._nodes.length;t++){const n=this._distance(this._nodes[t],e);n<s&&(s=n,o=t)}const h=this._topological_neighbor(o);return Math.min(...h)})}}
