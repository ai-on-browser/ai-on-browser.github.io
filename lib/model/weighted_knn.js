var M=Object.defineProperty;var e=(t,i)=>M(t,"name",{value:i,configurable:!0});const u={euclid:e(()=>(t,i)=>Math.sqrt(t.reduce((a,s,r)=>a+(s-i[r])**2,0)),"euclid"),manhattan:e(()=>(t,i)=>t.reduce((a,s,r)=>a+Math.abs(s-i[r]),0),"manhattan"),chebyshev:e(()=>(t,i)=>Math.max(...t.map((a,s)=>Math.abs(a-i[s]))),"chebyshev"),minkowski:e(({p:t=2}={})=>(i,a)=>Math.pow(i.reduce((s,r,c)=>s+(r-a[c])**t,0),1/t),"minkowski")},l={gaussian:e(t=>Math.exp(-(t**2)/2),"gaussian"),rectangular:e(t=>Math.abs(t)>1?0:.5,"rectangular"),triangular:e(t=>Math.abs(t)>1?0:1-Math.abs(t),"triangular"),epanechnikov:e(t=>Math.abs(t)>1?0:3/4*(1-t**2),"epanechnikov"),quartic:e(t=>Math.abs(t)>1?0:15/16*(1-t**2)**2,"quartic"),triweight:e(t=>Math.abs(t)>1?0:35/32*(1-t**2)**3,"triweight"),cosine:e(t=>Math.abs(t)>1?0:Math.PI/4*Math.cos(Math.PI/2*t),"cosine"),inversion:e(t=>1/Math.abs(t),"inversion")};export default class w{static{e(this,"WeightedKNN")}constructor(i,a="euclid",s="gaussian"){this._k=i,this._metric=a,typeof this._metric=="function"?this._d=this._metric:this._d=u[this._metric](),this._weight=s,this._w=l[this._weight]}fit(i,a){this._x=i,this._y=a,this._c=[...new Set(a)]}predict(i){return i.map(a=>{const s=this._x.map((h,n)=>({i:n,d:this._d(a,h)}));s.sort((h,n)=>h.d-n.d);const r=s[this._k].d,c={};for(let h=0;h<this._k&&h<s.length;h++){const n=s[h].i;c[this._y[n]]?c[this._y[n]].w+=this._w(s[h].d/r):c[this._y[n]]={category:this._y[n],w:this._w(s[h].d/r)}}let _=0,o=null;for(const h of Object.keys(c))_<c[h].w&&(_=c[h].w,o=c[h].category);return o})}}
