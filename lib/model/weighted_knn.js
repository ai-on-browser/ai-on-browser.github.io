var u=Object.defineProperty;var h=(t,i)=>u(t,"name",{value:i,configurable:!0});const M={euclid:h(()=>(t,i)=>Math.sqrt(t.reduce((a,s,r)=>a+(s-i[r])**2,0)),"euclid"),manhattan:h(()=>(t,i)=>t.reduce((a,s,r)=>a+Math.abs(s-i[r]),0),"manhattan"),chebyshev:h(()=>(t,i)=>Math.max(...t.map((a,s)=>Math.abs(a-i[s]))),"chebyshev"),minkowski:h(({p:t=2}={})=>(i,a)=>i.reduce((s,r,c)=>s+(r-a[c])**t,0)**(1/t),"minkowski")},l={gaussian:h(t=>Math.exp(-(t**2)/2),"gaussian"),rectangular:h(t=>Math.abs(t)>1?0:.5,"rectangular"),triangular:h(t=>Math.abs(t)>1?0:1-Math.abs(t),"triangular"),epanechnikov:h(t=>Math.abs(t)>1?0:3/4*(1-t**2),"epanechnikov"),quartic:h(t=>Math.abs(t)>1?0:15/16*(1-t**2)**2,"quartic"),triweight:h(t=>Math.abs(t)>1?0:35/32*(1-t**2)**3,"triweight"),cosine:h(t=>Math.abs(t)>1?0:Math.PI/4*Math.cos(Math.PI/2*t),"cosine"),inversion:h(t=>1/Math.abs(t),"inversion")};export default class d{static{h(this,"WeightedKNN")}constructor(i,a="euclid",s="gaussian"){this._k=i,this._metric=a,typeof this._metric=="function"?this._d=this._metric:this._d=M[this._metric](),this._weight=s,this._w=l[this._weight]}fit(i,a){this._x=i,this._y=a,this._c=[...new Set(a)]}predict(i){return i.map(a=>{const s=this._x.map((e,n)=>({i:n,d:this._d(a,e)}));s.sort((e,n)=>e.d-n.d);const r=s[this._k].d,c={};for(let e=0;e<this._k&&e<s.length;e++){const n=s[e].i;c[this._y[n]]?c[this._y[n]].w+=this._w(s[e].d/r):c[this._y[n]]={category:this._y[n],w:this._w(s[e].d/r)}}let _=0,o=null;for(const e of Object.keys(c))_<c[e].w&&(_=c[e].w,o=c[e].category);return o})}}
