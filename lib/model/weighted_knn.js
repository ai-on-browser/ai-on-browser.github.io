export default class WeightedKNN{constructor(t,s="euclid",a="gaussian"){switch(this._k=t,this._metric=s,this._metric){case"euclid":this._d=(t,s)=>Math.sqrt(t.reduce(((t,a,h)=>t+(a-s[h])**2),0));break;case"manhattan":this._d=(t,s)=>t.reduce(((t,a,h)=>t+Math.abs(a-s[h])),0);break;case"chebyshev":this._d=(t,s)=>Math.max(...t.map(((t,a)=>Math.abs(t-s[a]))));break;case"minkowski":this._dp=2,this._d=(t,s)=>Math.pow(t.reduce(((t,a,h)=>t+(a-s[h])**this._dp),0),1/this._dp)}switch(this._weight=a,this._weight){case"gaussian":this._w=t=>Math.exp(-(t**2)/2);break;case"rectangular":this._w=t=>Math.abs(t)>1?0:.5;break;case"triangular":this._w=t=>Math.abs(t)>1?0:1-Math.abs(t);break;case"epanechnikov":this._w=t=>Math.abs(t)>1?0:3/4*(1-t**2);break;case"quartic":this._w=t=>Math.abs(t)>1?0:15/16*(1-t**2)**2;break;case"triweight":this._w=t=>Math.abs(t)>1?0:35/32*(1-t**2)**3;break;case"cosine":this._w=t=>Math.abs(t)>1?0:Math.PI/4*Math.cos(Math.PI/2*t);break;case"inversion":this._w=t=>1/Math.abs(t)}}fit(t,s){this._x=t,this._y=s,this._c=[...new Set(s)]}predict(t){return t.map((t=>{const s=this._x.map(((s,a)=>({i:a,d:this._d(t,s)})));s.sort(((t,s)=>t.d-s.d));const a=s[this._k].d,h={};for(let t=0;t<this._k&&t<s.length;t++){const e=s[t].i;h[this._y[e]]?h[this._y[e]].w+=this._w(s[t].d/a):h[this._y[e]]={category:this._y[e],w:this._w(s[t].d/a)}}let e=0,i=null;for(const t of Object.keys(h))e<h[t].w&&(e=h[t].w,i=h[t].category);return i}))}}