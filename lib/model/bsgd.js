import Matrix from"../util/matrix.js";export default class BSGD{constructor(s=10,t=1,h=1,i="removal",e="gaussian"){if(this._b=s,this._eta=t,this._lambda=h,this._maintenance=i,"function"==typeof e)this._kernel=e;else switch(e){case"gaussian":this._s=1,this._kernel=(s,t)=>Math.exp(-(s.reduce(((s,h,i)=>s+(h-t[i])**2),0)**2)/this._s**2);break;case"polynomial":this._d=2,this._kernel=(s,t)=>(1+s.reduce(((s,h,i)=>s+h*t[i])))**this._d}}init(s,t){this._x=s,this._y=t,this._sv=[],this._alpha=[]}fit(){const s=(1+Math.sqrt(5))/2;for(let t=0;t<this._x.length;t++){let h=0;for(let s=0;s<this._sv.length;s++)h+=this._alpha[s]*this._kernel(this._x[t],this._sv[s]);if(this._alpha=this._alpha.map((s=>s*(1-this._eta*this._lambda))),h*this._y[t]<1&&(this._alpha.push(this._eta*this._y[t]),this._sv.push(this._x[t]),this._sv.length>this._b)){let t=1/0,h=-1;for(let s=0;s<this._sv.length;s++){const i=this._alpha[s]**2*this._kernel(this._sv[s],this._sv[s]);i<t&&(t=i,h=s)}if("projection"===this._maintenance){const s=this._sv.splice(h,1)[0],t=this._alpha.splice(h,1)[0],i=new Matrix(this._b,this._b),e=new Matrix(this._b,1);for(let t=0;t<this._b;t++){i.set(t,t,this._kernel(this._sv[t],this._sv[t]));for(let s=t;s<this._b;s++){const h=this._kernel(this._sv[t],this._sv[s]);i.set(t,s,h),i.set(s,t,h)}e.set(t,0,this._kernel(s,this._sv[t]))}const _=i.norm()/1e3;for(let s=0;s<this._b;s++)i.addAt(s,s,_);const a=i.solve(e);for(let s=0;s<this._b;s++)this._alpha[s]+=t*a.at(s,0)}else if("merging"===this._maintenance){let t=1/0,i=0,e=0,_=null;for(let a=0;a<this._sv.length;a++){if(a===h)continue;const l=this._alpha[h]/(this._alpha[h]+this._alpha[a]),n=s=>l*this._kernel(this._sv[h].map((t=>(1-s)*t)),this._sv[a].map((t=>(1-s)*t)))+(1-l)*this._kernel(this._sv[h].map((t=>s*t)),this._sv[a].map((t=>s*t)));let r=[0,n(0)],p=[1,n(1)],v=[1/(1+s),n(1/(1+s))];for(;p[0]-r[0]>1e-4;){const s=r[0]+(p[0]-v[0]),t=n(s);s<v[0]?t<v[1]?r=[s,t]:(p=v,v=[s,t]):t<v[1]?(r=v,v=[s,t]):p=[s,t]}const o=(r[0]+p[0])/2,c=this._sv[h].map(((s,t)=>o*s+(1-o)*this._sv[a][t])),m=this._alpha[h]*this._kernel(this._sv[h],c)+this._alpha[a]*this._kernel(this._sv[a],c),f=this._alpha[h]**2*this._kernel(this._sv[h],this._sv[h])+this._alpha[a]**2*this._kernel(this._sv[a],this._sv[a])+m**2+this._kernel(c,c)+this._alpha[h]*this._alpha[a]*this._kernel(this._sv[h],this._sv[a])-this._alpha[h]*m*this._kernel(this._sv[h],c)-this._alpha[a]*m*this._kernel(this._sv[a],c);f<t&&(t=f,i=a,e=m,_=c)}this._sv.splice(Math.max(h,i),1),this._alpha.splice(Math.max(h,i),1),this._sv.splice(Math.min(h,i),1),this._alpha.splice(Math.min(h,i),1),this._sv.push(_),this._alpha.push(e)}else this._sv.splice(h,1),this._alpha.splice(h,1)}}}predict(s){const t=[];for(let h=0;h<s.length;h++){let i=0;for(let t=0;t<this._sv.length;t++)i+=this._alpha[t]*this._kernel(s[h],this._sv[t]);t[h]=i<0?-1:1}return t}}