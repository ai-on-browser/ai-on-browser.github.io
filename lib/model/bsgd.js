var A=Object.defineProperty;var z=(q,v)=>A(q,"name",{value:v,configurable:!0});import j from"../util/matrix.js";export default class B{static{z(this,"BSGD")}constructor(v=10,k=1,f=1,p="removal",h="gaussian"){if(this._b=v,this._eta=k,this._lambda=f,this._maintenance=p,typeof h=="function")this._kernel=h;else switch(typeof h=="string"&&(h={name:h}),h.name){case"gaussian":this._s=h.s??1,this._kernel=(c,i)=>Math.exp(-(c.reduce((s,n,t)=>s+(n-i[t])**2,0)**2)/this._s**2);break;case"polynomial":this._d=h.d??2,this._kernel=(c,i)=>(1+c.reduce((s,n,t)=>s+n*i[t]))**this._d;break}this._sv=[],this._alpha=[]}fit(v,k){const f=(1+Math.sqrt(5))/2;for(let p=0;p<v.length;p++){let h=0;for(let c=0;c<this._sv.length;c++)h+=this._alpha[c]*this._kernel(v[p],this._sv[c]);if(this._alpha=this._alpha.map(c=>c*(1-this._eta*this._lambda)),h*k[p]<1&&(this._alpha.push(this._eta*k[p]),this._sv.push(v[p]),this._sv.length>this._b)){let c=1/0,i=-1;for(let s=0;s<this._sv.length;s++){const n=this._alpha[s]**2*this._kernel(this._sv[s],this._sv[s]);n<c&&(c=n,i=s)}if(this._maintenance==="projection"){const s=this._sv.splice(i,1)[0],n=this._alpha.splice(i,1)[0],t=new j(this._b,this._b),m=new j(this._b,1);for(let _=0;_<this._b;_++){t.set(_,_,this._kernel(this._sv[_],this._sv[_]));for(let l=_;l<this._b;l++){const w=this._kernel(this._sv[_],this._sv[l]);t.set(_,l,w),t.set(l,_,w)}m.set(_,0,this._kernel(s,this._sv[_]))}const a=t.norm()/1e3;for(let _=0;_<this._b;_++)t.addAt(_,_,a);const g=t.solve(m);for(let _=0;_<this._b;_++)this._alpha[_]+=n*g.at(_,0)}else if(this._maintenance==="merging"){let s=1/0,n=0,t=0,m=null;for(let a=0;a<this._sv.length;a++){if(a===i)continue;const g=this._alpha[i]/(this._alpha[i]+this._alpha[a]),_=z(o=>g*this._kernel(this._sv[i].map(r=>(1-o)*r),this._sv[a].map(r=>(1-o)*r))+(1-g)*this._kernel(this._sv[i].map(r=>o*r),this._sv[a].map(r=>o*r)),"fh");let l=[0,_(0)],w=[1,_(1)],e=[1/(1+f),_(1/(1+f))];for(;w[0]-l[0]>1e-4;){const o=l[0]+(w[0]-e[0]),r=_(o);o<e[0]?r<e[1]?l=[o,r]:(w=e,e=[o,r]):r<e[1]?(l=e,e=[o,r]):w=[o,r]}const b=(l[0]+w[0])/2,d=this._sv[i].map((o,r)=>b*o+(1-b)*this._sv[a][r]),M=this._alpha[i]*this._kernel(this._sv[i],d)+this._alpha[a]*this._kernel(this._sv[a],d),x=this._alpha[i]**2*this._kernel(this._sv[i],this._sv[i])+this._alpha[a]**2*this._kernel(this._sv[a],this._sv[a])+M**2+this._kernel(d,d)+this._alpha[i]*this._alpha[a]*this._kernel(this._sv[i],this._sv[a])-this._alpha[i]*M*this._kernel(this._sv[i],d)-this._alpha[a]*M*this._kernel(this._sv[a],d);x<s&&(s=x,n=a,t=M,m=d)}this._sv.splice(Math.max(i,n),1),this._alpha.splice(Math.max(i,n),1),this._sv.splice(Math.min(i,n),1),this._alpha.splice(Math.min(i,n),1),this._sv.push(m),this._alpha.push(t)}else this._sv.splice(i,1),this._alpha.splice(i,1)}}}predict(v){const k=[];for(let f=0;f<v.length;f++){let p=0;for(let h=0;h<this._sv.length;h++)p+=this._alpha[h]*this._kernel(v[f],this._sv[h]);k[f]=p<0?-1:1}return k}}export class MulticlassBSGD{static{z(this,"MulticlassBSGD")}constructor(v=10,k=1,f=1,p="removal",h="gaussian"){if(this._b=v,this._eta=k,this._lambda=f,this._maintenance=p,typeof h=="function")this._kernel=h;else switch(typeof h=="string"&&(h={name:h}),h.name){case"gaussian":this._s=h.s??1,this._kernel=(c,i)=>Math.exp(-(c.reduce((s,n,t)=>s+(n-i[t])**2,0)**2)/this._s**2);break;case"polynomial":this._d=h.d??2,this._kernel=(c,i)=>(1+c.reduce((s,n,t)=>s+n*i[t]))**this._d;break}this._classes=[],this._sv=[],this._alpha=[]}fit(v,k){const f=(1+Math.sqrt(5))/2;for(let p=0;p<v.length;p++){let h=this._classes.indexOf(k[p]);h<0&&(h=this._classes.length,this._classes.push(k[p]),this._sv.push([]),this._alpha.push([]));let c=-1/0,i=-1;for(let s=0;s<this._classes.length;s++){let n=0;for(let t=0;t<this._sv[s].length;t++)n+=this._alpha[s][t]*this._kernel(v[p],this._sv[s][t]);c<n&&(c=n,i=s)}for(let s=0;s<this._classes.length;s++)this._alpha[s]=this._alpha[s].map(n=>n*(1-this._eta*this._lambda));if(h!==i){this._alpha[h].push(this._eta),this._sv[h].push(v[p]),this._alpha[i].push(-this._eta),this._sv[i].push(v[p]);for(const s of[h,i]){if(this._sv[s].length<=this._b)continue;let n=1/0,t=-1;for(let m=0;m<this._sv[s].length;m++){const a=this._alpha[s][m]**2*this._kernel(this._sv[s][m],this._sv[s][m]);a<n&&(n=a,t=m)}if(this._maintenance==="projection"){const m=this._sv[s].splice(t,1)[0],a=this._alpha[s].splice(t,1)[0],g=new j(this._b,this._b),_=new j(this._b,1);for(let e=0;e<this._b;e++){g.set(e,e,this._kernel(this._sv[s][e],this._sv[s][e]));for(let b=e;b<this._b;b++){const d=this._kernel(this._sv[s][e],this._sv[s][b]);g.set(e,b,d),g.set(b,e,d)}_.set(e,0,this._kernel(m,this._sv[s][e]))}const l=g.norm()/1e3;for(let e=0;e<this._b;e++)g.addAt(e,e,l);const w=g.solve(_);for(let e=0;e<this._b;e++)this._alpha[s][e]+=a*w.at(e,0)}else if(this._maintenance==="merging"){let m=1/0,a=0,g=0,_=null;for(let l=0;l<this._sv[s].length;l++){if(l===t)continue;const w=this._alpha[s][t]/(this._alpha[s][t]+this._alpha[s][l]),e=z(y=>w*this._kernel(this._sv[s][t].map(u=>(1-y)*u),this._sv[s][l].map(u=>(1-y)*u))+(1-w)*this._kernel(this._sv[s][t].map(u=>y*u),this._sv[s][l].map(u=>y*u)),"fh");let b=[0,e(0)],d=[1,e(1)],M=[1/(1+f),e(1/(1+f))];for(;d[0]-b[0]>1e-4;){const y=b[0]+(d[0]-M[0]),u=e(y);y<M[0]?u<M[1]?b=[y,u]:(d=M,M=[y,u]):u<M[1]?(b=M,M=[y,u]):d=[y,u]}const x=(b[0]+d[0])/2,o=this._sv[s][t].map((y,u)=>x*y+(1-x)*this._sv[s][l][u]),r=this._alpha[s][t]*this._kernel(this._sv[s][t],o)+this._alpha[s][l]*this._kernel(this._sv[s][l],o),I=this._alpha[s][t]**2*this._kernel(this._sv[s][t],this._sv[s][t])+this._alpha[s][l]**2*this._kernel(this._sv[s][l],this._sv[s][l])+r**2+this._kernel(o,o)+this._alpha[s][t]*this._alpha[s][l]*this._kernel(this._sv[s][t],this._sv[s][l])-this._alpha[s][t]*r*this._kernel(this._sv[s][t],o)-this._alpha[s][l]*r*this._kernel(this._sv[s][l],o);I<m&&(m=I,a=l,g=r,_=o)}this._sv[s].splice(Math.max(t,a),1),this._alpha[s].splice(Math.max(t,a),1),this._sv[s].splice(Math.min(t,a),1),this._alpha[s].splice(Math.min(t,a),1),this._sv[s].push(_),this._alpha[s].push(g)}else this._sv[s].splice(t,1),this._alpha[s].splice(t,1)}}}}predict(v){const k=[];for(let f=0;f<v.length;f++){let p=-1/0;k[f]=null;for(let h=0;h<this._classes.length;h++){let c=0;for(let i=0;i<this._sv[h].length;i++)c+=this._alpha[h][i]*this._kernel(v[f],this._sv[h][i]);p<c&&(p=c,k[f]=this._classes[h])}}return k}}
