var B=Object.defineProperty;var z=(x,p)=>B(x,"name",{value:p,configurable:!0});import q from"../util/matrix.js";const A={gaussian:z(({s:x=1})=>(p,r)=>Math.exp(-(p.reduce((o,n,t)=>o+(n-r[t])**2,0)**2)/x**2),"gaussian"),polynomial:z(({d:x=2})=>(p,r)=>(1+p.reduce((o,n,t)=>o+n*r[t]))**x,"polynomial")};export default class D{static{z(this,"BSGD")}constructor(p=10,r=1,o=1,n="removal",t="gaussian"){this._b=p,this._eta=r,this._lambda=o,this._maintenance=n,typeof t=="function"?this._kernel=t:(typeof t=="string"&&(t={name:t}),this._kernel=A[t.name](t)),this._sv=[],this._alpha=[]}fit(p,r){const o=(1+Math.sqrt(5))/2;for(let n=0;n<p.length;n++){let t=0;for(let k=0;k<this._sv.length;k++)t+=this._alpha[k]*this._kernel(p[n],this._sv[k]);if(this._alpha=this._alpha.map(k=>k*(1-this._eta*this._lambda)),t*r[n]<1&&(this._alpha.push(this._eta*r[n]),this._sv.push(p[n]),this._sv.length>this._b)){let k=1/0,e=-1;for(let s=0;s<this._sv.length;s++){const f=this._alpha[s]**2*this._kernel(this._sv[s],this._sv[s]);f<k&&(k=f,e=s)}if(this._maintenance==="projection"){const s=this._sv.splice(e,1)[0],f=this._alpha.splice(e,1)[0],i=new q(this._b,this._b),m=new q(this._b,1);for(let _=0;_<this._b;_++){i.set(_,_,this._kernel(this._sv[_],this._sv[_]));for(let l=_;l<this._b;l++){const M=this._kernel(this._sv[_],this._sv[l]);i.set(_,l,M),i.set(l,_,M)}m.set(_,0,this._kernel(s,this._sv[_]))}const a=i.norm()/1e3;for(let _=0;_<this._b;_++)i.addAt(_,_,a);const d=i.solve(m);for(let _=0;_<this._b;_++)this._alpha[_]+=f*d.at(_,0)}else if(this._maintenance==="merging"){let s=1/0,f=0,i=0,m=null;for(let a=0;a<this._sv.length;a++){if(a===e)continue;const d=this._alpha[e]/(this._alpha[e]+this._alpha[a]),_=z(c=>d*this._kernel(this._sv[e].map(v=>(1-c)*v),this._sv[a].map(v=>(1-c)*v))+(1-d)*this._kernel(this._sv[e].map(v=>c*v),this._sv[a].map(v=>c*v)),"fh");let l=[0,_(0)],M=[1,_(1)],h=[1/(1+o),_(1/(1+o))];for(;M[0]-l[0]>1e-4;){const c=l[0]+(M[0]-h[0]),v=_(c);c<h[0]?v<h[1]?l=[c,v]:(M=h,h=[c,v]):v<h[1]?(l=h,h=[c,v]):M=[c,v]}const b=(l[0]+M[0])/2,u=this._sv[e].map((c,v)=>b*c+(1-b)*this._sv[a][v]),w=this._alpha[e]*this._kernel(this._sv[e],u)+this._alpha[a]*this._kernel(this._sv[a],u),j=this._alpha[e]**2*this._kernel(this._sv[e],this._sv[e])+this._alpha[a]**2*this._kernel(this._sv[a],this._sv[a])+w**2+this._kernel(u,u)+this._alpha[e]*this._alpha[a]*this._kernel(this._sv[e],this._sv[a])-this._alpha[e]*w*this._kernel(this._sv[e],u)-this._alpha[a]*w*this._kernel(this._sv[a],u);j<s&&(s=j,f=a,i=w,m=u)}this._sv.splice(Math.max(e,f),1),this._alpha.splice(Math.max(e,f),1),this._sv.splice(Math.min(e,f),1),this._alpha.splice(Math.min(e,f),1),this._sv.push(m),this._alpha.push(i)}else this._sv.splice(e,1),this._alpha.splice(e,1)}}}predict(p){const r=[];for(let o=0;o<p.length;o++){let n=0;for(let t=0;t<this._sv.length;t++)n+=this._alpha[t]*this._kernel(p[o],this._sv[t]);r[o]=n<0?-1:1}return r}}export class MulticlassBSGD{static{z(this,"MulticlassBSGD")}constructor(p=10,r=1,o=1,n="removal",t="gaussian"){this._b=p,this._eta=r,this._lambda=o,this._maintenance=n,typeof t=="function"?this._kernel=t:(typeof t=="string"&&(t={name:t}),this._kernel=A[t.name](t)),this._classes=[],this._sv=[],this._alpha=[]}fit(p,r){const o=(1+Math.sqrt(5))/2;for(let n=0;n<p.length;n++){let t=this._classes.indexOf(r[n]);t<0&&(t=this._classes.length,this._classes.push(r[n]),this._sv.push([]),this._alpha.push([]));let k=-1/0,e=-1;for(let s=0;s<this._classes.length;s++){let f=0;for(let i=0;i<this._sv[s].length;i++)f+=this._alpha[s][i]*this._kernel(p[n],this._sv[s][i]);k<f&&(k=f,e=s)}for(let s=0;s<this._classes.length;s++)this._alpha[s]=this._alpha[s].map(f=>f*(1-this._eta*this._lambda));if(t!==e){this._alpha[t].push(this._eta),this._sv[t].push(p[n]),this._alpha[e].push(-this._eta),this._sv[e].push(p[n]);for(const s of[t,e]){if(this._sv[s].length<=this._b)continue;let f=1/0,i=-1;for(let m=0;m<this._sv[s].length;m++){const a=this._alpha[s][m]**2*this._kernel(this._sv[s][m],this._sv[s][m]);a<f&&(f=a,i=m)}if(this._maintenance==="projection"){const m=this._sv[s].splice(i,1)[0],a=this._alpha[s].splice(i,1)[0],d=new q(this._b,this._b),_=new q(this._b,1);for(let h=0;h<this._b;h++){d.set(h,h,this._kernel(this._sv[s][h],this._sv[s][h]));for(let b=h;b<this._b;b++){const u=this._kernel(this._sv[s][h],this._sv[s][b]);d.set(h,b,u),d.set(b,h,u)}_.set(h,0,this._kernel(m,this._sv[s][h]))}const l=d.norm()/1e3;for(let h=0;h<this._b;h++)d.addAt(h,h,l);const M=d.solve(_);for(let h=0;h<this._b;h++)this._alpha[s][h]+=a*M.at(h,0)}else if(this._maintenance==="merging"){let m=1/0,a=0,d=0,_=null;for(let l=0;l<this._sv[s].length;l++){if(l===i)continue;const M=this._alpha[s][i]/(this._alpha[s][i]+this._alpha[s][l]),h=z(y=>M*this._kernel(this._sv[s][i].map(g=>(1-y)*g),this._sv[s][l].map(g=>(1-y)*g))+(1-M)*this._kernel(this._sv[s][i].map(g=>y*g),this._sv[s][l].map(g=>y*g)),"fh");let b=[0,h(0)],u=[1,h(1)],w=[1/(1+o),h(1/(1+o))];for(;u[0]-b[0]>1e-4;){const y=b[0]+(u[0]-w[0]),g=h(y);y<w[0]?g<w[1]?b=[y,g]:(u=w,w=[y,g]):g<w[1]?(b=w,w=[y,g]):u=[y,g]}const j=(b[0]+u[0])/2,c=this._sv[s][i].map((y,g)=>j*y+(1-j)*this._sv[s][l][g]),v=this._alpha[s][i]*this._kernel(this._sv[s][i],c)+this._alpha[s][l]*this._kernel(this._sv[s][l],c),I=this._alpha[s][i]**2*this._kernel(this._sv[s][i],this._sv[s][i])+this._alpha[s][l]**2*this._kernel(this._sv[s][l],this._sv[s][l])+v**2+this._kernel(c,c)+this._alpha[s][i]*this._alpha[s][l]*this._kernel(this._sv[s][i],this._sv[s][l])-this._alpha[s][i]*v*this._kernel(this._sv[s][i],c)-this._alpha[s][l]*v*this._kernel(this._sv[s][l],c);I<m&&(m=I,a=l,d=v,_=c)}this._sv[s].splice(Math.max(i,a),1),this._alpha[s].splice(Math.max(i,a),1),this._sv[s].splice(Math.min(i,a),1),this._alpha[s].splice(Math.min(i,a),1),this._sv[s].push(_),this._alpha[s].push(d)}else this._sv[s].splice(i,1),this._alpha[s].splice(i,1)}}}}predict(p){const r=[];for(let o=0;o<p.length;o++){let n=-1/0;r[o]=null;for(let t=0;t<this._classes.length;t++){let k=0;for(let e=0;e<this._sv[t].length;e++)k+=this._alpha[t][e]*this._kernel(p[o],this._sv[t][e]);n<k&&(n=k,r[o]=this._classes[t])}}return r}}
