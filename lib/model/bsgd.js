import Matrix from"../util/matrix.js";export default class BSGD{constructor(s=10,t=1,h=1,i="removal",e="gaussian"){if(this._b=s,this._eta=t,this._lambda=h,this._maintenance=i,"function"==typeof e)this._kernel=e;else switch(e){case"gaussian":this._s=1,this._kernel=(s,t)=>Math.exp(-(s.reduce(((s,h,i)=>s+(h-t[i])**2),0)**2)/this._s**2);break;case"polynomial":this._d=2,this._kernel=(s,t)=>(1+s.reduce(((s,h,i)=>s+h*t[i])))**this._d}this._sv=[],this._alpha=[]}fit(s,t){const h=(1+Math.sqrt(5))/2;for(let i=0;i<s.length;i++){let e=0;for(let t=0;t<this._sv.length;t++)e+=this._alpha[t]*this._kernel(s[i],this._sv[t]);if(this._alpha=this._alpha.map((s=>s*(1-this._eta*this._lambda))),e*t[i]<1&&(this._alpha.push(this._eta*t[i]),this._sv.push(s[i]),this._sv.length>this._b)){let s=1/0,t=-1;for(let h=0;h<this._sv.length;h++){const i=this._alpha[h]**2*this._kernel(this._sv[h],this._sv[h]);i<s&&(s=i,t=h)}if("projection"===this._maintenance){const s=this._sv.splice(t,1)[0],h=this._alpha.splice(t,1)[0],i=new Matrix(this._b,this._b),e=new Matrix(this._b,1);for(let t=0;t<this._b;t++){i.set(t,t,this._kernel(this._sv[t],this._sv[t]));for(let s=t;s<this._b;s++){const h=this._kernel(this._sv[t],this._sv[s]);i.set(t,s,h),i.set(s,t,h)}e.set(t,0,this._kernel(s,this._sv[t]))}const _=i.norm()/1e3;for(let s=0;s<this._b;s++)i.addAt(s,s,_);const a=i.solve(e);for(let s=0;s<this._b;s++)this._alpha[s]+=h*a.at(s,0)}else if("merging"===this._maintenance){let s=1/0,i=0,e=0,_=null;for(let a=0;a<this._sv.length;a++){if(a===t)continue;const l=this._alpha[t]/(this._alpha[t]+this._alpha[a]),n=s=>l*this._kernel(this._sv[t].map((t=>(1-s)*t)),this._sv[a].map((t=>(1-s)*t)))+(1-l)*this._kernel(this._sv[t].map((t=>s*t)),this._sv[a].map((t=>s*t)));let r=[0,n(0)],p=[1,n(1)],v=[1/(1+h),n(1/(1+h))];for(;p[0]-r[0]>1e-4;){const s=r[0]+(p[0]-v[0]),t=n(s);s<v[0]?t<v[1]?r=[s,t]:(p=v,v=[s,t]):t<v[1]?(r=v,v=[s,t]):p=[s,t]}const o=(r[0]+p[0])/2,c=this._sv[t].map(((s,t)=>o*s+(1-o)*this._sv[a][t])),m=this._alpha[t]*this._kernel(this._sv[t],c)+this._alpha[a]*this._kernel(this._sv[a],c),f=this._alpha[t]**2*this._kernel(this._sv[t],this._sv[t])+this._alpha[a]**2*this._kernel(this._sv[a],this._sv[a])+m**2+this._kernel(c,c)+this._alpha[t]*this._alpha[a]*this._kernel(this._sv[t],this._sv[a])-this._alpha[t]*m*this._kernel(this._sv[t],c)-this._alpha[a]*m*this._kernel(this._sv[a],c);f<s&&(s=f,i=a,e=m,_=c)}this._sv.splice(Math.max(t,i),1),this._alpha.splice(Math.max(t,i),1),this._sv.splice(Math.min(t,i),1),this._alpha.splice(Math.min(t,i),1),this._sv.push(_),this._alpha.push(e)}else this._sv.splice(t,1),this._alpha.splice(t,1)}}}predict(s){const t=[];for(let h=0;h<s.length;h++){let i=0;for(let t=0;t<this._sv.length;t++)i+=this._alpha[t]*this._kernel(s[h],this._sv[t]);t[h]=i<0?-1:1}return t}}