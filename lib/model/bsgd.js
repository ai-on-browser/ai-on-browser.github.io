import Matrix from"../util/matrix.js";export default class BSGD{constructor(s=10,t=1,h=1,i="removal",e="gaussian"){if(this._b=s,this._eta=t,this._lambda=h,this._maintenance=i,"function"==typeof e)this._kernel=e;else switch(e){case"gaussian":this._s=1,this._kernel=(s,t)=>Math.exp(-(s.reduce(((s,h,i)=>s+(h-t[i])**2),0)**2)/this._s**2);break;case"polynomial":this._d=2,this._kernel=(s,t)=>(1+s.reduce(((s,h,i)=>s+h*t[i])))**this._d}this._sv=[],this._alpha=[]}fit(s,t){const h=(1+Math.sqrt(5))/2;for(let i=0;i<s.length;i++){let e=0;for(let t=0;t<this._sv.length;t++)e+=this._alpha[t]*this._kernel(s[i],this._sv[t]);if(this._alpha=this._alpha.map((s=>s*(1-this._eta*this._lambda))),e*t[i]<1&&(this._alpha.push(this._eta*t[i]),this._sv.push(s[i]),this._sv.length>this._b)){let s=1/0,t=-1;for(let h=0;h<this._sv.length;h++){const i=this._alpha[h]**2*this._kernel(this._sv[h],this._sv[h]);i<s&&(s=i,t=h)}if("projection"===this._maintenance){const s=this._sv.splice(t,1)[0],h=this._alpha.splice(t,1)[0],i=new Matrix(this._b,this._b),e=new Matrix(this._b,1);for(let t=0;t<this._b;t++){i.set(t,t,this._kernel(this._sv[t],this._sv[t]));for(let s=t;s<this._b;s++){const h=this._kernel(this._sv[t],this._sv[s]);i.set(t,s,h),i.set(s,t,h)}e.set(t,0,this._kernel(s,this._sv[t]))}const _=i.norm()/1e3;for(let s=0;s<this._b;s++)i.addAt(s,s,_);const l=i.solve(e);for(let s=0;s<this._b;s++)this._alpha[s]+=h*l.at(s,0)}else if("merging"===this._maintenance){let s=1/0,i=0,e=0,_=null;for(let l=0;l<this._sv.length;l++){if(l===t)continue;const a=this._alpha[t]/(this._alpha[t]+this._alpha[l]),n=s=>a*this._kernel(this._sv[t].map((t=>(1-s)*t)),this._sv[l].map((t=>(1-s)*t)))+(1-a)*this._kernel(this._sv[t].map((t=>s*t)),this._sv[l].map((t=>s*t)));let p=[0,n(0)],r=[1,n(1)],v=[1/(1+h),n(1/(1+h))];for(;r[0]-p[0]>1e-4;){const s=p[0]+(r[0]-v[0]),t=n(s);s<v[0]?t<v[1]?p=[s,t]:(r=v,v=[s,t]):t<v[1]?(p=v,v=[s,t]):r=[s,t]}const c=(p[0]+r[0])/2,o=this._sv[t].map(((s,t)=>c*s+(1-c)*this._sv[l][t])),f=this._alpha[t]*this._kernel(this._sv[t],o)+this._alpha[l]*this._kernel(this._sv[l],o),m=this._alpha[t]**2*this._kernel(this._sv[t],this._sv[t])+this._alpha[l]**2*this._kernel(this._sv[l],this._sv[l])+f**2+this._kernel(o,o)+this._alpha[t]*this._alpha[l]*this._kernel(this._sv[t],this._sv[l])-this._alpha[t]*f*this._kernel(this._sv[t],o)-this._alpha[l]*f*this._kernel(this._sv[l],o);m<s&&(s=m,i=l,e=f,_=o)}this._sv.splice(Math.max(t,i),1),this._alpha.splice(Math.max(t,i),1),this._sv.splice(Math.min(t,i),1),this._alpha.splice(Math.min(t,i),1),this._sv.push(_),this._alpha.push(e)}else this._sv.splice(t,1),this._alpha.splice(t,1)}}}predict(s){const t=[];for(let h=0;h<s.length;h++){let i=0;for(let t=0;t<this._sv.length;t++)i+=this._alpha[t]*this._kernel(s[h],this._sv[t]);t[h]=i<0?-1:1}return t}}export class MulticlassBSGD{constructor(s=10,t=1,h=1,i="removal",e="gaussian"){if(this._b=s,this._eta=t,this._lambda=h,this._maintenance=i,"function"==typeof e)this._kernel=e;else switch(e){case"gaussian":this._s=1,this._kernel=(s,t)=>Math.exp(-(s.reduce(((s,h,i)=>s+(h-t[i])**2),0)**2)/this._s**2);break;case"polynomial":this._d=2,this._kernel=(s,t)=>(1+s.reduce(((s,h,i)=>s+h*t[i])))**this._d}this._classes=[],this._sv=[],this._alpha=[]}fit(s,t){const h=(1+Math.sqrt(5))/2;for(let i=0;i<s.length;i++){let e=this._classes.indexOf(t[i]);e<0&&(e=this._classes.length,this._classes.push(t[i]),this._sv.push([]),this._alpha.push([]));let _=-1/0,l=-1;for(let t=0;t<this._classes.length;t++){let h=0;for(let e=0;e<this._sv[t].length;e++)h+=this._alpha[t][e]*this._kernel(s[i],this._sv[t][e]);_<h&&(_=h,l=t)}for(let s=0;s<this._classes.length;s++)this._alpha[s]=this._alpha[s].map((s=>s*(1-this._eta*this._lambda)));if(e!==l){this._alpha[e].push(this._eta),this._sv[e].push(s[i]),this._alpha[l].push(-this._eta),this._sv[l].push(s[i]);for(const s of[e,l]){if(this._sv[s].length<=this._b)continue;let t=1/0,i=-1;for(let h=0;h<this._sv[s].length;h++){const e=this._alpha[s][h]**2*this._kernel(this._sv[s][h],this._sv[s][h]);e<t&&(t=e,i=h)}if("projection"===this._maintenance){const t=this._sv[s].splice(i,1)[0],h=this._alpha[s].splice(i,1)[0],e=new Matrix(this._b,this._b),_=new Matrix(this._b,1);for(let h=0;h<this._b;h++){e.set(h,h,this._kernel(this._sv[s][h],this._sv[s][h]));for(let t=h;t<this._b;t++){const i=this._kernel(this._sv[s][h],this._sv[s][t]);e.set(h,t,i),e.set(t,h,i)}_.set(h,0,this._kernel(t,this._sv[s][h]))}const l=e.norm()/1e3;for(let s=0;s<this._b;s++)e.addAt(s,s,l);const a=e.solve(_);for(let t=0;t<this._b;t++)this._alpha[s][t]+=h*a.at(t,0)}else if("merging"===this._maintenance){let t=1/0,e=0,_=0,l=null;for(let a=0;a<this._sv[s].length;a++){if(a===i)continue;const n=this._alpha[s][i]/(this._alpha[s][i]+this._alpha[s][a]),p=t=>n*this._kernel(this._sv[s][i].map((s=>(1-t)*s)),this._sv[s][a].map((s=>(1-t)*s)))+(1-n)*this._kernel(this._sv[s][i].map((s=>t*s)),this._sv[s][a].map((s=>t*s)));let r=[0,p(0)],v=[1,p(1)],c=[1/(1+h),p(1/(1+h))];for(;v[0]-r[0]>1e-4;){const s=r[0]+(v[0]-c[0]),t=p(s);s<c[0]?t<c[1]?r=[s,t]:(v=c,c=[s,t]):t<c[1]?(r=c,c=[s,t]):v=[s,t]}const o=(r[0]+v[0])/2,f=this._sv[s][i].map(((t,h)=>o*t+(1-o)*this._sv[s][a][h])),m=this._alpha[s][i]*this._kernel(this._sv[s][i],f)+this._alpha[s][a]*this._kernel(this._sv[s][a],f),k=this._alpha[s][i]**2*this._kernel(this._sv[s][i],this._sv[s][i])+this._alpha[s][a]**2*this._kernel(this._sv[s][a],this._sv[s][a])+m**2+this._kernel(f,f)+this._alpha[s][i]*this._alpha[s][a]*this._kernel(this._sv[s][i],this._sv[s][a])-this._alpha[s][i]*m*this._kernel(this._sv[s][i],f)-this._alpha[s][a]*m*this._kernel(this._sv[s][a],f);k<t&&(t=k,e=a,_=m,l=f)}this._sv[s].splice(Math.max(i,e),1),this._alpha[s].splice(Math.max(i,e),1),this._sv[s].splice(Math.min(i,e),1),this._alpha[s].splice(Math.min(i,e),1),this._sv[s].push(l),this._alpha[s].push(_)}else this._sv[s].splice(i,1),this._alpha[s].splice(i,1)}}}}predict(s){const t=[];for(let h=0;h<s.length;h++){let i=-1/0;t[h]=null;for(let e=0;e<this._classes.length;e++){let _=0;for(let t=0;t<this._sv[e].length;t++)_+=this._alpha[e][t]*this._kernel(s[h],this._sv[e][t]);i<_&&(i=_,t[h]=this._classes[e])}}return t}}