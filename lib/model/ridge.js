import{Matrix}from"../util/math.js";export class Ridge{constructor(t=.1){this._w=null,this._lambda=t}fit(t,r){t=Matrix.fromArray(t),r=Matrix.fromArray(r);const s=t.tDot(t);for(let t=0;t<s.rows;t++)s.addAt(t,t,this._lambda);this._w=s.solve(t.t).dot(r)}predict(t){return(t=Matrix.fromArray(t)).dot(this._w).toArray()}importance(){return this._w.value}}export class KernelRidge{constructor(t=.1,r=null){this._w=null,this._x=null,this._lambda=t,this._kernel=null,"gaussian"===r&&(this._kernel=(t,r,s=1)=>{const i=t.copySub(r).reduce(((t,r)=>t+r*r),0);return Math.exp(-i/s**2)})}fit(t,r){t=Matrix.fromArray(t),r=Matrix.fromArray(r);const s=new Matrix(t.rows,t.rows);this._x=[];for(let r=0;r<t.rows;r++){this._x.push(t.row(r)),s.set(r,r,this._kernel(this._x[r],this._x[r])+this._lambda);for(let t=0;t<r;t++){const i=this._kernel(this._x[r],this._x[t]);s.set(r,t,i),s.set(t,r,i)}}this._w=s.solve(r)}predict(t){t=Matrix.fromArray(t);const r=new Matrix(t.rows,this._x.length);for(let s=0;s<t.rows;s++){const i=t.row(s);for(let t=0;t<this._x.length;t++){const e=this._kernel(i,this._x[t]);r.set(s,t,e)}}return r.dot(this._w).toArray()}importance(){return this._w.value}}