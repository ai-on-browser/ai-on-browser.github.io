var f=Object.defineProperty;var d=(_,t)=>f(_,"name",{value:t,configurable:!0});import u from"../util/matrix.js";import l from"./neuralnetwork.js";export default class L{static{d(this,"GAN")}constructor(t,e,i,a,c,o,n){this._type=n,this._noise_dim=t,this._epoch=0;const r=[{type:"input",name:"dic_in"}];this._generatorNetLeyers=[{type:"input",name:"gen_in"}],n==="conditional"&&(r.push({type:"input",name:"cond",input:[]},{type:"onehot",name:"cond_oh",input:["cond"],class_size:o},{type:"concat",input:["dic_in","cond_oh"]}),this._generatorNetLeyers.push({type:"input",name:"cond",input:[]},{type:"onehot",name:"cond_oh",input:["cond"],class_size:o},{type:"concat",input:["gen_in","cond_oh"]})),r.push(...i,{type:"full",out_size:2},{type:"softmax"}),this._generatorNetLeyers.push(...e),this._discriminator=l.fromObject(r,"mse",c),this._g_opt=a}get epoch(){return this._epoch}fit(t,e,i,a,c,o){this._generator||(this._generatorNetLeyers.push({type:"full",out_size:t[0].length},{type:"leaky_relu",a:.1,name:"generate"}),this._generatorNetLeyers.push({type:"include",net:this._discriminator,input_to:"dic_in",train:!1}),this._generator=l.fromObject(this._generatorNetLeyers,"mse",this._g_opt));const n=e,r=[].concat(n,n);e=Array(t.length).fill([1,0]);for(let s=0;s<t.length;s++)e.push([0,1]);const g=Array(t.length).fill([1,0]);let h=null,p=null;for(let s=0;s<i;s++){const m=this.generate(t.length,n);p=this._discriminator.fit({dic_in:[].concat(t,m),cond:r},e,1,c,o);const y=u.randn(t.length,this._noise_dim).toArray();h=this._generator.fit({gen_in:y,cond:n},g,1,a,o),this._epoch++}return{discriminatorLoss:p[0],generatorLoss:h[0]}}prob(t,e){return this._discriminator.calc({dic_in:t,cond:e}).toArray()}generate(t,e){const i=u.randn(t,this._noise_dim).toArray();return this._generator.calc({gen_in:i,cond:e},null,["generate"]).generate.toArray()}}
