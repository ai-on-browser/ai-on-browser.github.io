import{Matrix}from"../util/math.js";import NeuralNetwork from"./neuralnetwork.js";export default class GAN{constructor(t,n,e,i,o,r,c){this._type=c,this._noise_dim=t,this._epoch=0;const a=[{type:"input",name:"dic_in"}],s=[{type:"input",name:"gen_in"}];"conditional"===c&&(a.push({type:"input",name:"cond",input:[]},{type:"onehot",name:"cond_oh",input:["cond"],class_size:r},{type:"concat",input:["dic_in","cond_oh"]}),s.push({type:"input",name:"cond",input:[]},{type:"onehot",name:"cond_oh",input:["cond"],class_size:r},{type:"concat",input:["gen_in","cond_oh"]})),a.push(...e,{type:"full",out_size:2},{type:"softmax"}),s.push(...n,{type:"full",out_size:2},{type:"leaky_relu",a:.1,name:"generate"}),this._discriminator=NeuralNetwork.fromObject(a,"mse",o),s.push({type:"include",net:this._discriminator,input_to:"dic_in",train:!1}),this._generator=NeuralNetwork.fromObject(s,"mse",i)}get epoch(){return this._epoch}fit(t,n,e,i,o,r){const c=n,a=[].concat(c,c);n=Array(t.length).fill([1,0]);for(let e=0;e<t.length;e++)n.push([0,1]);const s=Array(t.length).fill([1,0]);let p=null;for(let h=0;h<e;h++){p=this.generate(t.length,c),this._discriminator.fit({dic_in:[].concat(t,p),cond:a},n,1,o,r);const e=Matrix.randn(t.length,this._noise_dim).toArray();this._generator.fit({gen_in:e,cond:c},s,1,i,r),this._epoch++}return p}prob(t,n){return this._discriminator.calc({dic_in:t,cond:n}).toArray()}generate(t,n){const e=Matrix.randn(t,this._noise_dim).toArray();return this._generator.calc({gen_in:e,cond:n},null,["generate"]).generate.toArray()}}