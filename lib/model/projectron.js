var g=Object.defineProperty;var c=(a,r)=>g(a,"name",{value:r,configurable:!0});export class Projectron{static{c(this,"Projectron")}constructor(r=0,l="gaussian"){if(this._eta=r,typeof l=="function")this._kernel=l;else switch(l){case"gaussian":this._s=1,this._kernel=(i,_)=>Math.exp(-(i.reduce((o,h,s)=>o+(h-_[s])**2,0)**2)/this._s**2);break;case"polynomial":this._d=2,this._kernel=(i,_)=>(1+i.reduce((o,h,s)=>o+h*_[s]))**this._d;break}this._S=[],this._a=[],this._kinv=[]}fit(r,l){for(let i=0;i<r.length;i++){const _=[];for(let s=0;s<this._S.length;s++){const k=this._S[s];_[s]=this._kernel(r[i],k)}let o=0;for(let s=0;s<this._S.length;s++)o+=this._a[s]*_[s];if((o<0?-1:1)*l[i]<=0){const s=[];for(let t=0;t<this._kinv.length;t++){s[t]=0;for(let e=0;e<this._kinv[t].length;e++)s[t]+=this._kinv[t][e]*_[e]}let k=this._kernel(r[i],r[i]);for(let t=0;t<s.length;t++)k-=_[t]*s[t];if(k<=this._eta**2)for(let t=0;t<s.length;t++)this._a[t]+=l[i]*s[t];else{this._S.push(r[i]),this._a.push(l[i]);const t=[];for(let e=0;e<s.length+1;e++){t[e]=[];for(let n=0;n<s.length+1;n++)e<this._kinv.length&&n<this._kinv[e].length?t[e][n]=this._kinv[e][n]+s[e]*s[n]/k:e<this._kinv.length?t[e][n]=-s[e]/k:n<this._kinv.length?t[e][n]=-s[n]/k:t[e][n]=1/k}this._kinv=t}}}}predict(r){const l=[];for(let i=0;i<r.length;i++){const _=[];for(let h=0;h<this._S.length;h++){const s=this._S[h];_[h]=this._kernel(r[i],s)}let o=0;for(let h=0;h<this._S.length;h++)o+=this._a[h]*_[h];l[i]=o<0?-1:1}return l}}export class Projectronpp{static{c(this,"Projectronpp")}constructor(r=0,l="gaussian"){if(this._eta=r,typeof l=="function")this._kernel=l;else switch(l){case"gaussian":this._s=1,this._kernel=(i,_)=>Math.exp(-(i.reduce((o,h,s)=>o+(h-_[s])**2,0)**2)/this._s**2);break;case"polynomial":this._d=2,this._kernel=(i,_)=>(1+i.reduce((o,h,s)=>o+h*_[s]))**this._d;break}this._S=[],this._a=[],this._kinv=[]}fit(r,l){for(let i=0;i<r.length;i++){const _=[];for(let t=0;t<this._S.length;t++){const e=this._S[t];_[t]=this._kernel(r[i],e)}let o=0;for(let t=0;t<this._S.length;t++)o+=this._a[t]*_[t];const h=o<0?-1:1,s=[];for(let t=0;t<this._kinv.length;t++){s[t]=0;for(let e=0;e<this._kinv[t].length;e++)s[t]+=this._kinv[t][e]*_[e]}let k=this._kernel(r[i],r[i]);for(let t=0;t<s.length;t++)k-=_[t]*s[t];if(h*l[i]<=0)if(k<=this._eta**2)for(let t=0;t<s.length;t++)this._a[t]+=l[i]*s[t];else{this._S.push(r[i]),this._a.push(l[i]);const t=[];for(let e=0;e<s.length+1;e++){t[e]=[];for(let n=0;n<s.length+1;n++)e<this._kinv.length&&n<this._kinv[e].length?t[e][n]=this._kinv[e][n]+s[e]*s[n]/k:e<this._kinv.length?t[e][n]=-s[e]/k:n<this._kinv.length?t[e][n]=-s[n]/k:t[e][n]=1/k}this._kinv=t}else if(l[i]*o<=1){const t=Math.max(0,1-o*l[i]);if(t>=Math.sqrt(k)/this._eta){let e=0;for(let f=0;f<s.length;f++)e+=_[f]*s[f];const n=Math.min(t/e,2*(t-Math.sqrt(k)/this._eta)/e,1);for(let f=0;f<s.length;f++)this._a[f]+=l[i]*n*s[f]}}}}predict(r){const l=[];for(let i=0;i<r.length;i++){const _=[];for(let h=0;h<this._S.length;h++){const s=this._S[h];_[h]=this._kernel(r[i],s)}let o=0;for(let h=0;h<this._S.length;h++)o+=this._a[h]*_[h];l[i]=o<0?-1:1}return l}}
