export class Projectron{constructor(t=0,s="gaussian"){switch(this._eta=t,s){case"gaussian":this._s=1,this._kernel=(t,s)=>Math.exp(-(t.reduce(((t,h,i)=>t+(h-s[i])**2),0)**2)/this._s**2);break;case"polynomial":this._d=2,this._kernel=(t,s)=>(1+t.reduce(((t,h,i)=>t+h*s[i])))**this._d}}init(t,s){this._x=t,this._y=s,this._S=[],this._a=[],this._kinv=[]}fit(){for(let t=0;t<this._x.length;t++){const s=[];for(let h=0;h<this._S.length;h++){const i=this._S[h];s[h]=this._kernel(this._x[t],this._x[i])}let h=0;for(let t=0;t<this._S.length;t++)h+=this._a[t]*s[t];if((h<0?-1:1)*this._y[t]<=0){const h=[];for(let t=0;t<this._kinv.length;t++){h[t]=0;for(let i=0;i<this._kinv[t].length;i++)h[t]+=this._kinv[t][i]*s[i]}let i=this._kernel(this._x[t],this._x[t]);for(let t=0;t<h.length;t++)i-=s[t]*h[t];if(i<=this._eta**2)for(let s=0;s<h.length;s++)this._a[s]+=this._y[t]*h[s];else{this._S.push(t),this._a.push(this._y[t]);const s=[];for(let t=0;t<h.length+1;t++){s[t]=[];for(let e=0;e<h.length+1;e++)t<this._kinv.length&&e<this._kinv[t].length?s[t][e]=this._kinv[t][e]+h[t]*h[e]/i:t<this._kinv.length?s[t][e]=-h[t]/i:e<this._kinv.length?s[t][e]=-h[e]/i:s[t][e]=1/i}this._kinv=s}}}}predict(t){const s=[];for(let h=0;h<t.length;h++){const i=[];for(let s=0;s<this._S.length;s++){const e=this._S[s];i[s]=this._kernel(t[h],this._x[e])}let e=0;for(let t=0;t<this._S.length;t++)e+=this._a[t]*i[t];s[h]=e<0?-1:1}return s}}export class Projectronpp{constructor(t=0,s="gaussian"){switch(this._eta=t,s){case"gaussian":this._s=1,this._kernel=(t,s)=>Math.exp(-(t.reduce(((t,h,i)=>t+(h-s[i])**2),0)**2)/this._s**2);break;case"polynomial":this._d=2,this._kernel=(t,s)=>(1+t.reduce(((t,h,i)=>t+h*s[i])))**this._d}}init(t,s){this._x=t,this._y=s,this._S=[],this._a=[],this._kinv=[]}fit(){for(let t=0;t<this._x.length;t++){const s=[];for(let h=0;h<this._S.length;h++){const i=this._S[h];s[h]=this._kernel(this._x[t],this._x[i])}let h=0;for(let t=0;t<this._S.length;t++)h+=this._a[t]*s[t];const i=h<0?-1:1,e=[];for(let t=0;t<this._kinv.length;t++){e[t]=0;for(let h=0;h<this._kinv[t].length;h++)e[t]+=this._kinv[t][h]*s[h]}let _=this._kernel(this._x[t],this._x[t]);for(let t=0;t<e.length;t++)_-=s[t]*e[t];if(i*this._y[t]<=0)if(_<=this._eta**2)for(let s=0;s<e.length;s++)this._a[s]+=this._y[t]*e[s];else{this._S.push(t),this._a.push(this._y[t]);const s=[];for(let t=0;t<e.length+1;t++){s[t]=[];for(let h=0;h<e.length+1;h++)t<this._kinv.length&&h<this._kinv[t].length?s[t][h]=this._kinv[t][h]+e[t]*e[h]/_:t<this._kinv.length?s[t][h]=-e[t]/_:h<this._kinv.length?s[t][h]=-e[h]/_:s[t][h]=1/_}this._kinv=s}else if(this._y[t]*h<=1){const i=Math.max(0,1-h*this._y[t]);if(i>=Math.sqrt(_)/this._eta){let h=0;for(let t=0;t<e.length;t++)h+=s[t]*e[t];const n=Math.min(i/h,2*(i-Math.sqrt(_)/this._eta)/h,1);for(let s=0;s<e.length;s++)this._a[s]+=this._y[t]*n*e[s]}}}}predict(t){const s=[];for(let h=0;h<t.length;h++){const i=[];for(let s=0;s<this._S.length;s++){const e=this._S[s];i[s]=this._kernel(t[h],this._x[e])}let e=0;for(let t=0;t<this._S.length;t++)e+=this._a[t]*i[t];s[h]=e<0?-1:1}return s}}