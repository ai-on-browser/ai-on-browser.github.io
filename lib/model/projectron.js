export class Projectron{constructor(t=0,e="gaussian"){if(this._eta=t,"function"==typeof e)this._kernel=e;else switch(e){case"gaussian":this._s=1,this._kernel=(t,e)=>Math.exp(-(t.reduce(((t,s,h)=>t+(s-e[h])**2),0)**2)/this._s**2);break;case"polynomial":this._d=2,this._kernel=(t,e)=>(1+t.reduce(((t,s,h)=>t+s*e[h])))**this._d}this._S=[],this._a=[],this._kinv=[]}fit(t,e){for(let s=0;s<t.length;s++){const h=[];for(let e=0;e<this._S.length;e++){const i=this._S[e];h[e]=this._kernel(t[s],i)}let i=0;for(let t=0;t<this._S.length;t++)i+=this._a[t]*h[t];if((i<0?-1:1)*e[s]<=0){const i=[];for(let t=0;t<this._kinv.length;t++){i[t]=0;for(let e=0;e<this._kinv[t].length;e++)i[t]+=this._kinv[t][e]*h[e]}let n=this._kernel(t[s],t[s]);for(let t=0;t<i.length;t++)n-=h[t]*i[t];if(n<=this._eta**2)for(let t=0;t<i.length;t++)this._a[t]+=e[s]*i[t];else{this._S.push(t[s]),this._a.push(e[s]);const h=[];for(let t=0;t<i.length+1;t++){h[t]=[];for(let e=0;e<i.length+1;e++)t<this._kinv.length&&e<this._kinv[t].length?h[t][e]=this._kinv[t][e]+i[t]*i[e]/n:t<this._kinv.length?h[t][e]=-i[t]/n:e<this._kinv.length?h[t][e]=-i[e]/n:h[t][e]=1/n}this._kinv=h}}}}predict(t){const e=[];for(let s=0;s<t.length;s++){const h=[];for(let e=0;e<this._S.length;e++){const i=this._S[e];h[e]=this._kernel(t[s],i)}let i=0;for(let t=0;t<this._S.length;t++)i+=this._a[t]*h[t];e[s]=i<0?-1:1}return e}}export class Projectronpp{constructor(t=0,e="gaussian"){if(this._eta=t,"function"==typeof e)this._kernel=e;else switch(e){case"gaussian":this._s=1,this._kernel=(t,e)=>Math.exp(-(t.reduce(((t,s,h)=>t+(s-e[h])**2),0)**2)/this._s**2);break;case"polynomial":this._d=2,this._kernel=(t,e)=>(1+t.reduce(((t,s,h)=>t+s*e[h])))**this._d}this._S=[],this._a=[],this._kinv=[]}fit(t,e){for(let s=0;s<t.length;s++){const h=[];for(let e=0;e<this._S.length;e++){const i=this._S[e];h[e]=this._kernel(t[s],i)}let i=0;for(let t=0;t<this._S.length;t++)i+=this._a[t]*h[t];const n=i<0?-1:1,l=[];for(let t=0;t<this._kinv.length;t++){l[t]=0;for(let e=0;e<this._kinv[t].length;e++)l[t]+=this._kinv[t][e]*h[e]}let _=this._kernel(t[s],t[s]);for(let t=0;t<l.length;t++)_-=h[t]*l[t];if(n*e[s]<=0)if(_<=this._eta**2)for(let t=0;t<l.length;t++)this._a[t]+=e[s]*l[t];else{this._S.push(t[s]),this._a.push(e[s]);const h=[];for(let t=0;t<l.length+1;t++){h[t]=[];for(let e=0;e<l.length+1;e++)t<this._kinv.length&&e<this._kinv[t].length?h[t][e]=this._kinv[t][e]+l[t]*l[e]/_:t<this._kinv.length?h[t][e]=-l[t]/_:e<this._kinv.length?h[t][e]=-l[e]/_:h[t][e]=1/_}this._kinv=h}else if(e[s]*i<=1){const t=Math.max(0,1-i*e[s]);if(t>=Math.sqrt(_)/this._eta){let i=0;for(let t=0;t<l.length;t++)i+=h[t]*l[t];const n=Math.min(t/i,2*(t-Math.sqrt(_)/this._eta)/i,1);for(let t=0;t<l.length;t++)this._a[t]+=e[s]*n*l[t]}}}}predict(t){const e=[];for(let s=0;s<t.length;s++){const h=[];for(let e=0;e<this._S.length;e++){const i=this._S[e];h[e]=this._kernel(t[s],i)}let i=0;for(let t=0;t<this._S.length;t++)i+=this._a[t]*h[t];e[s]=i<0?-1:1}return e}}