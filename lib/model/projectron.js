var g=Object.defineProperty;var c=(a,o)=>g(a,"name",{value:o,configurable:!0});export class Projectron{static{c(this,"Projectron")}constructor(o=0,h="gaussian"){if(this._eta=o,typeof h=="function")this._kernel=h;else switch(typeof h=="string"&&(h={name:h}),h.name){case"gaussian":this._s=h.s??1,this._kernel=(e,_)=>Math.exp(-(e.reduce((r,n,s)=>r+(n-_[s])**2,0)**2)/this._s**2);break;case"polynomial":this._d=h.d??2,this._kernel=(e,_)=>(1+e.reduce((r,n,s)=>r+n*_[s]))**this._d;break}this._S=[],this._a=[],this._kinv=[]}fit(o,h){for(let e=0;e<o.length;e++){const _=[];for(let s=0;s<this._S.length;s++){const f=this._S[s];_[s]=this._kernel(o[e],f)}let r=0;for(let s=0;s<this._S.length;s++)r+=this._a[s]*_[s];if((r<0?-1:1)*h[e]<=0){const s=[];for(let t=0;t<this._kinv.length;t++){s[t]=0;for(let i=0;i<this._kinv[t].length;i++)s[t]+=this._kinv[t][i]*_[i]}let f=this._kernel(o[e],o[e]);for(let t=0;t<s.length;t++)f-=_[t]*s[t];if(f<=this._eta**2)for(let t=0;t<s.length;t++)this._a[t]+=h[e]*s[t];else{this._S.push(o[e]),this._a.push(h[e]);const t=[];for(let i=0;i<s.length+1;i++){t[i]=[];for(let l=0;l<s.length+1;l++)i<this._kinv.length&&l<this._kinv[i].length?t[i][l]=this._kinv[i][l]+s[i]*s[l]/f:i<this._kinv.length?t[i][l]=-s[i]/f:l<this._kinv.length?t[i][l]=-s[l]/f:t[i][l]=1/f}this._kinv=t}}}}predict(o){const h=[];for(let e=0;e<o.length;e++){const _=[];for(let n=0;n<this._S.length;n++){const s=this._S[n];_[n]=this._kernel(o[e],s)}let r=0;for(let n=0;n<this._S.length;n++)r+=this._a[n]*_[n];h[e]=r<0?-1:1}return h}}export class Projectronpp{static{c(this,"Projectronpp")}constructor(o=0,h="gaussian"){if(this._eta=o,typeof h=="function")this._kernel=h;else switch(typeof h=="string"&&(h={name:h}),h.name){case"gaussian":this._s=h.s??1,this._kernel=(e,_)=>Math.exp(-(e.reduce((r,n,s)=>r+(n-_[s])**2,0)**2)/this._s**2);break;case"polynomial":this._d=h.d??2,this._kernel=(e,_)=>(1+e.reduce((r,n,s)=>r+n*_[s]))**this._d;break}this._S=[],this._a=[],this._kinv=[]}fit(o,h){for(let e=0;e<o.length;e++){const _=[];for(let t=0;t<this._S.length;t++){const i=this._S[t];_[t]=this._kernel(o[e],i)}let r=0;for(let t=0;t<this._S.length;t++)r+=this._a[t]*_[t];const n=r<0?-1:1,s=[];for(let t=0;t<this._kinv.length;t++){s[t]=0;for(let i=0;i<this._kinv[t].length;i++)s[t]+=this._kinv[t][i]*_[i]}let f=this._kernel(o[e],o[e]);for(let t=0;t<s.length;t++)f-=_[t]*s[t];if(n*h[e]<=0)if(f<=this._eta**2)for(let t=0;t<s.length;t++)this._a[t]+=h[e]*s[t];else{this._S.push(o[e]),this._a.push(h[e]);const t=[];for(let i=0;i<s.length+1;i++){t[i]=[];for(let l=0;l<s.length+1;l++)i<this._kinv.length&&l<this._kinv[i].length?t[i][l]=this._kinv[i][l]+s[i]*s[l]/f:i<this._kinv.length?t[i][l]=-s[i]/f:l<this._kinv.length?t[i][l]=-s[l]/f:t[i][l]=1/f}this._kinv=t}else if(h[e]*r<=1){const t=Math.max(0,1-r*h[e]);if(t>=Math.sqrt(f)/this._eta){let i=0;for(let k=0;k<s.length;k++)i+=_[k]*s[k];const l=Math.min(t/i,2*(t-Math.sqrt(f)/this._eta)/i,1);for(let k=0;k<s.length;k++)this._a[k]+=h[e]*l*s[k]}}}}predict(o){const h=[];for(let e=0;e<o.length;e++){const _=[];for(let n=0;n<this._S.length;n++){const s=this._S[n];_[n]=this._kernel(o[e],s)}let r=0;for(let n=0;n<this._S.length;n++)r+=this._a[n]*_[n];h[e]=r<0?-1:1}return h}}
