export class Projectron{constructor(t=0,s="gaussian"){if(this._eta=t,"function"==typeof s)this._kernel=s;else switch(s){case"gaussian":this._s=1,this._kernel=(t,s)=>Math.exp(-(t.reduce(((t,i,h)=>t+(i-s[h])**2),0)**2)/this._s**2);break;case"polynomial":this._d=2,this._kernel=(t,s)=>(1+t.reduce(((t,i,h)=>t+i*s[h])))**this._d}}init(t,s){this._x=t,this._y=s,this._S=[],this._a=[],this._kinv=[]}fit(){for(let t=0;t<this._x.length;t++){const s=[];for(let i=0;i<this._S.length;i++){const h=this._S[i];s[i]=this._kernel(this._x[t],this._x[h])}let i=0;for(let t=0;t<this._S.length;t++)i+=this._a[t]*s[t];if((i<0?-1:1)*this._y[t]<=0){const i=[];for(let t=0;t<this._kinv.length;t++){i[t]=0;for(let h=0;h<this._kinv[t].length;h++)i[t]+=this._kinv[t][h]*s[h]}let h=this._kernel(this._x[t],this._x[t]);for(let t=0;t<i.length;t++)h-=s[t]*i[t];if(h<=this._eta**2)for(let s=0;s<i.length;s++)this._a[s]+=this._y[t]*i[s];else{this._S.push(t),this._a.push(this._y[t]);const s=[];for(let t=0;t<i.length+1;t++){s[t]=[];for(let e=0;e<i.length+1;e++)t<this._kinv.length&&e<this._kinv[t].length?s[t][e]=this._kinv[t][e]+i[t]*i[e]/h:t<this._kinv.length?s[t][e]=-i[t]/h:e<this._kinv.length?s[t][e]=-i[e]/h:s[t][e]=1/h}this._kinv=s}}}}predict(t){const s=[];for(let i=0;i<t.length;i++){const h=[];for(let s=0;s<this._S.length;s++){const e=this._S[s];h[s]=this._kernel(t[i],this._x[e])}let e=0;for(let t=0;t<this._S.length;t++)e+=this._a[t]*h[t];s[i]=e<0?-1:1}return s}}export class Projectronpp{constructor(t=0,s="gaussian"){if(this._eta=t,"function"==typeof s)this._kernel=s;else switch(s){case"gaussian":this._s=1,this._kernel=(t,s)=>Math.exp(-(t.reduce(((t,i,h)=>t+(i-s[h])**2),0)**2)/this._s**2);break;case"polynomial":this._d=2,this._kernel=(t,s)=>(1+t.reduce(((t,i,h)=>t+i*s[h])))**this._d}}init(t,s){this._x=t,this._y=s,this._S=[],this._a=[],this._kinv=[]}fit(){for(let t=0;t<this._x.length;t++){const s=[];for(let i=0;i<this._S.length;i++){const h=this._S[i];s[i]=this._kernel(this._x[t],this._x[h])}let i=0;for(let t=0;t<this._S.length;t++)i+=this._a[t]*s[t];const h=i<0?-1:1,e=[];for(let t=0;t<this._kinv.length;t++){e[t]=0;for(let i=0;i<this._kinv[t].length;i++)e[t]+=this._kinv[t][i]*s[i]}let n=this._kernel(this._x[t],this._x[t]);for(let t=0;t<e.length;t++)n-=s[t]*e[t];if(h*this._y[t]<=0)if(n<=this._eta**2)for(let s=0;s<e.length;s++)this._a[s]+=this._y[t]*e[s];else{this._S.push(t),this._a.push(this._y[t]);const s=[];for(let t=0;t<e.length+1;t++){s[t]=[];for(let i=0;i<e.length+1;i++)t<this._kinv.length&&i<this._kinv[t].length?s[t][i]=this._kinv[t][i]+e[t]*e[i]/n:t<this._kinv.length?s[t][i]=-e[t]/n:i<this._kinv.length?s[t][i]=-e[i]/n:s[t][i]=1/n}this._kinv=s}else if(this._y[t]*i<=1){const h=Math.max(0,1-i*this._y[t]);if(h>=Math.sqrt(n)/this._eta){let i=0;for(let t=0;t<e.length;t++)i+=s[t]*e[t];const _=Math.min(h/i,2*(h-Math.sqrt(n)/this._eta)/i,1);for(let s=0;s<e.length;s++)this._a[s]+=this._y[t]*_*e[s]}}}}predict(t){const s=[];for(let i=0;i<t.length;i++){const h=[];for(let s=0;s<this._S.length;s++){const e=this._S[s];h[s]=this._kernel(t[i],this._x[e])}let e=0;for(let t=0;t<this._S.length;t++)e+=this._a[t]*h[t];s[i]=e<0?-1:1}return s}}