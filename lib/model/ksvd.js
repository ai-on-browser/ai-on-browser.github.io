import Matrix from"../util/matrix.js";export default class KSVD{constructor(t,o,s=o){this._y=Matrix.fromArray(t),this._m=o,this._k=s,this._d=Matrix.randn(this._y.cols,o),this._d.div(this._d.copyMap((t=>t**2)).mean(0).copyMap(Math.sqrt))}fit(){const t=new Matrix(this._y.rows,this._m);for(let o=0;o<this._y.rows;o++){const s=this._omp(this._y.row(o).t);t.set(o,0,s.t)}for(let o=0;o<this._m;o++){const s=t.col(o).value.map((t=>0!==t)),r=this._y.row(s);r.sub(t.row(s).dot(this._d.t));const[i,e,h]=r.svd();this._d.set(0,o,h.row(0).t);for(let r=0,h=0;r<s.length;r++)s[r]&&(t.set(r,o,i.at(h,0)*e[0]),h++)}this._r=t;return this._y.copySub(this._r.dot(this._d.t)).norm()**2}_omp(t){let o=Matrix.zeros(this._m,1),s=t;const r=[];for(let i=0;i<this._k;i++){let i=1/0,e=-1;for(let t=0;t<this._m;t++){if(r.indexOf(t)>=0)continue;const o=this._d.col(t),h=s.norm()**2-o.tDot(s).toScaler()**2/(o.norm()**2+1e-12);h<i&&(i=h,e=t)}r.push(e);const h=this._d.col(r),_=h.tDot(h).solve(h.tDot(t));for(let t=0;t<r.length;t++)o.set(r[t],0,_.row(t));if(s=t.copySub(h.dot(_)),s.norm()<1e-8)break}return o}predict(){return this._r.toArray()}}