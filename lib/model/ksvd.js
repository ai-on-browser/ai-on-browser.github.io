import Matrix from"../util/matrix.js";export default class KSVD{constructor(t,s,r=s){this._y=Matrix.fromArray(t),this._m=s,this._k=r,this._d=Matrix.randn(this._y.cols,s),this._d.div(Matrix.map(Matrix.map(this._d,(t=>t**2)).mean(0),Math.sqrt))}fit(){const t=new Matrix(this._y.rows,this._m);for(let s=0;s<this._y.rows;s++){const r=this._omp(this._y.row(s).t);t.set(s,0,r.t)}for(let s=0;s<this._m;s++){const r=t.col(s).value.map((t=>0!==t)),o=this._y.row(r);o.sub(t.row(r).dot(this._d.t));const[i,e,h]=o.svd();this._d.set(0,s,h.row(0).t);for(let o=0,h=0;o<r.length;o++)r[o]&&(t.set(o,s,i.at(h,0)*e[0]),h++)}this._r=t;return Matrix.sub(this._y,this._r.dot(this._d.t)).norm()**2}_omp(t){let s=Matrix.zeros(this._m,1),r=t;const o=[];for(let i=0;i<this._k;i++){let i=1/0,e=-1;for(let t=0;t<this._m;t++){if(o.includes(t))continue;const s=this._d.col(t),h=r.norm()**2-s.tDot(r).toScaler()**2/(s.norm()**2+1e-12);h<i&&(i=h,e=t)}o.push(e);const h=this._d.col(o),_=h.tDot(h).solve(h.tDot(t));for(let t=0;t<o.length;t++)s.set(o[t],0,_.row(t));if(r=Matrix.sub(t,h.dot(_)),r.norm()<1e-8)break}return s}predict(){return this._r.toArray()}}