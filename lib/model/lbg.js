var y=Object.defineProperty;var u=(m,e)=>y(m,"name",{value:e,configurable:!0});import _ from"../util/matrix.js";export default class w{static{u(this,"LBG")}constructor(){this._centroids=[]}get centroids(){return this._centroids}get size(){return this._centroids.length}_distance(e,o){return Math.sqrt(e.reduce((c,n,r)=>c+(n-o[r])**2,0))}clear(){this._centroids=[]}fit(e){const o=_.fromArray(e);if(this._centroids.length===0){this._centroids=o.mean(0).toArray();return}const c=[],n=_.div(_.sub(o.max(0),o.min()),100).value;for(const s of this._centroids){const l=s.concat(),h=s.concat();for(let i=0;i<n.length;i++)l[i]+=n[i],h[i]-=n[i];c.push(l,h)}this._centroids=c;let r=0;do{const s=this.predict(e),l=this._centroids.length,h=this._centroids.map(t=>Array.from(t,()=>0)),i=Array(l).fill(0),a=e.length;for(let t=0;t<a;t++){for(let d=0;d<e[t].length;d++)h[s[t]][d]+=e[t][d];i[s[t]]++}r=0;for(let t=0;t<l;t++){const d=h[t].map(f=>f/i[t]);r+=this._centroids[t].reduce((f,p,g)=>f+(p-d[g])**2,0),this._centroids[t]=h[t].map(f=>f/i[t])}}while(r>0)}predict(e){if(this._centroids.length===0)throw new Error("Call fit before predict.");return e.map(o=>{let c=1/0,n=-1;for(let r=0;r<this._centroids.length;r++){const s=this._distance(o,this._centroids[r]);s<c&&(c=s,n=r)}return n})}}
