var p=Object.defineProperty;var u=(l,t)=>p(l,"name",{value:t,configurable:!0});const _=u(function(l){for(let t=l.length-1;t>0;t--){let n=Math.floor(Math.random()*(t+1));[l[t],l[n]]=[l[n],l[t]]}return l},"shuffle");class g{static{u(this,"IsolationTree")}constructor(){this._tree={}}get c(){const t=this._n;return 2*Math.log(t-1)+.5772156649-2*(t-1)/t}_separate(t){const n=t.length;if(n<=1)return;const e=[],s=[];for(let r=0;r<t[0].length;r++){let c=1/0,f=-1/0;for(let a=0;a<n;a++)c=Math.min(c,t[a][r]),f=Math.max(f,t[a][r]);c<f&&(s.push([c,f]),e.push(r))}if(e.length===0)return;const h=Math.floor(Math.random()*e.length),o=e[h],i=Math.random()*(s[h][1]-s[h][0])+s[h][0];return[o,i]}fit(t){this._n=t.length;const n=[[this._tree,t]];for(;n.length>0;){const[e,s]=n.pop(),h=this._separate(s);if(!h)continue;[e.feature,e.threshold]=h;const o=[],i=[];for(let r=0;r<s.length;r++)s[r][e.feature]<=e.threshold?o.push(s[r]):i.push(s[r]);n.push([e.left={},o]),n.push([e.right={},i])}}depth(t){return t.map(n=>{let e=this._tree,s=0;for(;e.left;)e=n[e.feature]<=e.threshold?e.left:e.right,s++;return s})}}export default class m{static{u(this,"IsolationForest")}constructor(t=100,n=.8){this._tree_num=t,this._rate=n,this._trees=[]}fit(t){this._trees=[];const n=Math.ceil(t.length*this._rate),e=t.map((s,h)=>h);for(let s=0;s<this._tree_num;s++){_(e);const h=[];for(let i=0;i<n;i++)h.push(t[e[i]]);const o=new g;o.fit(h),this._trees.push(o)}}predict(t){const n=t.length,e=this._trees.map(o=>o.depth(t)),s=this._trees.reduce((o,i)=>o+i.c,0)/this._trees.length,h=[];for(let o=0;o<n;o++){let i=0;for(let r=0;r<e.length;r++)i+=e[r][o];i/=e.length,h.push(2**(-i/s))}return h}}
