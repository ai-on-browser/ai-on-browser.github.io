var p=Object.defineProperty;var u=(l,t)=>p(l,"name",{value:t,configurable:!0});const _=u(l=>{for(let t=l.length-1;t>0;t--){const n=Math.floor(Math.random()*(t+1));[l[t],l[n]]=[l[n],l[t]]}return l},"shuffle");class g{static{u(this,"IsolationTree")}constructor(){this._tree={}}get c(){const t=this._n;return 2*Math.log(t-1)+.5772156649-2*(t-1)/t}_separate(t){const n=t.length;if(n<=1)return;const e=[],s=[];for(let o=0;o<t[0].length;o++){let c=1/0,f=-1/0;for(let a=0;a<n;a++)c=Math.min(c,t[a][o]),f=Math.max(f,t[a][o]);c<f&&(s.push([c,f]),e.push(o))}if(e.length===0)return;const h=Math.floor(Math.random()*e.length),r=e[h],i=Math.random()*(s[h][1]-s[h][0])+s[h][0];return[r,i]}fit(t){this._n=t.length;const n=[[this._tree,t]];for(;n.length>0;){const[e,s]=n.pop(),h=this._separate(s);if(!h)continue;[e.feature,e.threshold]=h;const r=[],i=[];for(let o=0;o<s.length;o++)s[o][e.feature]<=e.threshold?r.push(s[o]):i.push(s[o]);e.left={},e.right={},n.push([e.left,r]),n.push([e.right,i])}}depth(t){return t.map(n=>{let e=this._tree,s=0;for(;e.left;)e=n[e.feature]<=e.threshold?e.left:e.right,s++;return s})}}export default class m{static{u(this,"IsolationForest")}constructor(t=100,n=.8){this._tree_num=t,this._rate=n,this._trees=[]}fit(t){this._trees=[];const n=Math.ceil(t.length*this._rate),e=t.map((s,h)=>h);for(let s=0;s<this._tree_num;s++){_(e);const h=[];for(let i=0;i<n;i++)h.push(t[e[i]]);const r=new g;r.fit(h),this._trees.push(r)}}predict(t){const n=t.length,e=this._trees.map(r=>r.depth(t)),s=this._trees.reduce((r,i)=>r+i.c,0)/this._trees.length,h=[];for(let r=0;r<n;r++){let i=0;for(let o=0;o<e.length;o++)i+=e[o][r];i/=e.length,h.push(2**(-i/s))}return h}}
