const shuffle=function(t){for(let e=t.length-1;e>0;e--){let r=Math.floor(Math.random()*(e+1));[t[e],t[r]]=[t[r],t[e]]}return t};class IsolationTree{constructor(){this._tree={}}get c(){const t=this._n;return 2*Math.log(t-1)+.5772156649-2*(t-1)/t}_separate(t){const e=t.length;if(e<=1)return;const r=[],s=[];for(let h=0;h<t[0].length;h++){let n=1/0,o=-1/0;for(let r=0;r<e;r++)n=Math.min(n,t[r][h]),o=Math.max(o,t[r][h]);n<o&&(s.push([n,o]),r.push(h))}if(0===r.length)return;const h=Math.floor(Math.random()*r.length);return[r[h],Math.random()*(s[h][1]-s[h][0])+s[h][0]]}fit(t){this._n=t.length;const e=[[this._tree,t]];for(;e.length>0;){const[t,r]=e.pop(),s=this._separate(r);if(!s)continue;[t.feature,t.threshold]=s;const h=[],n=[];for(let e=0;e<r.length;e++)r[e][t.feature]<=t.threshold?h.push(r[e]):n.push(r[e]);e.push([t.left={},h]),e.push([t.right={},n])}}depth(t){return t.map((t=>{let e=this._tree,r=0;for(;e.left;)e=t[e.feature]<=e.threshold?e.left:e.right,r++;return r}))}}export default class IsolationForest{constructor(t=100,e=.8){this._tree_num=t,this._rate=e,this._trees=[]}fit(t){this._trees=[];const e=Math.ceil(t.length*this._rate),r=t.map(((t,e)=>e));for(let s=0;s<this._tree_num;s++){shuffle(r);const s=[];for(let h=0;h<e;h++)s.push(t[r[h]]);const h=new IsolationTree;h.fit(s),this._trees.push(h)}}predict(t){const e=t.length,r=this._trees.map((e=>e.depth(t))),s=this._trees.reduce(((t,e)=>t+e.c),0)/this._trees.length,h=[];for(let t=0;t<e;t++){let e=0;for(let s=0;s<r.length;s++)e+=r[s][t];e/=r.length,h.push(2**(-e/s))}return h}}