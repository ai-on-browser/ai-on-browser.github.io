import{Tree}from"../util/math.js";const shuffle=function(t){for(let e=t.length-1;e>0;e--){let s=Math.floor(Math.random()*(e+1));[t[e],t[s]]=[t[s],t[e]]}return t};class IsolationTree{constructor(t){this._datas=t,this._tree=new Tree({}),this._features=t[0].length,this._n=t.length}get c(){const t=this._n;return 2*Math.log(t-1)+.5772156649-2*(t-1)/t}_separate(t){const e=t.length;if(e<=1)return;const s=[],r=[];for(let h=0;h<this._features;h++){let l=1/0,o=-1/0;for(let s=0;s<e;s++)l=Math.min(l,t[s][h]),o=Math.max(o,t[s][h]);l<o&&(r.push([l,o]),s.push(h))}if(0===s.length)return;const h=Math.floor(Math.random()*s.length);return[s[h],Math.random()*(r[h][1]-r[h][0])+r[h][0]]}fit(){const t=[[this._tree,this._datas]];for(;t.length>0;){const[e,s]=t.pop();if(e.isLeaf()){const t=this._separate(s);if(!t)continue;const[r,h]=t;e.value.feature=r,e.value.threshold=h,e.push({}),e.push({})}const r=[],h=[];for(let t=0;t<s.length;t++)s[t][e.value.feature]<=e.value.threshold?r.push(s[t]):h.push(s[t]);t.push([e.at(0),r]),t.push([e.at(1),h])}}depth(t){return t.map((t=>{let e=this._tree,s=0;for(;!e.isLeaf();)e=t[e.value.feature]<=e.value.threshold?e.at(0):e.at(1),s++;return s}))}}export default class IsolationForest{constructor(t,e,s=.8){this._trees=[];let r=Math.ceil(t.length*s),h=[];for(let e=0;e<t.length;h.push(e++));for(let s=0;s<e;s++){shuffle(h);let e=[];for(let s=0;s<r;s++)e.push(t[h[s]]);this._trees.push(new IsolationTree(e))}}fit(){this._trees.forEach((t=>t.fit()))}predict(t){const e=t.length,s=this._trees.map((e=>e.depth(t))),r=this._trees.reduce(((t,e)=>t+e.c),0)/this._trees.length,h=[];for(let t=0;t<e;t++){let e=0;for(let r=0;r<s.length;r++)e+=s[r][t];e/=s.length,h.push(2**(-e/r))}return h}}