import{Tree}from"../util/math.js";const shuffle=function(t){for(let e=t.length-1;e>0;e--){let s=Math.floor(Math.random()*(e+1));[t[e],t[s]]=[t[s],t[e]]}return t};class IsolationTree{constructor(){this._tree=new Tree({})}get c(){const t=this._n;return 2*Math.log(t-1)+.5772156649-2*(t-1)/t}_separate(t){const e=t.length;if(e<=1)return;const s=[],r=[];for(let h=0;h<t[0].length;h++){let n=1/0,o=-1/0;for(let s=0;s<e;s++)n=Math.min(n,t[s][h]),o=Math.max(o,t[s][h]);n<o&&(r.push([n,o]),s.push(h))}if(0===s.length)return;const h=Math.floor(Math.random()*s.length);return[s[h],Math.random()*(r[h][1]-r[h][0])+r[h][0]]}fit(t){this._n=t.length;const e=[[this._tree,t]];for(;e.length>0;){const[t,s]=e.pop();if(t.isLeaf()){const e=this._separate(s);if(!e)continue;const[r,h]=e;t.value.feature=r,t.value.threshold=h,t.push({}),t.push({})}const r=[],h=[];for(let e=0;e<s.length;e++)s[e][t.value.feature]<=t.value.threshold?r.push(s[e]):h.push(s[e]);e.push([t.at(0),r]),e.push([t.at(1),h])}}depth(t){return t.map((t=>{let e=this._tree,s=0;for(;!e.isLeaf();)e=t[e.value.feature]<=e.value.threshold?e.at(0):e.at(1),s++;return s}))}}export default class IsolationForest{constructor(t=100,e=.8){this._tree_num=t,this._rate=e,this._trees=[]}fit(t){this._trees=[];const e=Math.ceil(t.length*this._rate),s=[];for(let e=0;e<t.length;s.push(e++));for(let r=0;r<this._tree_num;r++){shuffle(s);const r=[];for(let h=0;h<e;h++)r.push(t[s[h]]);const h=new IsolationTree;h.fit(r),this._trees.push(h)}}predict(t){const e=t.length,s=this._trees.map((e=>e.depth(t))),r=this._trees.reduce(((t,e)=>t+e.c),0)/this._trees.length,h=[];for(let t=0;t<e;t++){let e=0;for(let r=0;r<s.length;r++)e+=s[r][t];e/=s.length,h.push(2**(-e/r))}return h}}