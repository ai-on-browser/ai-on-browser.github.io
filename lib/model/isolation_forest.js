import Tree from"../util/tree.js";const shuffle=function(t){for(let e=t.length-1;e>0;e--){let r=Math.floor(Math.random()*(e+1));[t[e],t[r]]=[t[r],t[e]]}return t};class IsolationTree{constructor(){this._tree=new Tree({})}get c(){const t=this._n;return 2*Math.log(t-1)+.5772156649-2*(t-1)/t}_separate(t){const e=t.length;if(e<=1)return;const r=[],s=[];for(let h=0;h<t[0].length;h++){let n=1/0,o=-1/0;for(let r=0;r<e;r++)n=Math.min(n,t[r][h]),o=Math.max(o,t[r][h]);n<o&&(s.push([n,o]),r.push(h))}if(0===r.length)return;const h=Math.floor(Math.random()*r.length);return[r[h],Math.random()*(s[h][1]-s[h][0])+s[h][0]]}fit(t){this._n=t.length;const e=[[this._tree,t]];for(;e.length>0;){const[t,r]=e.pop();if(t.isLeaf()){const e=this._separate(r);if(!e)continue;const[s,h]=e;t.value.feature=s,t.value.threshold=h,t.push({}),t.push({})}const s=[],h=[];for(let e=0;e<r.length;e++)r[e][t.value.feature]<=t.value.threshold?s.push(r[e]):h.push(r[e]);e.push([t.at(0),s]),e.push([t.at(1),h])}}depth(t){return t.map((t=>{let e=this._tree,r=0;for(;!e.isLeaf();)e=t[e.value.feature]<=e.value.threshold?e.at(0):e.at(1),r++;return r}))}}export default class IsolationForest{constructor(t=100,e=.8){this._tree_num=t,this._rate=e,this._trees=[]}fit(t){this._trees=[];const e=Math.ceil(t.length*this._rate),r=[];for(let e=0;e<t.length;r.push(e++));for(let s=0;s<this._tree_num;s++){shuffle(r);const s=[];for(let h=0;h<e;h++)s.push(t[r[h]]);const h=new IsolationTree;h.fit(s),this._trees.push(h)}}predict(t){const e=t.length,r=this._trees.map((e=>e.depth(t))),s=this._trees.reduce(((t,e)=>t+e.c),0)/this._trees.length,h=[];for(let t=0;t<e;t++){let e=0;for(let s=0;s<r.length;s++)e+=r[s][t];e/=r.length,h.push(2**(-e/s))}return h}}