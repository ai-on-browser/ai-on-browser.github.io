var a=Object.defineProperty;var f=(o,i)=>a(o,"name",{value:i,configurable:!0});export class LVQCluster{static{f(this,"LVQCluster")}constructor(i){this._k=i,this._w=null}_distance(i,e){return Math.sqrt(i.reduce((s,t,h)=>s+(t-e[h])**2,0))}_nearest(i){let e=1/0,s=-1;for(let t=0;t<this._w.length;t++){const h=this._distance(i,this._w[t]);h<e&&(e=h,s=t)}return s}_init(i){const e=i.length,s=[];for(let t=0;t<this._k;t++)s.push(Math.floor(Math.random()*(e-t)));for(let t=this._k-1;t>=0;t--)for(let h=this._k-1;h>t;h--)s[t]<=s[h]&&s[h]++;this._w=[];for(let t=0;t<this._k;t++)this._w[t]=i[s[t]]}fit(i,e=.1){this._w||this._init(i);for(let s=0;s<i.length;s++){const t=this._nearest(i[s]);this._w[t]=this._w[t].map((h,n)=>h+e*(i[s][n]-h))}}predict(i){if(this._w===null)throw new Error("Call fit before predict.");return i.map(e=>this._nearest(e))}}export class LVQClassifier{static{f(this,"LVQClassifier")}constructor(i){this._m=null,this._c=[],this._type=i,this._w=.2}_distance(i,e){return Math.sqrt(i.reduce((s,t,h)=>s+(t-e[h])**2,0))}_nears(i){const e=[];for(let s=0;s<this._m.length;s++){const t=this._distance(i,this._m[s]);let h=0;for(;h<e.length&&!(t<e[h].d);h++);e.splice(h,0,{d:t,c:this._c[s],i:s})}return e}_init(i,e){const s=i.length;this._c=[...new Set(e)],this._m=[];for(let t=0;t<s;t++){const h=this._c.indexOf(e[t]);this._m[h]||(this._m[h]=i[t].concat())}}fit(i,e,s=.1){this._m||this._init(i,e);for(let t=0;t<i.length;t++)if(this._type===1){const h=this._nears(i[t])[0];e[t]===h.c?this._m[h.i]=this._m[h.i].map((n,r)=>n+s*(i[t][r]-n)):this._m[h.i]=this._m[h.i].map((n,r)=>n-s*(i[t][r]-n))}else if(this._type===2){const h=this._nears(i[t]),n=h.find(_=>_.c===e[t]),r=h.find(_=>_.c!==e[t]),c=(1-this._w)/(1+this._w);Math.min(n.d/r.d,r.d/n.d)>c&&(this._m[n.i]=this._m[n.i].map((_,m)=>_+s*(i[t][m]-_)),this._m[r.i]=this._m[r.i].map((_,m)=>_-s*(i[t][m]-_)))}else if(this._type===3){const h=this._nears(i[t]),n=h[0],r=h[1];if(n.c===e[t]&&r.c===e[t])this._m[n.i]=this._m[n.i].map((c,_)=>c+s*(i[t][_]-c)),this._m[r.i]=this._m[r.i].map((c,_)=>c+s*(i[t][_]-c));else if(n.c!==e[t]&&r.c===e[t]){const c=(1-this._w)/(1+this._w);Math.min(r.d/n.d,n.d/r.d)>c&&(this._m[r.i]=this._m[r.i].map((_,m)=>_+s*(i[t][m]-_)),this._m[n.i]=this._m[n.i].map((_,m)=>_-s*(i[t][m]-_)))}}}predict(i){if(this._m===null)throw new Error("Call fit before predict.");return i.map(e=>this._nears(e)[0].c)}}
