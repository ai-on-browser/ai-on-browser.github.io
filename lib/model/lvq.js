export class LVQCluster{constructor(t){this._k=t,this._w=null}_distance(t,i){return Math.sqrt(t.reduce(((t,s,h)=>t+(s-i[h])**2),0))}_nearest(t){let i=1/0,s=-1;for(let h=0;h<this._w.length;h++){const e=this._distance(t,this._w[h]);e<i&&(i=e,s=h)}return s}_init(t){const i=t.length,s=[];for(let t=0;t<this._k;t++)s.push(Math.floor(Math.random()*(i-t)));for(let t=this._k-1;t>=0;t--)for(let i=this._k-1;i>t;i--)s[t]<=s[i]&&s[i]++;this._w=[];for(let i=0;i<this._k;i++)this._w[i]=t[s[i]]}fit(t,i=.1){this._w||this._init(t);for(let s=0;s<t.length;s++){const h=this._nearest(t[s]);this._w[h]=this._w[h].map(((h,e)=>h+i*(t[s][e]-h)))}}predict(t){if(null===this._w)throw new Error("Call fit before predict.");return t.map((t=>this._nearest(t)))}}export class LVQClassifier{constructor(t){this._m=null,this._c=[],this._type=t,this._w=.2}_distance(t,i){return Math.sqrt(t.reduce(((t,s,h)=>t+(s-i[h])**2),0))}_nears(t){const i=[];for(let s=0;s<this._m.length;s++){const h=this._distance(t,this._m[s]);let e=0;for(;e<i.length&&!(h<i[e].d);e++);i.splice(e,0,{d:h,c:this._c[s],i:s})}return i}_init(t,i){const s=t.length;this._c=[...new Set(i)],this._m=[];for(let h=0;h<s;h++){const s=this._c.indexOf(i[h]);this._m[s]||(this._m[s]=t[h].concat())}}fit(t,i,s=.1){this._m||this._init(t,i);for(let h=0;h<t.length;h++)if(1===this._type){const e=this._nears(t[h])[0];i[h]===e.c?this._m[e.i]=this._m[e.i].map(((i,e)=>i+s*(t[h][e]-i))):this._m[e.i]=this._m[e.i].map(((i,e)=>i-s*(t[h][e]-i)))}else if(2===this._type){const e=this._nears(t[h]),_=e.find((t=>t.c===i[h])),r=e.find((t=>t.c!==i[h])),n=(1-this._w)/(1+this._w);Math.min(_.d/r.d,r.d/_.d)>n&&(this._m[_.i]=this._m[_.i].map(((i,e)=>i+s*(t[h][e]-i))),this._m[r.i]=this._m[r.i].map(((i,e)=>i-s*(t[h][e]-i))))}else if(3===this._type){const e=this._nears(t[h]),_=e[0],r=e[1];if(_.c===i[h]&&r.c===i[h])this._m[_.i]=this._m[_.i].map(((i,e)=>i+s*(t[h][e]-i))),this._m[r.i]=this._m[r.i].map(((i,e)=>i+s*(t[h][e]-i)));else if(_.c!==i[h]&&r.c===i[h]){const i=(1-this._w)/(1+this._w);Math.min(r.d/_.d,_.d/r.d)>i&&(this._m[r.i]=this._m[r.i].map(((i,e)=>i+s*(t[h][e]-i))),this._m[_.i]=this._m[_.i].map(((i,e)=>i-s*(t[h][e]-i))))}}}predict(t){if(null===this._m)throw new Error("Call fit before predict.");return t.map((t=>this._nears(t)[0].c))}}