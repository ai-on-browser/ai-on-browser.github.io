var p=Object.defineProperty;var x=(_,h)=>p(_,"name",{value:h,configurable:!0});export default class k{static{x(this,"HDBSCAN")}constructor(h=5,r=5,a="euclid"){switch(this._minClusterSize=h,this._minPts=r,this._metric=a,this._metric){case"euclid":this._d=(n,d)=>Math.sqrt(n.reduce((s,f,u)=>s+(f-d[u])**2,0));break;case"manhattan":this._d=(n,d)=>n.reduce((s,f,u)=>s+Math.abs(f-d[u]),0);break;case"chebyshev":this._d=(n,d)=>Math.max(...n.map((s,f)=>Math.abs(s-d[f])));break}}get size(){if(!this._lastResult)return 0;const h=new Set;for(let r=0;r<this._lastResult.length;r++)this._lastResult[r]>=0&&h.add(this._lastResult[r]);return h.size}predict(h){const r=h.length,a=[],n=[];for(let t=0;t<r;t++)a[t]=[],n[t]=[];const d=[];for(let t=0;t<r;t++){a[t][t]=0;for(let i=t+1;i<r;i++)a[t][i]=a[i][t]=this._d(h[t],h[i]);const e=a[t].concat();e.sort((i,c)=>i-c),d[t]=e[this._minPts]}for(let t=0;t<r;t++){n[t][t]=0;for(let e=t+1;e<r;e++)n[t][e]=n[e][t]=Math.max(d[t],d[e],a[t][e])}const s=[];for(let t=0;t<r;t++)s[t]={index:[t],distance:0,children:[]};for(;s.length>1;){let t=-1,e=-1,i=1/0;const c=s.length;for(let l=0;l<c;l++)for(let b=l+1;b<c;b++)n[l][b]<i&&(t=l,e=b,i=n[l][b]);for(let l=0;l<c;l++)l!=e&&l!=t&&(n[t][l]=n[l][t]=Math.min(n[t][l],n[e][l]),n[l].splice(e,1));n[t].splice(e,1),n.splice(e,1),s[t]={distance:i,index:[...s[t].index,...s[e].index],children:[s[t],s[e]]},s.splice(e,1)}const f={},u=[[s[0],f]],o=[];for(;u.length>0;){let[t,e]=u.pop();for(e.index=t.index,e.lbirth=1/t.distance,e.stability=0,e.children=[],o.push(e);;){for(let i=t.children.length-1;i>=0;i--){const c=t.children[i];c.index.length<this._minClusterSize&&(t.children.splice(i,1),c.distance>0&&(e.stability+=c.index.length*(1/c.distance-e.lbirth)))}if(t.children.length===0)break;if(t.children.length===1)t=t.children[0];else{for(let i=0;i<t.children.length;i++){const c={};u.push([t.children[i],e.children[i]=c])}break}}}for(let t=o.length-1;t>=0;t--){const e=o[t];if(e.children.length<=0)continue;let i=0;for(let c=0;c<e.children.length;c++){const l=e.children[c];e.stability+=l.index.length*(l.lbirth-e.lbirth),i+=l.stability}e.stability>i?e.isCluster=!0:e.stability=i}let m=0;const g=Array(r).fill(-1);for(let t=0;t<o.length;t++)if(o[t].isCluster){for(let e=0;e<o[t].index.length;e++)g[o[t].index[e]]<0&&(g[o[t].index[e]]=m);m++}return this._lastResult=g.concat(),g}}
