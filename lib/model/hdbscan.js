import Tree from"../util/tree.js";export default class HDBSCAN{constructor(t=5,e=5,l="euclid"){switch(this._minClusterSize=t,this._minPts=e,this._metric=l,this._metric){case"euclid":this._d=(t,e)=>Math.sqrt(t.reduce(((t,l,i)=>t+(l-e[i])**2),0));break;case"manhattan":this._d=(t,e)=>t.reduce(((t,l,i)=>t+Math.abs(l-e[i])),0);break;case"chebyshev":this._d=(t,e)=>Math.max(...t.map(((t,l)=>Math.abs(t-e[l]))))}}get size(){if(!this._lastResult)return 0;const t=new Set;for(let e=0;e<this._lastResult.length;e++)this._lastResult[e]>=0&&t.add(this._lastResult[e]);return t.size}predict(t){const e=t.length,l=[],i=[];for(let t=0;t<e;t++)l[t]=[],i[t]=[];const s=[];for(let i=0;i<e;i++){l[i][i]=0;for(let s=i+1;s<e;s++)l[i][s]=l[s][i]=this._d(t[i],t[s]);const n=l[i].concat();n.sort(((t,e)=>t-e)),s[i]=n[this._minPts]}for(let t=0;t<e;t++){i[t][t]=0;for(let n=t+1;n<e;n++)i[t][n]=i[n][t]=Math.max(s[t],s[n],l[t][n])}const n=[];for(let l=0;l<e;l++)n[l]=new Tree({point:t[l],index:[l],distance:0});for(;n.length>1;){let t=-1,e=-1,l=1/0;const s=n.length;for(let n=0;n<s;n++)for(let r=n+1;r<s;r++)i[n][r]<l&&(t=n,e=r,l=i[n][r]);for(let l=0;l<s;l++)l!=e&&l!=t&&(i[t][l]=i[l][t]=Math.min(i[t][l],i[e][l]),i[l].splice(e,1));i[t].splice(e,1),i.splice(e,1),n[t]=new Tree({distance:l,index:[...n[t].value.index,...n[e].value.index]},[n[t],n[e]]),n.splice(e,1)}const r=[[n[0],{}]],a=[];for(;r.length>0;){let[t,e]=r.pop();for(e.index=t.value.index,e.lbirth=1/t.value.distance,e.stability=0,e.children=[],a.push(e);;){for(let l=t.length-1;l>=0;l--){const i=t.at(l);i.value.index.length<this._minClusterSize&&(t.removeAt(l),i.value.distance>0&&(e.stability+=i.value.index.length*(1/i.value.distance-e.lbirth)))}if(0===t.length)break;if(1!==t.length){for(let l=0;l<t.length;l++){const i={};r.push([t.at(l),e.children[l]=i])}break}t=t.at(0)}}for(let t=a.length-1;t>=0;t--){const e=a[t];if(e.children.length<=0)continue;let l=0;for(let t=0;t<e.children.length;t++){const i=e.children[t];e.stability+=i.index.length*(i.lbirth-e.lbirth),l+=i.stability}e.stability>l?e.isCluster=!0:e.stability=l}let h=0;const c=Array(e).fill(-1);for(let t=0;t<a.length;t++)if(a[t].isCluster){for(let e=0;e<a[t].index.length;e++)c[a[t].index[e]]<0&&(c[a[t].index[e]]=h);h++}return this._lastResult=c.concat(),c}}