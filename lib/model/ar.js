import Matrix from"../util/matrix.js";export default class AR{constructor(t,s="lsm"){this._p=t,this._method=s}fit(t){"lsm"===this._method?this._lsm(t):"yuleWalker"===this._method?this._yuleWalker(t):"levinson"===this._method?this._levinson(t):"householder"===this._method&&this._householder(t)}_lsm(t){const s=t.length,i=new Matrix(s-this._p,1,t.slice(this._p)),e=new Matrix(s-this._p,this._p);for(let i=0;i<s-this._p;i++)for(let s=0;s<this._p;s++)e.set(i,s,t[i+this._p-1-s]);const h=e.tDot(e);this._phi=h.solve(e.t).dot(i)}_yuleWalker(t){const s=t.length,i=new Matrix(this._p,1),e=new Matrix(this._p,this._p),h=t.reduce(((t,s)=>t+s),0)/s;for(let o=0;o<=this._p;o++){let l=0;for(let i=0;i<s-o;i++)l+=(t[i]-h)*(t[i+o]-h);if(l/=s-o,o>0&&i.set(o-1,0,l),o<this._p)for(let t=0;t<this._p-o;t++)e.set(t,o+t,l),e.set(o+t,t,l)}this._phi=e.solve(i),this._variance=e.at(0,0)-this._phi.tDot(i).toScaler()}_levinson(t){const s=t.length,i=[],e=t.reduce(((t,s)=>t+s),0)/s;for(let h=0;h<=this._p;h++){let o=0;for(let i=0;i<s-h;i++)o+=(t[i]-e)*(t[i+h]-e);o/=s-h,i[h]=o}const h=[];h[0]=i[0];let o=[];for(let t=0;t<this._p;t++){const s=[];s[t]=i[t+1];for(let e=0;e<t;e++)s[t]-=o[e]*i[t-e];s[t]/=h[t];for(let i=0;i<t;i++)s[i]=o[i]-s[t]*o[t-i-1];h[t+1]=h[t]*(1-s[t]**2),o=s}this._phi=Matrix.fromArray(o)}_householder(t){const s=t.length,i=new Matrix(s-this._p,this._p+1);for(let e=0;e<s-this._p;e++){for(let s=0;s<this._p;s++)i.set(e,s,t[e+this._p-1-s]);i.set(e,this._p,t[e+this._p])}const[,e]=i.qr(),h=e.block(0,0,this._p,this._p),o=e.block(0,this._p,this._p,this._p+1);this._phi=h.solveUpperTriangular(o)}predict(t,s){const i=[],e=t.slice(t.length-this._p);e.reverse();for(let t=0;t<s;t++){const t=new Matrix(1,this._p,e).dot(this._phi).toScaler();i.push(t),e.unshift(t),e.pop()}return i}}