import{Matrix}from"../util/math.js";export default class AR{constructor(t){this._p=t}fit(t){this._lsm(t)}_lsm(t){const s=t.length,e=new Matrix(s-this._p,1,t.slice(this._p)),i=new Matrix(s-this._p,this._p);for(let e=0;e<s-this._p;e++)for(let s=0;s<this._p;s++)i.set(e,s,t[e+this._p-1-s]);const h=i.tDot(i);this._phi=h.solve(i.t).dot(e)}_yuleWalker(t){const s=t.length,e=new Matrix(this._p,1),i=new Matrix(this._p,this._p),h=t.reduce(((t,s)=>t+s),0)/s;for(let r=0;r<=this._p;r++){let o=0;for(let e=0;e<s-r;e++)o+=(t[e]-h)*(t[e+r]-h);if(o/=s-r,r>0&&e.set(r-1,0,o),r<this._p)for(let t=0;t<this._p-r;t++)i.set(t,r+t,o),i.set(r+t,t,o)}this._phi=i.solve(e),this._variance=i.at(0,0)-this._phi.tDot(e).value[0]}_levinson(t){const s=t.length,e=[],i=t.reduce(((t,s)=>t+s),0)/s;for(let h=0;h<=this._p;h++){let r=0;for(let e=0;e<s-h;e++)r+=(t[e]-i)*(t[e+h]-i);r/=s-h,e[h]=r}const h=[];h[0]=e[0];let r=[];for(let t=0;t<this._p;t++){const s=[];s[t]=e[t+1];for(let i=0;i<t;i++)s[t]-=r[i]*e[t-i];s[t]/=h[t];for(let e=0;e<t;e++)s[e]=r[e]-s[t]*r[t-e-1];h[t+1]=h[t]*(1-s[t]**2),r=s}this._phi=Matrix.fromArray(r)}predict(t,s){const e=[],i=t.slice(t.length-this._p);i.reverse();for(let t=0;t<s;t++){const t=new Matrix(1,this._p,i).dot(this._phi).value[0];e.push(t),i.unshift(t),i.pop()}return e}}