import Matrix from"../util/matrix.js";export default class AR{constructor(t){this._p=t}fit(t){this._lsm(t)}_lsm(t){const s=t.length,i=new Matrix(s-this._p,1,t.slice(this._p)),e=new Matrix(s-this._p,this._p);for(let i=0;i<s-this._p;i++)for(let s=0;s<this._p;s++)e.set(i,s,t[i+this._p-1-s]);const h=e.tDot(e);this._phi=h.solve(e.t).dot(i)}_yuleWalker(t){const s=t.length,i=new Matrix(this._p,1),e=new Matrix(this._p,this._p),h=t.reduce(((t,s)=>t+s),0)/s;for(let r=0;r<=this._p;r++){let o=0;for(let i=0;i<s-r;i++)o+=(t[i]-h)*(t[i+r]-h);if(o/=s-r,r>0&&i.set(r-1,0,o),r<this._p)for(let t=0;t<this._p-r;t++)e.set(t,r+t,o),e.set(r+t,t,o)}this._phi=e.solve(i),this._variance=e.at(0,0)-this._phi.tDot(i).toScaler()}_levinson(t){const s=t.length,i=[],e=t.reduce(((t,s)=>t+s),0)/s;for(let h=0;h<=this._p;h++){let r=0;for(let i=0;i<s-h;i++)r+=(t[i]-e)*(t[i+h]-e);r/=s-h,i[h]=r}const h=[];h[0]=i[0];let r=[];for(let t=0;t<this._p;t++){const s=[];s[t]=i[t+1];for(let e=0;e<t;e++)s[t]-=r[e]*i[t-e];s[t]/=h[t];for(let i=0;i<t;i++)s[i]=r[i]-s[t]*r[t-i-1];h[t+1]=h[t]*(1-s[t]**2),r=s}this._phi=Matrix.fromArray(r)}_householder(t){const s=t.length,i=new Matrix(s-this._p,this._p+1);for(let e=0;e<s-this._p;e++){for(let s=0;s<this._p;s++)i.set(e,s,t[e+this._p-1-s]);i.set(e,this._p,t[e+this._p])}const[,e]=i.qr(),h=e.block(0,0,this._p,this._p),r=e.block(0,this._p,this._p,this._p+1);this._phi=h.solveUpperTriangular(r)}predict(t,s){const i=[],e=t.slice(t.length-this._p);e.reverse();for(let t=0;t<s;t++){const t=new Matrix(1,this._p,e).dot(this._phi).toScaler();i.push(t),e.unshift(t),e.pop()}return i}}