import{Matrix}from"../util/math.js";export default class AR{constructor(t){this._p=t}fit(t){this._lsm(t)}_lsm(t){const s=t.length,i=new Matrix(s-this._p,1,t.slice(this._p)),e=new Matrix(s-this._p,this._p);for(let i=0;i<s-this._p;i++)for(let s=0;s<this._p;s++)e.set(i,s,t[i+this._p-1-s]);const h=e.tDot(e);this._phi=h.solve(e.t).dot(i)}_yuleWalker(t){const s=t.length,i=new Matrix(this._p,1),e=new Matrix(this._p,this._p),h=t.reduce(((t,s)=>t+s),0)/s;for(let p=0;p<=this._p;p++){let r=0;for(let i=0;i<s-p;i++)r+=(t[i]-h)*(t[i+p]-h);if(r/=s-p,p>0&&i.set(p-1,0,r),p<this._p)for(let t=0;t<this._p-p;t++)e.set(t,p+t,r),e.set(p+t,t,r)}this._phi=e.solve(i),this._variance=e.at(0,0)-this._phi.tDot(i).value[0]}_levinson(t){const s=t.length,i=[],e=t.reduce(((t,s)=>t+s),0)/s;for(let h=0;h<=this._p;h++){let p=0;for(let i=0;i<s-h;i++)p+=(t[i]-e)*(t[i+h]-e);p/=s-h,i[h]=p}const h=[];h[0]=i[0];let p=[];for(let t=0;t<this._p;t++){const s=[];s[t]=i[t+1];for(let e=0;e<t;e++)s[t]-=p[e]*i[t-e];s[t]/=h[t];for(let i=0;i<t;i++)s[i]=p[i]-s[t]*p[t-i-1];h[t+1]=h[t]*(1-s[t]**2),p=s}this._phi=Matrix.fromArray(p)}_householder(t){const s=t.length,i=new Matrix(s-this._p,this._p+1);for(let e=0;e<s-this._p;e++){for(let s=0;s<this._p;s++)i.set(e,s,t[e+this._p-1-s]);i.set(e,this._p,t[e+this._p])}const[e,h]=i.qr(),p=h.block(0,0,this._p,this._p),r=h.block(0,this._p,this._p,this._p+1);this._phi=p.solveUpperTriangular(r)}predict(t,s){const i=[],e=t.slice(t.length-this._p);e.reverse();for(let t=0;t<s;t++){const t=new Matrix(1,this._p,e).dot(this._phi).value[0];i.push(t),e.unshift(t),e.pop()}return i}}