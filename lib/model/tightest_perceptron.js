const logGamma=t=>{let e=0;if(Number.isInteger(t))for(let s=2;s<t;s++)e+=Math.log(s);else if(Number.isInteger(t-.5)){const s=t-.5;e=Math.log(Math.sqrt(Math.PI))-Math.log(2)*s;for(let t=2*s-1;t>0;t-=2)e+=Math.log(t)}else if(t<.5)e=Math.log(Math.PI)-Math.log(Math.sin(Math.PI*t))-logGamma(1-t);else{const s=[676.5203681218851,-1259.1392167224028,771.3234287776531,-176.6150291621406,12.507343278686905,-.13857109526572012,9984369578019572e-21,1.5056327351493116e-7];t-=1,e=.9999999999998099;for(let h=0;h<s.length;h++)e+=s[h]/(t+h+1);const h=t+s.length-.5;e=Math.log(Math.sqrt(2*Math.PI))+Math.log(h)*(t+.5)-h+Math.log(e)}return e},logBeta=(t,e)=>logGamma(t)+logGamma(e)-logGamma(t+e),hypergeometric=(t,e,s,h)=>{let a=1,i=0;const l=Math.log(h);for(let h=0;h<1e3;h++){i=i+l+Math.log(t+h)+Math.log(e+h)-Math.log(s+h)-Math.log(1+h);const o=Math.exp(i);if(a+=o,Math.abs(o/a)<1e-14)break}return a},logIncompleteBeta=(t,e,s)=>{if(1===s)return Math.log(t)*e-Math.log(e);if(1===e)return Math.log(1-(1-t)**s)-Math.log(s);if(.5===e&&0===s)return Math.log(2*Math.atanh(Math.sqrt(t)));if(.5===e&&.5===s)return Math.log(2*Math.asin(Math.sqrt(t)));if(Number.isInteger(s)){const h=t**e;let a=h/e;for(let i=1;i<s;i++)a=(i*a+h*(1-t)**i)/(e+i);return Math.log(a)}if(Number.isInteger(e)){const h=(1-t)**s;let a=(1-h)/s;for(let i=1;i<e;i++)a=(i*a-t**i*h)/(i+s);return Math.log(a)}return e<s?Math.log(Math.exp(logBeta(e,s))-Math.exp(logIncompleteBeta(1-t,s,e))):Math.log(t)*e-Math.log(e)+s*Math.log(1-t)+Math.log(hypergeometric(e+s,1,e+1,t))},regularizedIncompleteBeta=(t,e,s)=>0===t?0:1===t?1:1===s?t**e:1===e?1-(1-t)**s:e<s?1-regularizedIncompleteBeta(1-t,s,e):Math.exp(logIncompleteBeta(t,e,s)-logBeta(e,s));export default class TightestPerceptron{constructor(t=10,e="gaussian",s="hinge"){if(this._b=t,"function"==typeof e)this._kernel=e;else switch(e){case"gaussian":this._s=1,this._kernel=(t,e)=>Math.exp(-(t.reduce(((t,s,h)=>t+(s-e[h])**2),0)**2)/this._s**2);break;case"polynomial":this._d=2,this._kernel=(t,e)=>(1+t.reduce(((t,s,h)=>t+s*e[h])))**this._d}"hinge"===s?(this._accuracyLossP=t=>Math.max(0,1-t),this._accuracyLossN=t=>Math.max(0,1+t)):(this._accuracyLossP=t=>t<0?1:0,this._accuracyLossN=t=>t<0?0:1),this._ap=1,this._an=1}init(t,e){this._x=t,this._y=e,this._sv=[]}fit(){for(let t=0;t<this._x.length;t++){let e=0;for(let s=0;s<this._sv.length;s++){const h=this._sv[s];e+=h.y*this._kernel(this._x[t],h.x)}if(e*this._y[t]<=0){if(1===this._y[t]?this._sv.push({x:this._x[t],y:this._y[t],cp:1,cn:0}):this._sv.push({x:this._x[t],y:this._y[t],cp:0,cn:1}),this._sv.length>this._b){let t=1/0,e=-1;for(let s=0;s<this._sv.length;s++){let h=0;for(let t=0;t<this._sv.length;t++){let e=0;for(let h=0;h<this._sv.length;h++){if(h===s)continue;const a=this._sv[h];e+=a.y*this._kernel(this._sv[t].x,a.x)}const a=this._accuracyLossP(e),i=this._accuracyLossN(e),l=1-regularizedIncompleteBeta(.5,this._sv[t].cp+this._ap,this._sv[t].cn+this._an);h+=l*a+(1-l)*i}h/=this._sv.length,h<t&&(t=h,e=s)}const s=this._sv.splice(e,1)[0];this._updateSummary(s.x,s.cp,s.cn)}}else 1===this._y[t]?this._updateSummary(this._x[t],1,0):this._updateSummary(this._x[t],0,1)}}_updateSummary(t,e,s){if(0===this._sv.length)return;let h=1/0,a=-1;for(let e=0;e<this._sv.length;e++){const s=this._sv[e].x.reduce(((e,s,h)=>e+(s-t[h])**2),0);s<h&&(h=s,a=e)}const i=this._kernel(t,this._sv[a].x);this._sv[a].cp+=e*i,this._sv[a].cn+=s*i}predict(t){const e=[];for(let s=0;s<t.length;s++){let h=0;for(let e=0;e<this._sv.length;e++){const a=this._sv[e];h+=a.y*this._kernel(t[s],a.x)}e[s]=h<0?-1:1}return e}}