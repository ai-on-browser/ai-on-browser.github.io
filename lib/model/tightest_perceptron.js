const logGamma=t=>{let s=0;if(Number.isInteger(t))for(let e=2;e<t;e++)s+=Math.log(e);else if(Number.isInteger(t-.5)){const e=t-.5;s=Math.log(Math.sqrt(Math.PI))-Math.log(2)*e;for(let t=2*e-1;t>0;t-=2)s+=Math.log(t)}else if(t<.5)s=Math.log(Math.PI)-Math.log(Math.sin(Math.PI*t))-logGamma(1-t);else{const e=[676.5203681218851,-1259.1392167224028,771.3234287776531,-176.6150291621406,12.507343278686905,-.13857109526572012,9984369578019572e-21,1.5056327351493116e-7];t-=1,s=.9999999999998099;for(let h=0;h<e.length;h++)s+=e[h]/(t+h+1);const h=t+e.length-.5;s=Math.log(Math.sqrt(2*Math.PI))+Math.log(h)*(t+.5)-h+Math.log(s)}return s},beta=(t,s)=>Math.exp(logGamma(t)+logGamma(s)-logGamma(t+s)),hypergeometric=(t,s,e,h)=>{let i=1,a=0;const r=Math.log(h);for(let h=0;h<1e3;h++){a=a+r+Math.log(t+h)+Math.log(s+h)-Math.log(e+h)-Math.log(1+h);const l=Math.exp(a);if(i+=l,Math.abs(l/i)<1e-14)break}return i},incompleteBeta=(t,s,e)=>{if(1===e)return t**s/s;if(1===s)return(1-(1-t)**e)/e;if(.5===s&&0===e)return 2*Math.atanh(Math.sqrt(t));if(.5===s&&.5===e)return 2*Math.asin(Math.sqrt(t));if(Number.isInteger(e)){const h=t**s;let i=h/s;for(let a=1;a<e;a++)i=(a*i+h*(1-t)**a)/(s+a);return i}if(Number.isInteger(s)){const h=(1-t)**e;let i=(1-h)/e;for(let a=1;a<s;a++)i=(a*i-t**a*h)/(a+e);return i}return t**s/s*hypergeometric(s,1-e,s+1,t)},regularizedIncompleteBeta=(t,s,e)=>{return 0===t?0:1===t?1:1===e?t**s:1===s?1-(1-t)**e:incompleteBeta(t,s,e)/(h=s,i=e,Math.exp(logGamma(h)+logGamma(i)-logGamma(h+i)));var h,i};export default class TightestPerceptron{constructor(t=10,s="gaussian",e="hinge"){if(this._b=t,"function"==typeof s)this._kernel=s;else switch(s){case"gaussian":this._s=1,this._kernel=(t,s)=>Math.exp(-(t.reduce(((t,e,h)=>t+(e-s[h])**2),0)**2)/this._s**2);break;case"polynomial":this._d=2,this._kernel=(t,s)=>(1+t.reduce(((t,e,h)=>t+e*s[h])))**this._d}"hinge"===e?(this._accuracyLossP=t=>Math.max(0,1-t),this._accuracyLossN=t=>Math.max(0,1+t)):(this._accuracyLossP=t=>t<0?1:0,this._accuracyLossN=t=>t<0?0:1),this._ap=1,this._an=1}init(t,s){this._x=t,this._y=s,this._sv=[]}fit(){for(let a=0;a<this._x.length;a++){let r=0;for(let t=0;t<this._sv.length;t++){const s=this._sv[t];r+=s.y*this._kernel(this._x[a],s.x)}if(r*this._y[a]<=0){if(1===this._y[a]?this._sv.push({x:this._x[a],y:this._y[a],cp:1,cn:0}):this._sv.push({x:this._x[a],y:this._y[a],cp:0,cn:1}),this._sv.length>this._b){let a=1/0,r=-1;for(let l=0;l<this._sv.length;l++){let n=0;for(let a=0;a<this._sv.length;a++){let r=0;for(let t=0;t<this._sv.length;t++){if(t===l)continue;const s=this._sv[t];r+=s.y*this._kernel(this._sv[a].x,s.x)}const o=this._accuracyLossP(r),c=this._accuracyLossN(r),_=1-(t=.5,s=this._sv[a].cp+this._ap,e=this._sv[a].cn+this._an,h=void 0,i=void 0,0===t?0:1===t?1:1===e?t**s:1===s?1-(1-t)**e:incompleteBeta(t,s,e)/(h=s,i=e,Math.exp(logGamma(h)+logGamma(i)-logGamma(h+i))));n+=_*o+(1-_)*c}n/=this._sv.length,n<a&&(a=n,r=l)}const l=this._sv.splice(r,1)[0];this._updateSummary(l.x,l.cp,l.cn)}}else 1===this._y[a]?this._updateSummary(this._x[a],1,0):this._updateSummary(this._x[a],0,1)}var t,s,e,h,i}_updateSummary(t,s,e){if(0===this._sv.length)return;let h=1/0,i=-1;for(let s=0;s<this._sv.length;s++){const e=this._sv[s].x.reduce(((s,e,h)=>s+(e-t[h])**2),0);e<h&&(h=e,i=s)}const a=this._kernel(t,this._sv[i].x);this._sv[i].cp+=s*a,this._sv[i].cn+=e*a}predict(t){const s=[];for(let e=0;e<t.length;e++){let h=0;for(let s=0;s<this._sv.length;s++){const i=this._sv[s];h+=i.y*this._kernel(t[e],i.x)}s[e]=h<0?-1:1}return s}}