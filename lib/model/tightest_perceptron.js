var x=Object.defineProperty;var c=(s,t)=>x(s,"name",{value:t,configurable:!0});const f=c(s=>{let t=0;if(Number.isInteger(s))for(let e=2;e<s;e++)t+=Math.log(e);else if(Number.isInteger(s-.5)){const e=s-.5;t=Math.log(Math.sqrt(Math.PI))-Math.log(2)*e;for(let i=2*e-1;i>0;i-=2)t+=Math.log(i)}else if(s<.5)t=Math.log(Math.PI)-Math.log(Math.sin(Math.PI*s))-f(1-s);else{const e=[676.5203681218851,-1259.1392167224028,771.3234287776531,-176.6150291621406,12.507343278686905,-.13857109526572012,9984369578019572e-21,15056327351493116e-23];s-=1,t=.9999999999998099;for(let h=0;h<e.length;h++)t+=e[h]/(s+h+1);const i=s+e.length-.5;t=Math.log(Math.sqrt(2*Math.PI))+Math.log(i)*(s+.5)-i+Math.log(t)}return t},"logGamma"),m=c((s,t)=>f(s)+f(t)-f(s+t),"logBeta"),I=c((s,t,e,i)=>{let h=1,l=0;const n=Math.log(i);for(let r=0;r<1e3;r++){l=l+n+Math.log(s+r)+Math.log(t+r)-Math.log(e+r)-Math.log(1+r);const o=Math.exp(l);if(h+=o,Math.abs(o/h)<1e-14)break}return h},"hypergeometric"),v=c((s,t,e)=>{if(e===1)return Math.log(s)*t-Math.log(t);if(t===1)return Math.log(1-(1-s)**e)-Math.log(e);if(t===.5&&e===0)return Math.log(2*Math.atanh(Math.sqrt(s)));if(t===.5&&e===.5)return Math.log(2*Math.asin(Math.sqrt(s)));if(Number.isInteger(e)){const i=s**t;let h=i/t;for(let l=1;l<e;l++)h=(l*h+i*(1-s)**l)/(t+l);return Math.log(h)}else if(Number.isInteger(t)){const i=(1-s)**e;let h=(1-i)/e;for(let l=1;l<t;l++)h=(l*h-s**l*i)/(l+e);return Math.log(h)}return t<e?Math.log(Math.exp(m(t,e))-Math.exp(v(1-s,e,t))):Math.log(s)*t-Math.log(t)+e*Math.log(1-s)+Math.log(I(t+e,1,t+1,s))},"logIncompleteBeta"),k=c((s,t,e)=>s===0?0:s===1?1:e===1?s**t:t===1?1-(1-s)**e:t<e?1-k(1-s,e,t):Math.exp(v(s,t,e)-m(t,e)),"regularizedIncompleteBeta");export default class P{static{c(this,"TightestPerceptron")}constructor(t=10,e="gaussian",i="hinge"){if(this._b=t,typeof e=="function")this._kernel=e;else switch(e){case"gaussian":this._s=1,this._kernel=(h,l)=>Math.exp(-(h.reduce((n,r,o)=>n+(r-l[o])**2,0)**2)/this._s**2);break;case"polynomial":this._d=2,this._kernel=(h,l)=>(1+h.reduce((n,r,o)=>n+r*l[o]))**this._d;break}i==="hinge"?(this._accuracyLossP=h=>Math.max(0,1-h),this._accuracyLossN=h=>Math.max(0,1+h)):(this._accuracyLossP=h=>h<0?1:0,this._accuracyLossN=h=>h<0?0:1),this._ap=1,this._an=1,this._sv=[]}fit(t,e){for(let i=0;i<t.length;i++){let h=0;for(let l=0;l<this._sv.length;l++){const n=this._sv[l];h+=n.y*this._kernel(t[i],n.x)}if(h*e[i]<=0){if(e[i]===1?this._sv.push({x:t[i],y:e[i],cp:1,cn:0}):this._sv.push({x:t[i],y:e[i],cp:0,cn:1}),this._sv.length>this._b){let l=1/0,n=-1;for(let o=0;o<this._sv.length;o++){let g=0;for(let a=0;a<this._sv.length;a++){let _=0;for(let u=0;u<this._sv.length;u++){if(u===o)continue;const p=this._sv[u];_+=p.y*this._kernel(this._sv[a].x,p.x)}const y=this._accuracyLossP(_),d=this._accuracyLossN(_),M=1-k(.5,this._sv[a].cp+this._ap,this._sv[a].cn+this._an);g+=M*y+(1-M)*d}g/=this._sv.length,g<l&&(l=g,n=o)}const r=this._sv.splice(n,1)[0];this._updateSummary(r.x,r.cp,r.cn)}}else e[i]===1?this._updateSummary(t[i],1,0):this._updateSummary(t[i],0,1)}}_updateSummary(t,e,i){if(this._sv.length===0)return;let h=1/0,l=-1;for(let r=0;r<this._sv.length;r++){const o=this._sv[r].x.reduce((g,a,_)=>g+(a-t[_])**2,0);o<h&&(h=o,l=r)}const n=this._kernel(t,this._sv[l].x);this._sv[l].cp+=e*n,this._sv[l].cn+=i*n}predict(t){const e=[];for(let i=0;i<t.length;i++){let h=0;for(let l=0;l<this._sv.length;l++){const n=this._sv[l];h+=n.y*this._kernel(t[i],n.x)}e[i]=h<0?-1:1}return e}}
