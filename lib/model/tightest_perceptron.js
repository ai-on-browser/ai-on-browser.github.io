var I=Object.defineProperty;var c=(e,t)=>I(e,"name",{value:t,configurable:!0});const f=c(e=>{let t=0;if(Number.isInteger(e))for(let s=2;s<e;s++)t+=Math.log(s);else if(Number.isInteger(e-.5)){const s=e-.5;t=Math.log(Math.sqrt(Math.PI))-Math.log(2)*s;for(let i=2*s-1;i>0;i-=2)t+=Math.log(i)}else if(e<.5)t=Math.log(Math.PI)-Math.log(Math.sin(Math.PI*e))-f(1-e);else{const s=[676.5203681218851,-1259.1392167224028,771.3234287776531,-176.6150291621406,12.507343278686905,-.13857109526572012,9984369578019572e-21,15056327351493116e-23];e-=1,t=.9999999999998099;for(let h=0;h<s.length;h++)t+=s[h]/(e+h+1);const i=e+s.length-.5;t=Math.log(Math.sqrt(2*Math.PI))+Math.log(i)*(e+.5)-i+Math.log(t)}return t},"logGamma"),m=c((e,t)=>f(e)+f(t)-f(e+t),"logBeta"),k=c((e,t,s,i)=>{let h=1,n=0;const l=Math.log(i);for(let r=0;r<1e3;r++){n=n+l+Math.log(e+r)+Math.log(t+r)-Math.log(s+r)-Math.log(1+r);const o=Math.exp(n);if(h+=o,Math.abs(o/h)<1e-14)break}return h},"hypergeometric"),v=c((e,t,s)=>{if(s===1)return Math.log(e)*t-Math.log(t);if(t===1)return Math.log(1-(1-e)**s)-Math.log(s);if(t===.5&&s===0)return Math.log(2*Math.atanh(Math.sqrt(e)));if(t===.5&&s===.5)return Math.log(2*Math.asin(Math.sqrt(e)));if(Number.isInteger(s)){const i=e**t;let h=i/t;for(let n=1;n<s;n++)h=(n*h+i*(1-e)**n)/(t+n);return Math.log(h)}else if(Number.isInteger(t)){const i=(1-e)**s;let h=(1-i)/s;for(let n=1;n<t;n++)h=(n*h-e**n*i)/(n+s);return Math.log(h)}return t<s?Math.log(Math.exp(m(t,s))-Math.exp(v(1-e,s,t))):Math.log(e)*t-Math.log(t)+s*Math.log(1-e)+Math.log(k(t+s,1,t+1,e))},"logIncompleteBeta"),y=c((e,t,s)=>e===0?0:e===1?1:s===1?e**t:t===1?1-(1-e)**s:t<s?1-y(1-e,s,t):Math.exp(v(e,t,s)-m(t,s)),"regularizedIncompleteBeta");export default class P{static{c(this,"TightestPerceptron")}constructor(t=10,s="gaussian",i="hinge"){if(this._b=t,typeof s=="function")this._kernel=s;else switch(typeof s=="string"&&(s={name:s}),s.name){case"gaussian":this._s=s.s??1,this._kernel=(h,n)=>Math.exp(-(h.reduce((l,r,o)=>l+(r-n[o])**2,0)**2)/this._s**2);break;case"polynomial":this._d=s.d??2,this._kernel=(h,n)=>(1+h.reduce((l,r,o)=>l+r*n[o]))**this._d;break}i==="hinge"?(this._accuracyLossP=h=>Math.max(0,1-h),this._accuracyLossN=h=>Math.max(0,1+h)):(this._accuracyLossP=h=>h<0?1:0,this._accuracyLossN=h=>h<0?0:1),this._ap=1,this._an=1,this._sv=[]}fit(t,s){for(let i=0;i<t.length;i++){let h=0;for(let n=0;n<this._sv.length;n++){const l=this._sv[n];h+=l.y*this._kernel(t[i],l.x)}if(h*s[i]<=0){if(s[i]===1?this._sv.push({x:t[i],y:s[i],cp:1,cn:0}):this._sv.push({x:t[i],y:s[i],cp:0,cn:1}),this._sv.length>this._b){let n=1/0,l=-1;for(let o=0;o<this._sv.length;o++){let g=0;for(let a=0;a<this._sv.length;a++){let _=0;for(let u=0;u<this._sv.length;u++){if(u===o)continue;const p=this._sv[u];_+=p.y*this._kernel(this._sv[a].x,p.x)}const d=this._accuracyLossP(_),x=this._accuracyLossN(_),M=1-y(.5,this._sv[a].cp+this._ap,this._sv[a].cn+this._an);g+=M*d+(1-M)*x}g/=this._sv.length,g<n&&(n=g,l=o)}const r=this._sv.splice(l,1)[0];this._updateSummary(r.x,r.cp,r.cn)}}else s[i]===1?this._updateSummary(t[i],1,0):this._updateSummary(t[i],0,1)}}_updateSummary(t,s,i){if(this._sv.length===0)return;let h=1/0,n=-1;for(let r=0;r<this._sv.length;r++){const o=this._sv[r].x.reduce((g,a,_)=>g+(a-t[_])**2,0);o<h&&(h=o,n=r)}const l=this._kernel(t,this._sv[n].x);this._sv[n].cp+=s*l,this._sv[n].cn+=i*l}predict(t){const s=[];for(let i=0;i<t.length;i++){let h=0;for(let n=0;n<this._sv.length;n++){const l=this._sv[n];h+=l.y*this._kernel(t[i],l.x)}s[i]=h<0?-1:1}return s}}
