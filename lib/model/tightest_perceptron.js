var d=Object.defineProperty;var a=(s,t)=>d(s,"name",{value:t,configurable:!0});const _=a(s=>{let t=0;if(Number.isInteger(s))for(let e=2;e<s;e++)t+=Math.log(e);else if(Number.isInteger(s-.5)){const e=s-.5;t=Math.log(Math.sqrt(Math.PI))-Math.log(2)*e;for(let h=2*e-1;h>0;h-=2)t+=Math.log(h)}else if(s<.5)t=Math.log(Math.PI)-Math.log(Math.sin(Math.PI*s))-_(1-s);else{const e=[676.5203681218851,-1259.1392167224028,771.3234287776531,-176.6150291621406,12.507343278686905,-.13857109526572012,9984369578019572e-21,15056327351493116e-23];s-=1,t=.9999999999998099;for(let i=0;i<e.length;i++)t+=e[i]/(s+i+1);const h=s+e.length-.5;t=Math.log(Math.sqrt(2*Math.PI))+Math.log(h)*(s+.5)-h+Math.log(t)}return t},"logGamma"),m=a((s,t)=>_(s)+_(t)-_(s+t),"logBeta"),k=a((s,t,e,h)=>{let i=1,n=0;const r=Math.log(h);for(let l=0;l<1e3;l++){n=n+r+Math.log(s+l)+Math.log(t+l)-Math.log(e+l)-Math.log(1+l);const o=Math.exp(n);if(i+=o,Math.abs(o/i)<1e-14)break}return i},"hypergeometric"),v=a((s,t,e)=>{if(e===1)return Math.log(s)*t-Math.log(t);if(t===1)return Math.log(1-(1-s)**e)-Math.log(e);if(t===.5&&e===0)return Math.log(2*Math.atanh(Math.sqrt(s)));if(t===.5&&e===.5)return Math.log(2*Math.asin(Math.sqrt(s)));if(Number.isInteger(e)){const h=s**t;let i=h/t;for(let n=1;n<e;n++)i=(n*i+h*(1-s)**n)/(t+n);return Math.log(i)}else if(Number.isInteger(t)){const h=(1-s)**e;let i=(1-h)/e;for(let n=1;n<t;n++)i=(n*i-s**n*h)/(n+e);return Math.log(i)}return t<e?Math.log(Math.exp(m(t,e))-Math.exp(v(1-s,e,t))):Math.log(s)*t-Math.log(t)+e*Math.log(1-s)+Math.log(k(t+e,1,t+1,s))},"logIncompleteBeta"),y=a((s,t,e)=>s===0?0:s===1?1:e===1?s**t:t===1?1-(1-s)**e:t<e?1-y(1-s,e,t):Math.exp(v(s,t,e)-m(t,e)),"regularizedIncompleteBeta"),P={gaussian:a(({s=1})=>(t,e)=>Math.exp(-(t.reduce((h,i,n)=>h+(i-e[n])**2,0)**2)/s**2),"gaussian"),polynomial:a(({d:s=2})=>(t,e)=>(1+t.reduce((h,i,n)=>h+i*e[n],0))**s,"polynomial")};export default class N{static{a(this,"TightestPerceptron")}constructor(t=10,e="gaussian",h="hinge"){this._b=t,typeof e=="function"?this._kernel=e:(typeof e=="string"&&(e={name:e}),this._kernel=P[e.name](e)),h==="hinge"?(this._accuracyLossP=i=>Math.max(0,1-i),this._accuracyLossN=i=>Math.max(0,1+i)):(this._accuracyLossP=i=>i<0?1:0,this._accuracyLossN=i=>i<0?0:1),this._ap=1,this._an=1,this._sv=[]}fit(t,e){for(let h=0;h<t.length;h++){let i=0;for(let n=0;n<this._sv.length;n++){const r=this._sv[n];i+=r.y*this._kernel(t[h],r.x)}if(i*e[h]<=0){if(e[h]===1?this._sv.push({x:t[h],y:e[h],cp:1,cn:0}):this._sv.push({x:t[h],y:e[h],cp:0,cn:1}),this._sv.length>this._b){let n=1/0,r=-1;for(let o=0;o<this._sv.length;o++){let g=0;for(let c=0;c<this._sv.length;c++){let u=0;for(let f=0;f<this._sv.length;f++){if(f===o)continue;const p=this._sv[f];u+=p.y*this._kernel(this._sv[c].x,p.x)}const x=this._accuracyLossP(u),I=this._accuracyLossN(u),M=1-y(.5,this._sv[c].cp+this._ap,this._sv[c].cn+this._an);g+=M*x+(1-M)*I}g/=this._sv.length,g<n&&(n=g,r=o)}const l=this._sv.splice(r,1)[0];this._updateSummary(l.x,l.cp,l.cn)}}else e[h]===1?this._updateSummary(t[h],1,0):this._updateSummary(t[h],0,1)}}_updateSummary(t,e,h){if(this._sv.length===0)return;let i=1/0,n=-1;for(let l=0;l<this._sv.length;l++){const o=this._sv[l].x.reduce((g,c,u)=>g+(c-t[u])**2,0);o<i&&(i=o,n=l)}const r=this._kernel(t,this._sv[n].x);this._sv[n].cp+=e*r,this._sv[n].cn+=h*r}predict(t){const e=[];for(let h=0;h<t.length;h++){let i=0;for(let n=0;n<this._sv.length;n++){const r=this._sv[n];i+=r.y*this._kernel(t[h],r.x)}e[h]=i<0?-1:1}return e}}
