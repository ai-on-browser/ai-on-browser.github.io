var n=Object.defineProperty;var a=(l,e)=>n(l,"name",{value:e,configurable:!0});import m from"./neuralnetwork.js";import{FlowLayer as f}from"./nns/layer/base.js";import u from"./nns/layer/reverse.js";import p from"../util/matrix.js";export default class d{static{a(this,"NICE")}constructor(e,r){const t=[{type:"input"}];for(let o=0;o<e;o++)t.push({type:"reverse",axis:1}),t.push({type:"additive_coupling"});t.push({type:"output"}),this._model=m.fromObject(t,null,r),this._epoch=0,this._p=o=>p.map(o,s=>Math.exp(-(s**2)/2)/Math.sqrt(2*Math.PI))}get epoch(){return this._epoch}fit(e,r,t,o){for(let s=0;s<r;s++)for(let i=0;i<e.length;i+=o){const h=Math.min(e.length,i+o),c=this._model.calc(e.slice(i,h));this._model.grad(c),this._model.update(t)}this._epoch+=r}predict(e){return this._model.calc(e).toArray()}generate(e){e=p.fromArray(e);for(let r=this._model._graph.size-1;r>=0;r--){const t=this._model._graph.nodes[r];t.layer instanceof f?e=t.layer.inverse(e):t.layer instanceof u&&(e=t.layer.calc(e))}return e.toArray()}}
