import{Matrix}from"../util/math.js";export default class NeighbourhoodComponentsAnalysis{constructor(t=null,o=.1){this._w=null,this._d=t,this._lr=o}fit(t,o){t=Matrix.fromArray(t),this._w||(this._w=Matrix.randn(this._d||t.cols,t.cols)),t.sub(t.mean(0)),t.div(t.variance(0));const r=t.rows,s=[];for(let t=0;t<r;s[t++]=[]);for(let o=0;o<r;o++){const r=t.row(o);s[o][o]=r.copySub(r);for(let i=0;i<o;i++){const e=r.copySub(t.row(i));s[o][i]=e,s[i][o]=e.copyMap((t=>-t))}}const i=new Matrix(r,r);for(let t=0;t<r;t++){i.set(t,t,0);for(let o=0;o<t;o++){const r=s[t][o].copyMult(this._w),e=Math.exp(-(r.norm()**2));i.set(t,o,e),i.set(o,t,e)}}i.div(i.sum(1));const e=[];for(let t=0;t<r;t++){e[t]=0;for(let s=0;s<r;s++)o[t]===o[s]&&(e[t]+=i.at(t,s))}const l=Matrix.zeros(this._w.cols,this._w.cols);for(let t=0;t<r;t++){const n=[];for(let o=0;o<r;o++){const r=s[t][o];n[o]=r.tDot(r),l.add(n[o].copyMult(i.at(t,o)*e[t]))}for(let s=0;s<r;s++){if(o[t]!==o[s])continue;const r=n[s];r.mult(i.at(t,s)),l.sub(r)}}const n=this._w.dot(l);n.mult(2*this._lr),this._w.sub(n)}importance(){return this._w.mean(0).value}predict(t){return Matrix.fromArray(t).dot(this._w.t).toArray()}}