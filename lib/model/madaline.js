var z=Object.defineProperty;var d=(k,e)=>z(k,"name",{value:e,configurable:!0});class M{static{d(this,"ADALINE")}constructor(e,i="step"){this._r=e,i==="step"?this._a=h=>h<=0?-1:1:i==="sigmoid"&&(this._a=h=>1/(1+Math.exp(-h))),this._w=null,this._b=0}_init(e){if(!this._w){this._w=[];for(let i=0;i<e[0].length;i++)this._w[i]=Math.random()-.5}}fit(e,i){this._init(e);const h=Array(this._w.length).fill(0);let l=0;for(let t=0;t<e.length;t++){const o=i[t];for(let s=0;s<e[t].length;s++)h[s]+=e[t][s]*o;l+=o}for(let t=0;t<this._w.length;t++)this._w[t]+=h[t]*this._r/e.length;this._b+=l*this._r/e.length}output(e){this._init(e);const i=[];for(let h=0;h<e.length;h++){const l=this._w.reduce((t,o,s)=>t+o*e[h][s],this._b);i[h]=l}return[i,i.map(this._a)]}}export default class E{static{d(this,"MADALINE")}constructor(e,i=2,h){if(i===1&&e.length>1)throw new Error("When the rule is 1, only single layer is accepted.");this._sizes=e,this._rule=i,this._rate=h,this._logic="maj",this._layers=[];for(let l=0;l<this._sizes.length;l++){this._layers[l]=[];for(let t=0;t<this._sizes[l];t++)this._layers[l][t]=new M(h,i===3?"sigmoid":"step")}}fit(e,i){if(Array.isArray(i[0])||(i=i.map(t=>[t])),this._rule!==1&&this._sizes.length===this._layers.length){const t=[];for(let o=0;o<i[0].length;o++)t.push(new M(this._rate,this._rule===3?"sigmoid":"step"));this._layers.push(t)}const h=e.length,l=Array.from(e,(t,o)=>o);for(let t=h-1;t>0;t--){const o=Math.floor(Math.random()*(t+1));[l[t],l[o]]=[l[o],l[t]]}if(e=l.map(t=>e[t]),i=l.map(t=>i[t]),this._rule===1)for(let t=0;t<e.length;t++)this._fit1([e[t]],[i[t]]);else if(this._rule===2)for(let t=0;t<e.length;t++)this._fit2([e[t]],[i[t]]);else for(let t=0;t<e.length;t++)this._fit3([e[t]],[i[t]])}_fit1(e,i){const h=e.length,l=this.outputLayers(e),t=l[l.length-1],o=l[0];for(let s=0;s<this._layers[0].length;s++){const r=[],g=[];for(let n=0;n<h;n++)t[n][0]!==i[n][0]&&(o[n][s]<=0?-1:1)!==i[n][0]&&(r.push(e[n]),g.push(i[n][0]-o[n][s]));r.length>0&&this._layers[0][s].fit(r,g)}}_fit2(e,i){const h=e.length,l=d(s=>s<=0?-1:1,"stepfn");for(let s=0;s<this._layers.length-1;s++){const r=this.outputLayers(e),g=r[s],n=s===0?e:r[s-1].map(f=>f.map(l)),A=r[r.length-1];let L=0;const y=Array.from(this._layers[s],(f,a)=>[0,a]);for(let f=0;f<h;f++){for(let a=0;a<g[f].length;a++)y[a][0]+=Math.abs(g[f][a])/h;L+=A[f].reduce((a,p,m)=>a+(l(p)-i[f][m])**2,0)}y.sort((f,a)=>f[0]-a[0]);for(let f=0;f<Math.ceil(y.length/2);f++){const a=y[f][1],p=[];for(let _=0;_<h;_++)p[_]=g[_].concat(),p[_][a]=-p[_][a];const m=this.outputLayers(p,s+1),j=m[m.length-1];let c=0;for(let _=0;_<h;_++)c+=j[_].reduce((u,w,b)=>u+(l(w)-i[_][b])**2,0);L<=c||this._layers[s][a].fit(n,p.map((_,u)=>_[a]-g[u][a]))}}const t=this._layers[this._layers.length-1],o=this.outputLayers(e);for(let s=0;s<t.length;s++)t[s].fit(o[o.length-2].map(r=>r.map(l)),o[o.length-1].map((r,g)=>i[g][s]-l(r[s])))}_fit3(e,i){const h=e.length,l=1e-4;for(let s=0;s<this._layers.length-1;s++)for(let r=0;r<this._layers[s].length;r++){const g=this._layers[s][r]._a,n=this.outputLayers(e),A=n[s],L=s===0?e:n[s-1].map(c=>c.map(_=>_<=0?-1:1)),y=n[n.length-1];let f=0;for(let c=0;c<h;c++)f+=y[c].reduce((_,u,w)=>_+(g(u)-i[c][w])**2,0);f/=h;const a=[];for(let c=0;c<h;c++)a[c]=A[c].concat(),a[c][r]+=l,a[c]=a[c].map(g);const p=this.outputLayers(a,s+1),m=p[p.length-1];let j=0;for(let c=0;c<h;c++)j+=m[c].reduce((_,u,w)=>_+(g(u)-i[c][w])**2,0);j/=h,this._layers[s][r].fit(L,Array(h).fill(-((f-j)**2/l)))}const t=this._layers[this._layers.length-1],o=this.outputLayers(e);for(let s=0;s<t.length;s++)t[s].fit(o[o.length-2],o[o.length-1].map((r,g)=>i[g][s]-r[s]))}outputLayers(e,i=0){let h=e;const l=[];for(let t=i;t<this._layers.length;t++){const o=Array.from(e,()=>[]);l[t]=Array.from(e,()=>[]);for(let s=0;s<this._layers[t].length;s++){const[r,g]=this._layers[t][s].output(h);for(let n=0;n<e.length;n++)l[t][n][s]=r[n],o[n][s]=g[n]}h=o}if(this._rule===1&&this._logic==="maj"){const t=[];for(let o=0;o<e.length;o++)t[o]=[h[o].reduce((s,r)=>s+r,0)<=0?-1:1];l[this._layers.length]=t}return l}predict(e){const i=this.outputLayers(e);return i[i.length-1].map(h=>h.map(l=>l<=0?-1:1))}}
