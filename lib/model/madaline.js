class ADALINE{constructor(t,e="step"){this._r=t,"step"===e?this._a=t=>t<=0?-1:1:"sigmoid"===e&&(this._a=t=>1/(1+Math.exp(-t))),this._w=null,this._b=0}_init(t){if(!this._w){this._w=[];for(let e=0;e<t[0].length;e++)this._w[e]=Math.random()-.5}}fit(t,e){this._init(t);const s=Array(this._w.length).fill(0);let l=0;for(let h=0;h<t.length;h++){const r=e[h];for(let e=0;e<t[h].length;e++)s[e]+=t[h][e]*r;l+=r}for(let e=0;e<this._w.length;e++)this._w[e]+=s[e]*this._r/t.length;this._b+=l*this._r/t.length}output(t){this._init(t);const e=[];for(let s=0;s<t.length;s++){const l=this._w.reduce(((e,l,h)=>e+l*t[s][h]),this._b);e[s]=l}return[e,e.map(this._a)]}}export default class MADALINE{constructor(t,e=2,s){if(1===e&&t.length>1)throw new Error("When the rule is 1, only single layer is accepted.");this._sizes=t,this._rule=e,this._rate=s,this._logic="maj",this._layers=[];for(let t=0;t<this._sizes.length;t++){this._layers[t]=[];for(let l=0;l<this._sizes[t];l++)this._layers[t][l]=new ADALINE(s,3===e?"sigmoid":"step")}}fit(t,e){if(Array.isArray(e[0])||(e=e.map((t=>[t]))),1!==this._rule&&this._sizes.length===this._layers.length){const t=[];for(let s=0;s<e[0].length;s++)t.push(new ADALINE(this._rate,3===this._rule?"sigmoid":"step"));this._layers.push(t)}const s=t.length,l=Array.from(t,((t,e)=>e));for(let t=s-1;t>0;t--){const e=Math.floor(Math.random()*(t+1));[l[t],l[e]]=[l[e],l[t]]}if(t=l.map((e=>t[e])),e=l.map((t=>e[t])),1===this._rule)for(let s=0;s<t.length;s++)this._fit1([t[s]],[e[s]]);else if(2===this._rule)for(let s=0;s<t.length;s++)this._fit2([t[s]],[e[s]]);else for(let s=0;s<t.length;s++)this._fit3([t[s]],[e[s]])}_fit1(t,e){const s=t.length,l=this.outputLayers(t),h=l[l.length-1],r=l[0];for(let l=0;l<this._layers[0].length;l++){const i=[],o=[];for(let n=0;n<s;n++)h[n][0]!==e[n][0]&&(r[n][l]<=0?-1:1)!==e[n][0]&&(i.push(t[n]),o.push(e[n][0]-r[n][l]));i.length>0&&this._layers[0][l].fit(i,o)}}_fit2(t,e){const s=t.length,l=t=>t<=0?-1:1;for(let h=0;h<this._layers.length-1;h++){const r=this.outputLayers(t),i=r[h],o=0===h?t:r[h-1].map((t=>t.map(l))),n=r[r.length-1];let a=0;const _=Array.from(this._layers[h],((t,e)=>[0,e]));for(let t=0;t<s;t++){for(let e=0;e<i[t].length;e++)_[e][0]+=Math.abs(i[t][e])/s;a+=n[t].reduce(((s,h,r)=>s+(l(h)-e[t][r])**2),0)}_.sort(((t,e)=>t[0]-e[0]));for(let t=0;t<Math.ceil(_.length/2);t++){const r=_[t][1],n=[];for(let t=0;t<s;t++)n[t]=i[t].concat(),n[t][r]=-n[t][r];const f=this.outputLayers(n,h+1),g=f[f.length-1];let c=0;for(let t=0;t<s;t++)c+=g[t].reduce(((s,h,r)=>s+(l(h)-e[t][r])**2),0);a<=c||this._layers[h][r].fit(o,n.map(((t,e)=>t[r]-i[e][r])))}}const h=this._layers[this._layers.length-1],r=this.outputLayers(t);for(let t=0;t<h.length;t++)h[t].fit(r[r.length-2].map((t=>t.map(l))),r[r.length-1].map(((s,h)=>e[h][t]-l(s[t]))))}_fit3(t,e){const s=t.length,l=1e-4;for(let h=0;h<this._layers.length-1;h++)for(let r=0;r<this._layers[h].length;r++){const i=this._layers[h][r]._a,o=this.outputLayers(t),n=o[h],a=0===h?t:o[h-1].map((t=>t.map((t=>t<=0?-1:1)))),_=o[o.length-1];let f=0;for(let t=0;t<s;t++)f+=_[t].reduce(((s,l,h)=>s+(i(l)-e[t][h])**2),0);f/=s;const g=[];for(let t=0;t<s;t++)g[t]=n[t].concat(),g[t][r]+=l,g[t]=g[t].map(i);const c=this.outputLayers(g,h+1),u=c[c.length-1];let y=0;for(let t=0;t<s;t++)y+=u[t].reduce(((s,l,h)=>s+(i(l)-e[t][h])**2),0);y/=s,this._layers[h][r].fit(a,Array(s).fill(-((f-y)**2)/l))}const h=this._layers[this._layers.length-1],r=this.outputLayers(t);for(let t=0;t<h.length;t++)h[t].fit(r[r.length-2],r[r.length-1].map(((s,l)=>e[l][t]-s[t])))}outputLayers(t,e=0){let s=t;const l=[];for(let h=e;h<this._layers.length;h++){const e=Array.from(t,(()=>[]));l[h]=Array.from(t,(()=>[]));for(let r=0;r<this._layers[h].length;r++){const[i,o]=this._layers[h][r].output(s);for(let s=0;s<t.length;s++)l[h][s][r]=i[s],e[s][r]=o[s]}s=e}if(1===this._rule&&"maj"===this._logic){const e=[];for(let l=0;l<t.length;l++)e[l]=[s[l].reduce(((t,e)=>t+e),0)<=0?-1:1];l[this._layers.length]=e}return l}predict(t){const e=this.outputLayers(t);return e[e.length-1].map((t=>t.map((t=>t<=0?-1:1))))}}