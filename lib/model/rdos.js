export default class RDOS{constructor(t,e,s="gaussian"){this._k=t,this._h=e,"gaussian"===s&&(this._kernel=t=>Math.exp(-t.reduce(((t,e)=>t+e**2),0)/2)/Math.sqrt(2*Math.PI)**t.length)}_distance(t,e){return Math.sqrt(t.reduce(((t,s,o)=>t+(s-e[o])**2),0))}predict(t){const e=t.length,s=[];for(let o=0;o<e;o++){s[o]=[],s[o][o]={d:0,i:o};for(let e=0;e<o;e++){const r=this._distance(t[o],t[e]);s[o][e]={d:r,i:e},s[e][o]={d:r,i:o}}}const o=[];for(let t=0;t<e;t++)s[t].sort(((t,e)=>t.d-e.d)),o[t]=s[t].slice(1,this._k+1).map((t=>t.i));const r=[];for(let t=0;t<e;t++){r[t]=[];for(let s=0;s<e;s++)o[s].some((e=>e===t))&&r[t].push(s)}const n=[],i=[];for(let s=0;s<e;s++){const e=new Set;for(let t=0;t<this._k;t++)for(const n of r[o[s][t]])n!==s&&e.add(n);i[s]=new Set([...o[s],...r[s],...e]),n[s]=this._kernel(Array(t[s].length).fill(0));for(const e of i[s]){const o=t[s].map(((s,o)=>(s-t[e][o])/this._h));n[s]+=this._kernel(o)}n[s]/=this._h**t[s].length*(i[s].size+1)}const h=[];for(let t=0;t<e;t++){let e=0;for(const s of i[t])e+=n[s];h[t]=e/(i[t].size*n[t])}return h}}