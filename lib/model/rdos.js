export default class RDOS{constructor(t,e,s="gaussian"){this._k=t,this._h=e,"function"==typeof s?this._kernel=s:"gaussian"===s&&(this._kernel=t=>Math.exp(-t.reduce(((t,e)=>t+e**2),0)/2)/Math.sqrt(2*Math.PI)**t.length)}_distance(t,e){return Math.sqrt(t.reduce(((t,s,o)=>t+(s-e[o])**2),0))}predict(t){const e=t.length,s=[];for(let o=0;o<e;o++){s[o]=[],s[o][o]={d:0,i:o};for(let e=0;e<o;e++){const n=this._distance(t[o],t[e]);s[o][e]={d:n,i:e},s[e][o]={d:n,i:o}}}const o=[];for(let t=0;t<e;t++)s[t].sort(((t,e)=>t.d-e.d)),o[t]=s[t].slice(1,this._k+1).map((t=>t.i));const n=[];for(let t=0;t<e;t++){n[t]=[];for(let s=0;s<e;s++)o[s].some((e=>e===t))&&n[t].push(s)}const r=[],i=[];for(let s=0;s<e;s++){const e=new Set;for(let t=0;t<this._k;t++)for(const r of n[o[s][t]])r!==s&&e.add(r);i[s]=new Set([...o[s],...n[s],...e]),r[s]=this._kernel(Array(t[s].length).fill(0));for(const e of i[s]){const o=t[s].map(((s,o)=>(s-t[e][o])/this._h));r[s]+=this._kernel(o)}r[s]/=this._h**t[s].length*(i[s].size+1)}const h=[];for(let t=0;t<e;t++){let e=0;for(const s of i[t])e+=r[s];h[t]=e/(i[t].size*r[t])}return h}}