export default class KModes{constructor(){this._modes=[],this._categories=null}get size(){return this._modes.length}add(t){if(!this._categories){this._categories=[];for(let e=0;e<t[0].length;e++)this._categories[e]=[...new Set(t.map((t=>t[e])))]}const e=[];for(let t=0;t<this._categories.length;t++){const s=Array(this._categories[t].length);let r=0;for(let t=0;t<s.length;t++)s[t]=Math.random(),r+=s[t];e[t]=s.map((t=>t/r))}this._modes.push(e)}clear(){this._modes=[]}predict(t){if(0===this._modes.length)throw new Error("Call fit before predict.");return t.map((t=>{let e=1/0,s=-1;for(let r=0;r<this._modes.length;r++){let h=0;for(let e=0;e<t.length;e++)for(let s=0;s<this._modes[r][e].length;s++)this._categories[e][s]===t[e]?h+=(this._modes[r][e][s]-1)**2:h+=this._modes[r][e][s]**2;h<e&&(e=h,s=r)}return s}))}fit(t){if(0===this._modes.length||0===t.length)return 0;const e=this.predict(t);let s=0;for(let r=0;r<this._modes.length;r++){const h=[];for(let o=0;o<this._modes[r].length;o++){h[o]=Array(this._modes[r][o].length).fill(0);let i=0;for(let s=0;s<e.length;s++)e[s]===r&&(h[o][this._categories[o].indexOf(t[s][o])]++,i++);h[o]=h[o].map((t=>0===t?0:t/i)),s+=Math.sqrt(this._modes[r][o].reduce(((t,e,s)=>t+(e-h[o][s])**2),0))}this._modes[r]=h}return Math.sqrt(s)}}