var d=Object.defineProperty;var r=(o,h)=>d(o,"name",{value:h,configurable:!0});export default class c{static{r(this,"EnsembleBinaryModel")}constructor(h,i,t){return i==="oneone"?new m(h,t):i==="onerest"?new a(h,t):null}init(h,i){}fit(h,i,...t){}predict(h){}}class a{static{r(this,"OneVsRestModel")}constructor(h,i){if(i&&!Array.isArray(i)&&(i=[...i]),this._modelcls=h,this._classes=i,this._model=[],this._n=0,i){this._n=i.length;for(let t=0;t<this._n;t++)this._model[t]=new h}}init(h,i){if(i=i.flat(),!this._classes){this._classes=[...new Set(i)],this._n=this._classes.length;for(let t=0;t<this._n;t++)this._model[t]=new this._modelcls}for(let t=0;t<this._n;t++)if(this._model[t].init){const l=i.map(e=>e===this._classes[t]?1:-1);this._model[t].init(h,l)}}fit(h,i,...t){this._classes||this.init(h,i);for(let l=0;l<this._n;l++)if(this._model[l].init&&this._model[l].init.length>=2)this._model[l].fit(h,i,...t);else{const e=i.flat().map(s=>s===this._classes[l]?1:-1);this._model[l].fit(h,e,...t)}}predict(h){let i=[];for(let t=0;t<this._n;t++)this._model[t].predict(h).map((l,e)=>{i[e]||(i[e]=[]),i[e][t]=Array.isArray(l)?l[0]:l});return i.map(t=>{let l=-1/0,e=-1;for(let s=0;s<t.length;s++)t[s]>l&&(l=t[s],e=s);return this._classes[e]})}}class m{static{r(this,"OneVsOneModel")}constructor(h,i){if(i&&!Array.isArray(i)&&(i=[...i]),this._modelcls=h,this._classes=i,this._model=[],this._n=0,i){this._n=i.length;for(let t=0;t<this._n;t++){this._model[t]=[];for(let l=0;l<t;l++)this._model[t][l]=new h}}}init(h,i){if(i=i.flat(),!this._classes){this._classes=[...new Set(i)],this._n=this._classes.length;for(let e=0;e<this._n;e++){this._model[e]=[];for(let s=0;s<e;s++)this._model[e][s]=new this._modelcls}}let t={};i.forEach((e,s)=>{t[e]||(t[e]=[]),t[e].push(h[s])});let l=[];for(let e=0;e<this._n;e++){l[e]=Array(t[this._classes[e]].length).fill(1);for(let s=0;s<e;s++)if(this._model[e][s].init){const n=t[this._classes[e]].concat(t[this._classes[s]]),_=l[e].concat(l[s]);this._model[e][s].init(n,_)}l[e].fill(-1)}}fit(h,i,...t){this._classes||this.init(h,i);const l={};i?.flat().forEach((s,n)=>{l[s]||(l[s]=[]),l[s].push(h[n])});const e=[];for(let s=0;s<this._n;s++){e[s]=Array(l[this._classes[s]]?.length??0).fill(1);for(let n=0;n<s;n++)if(this._model[s][n].init&&this._model[s][n].init.length>=2)this._model[s][n].fit(h,i,...t);else{const _=l[this._classes[s]].concat(l[this._classes[n]]),f=e[s].concat(e[n]);this._model[s][n].fit(_,f,...t)}e[s].fill(-1)}}predict(h){let i=[];for(let t=0;t<h.length;t++)i.push(Array(this._n).fill(0));for(let t=0;t<this._n;t++)for(let l=0;l<t;l++)this._model[t][l].predict(h).map((e,s)=>{i[s][e>0?t:l]++});return i.map(t=>{let l=-1/0,e=-1;for(let s=0;s<t.length;s++)t[s]>l&&(l=t[s],e=s);return this._classes[e]})}}
