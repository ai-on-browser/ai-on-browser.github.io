export default class EnsembleBinaryModel{constructor(s,t,i,e){return"oneone"===t?new OneVsOneModel(s,i,e):"onerest"===t?new OneVsRestModel(s,i,e):null}init(s,t){}fit(s,t,...i){}predict(s){}}const argmax=function(s,t){return 0===s.length?-1:(s=t?s.map(t):s).indexOf(Math.max(...s))};class OneVsRestModel{constructor(s,t,i){if(t&&!Array.isArray(t)&&(t=[...t]),this._modelcls=s,this._classes=t,this._model=[],this._n=0,this._init_args=i||[],t){this._n=t.length;for(let t=0;t<this._n;t++)this._model[t]=new s(...this._init_args)}}init(s,t){if(t=t.flat(),!this._classes){this._classes=[...new Set(t)],this._n=this._classes.length;for(let s=0;s<this._n;s++)this._model[s]=new this._modelcls(...this._init_args)}for(let i=0;i<this._n;i++)if(this._model[i].init){const e=t.map((s=>s===this._classes[i]?1:-1));this._model[i].init(s,e)}}fit(s,t,...i){this._classes||this.init(s,t);for(let e=0;e<this._n;e++)if(this._model[e].init)this._model[e].fit(s,t,...i);else{const l=t.flat().map((s=>s===this._classes[e]?1:-1));this._model[e].fit(s,l,...i)}}predict(s){let t=[];for(let i=0;i<this._n;i++)this._model[i].predict(s).map(((s,e)=>{t[e]||(t[e]=[]),t[e][i]=Array.isArray(s)?s[0]:s}));return t.map((s=>this._classes[argmax(s)]))}}class OneVsOneModel{constructor(s,t,i){if(t&&!Array.isArray(t)&&(t=[...t]),this._modelcls=s,this._classes=t,this._model=[],this._n=0,this._init_args=i||[],t){this._n=t.length;for(let t=0;t<this._n;t++){this._model[t]=[];for(let i=0;i<t;i++)this._model[t][i]=new s(...this._init_args)}}}init(s,t){if(t=t.flat(),!this._classes){this._classes=[...new Set(t)],this._n=this._classes.length;for(let s=0;s<this._n;s++){this._model[s]=[];for(let t=0;t<s;t++)this._model[s][t]=new this._modelcls(...this._init_args)}}let i={};t.forEach(((t,e)=>{i[t]||(i[t]=[]),i[t].push(s[e])}));let e=[];for(let s=0;s<this._n;s++){e[s]=Array(i[this._classes[s]].length).fill(1);for(let t=0;t<s;t++)if(this._model[s][t].init){const l=i[this._classes[s]].concat(i[this._classes[t]]),h=e[s].concat(e[t]);this._model[s][t].init(l,h)}e[s].fill(-1)}}fit(s,t,...i){this._classes||this.init(s,t);const e={};t?.flat().forEach(((t,i)=>{e[t]||(e[t]=[]),e[t].push(s[i])}));const l=[];for(let h=0;h<this._n;h++){l[h]=Array(e[this._classes[h]]?.length??0).fill(1);for(let n=0;n<h;n++)if(this._model[h][n].init)this._model[h][n].fit(s,t,...i);else{const s=e[this._classes[h]].concat(e[this._classes[n]]),t=l[h].concat(l[n]);this._model[h][n].fit(s,t,...i)}l[h].fill(-1)}}predict(s){let t=[];for(let i=0;i<s.length;i++)t.push(Array(this._n).fill(0));for(let i=0;i<this._n;i++)for(let e=0;e<i;e++)this._model[i][e].predict(s).map(((s,l)=>{t[l][s>0?i:e]++}));return t.map((s=>this._classes[argmax(s)]))}}