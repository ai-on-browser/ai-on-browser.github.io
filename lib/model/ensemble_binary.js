export default class EnsembleBinaryModel{constructor(s,t,e){return"oneone"===t?new OneVsOneModel(s,e):"onerest"===t?new OneVsRestModel(s,e):null}init(s,t){}fit(s,t,...e){}predict(s){}}const argmax=function(s,t){return 0===s.length?-1:(s=t?s.map(t):s).indexOf(Math.max(...s))};class OneVsRestModel{constructor(s,t){if(t&&!Array.isArray(t)&&(t=[...t]),this._modelcls=s,this._classes=t,this._model=[],this._n=0,t){this._n=t.length;for(let t=0;t<this._n;t++)this._model[t]=new s}}init(s,t){if(t=t.flat(),!this._classes){this._classes=[...new Set(t)],this._n=this._classes.length;for(let s=0;s<this._n;s++)this._model[s]=new this._modelcls}for(let e=0;e<this._n;e++)if(this._model[e].init){const i=t.map((s=>s===this._classes[e]?1:-1));this._model[e].init(s,i)}}fit(s,t,...e){this._classes||this.init(s,t);for(let i=0;i<this._n;i++)if(this._model[i].init)this._model[i].fit(s,t,...e);else{const l=t.flat().map((s=>s===this._classes[i]?1:-1));this._model[i].fit(s,l,...e)}}predict(s){let t=[];for(let e=0;e<this._n;e++)this._model[e].predict(s).map(((s,i)=>{t[i]||(t[i]=[]),t[i][e]=Array.isArray(s)?s[0]:s}));return t.map((s=>this._classes[argmax(s)]))}}class OneVsOneModel{constructor(s,t){if(t&&!Array.isArray(t)&&(t=[...t]),this._modelcls=s,this._classes=t,this._model=[],this._n=0,t){this._n=t.length;for(let t=0;t<this._n;t++){this._model[t]=[];for(let e=0;e<t;e++)this._model[t][e]=new s}}}init(s,t){if(t=t.flat(),!this._classes){this._classes=[...new Set(t)],this._n=this._classes.length;for(let s=0;s<this._n;s++){this._model[s]=[];for(let t=0;t<s;t++)this._model[s][t]=new this._modelcls}}let e={};t.forEach(((t,i)=>{e[t]||(e[t]=[]),e[t].push(s[i])}));let i=[];for(let s=0;s<this._n;s++){i[s]=Array(e[this._classes[s]].length).fill(1);for(let t=0;t<s;t++)if(this._model[s][t].init){const l=e[this._classes[s]].concat(e[this._classes[t]]),h=i[s].concat(i[t]);this._model[s][t].init(l,h)}i[s].fill(-1)}}fit(s,t,...e){this._classes||this.init(s,t);const i={};t?.flat().forEach(((t,e)=>{i[t]||(i[t]=[]),i[t].push(s[e])}));const l=[];for(let h=0;h<this._n;h++){l[h]=Array(i[this._classes[h]]?.length??0).fill(1);for(let n=0;n<h;n++)if(this._model[h][n].init)this._model[h][n].fit(s,t,...e);else{const s=i[this._classes[h]].concat(i[this._classes[n]]),t=l[h].concat(l[n]);this._model[h][n].fit(s,t,...e)}l[h].fill(-1)}}predict(s){let t=[];for(let e=0;e<s.length;e++)t.push(Array(this._n).fill(0));for(let e=0;e<this._n;e++)for(let i=0;i<e;i++)this._model[e][i].predict(s).map(((s,l)=>{t[l][s>0?e:i]++}));return t.map((s=>this._classes[argmax(s)]))}}