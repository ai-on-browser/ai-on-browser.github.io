import{Tree}from"../util/math.js";class Link{constructor(){this._link=[]}at(t,e){return t<e?this._link[t]?.[e]||0:this._link[e]?.[t]||0}set(t,e,n){t<e?(this._link[t]||=[],this._link[t][e]=n):(this._link[e]||=[],this._link[e][t]=n)}}export default class ROCK{constructor(t){this._th=t}_f(){return(1-this._th)/(1+this._th)}_g(t,e,n){const l=t.leafValues(),s=e.leafValues();let i=0;for(let t=0;t<l.length;t++)for(let e=0;e<s.length;e++)i+=n.at(l[t].index,s[e].index);const r=1+2*this._f();return i/((l.length+s.length)**r-l.length**r-s.length**r)}_sim(t,e){return 1/(1+Math.sqrt(t.reduce(((t,n,l)=>t+(n-e[l])**2),0)))}_link(t){const e=t.length,n=[];for(let t=0;t<e;n[t++]=[]);for(let l=0;l<e;l++)for(let s=l+1;s<e;s++)this._sim(t[l],t[s])>=this._th&&(n[l].push(s),n[s].push(l));const l=new Link;for(let t=0;t<e;t++){const e=n[t];for(let t=0;t<e.length;t++)for(let n=t+1;n<e.length-1;n++)l.set(e[t],e[n],l.at(e[t],e[n])+1)}return l}fit(t){const e=this._link(t),n=t.length,l=[];for(let e=0;e<n;e++)l.push(new Tree({point:t[e],index:e,distance:0}));const s=[];for(let t=0;t<n;t++){s[t]=[];for(let i=0;i<n;i++)e.at(t,i)>0&&s[t].push({index:i,g:this._g(l[t],l[i],e)});s[t].sort(((t,e)=>e.g-t.g)),l[t].value.g=s[t][0]?.g||0}l.sort(((t,e)=>e.value.g-t.value.g));let i=n;for(;l.length>2;){const t=l.shift();if(0===t.value.g){l.push(t);break}const n=t.value.index,r=s[n][0].index;let h=null;for(let t=0;t<l.length;t++)if(l[t].value.index===r){h=l.splice(t,1)[0];break}const o=i++,g=new Tree({index:o},[t,h]),u=[...new Set([...s[n].map((t=>t.index)),...s[r].map((t=>t.index))])];s[o]=[];for(let t=0;t<u.length;t++){if(u[t]===n||u[t]===r)continue;e.set(o,u[t],e.at(n,u[t])+e.at(r,u[t]));const i=l.find((e=>e.value.index===u[t])),h=this._g(g,i,e);s[o].push({index:u[t],g:h}),s[u[t]]=s[u[t]].filter((t=>t.index!==n&&t.index!==r)),s[u[t]].push({index:o,g:h}),s[u[t]].sort(((t,e)=>e.g-t.g)),i.value.g=s[u[t]][0].g}s[n]=[],s[r]=[],s[o].sort(((t,e)=>e.g-t.g)),g.value.g=s[o][0]?.g||0,l.push(g),l.sort(((t,e)=>e.value.g-t.value.g))}this._root=new Tree({g:0},l)}getClusters(t){const e=this._root.childs;for(;e.length<t;){let t=1/0,n=-1;for(let l=0;l<e.length;l++){const s=e[l];!s.isLeaf()&&s.value.g<t&&(n=l,t=s.value.g)}if(-1===n)break;const l=e[n];e.splice(n,1,l.at(0),l.at(1))}return e}predict(t){const e=[],n=this.getClusters(t);for(let t=0;t<n.length;t++){const l=n[t].leafValues();for(let n=0;n<l.length;n++)e[l[n].index]=t}return e}}