import Matrix from"../util/matrix.js";export class CELLIP{constructor(t=.1,s=.5){this._m=null,this._s=null,this._gamma=t,this._a=s}init(t,s){this._x=Matrix.fromArray(t),this._shift=this._x.mean(0),this._x.sub(this._shift),this._y=s,this._d=this._x.cols,this._m=Matrix.zeros(this._d,1),this._p=Matrix.eye(this._d,this._d,1+(1-this._a)*this._gamma)}update(t,s){const i=this._m.tDot(t).toScaler();if(i*s>0)return;const h=Math.sqrt(t.tDot(this._p).dot(t).toScaler()),_=(this._a*this._gamma-s*i)/h,r=t.copyMult(s/h),o=this._p.dot(r);o.mult(_),this._m.add(o);const a=this._p.dot(r).dot(r.tDot(this._p));a.mult(-2*_*(1-this._a)),a.add(this._p.copyMult(1-_**2)),this._p=a}fit(){for(let t=0;t<this._x.rows;t++)this.update(this._x.row(t).t,this._y[t])}predict(t){const s=Matrix.fromArray(t);s.sub(this._shift);return s.dot(this._m).value.map((t=>t<=0?-1:1))}}export class IELLIP{constructor(t=.9,s=.5){this._m=null,this._p=null,this._b=t,this._c=s}init(t,s){this._x=Matrix.fromArray(t),this._shift=this._x.mean(0),this._x.sub(this._shift),this._y=s,this._d=this._x.cols,this._m=Matrix.zeros(this._d,1),this._p=Matrix.eye(this._d,this._d),this._t=0}update(t,s){const i=this._m.tDot(t).toScaler();if(i*s>0)return;const h=Math.sqrt(t.tDot(this._p).dot(t).toScaler()),_=(1-s*i)/h,r=t.copyMult(s/h),o=this._c*this._b**this._t++,a=this._p.dot(r);a.mult(_),this._m.add(a);const d=this._p.dot(r).dot(r.tDot(this._p));d.mult(-o),d.add(this._p),d.mult(1/(1-o)),this._p=d}fit(){for(let t=0;t<this._x.rows;t++)this.update(this._x.row(t).t,this._y[t])}predict(t){const s=Matrix.fromArray(t);s.sub(this._shift);return s.dot(this._m).value.map((t=>t<=0?-1:1))}}