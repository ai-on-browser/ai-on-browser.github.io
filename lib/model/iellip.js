var p=Object.defineProperty;var n=(d,t)=>p(d,"name",{value:t,configurable:!0});import i from"../util/matrix.js";export class CELLIP{static{n(this,"CELLIP")}constructor(t=.1,s=.5){this._m=null,this._p=null,this._gamma=t,this._a=s}init(t,s){this._x=i.fromArray(t),this._shift=this._x.mean(0),this._x.sub(this._shift),this._y=s,this._d=this._x.cols,this._m=i.zeros(this._d,1),this._p=i.eye(this._d,this._d,1+(1-this._a)*this._gamma)}update(t,s){const _=this._m.tDot(t).toScaler();if(_*s>0)return;const h=Math.sqrt(t.tDot(this._p).dot(t).toScaler()),a=(this._a*this._gamma-s*_)/h,o=i.mult(t,s/h),m=this._p.dot(o);m.mult(a),this._m.add(m);const r=this._p.dot(o).dot(o.tDot(this._p));r.mult(-2*a*(1-this._a)),r.add(i.mult(this._p,1-a**2)),this._p=r}fit(){for(let t=0;t<this._x.rows;t++)this.update(this._x.row(t).t,this._y[t])}predict(t){const s=i.fromArray(t);return s.sub(this._shift),s.dot(this._m).value.map(h=>h<=0?-1:1)}}export class IELLIP{static{n(this,"IELLIP")}constructor(t=.9,s=.5){this._m=null,this._p=null,this._b=t,this._c=s}init(t,s){this._x=i.fromArray(t),this._shift=this._x.mean(0),this._x.sub(this._shift),this._y=s,this._d=this._x.cols,this._m=i.zeros(this._d,1),this._p=i.eye(this._d,this._d),this._t=0}update(t,s){const _=this._m.tDot(t).toScaler();if(_*s>0)return;const h=Math.sqrt(t.tDot(this._p).dot(t).toScaler()),a=(1-s*_)/h,o=i.mult(t,s/h),m=this._c*this._b**this._t++,r=this._p.dot(o);r.mult(a),this._m.add(r);const c=this._p.dot(o).dot(o.tDot(this._p));c.mult(-m),c.add(this._p),c.mult(1/(1-m)),this._p=c}fit(){for(let t=0;t<this._x.rows;t++)this.update(this._x.row(t).t,this._y[t])}predict(t){const s=i.fromArray(t);return s.sub(this._shift),s.dot(this._m).value.map(h=>h<=0?-1:1)}}
