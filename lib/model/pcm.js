import{Matrix}from"../util/math.js";export default class PossibilisticCMeans{constructor(t=2){this._m=t,this._c=[],this._u=[],this._k=1}_distance2(t,s){return t.reduce(((t,i,h)=>t+(i-s[h])**2),0)}init(t){this._x=t}add(){let t=null;for(;;){const s=Math.floor(Math.random()*this._x.length);if(t=this._x[s],this._c.every((s=>this._distance2(t,s)>0)))break}this._c.push(t.concat());const s=[],i=this._x.map((s=>this._distance2(t,s))),h=this._k*i.reduce(((t,s)=>t+s),0)/i.length;for(let t=0;t<this._x.length;t++)s[t]=1/(1+(i[t]**2/h)**(1/(this._m-1)));this._u.push(s)}fit(){const t=this._x[0].length;for(let t=0;t<this._u.length;t++){const s=this._x.map((s=>this._distance2(this._c[t],s)));let i=0,h=0;for(let _=0;_<this._x.length;_++)i+=this._u[t][_]**this._m,h+=s[_]*this._u[t][_]**this._m;h*=this._k/i;for(let i=0;i<this._x.length;i++)this._u[t][i]=1/(1+(s[i]/h)**(1/(this._m-1)))}const s=[];for(let i=0;i<this._u.length;i++){const h=Array(t).fill(0);let _=0;for(let s=0;s<this._x.length;s++){_+=this._u[i][s]**this._m;for(let _=0;_<t;_++)h[_]+=this._x[s][_]*this._u[i][s]**this._m}s.push(h.map((t=>t/_)))}this._c=s}predict(){return Matrix.fromArray(this._u).argmax(0).value}}