var N=Object.defineProperty;var C=(A,n)=>N(A,"name",{value:n,configurable:!0});import c from"../util/matrix.js";export default class j{static{C(this,"LSIF")}constructor(n,l,t,d){this._sigma_cand=n,this._lambda_cand=l,this._fold=t,this._kernelNum=d}_kernel_gaussian(n,l,t){const d=[];for(let i=0;i<l.rows;i++){const _=[];for(let e=0;e<n.rows;e++){const a=c.sub(l.row(i),n.row(e));_.push(Math.exp(-a.reduce((s,u)=>s+u**2,0)/(2*t**2)))}d.push(_)}return c.fromArray(d)}_regularization_path(n,l){const t=l.rows;n.add(c.eye(t,t,1e-12));const d=l.argmax(0).toScaler(),i=[l.at(d,0)],_=[c.zeros(t,1)],e=[];for(let a=0;a<t;a++)a!==d&&e.push(a);for(;i[i.length-1]>0;){const a=c.zeros(e.length,t);for(let o=0;o<e.length;o++)a.set(o,e[o],-1);const s=c.zeros(t+e.length,t+e.length);s.set(0,0,n),s.set(t,0,a),s.set(0,t,a.t);const u=s.solve(c.resize(l,t+e.length,l.cols)),g=s.solve(c.resize(c.ones(t,1),t+e.length,1));if(g.some(o=>o<=0))i.push(0),_.push(u.slice(0,t));else{let o=-1,h=-1/0;for(let m=0;m<t+e.length;m++){const p=u.at(m,0)/g.at(m,0);g.at(m,0)>0&&p>h&&(o=m,h=p)}h=Math.max(0,h),i.push(h),g.mult(h),u.sub(g),_.push(u.slice(0,t)),o<t?e.includes(o)||(e.push(o),e.sort((m,p)=>m-p)):e.splice(o-t,1)}}return a=>{if(a>=i[0])return _[0];for(let s=1;s<i.length;s++)if(i[s]<=a&&a<=i[s-1]){const u=(i[s]-a)/(i[s]-i[s-1]),g=(a-i[s-1])/(i[s]-i[s-1]),o=c.mult(_[s-1],u),h=c.mult(_[s],g);return o.add(h),o}}}fit(n,l){n=c.fromArray(n),l=c.fromArray(l);const t=n.rows,d=l.rows,i=Math.min(this._kernelNum,t),_=n.sample(i)[0];if(this._centers=_,this._sigma=this._sigma_cand[0],this._lambda=this._lambda_cand[0],this._sigma_cand.length>1){let g=1/0;const o=Array.from({length:t},(m,p)=>p%this._fold),h=Array.from({length:d},(m,p)=>p%this._fold);for(const m of this._sigma_cand){const p=this._kernel_gaussian(n,_,m),D=this._kernel_gaussian(l,_,m);for(let r=o.length-1;r>0;r--){const f=Math.floor(Math.random()*(r+1));[o[r],o[f]]=[o[f],o[r]]}for(let r=h.length-1;r>0;r--){const f=Math.floor(Math.random()*(r+1));[h[r],h[f]]=[h[f],h[r]]}const I=[];for(let r=0;r<this._fold;r++){const f=o.map(b=>b===r),k=h.map(b=>b===r),z=p.col(f),w=D.col(k),v=w.dot(w.t);v.div(w.cols);const M=z.mean(1);I.push(this._regularization_path(v,M))}for(const r of this._lambda_cand){let f=0;for(let k=0;k<this._fold;k++){const z=o.map(y=>y!==k),w=h.map(y=>y!==k),v=p.col(z),M=D.col(w),b=I[k](r);let S=c.map(M.tDot(b),y=>y**2).mean()/2;S-=v.tDot(b).mean(),f+=S}f/=this._fold,f<g&&(g=f,this._sigma=m,this._lambda=r)}}}const e=this._kernel_gaussian(n,_,this._sigma),a=this._kernel_gaussian(l,_,this._sigma),s=a.dot(a.t);s.div(d);const u=e.mean(1);this._kw=this._regularization_path(s,u)(this._lambda)}predict(n){return n=c.fromArray(n),this._kernel_gaussian(n,this._centers,this._sigma).tDot(this._kw).value}}
