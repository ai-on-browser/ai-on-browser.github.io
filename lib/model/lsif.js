import{Matrix}from"../util/math.js";export class LSIF{constructor(t,s,e,a){this._sigma_cand=t,this._lambda_cand=s,this._fold=e,this._kernelNum=a}_kernel_gaussian(t,s,e){const a=[];for(let o=0;o<s.rows;o++){const r=[];for(let a=0;a<t.rows;a++){const i=s.row(o).copySub(t.row(a));r.push(Math.exp(-i.reduce(((t,s)=>t+s**2),0)/(2*e**2)))}a.push(r)}return Matrix.fromArray(a)}_regularization_path(t,s){const e=s.rows;t.add(Matrix.eye(e,e,1e-12));const a=s.argmax(0).toScaler(),o=[s.at(a,0)],r=[Matrix.zeros(e,1)],i=[];for(let t=0;t<e;t++)t!==a&&i.push(t);for(;o[o.length-1]>0;){const a=Matrix.zeros(i.length,e);for(let t=0;t<i.length;t++)a.set(t,i[t],-1);const l=Matrix.zeros(e+i.length,e+i.length);l.set(0,0,t),l.set(e,0,a),l.set(0,e,a.t);const h=l.solve(s.resize(e+i.length,s.cols)),n=l.solve(Matrix.ones(e,1).resize(e+i.length,1));if(n.some((t=>t<=0)))o.push(0),r.push(h.slice(0,e));else{let t=-1,s=-1/0;for(let a=0;a<e+i.length;a++){const e=h.at(a,0)/n.at(a,0);n.at(a,0)>0&&e>s&&(t=a,s=e)}s=Math.max(0,s),o.push(s),n.mult(s),h.sub(n),r.push(h.slice(0,e)),t<e?i.indexOf(t)<0&&(i.push(t),i.sort(((t,s)=>t-s))):i.splice(t-e,1)}}return t=>{if(t>=o[0])return r[0];for(let s=1;s<o.length;s++)if(o[s]<=t&&t<=o[s-1]){const e=(o[s]-t)/(o[s]-o[s-1]),a=(t-o[s-1])/(o[s]-o[s-1]),i=r[s-1].copyMult(e),l=r[s].copyMult(a);return i.add(l),i}}}fit(t,s){t=Matrix.fromArray(t),s=Matrix.fromArray(s);const e=t.rows,a=s.rows,o=Math.min(this._kernelNum,e),r=this._centers=t.sample(o);if(this._sigma=this._sigma_cand[0],this._lambda=this._lambda_cand[0],this._sigma_cand.length>1){let o=1/0;const i=[];for(let t=0;t<e;t++)i[t]=t%this._fold;const l=[];for(let t=0;t<a;t++)l[t]=t%this._fold;for(const e of this._sigma_cand){const a=this._kernel_gaussian(t,r,e),h=this._kernel_gaussian(s,r,e);for(let t=i.length-1;t>0;t--){let s=Math.floor(Math.random()*(t+1));[i[t],i[s]]=[i[s],i[t]]}for(let t=l.length-1;t>0;t--){let s=Math.floor(Math.random()*(t+1));[l[t],l[s]]=[l[s],l[t]]}const n=[];for(let t=0;t<this._fold;t++){const s=i.map((s=>s===t)),e=l.map((s=>s===t)),o=a.col(s),r=h.col(e),_=r.dot(r.t);_.div(r.cols);const c=o.mean(1);n.push(this._regularization_path(_,c))}for(const t of this._lambda_cand){let s=0;for(let e=0;e<this._fold;e++){const o=i.map((t=>t!==e)),r=l.map((t=>t!==e)),_=a.col(o),c=h.col(r),f=n[e](t);let m=c.tDot(f).copyMap((t=>t**2)).mean()/2;m-=_.tDot(f).mean(),s+=m}s/=this._fold,s<o&&(o=s,this._sigma=e,this._lambda=t)}}}const i=this._kernel_gaussian(t,r,this._sigma),l=this._kernel_gaussian(s,r,this._sigma),h=l.dot(l.t);h.div(a);const n=i.mean(1);this._kw=this._regularization_path(h,n)(this._lambda)}predict(t){t=Matrix.fromArray(t);return this._kernel_gaussian(t,this._centers,this._sigma).tDot(this._kw).value}}export class LSIFCPD{constructor(t,s,e){this._window=t,this._take=s||Math.max(1,Math.floor(t/2)),this._lag=e||Math.max(1,Math.floor(this._take/2))}predict(t){const s=[];for(let e=0;e<t.length-this._window+1;e++)s.push(t.slice(e,e+this._window).flat());const e=[];for(let t=0;t<s.length-this._take-this._lag+1;t++){const a=Matrix.fromArray(s.slice(t,t+this._take)),o=Matrix.fromArray(s.slice(t+this._lag,t+this._take+this._lag)),r=new LSIF([100,10,1,.1,.01,.001],[100,10,1,.1,.01,.001],3,100);let i=0;r.fit(a,o);let l=r.predict(o);for(let t=0;t<l.length;t++)i+=(l[t]-1)**2/l.length;r.fit(o,a),l=r.predict(a);for(let t=0;t<l.length;t++)i+=(l[t]-1)**2/l.length;e.push(i)}return e}}