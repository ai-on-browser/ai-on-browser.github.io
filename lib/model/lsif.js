import Matrix from"../util/matrix.js";export default class LSIF{constructor(t,s,a,r){this._sigma_cand=t,this._lambda_cand=s,this._fold=a,this._kernelNum=r}_kernel_gaussian(t,s,a){const r=[];for(let e=0;e<s.rows;e++){const i=[];for(let r=0;r<t.rows;r++){const o=Matrix.sub(s.row(e),t.row(r));i.push(Math.exp(-o.reduce(((t,s)=>t+s**2),0)/(2*a**2)))}r.push(i)}return Matrix.fromArray(r)}_regularization_path(t,s){const a=s.rows;t.add(Matrix.eye(a,a,1e-12));const r=s.argmax(0).toScaler(),e=[s.at(r,0)],i=[Matrix.zeros(a,1)],o=[];for(let t=0;t<a;t++)t!==r&&o.push(t);for(;e[e.length-1]>0;){const r=Matrix.zeros(o.length,a);for(let t=0;t<o.length;t++)r.set(t,o[t],-1);const l=Matrix.zeros(a+o.length,a+o.length);l.set(0,0,t),l.set(a,0,r),l.set(0,a,r.t);const n=l.solve(Matrix.resize(s,a+o.length,s.cols)),h=l.solve(Matrix.resize(Matrix.ones(a,1),a+o.length,1));if(h.some((t=>t<=0)))e.push(0),i.push(n.slice(0,a));else{let t=-1,s=-1/0;for(let r=0;r<a+o.length;r++){const a=n.at(r,0)/h.at(r,0);h.at(r,0)>0&&a>s&&(t=r,s=a)}s=Math.max(0,s),e.push(s),h.mult(s),n.sub(h),i.push(n.slice(0,a)),t<a?o.indexOf(t)<0&&(o.push(t),o.sort(((t,s)=>t-s))):o.splice(t-a,1)}}return t=>{if(t>=e[0])return i[0];for(let s=1;s<e.length;s++)if(e[s]<=t&&t<=e[s-1]){const a=(e[s]-t)/(e[s]-e[s-1]),r=(t-e[s-1])/(e[s]-e[s-1]),o=Matrix.mult(i[s-1],a),l=Matrix.mult(i[s],r);return o.add(l),o}}}fit(t,s){t=Matrix.fromArray(t),s=Matrix.fromArray(s);const a=t.rows,r=s.rows,e=Math.min(this._kernelNum,a),i=this._centers=t.sample(e)[0];if(this._sigma=this._sigma_cand[0],this._lambda=this._lambda_cand[0],this._sigma_cand.length>1){let e=1/0;const o=Array.from({length:a},((t,s)=>s%this._fold)),l=Array.from({length:r},((t,s)=>s%this._fold));for(const a of this._sigma_cand){const r=this._kernel_gaussian(t,i,a),n=this._kernel_gaussian(s,i,a);for(let t=o.length-1;t>0;t--){let s=Math.floor(Math.random()*(t+1));[o[t],o[s]]=[o[s],o[t]]}for(let t=l.length-1;t>0;t--){let s=Math.floor(Math.random()*(t+1));[l[t],l[s]]=[l[s],l[t]]}const h=[];for(let t=0;t<this._fold;t++){const s=o.map((s=>s===t)),a=l.map((s=>s===t)),e=r.col(s),i=n.col(a),_=i.dot(i.t);_.div(i.cols);const c=e.mean(1);h.push(this._regularization_path(_,c))}for(const t of this._lambda_cand){let s=0;for(let a=0;a<this._fold;a++){const e=o.map((t=>t!==a)),i=l.map((t=>t!==a)),_=r.col(e),c=n.col(i),m=h[a](t);let f=Matrix.map(c.tDot(m),(t=>t**2)).mean()/2;f-=_.tDot(m).mean(),s+=f}s/=this._fold,s<e&&(e=s,this._sigma=a,this._lambda=t)}}}const o=this._kernel_gaussian(t,i,this._sigma),l=this._kernel_gaussian(s,i,this._sigma),n=l.dot(l.t);n.div(r);const h=o.mean(1);this._kw=this._regularization_path(n,h)(this._lambda)}predict(t){t=Matrix.fromArray(t);return this._kernel_gaussian(t,this._centers,this._sigma).tDot(this._kw).value}}