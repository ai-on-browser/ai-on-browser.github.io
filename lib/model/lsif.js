import Matrix from"../util/matrix.js";export class LSIF{constructor(t,s,a,e){this._sigma_cand=t,this._lambda_cand=s,this._fold=a,this._kernelNum=e}_kernel_gaussian(t,s,a){const e=[];for(let r=0;r<s.rows;r++){const i=[];for(let e=0;e<t.rows;e++){const o=Matrix.sub(s.row(r),t.row(e));i.push(Math.exp(-o.reduce(((t,s)=>t+s**2),0)/(2*a**2)))}e.push(i)}return Matrix.fromArray(e)}_regularization_path(t,s){const a=s.rows;t.add(Matrix.eye(a,a,1e-12));const e=s.argmax(0).toScaler(),r=[s.at(e,0)],i=[Matrix.zeros(a,1)],o=[];for(let t=0;t<a;t++)t!==e&&o.push(t);for(;r[r.length-1]>0;){const e=Matrix.zeros(o.length,a);for(let t=0;t<o.length;t++)e.set(t,o[t],-1);const l=Matrix.zeros(a+o.length,a+o.length);l.set(0,0,t),l.set(a,0,e),l.set(0,a,e.t);const n=l.solve(Matrix.resize(s,a+o.length,s.cols)),h=l.solve(Matrix.resize(Matrix.ones(a,1),a+o.length,1));if(h.some((t=>t<=0)))r.push(0),i.push(n.slice(0,a));else{let t=-1,s=-1/0;for(let e=0;e<a+o.length;e++){const a=n.at(e,0)/h.at(e,0);h.at(e,0)>0&&a>s&&(t=e,s=a)}s=Math.max(0,s),r.push(s),h.mult(s),n.sub(h),i.push(n.slice(0,a)),t<a?o.indexOf(t)<0&&(o.push(t),o.sort(((t,s)=>t-s))):o.splice(t-a,1)}}return t=>{if(t>=r[0])return i[0];for(let s=1;s<r.length;s++)if(r[s]<=t&&t<=r[s-1]){const a=(r[s]-t)/(r[s]-r[s-1]),e=(t-r[s-1])/(r[s]-r[s-1]),o=Matrix.mult(i[s-1],a),l=Matrix.mult(i[s],e);return o.add(l),o}}}fit(t,s){t=Matrix.fromArray(t),s=Matrix.fromArray(s);const a=t.rows,e=s.rows,r=Math.min(this._kernelNum,a),i=this._centers=t.sample(r)[0];if(this._sigma=this._sigma_cand[0],this._lambda=this._lambda_cand[0],this._sigma_cand.length>1){let r=1/0;const o=[];for(let t=0;t<a;t++)o[t]=t%this._fold;const l=[];for(let t=0;t<e;t++)l[t]=t%this._fold;for(const a of this._sigma_cand){const e=this._kernel_gaussian(t,i,a),n=this._kernel_gaussian(s,i,a);for(let t=o.length-1;t>0;t--){let s=Math.floor(Math.random()*(t+1));[o[t],o[s]]=[o[s],o[t]]}for(let t=l.length-1;t>0;t--){let s=Math.floor(Math.random()*(t+1));[l[t],l[s]]=[l[s],l[t]]}const h=[];for(let t=0;t<this._fold;t++){const s=o.map((s=>s===t)),a=l.map((s=>s===t)),r=e.col(s),i=n.col(a),_=i.dot(i.t);_.div(i.cols);const c=r.mean(1);h.push(this._regularization_path(_,c))}for(const t of this._lambda_cand){let s=0;for(let a=0;a<this._fold;a++){const r=o.map((t=>t!==a)),i=l.map((t=>t!==a)),_=e.col(r),c=n.col(i),f=h[a](t);let m=Matrix.map(c.tDot(f),(t=>t**2)).mean()/2;m-=_.tDot(f).mean(),s+=m}s/=this._fold,s<r&&(r=s,this._sigma=a,this._lambda=t)}}}const o=this._kernel_gaussian(t,i,this._sigma),l=this._kernel_gaussian(s,i,this._sigma),n=l.dot(l.t);n.div(e);const h=o.mean(1);this._kw=this._regularization_path(n,h)(this._lambda)}predict(t){t=Matrix.fromArray(t);return this._kernel_gaussian(t,this._centers,this._sigma).tDot(this._kw).value}}export class LSIFCPD{constructor(t,s,a){this._window=t,this._take=s||Math.max(1,Math.floor(t/2)),this._lag=a||Math.max(1,Math.floor(this._take/2))}predict(t){const s=[];for(let a=0;a<t.length-this._window+1;a++)s.push(t.slice(a,a+this._window).flat());const a=[];for(let t=0;t<s.length-this._take-this._lag+1;t++){const e=Matrix.fromArray(s.slice(t,t+this._take)),r=Matrix.fromArray(s.slice(t+this._lag,t+this._take+this._lag)),i=new LSIF([100,10,1,.1,.01,.001],[100,10,1,.1,.01,.001],3,100);let o=0;i.fit(e,r);let l=i.predict(r);for(let t=0;t<l.length;t++)o+=(l[t]-1)**2/l.length;i.fit(r,e),l=i.predict(e);for(let t=0;t<l.length;t++)o+=(l[t]-1)**2/l.length;a.push(o)}return a}}