import Matrix from"../util/matrix.js";export default class LSIF{constructor(t,s,a,r){this._sigma_cand=t,this._lambda_cand=s,this._fold=a,this._kernelNum=r}_kernel_gaussian(t,s,a){const r=[];for(let e=0;e<s.rows;e++){const o=[];for(let r=0;r<t.rows;r++){const i=Matrix.sub(s.row(e),t.row(r));o.push(Math.exp(-i.reduce(((t,s)=>t+s**2),0)/(2*a**2)))}r.push(o)}return Matrix.fromArray(r)}_regularization_path(t,s){const a=s.rows;t.add(Matrix.eye(a,a,1e-12));const r=s.argmax(0).toScaler(),e=[s.at(r,0)],o=[Matrix.zeros(a,1)],i=[];for(let t=0;t<a;t++)t!==r&&i.push(t);for(;e[e.length-1]>0;){const r=Matrix.zeros(i.length,a);for(let t=0;t<i.length;t++)r.set(t,i[t],-1);const l=Matrix.zeros(a+i.length,a+i.length);l.set(0,0,t),l.set(a,0,r),l.set(0,a,r.t);const n=l.solve(Matrix.resize(s,a+i.length,s.cols)),h=l.solve(Matrix.resize(Matrix.ones(a,1),a+i.length,1));if(h.some((t=>t<=0)))e.push(0),o.push(n.slice(0,a));else{let t=-1,s=-1/0;for(let r=0;r<a+i.length;r++){const a=n.at(r,0)/h.at(r,0);h.at(r,0)>0&&a>s&&(t=r,s=a)}s=Math.max(0,s),e.push(s),h.mult(s),n.sub(h),o.push(n.slice(0,a)),t<a?i.indexOf(t)<0&&(i.push(t),i.sort(((t,s)=>t-s))):i.splice(t-a,1)}}return t=>{if(t>=e[0])return o[0];for(let s=1;s<e.length;s++)if(e[s]<=t&&t<=e[s-1]){const a=(e[s]-t)/(e[s]-e[s-1]),r=(t-e[s-1])/(e[s]-e[s-1]),i=Matrix.mult(o[s-1],a),l=Matrix.mult(o[s],r);return i.add(l),i}}}fit(t,s){t=Matrix.fromArray(t),s=Matrix.fromArray(s);const a=t.rows,r=s.rows,e=Math.min(this._kernelNum,a),o=this._centers=t.sample(e)[0];if(this._sigma=this._sigma_cand[0],this._lambda=this._lambda_cand[0],this._sigma_cand.length>1){let e=1/0;const i=[];for(let t=0;t<a;t++)i[t]=t%this._fold;const l=[];for(let t=0;t<r;t++)l[t]=t%this._fold;for(const a of this._sigma_cand){const r=this._kernel_gaussian(t,o,a),n=this._kernel_gaussian(s,o,a);for(let t=i.length-1;t>0;t--){let s=Math.floor(Math.random()*(t+1));[i[t],i[s]]=[i[s],i[t]]}for(let t=l.length-1;t>0;t--){let s=Math.floor(Math.random()*(t+1));[l[t],l[s]]=[l[s],l[t]]}const h=[];for(let t=0;t<this._fold;t++){const s=i.map((s=>s===t)),a=l.map((s=>s===t)),e=r.col(s),o=n.col(a),_=o.dot(o.t);_.div(o.cols);const c=e.mean(1);h.push(this._regularization_path(_,c))}for(const t of this._lambda_cand){let s=0;for(let a=0;a<this._fold;a++){const e=i.map((t=>t!==a)),o=l.map((t=>t!==a)),_=r.col(e),c=n.col(o),m=h[a](t);let f=Matrix.map(c.tDot(m),(t=>t**2)).mean()/2;f-=_.tDot(m).mean(),s+=f}s/=this._fold,s<e&&(e=s,this._sigma=a,this._lambda=t)}}}const i=this._kernel_gaussian(t,o,this._sigma),l=this._kernel_gaussian(s,o,this._sigma),n=l.dot(l.t);n.div(r);const h=i.mean(1);this._kw=this._regularization_path(n,h)(this._lambda)}predict(t){t=Matrix.fromArray(t);return this._kernel_gaussian(t,this._centers,this._sigma).tDot(this._kw).value}}