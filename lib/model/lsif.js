var N=Object.defineProperty;var C=(A,n)=>N(A,"name",{value:n,configurable:!0});import c from"../util/matrix.js";export default class j{static{C(this,"LSIF")}constructor(n,l,t,d){this._sigma_cand=n,this._lambda_cand=l,this._fold=t,this._kernelNum=d}_kernel_gaussian(n,l,t){const d=[];for(let e=0;e<l.rows;e++){const m=[];for(let i=0;i<n.rows;i++){const a=c.sub(l.row(e),n.row(i));m.push(Math.exp(-a.reduce((s,u)=>s+u**2,0)/(2*t**2)))}d.push(m)}return c.fromArray(d)}_regularization_path(n,l){const t=l.rows;n.add(c.eye(t,t,1e-12));const d=l.argmax(0).toScaler(),e=[l.at(d,0)],m=[c.zeros(t,1)],i=[];for(let a=0;a<t;a++)a!==d&&i.push(a);for(;e[e.length-1]>0;){const a=c.zeros(i.length,t);for(let o=0;o<i.length;o++)a.set(o,i[o],-1);const s=c.zeros(t+i.length,t+i.length);s.set(0,0,n),s.set(t,0,a),s.set(0,t,a.t);const u=s.solve(c.resize(l,t+i.length,l.cols)),g=s.solve(c.resize(c.ones(t,1),t+i.length,1));if(g.some(o=>o<=0))e.push(0),m.push(u.slice(0,t));else{let o=-1,h=-1/0;for(let _=0;_<t+i.length;_++){const p=u.at(_,0)/g.at(_,0);g.at(_,0)>0&&p>h&&(o=_,h=p)}h=Math.max(0,h),e.push(h),g.mult(h),u.sub(g),m.push(u.slice(0,t)),o<t?i.includes(o)||(i.push(o),i.sort((_,p)=>_-p)):i.splice(o-t,1)}}return a=>{if(a>=e[0])return m[0];for(let s=1;s<e.length;s++)if(e[s]<=a&&a<=e[s-1]){const u=(e[s]-a)/(e[s]-e[s-1]),g=(a-e[s-1])/(e[s]-e[s-1]),o=c.mult(m[s-1],u),h=c.mult(m[s],g);return o.add(h),o}}}fit(n,l){n=c.fromArray(n),l=c.fromArray(l);const t=n.rows,d=l.rows,e=Math.min(this._kernelNum,t),m=this._centers=n.sample(e)[0];if(this._sigma=this._sigma_cand[0],this._lambda=this._lambda_cand[0],this._sigma_cand.length>1){let g=1/0;const o=Array.from({length:t},(_,p)=>p%this._fold),h=Array.from({length:d},(_,p)=>p%this._fold);for(const _ of this._sigma_cand){const p=this._kernel_gaussian(n,m,_),D=this._kernel_gaussian(l,m,_);for(let r=o.length-1;r>0;r--){let f=Math.floor(Math.random()*(r+1));[o[r],o[f]]=[o[f],o[r]]}for(let r=h.length-1;r>0;r--){let f=Math.floor(Math.random()*(r+1));[h[r],h[f]]=[h[f],h[r]]}const I=[];for(let r=0;r<this._fold;r++){const f=o.map(b=>b===r),k=h.map(b=>b===r),z=p.col(f),w=D.col(k),v=w.dot(w.t);v.div(w.cols);const M=z.mean(1);I.push(this._regularization_path(v,M))}for(const r of this._lambda_cand){let f=0;for(let k=0;k<this._fold;k++){const z=o.map(y=>y!==k),w=h.map(y=>y!==k),v=p.col(z),M=D.col(w),b=I[k](r);let S=c.map(M.tDot(b),y=>y**2).mean()/2;S-=v.tDot(b).mean(),f+=S}f/=this._fold,f<g&&(g=f,this._sigma=_,this._lambda=r)}}}const i=this._kernel_gaussian(n,m,this._sigma),a=this._kernel_gaussian(l,m,this._sigma),s=a.dot(a.t);s.div(d);const u=i.mean(1);this._kw=this._regularization_path(s,u)(this._lambda)}predict(n){return n=c.fromArray(n),this._kernel_gaussian(n,this._centers,this._sigma).tDot(this._kw).value}}
