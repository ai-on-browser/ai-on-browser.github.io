import NeuralNetwork from"./neuralnetwork.js";export default class Word2Vec{constructor(s,r,t,o,e){if(this._words=[null],this._wordsIdx={},this._wordsNumber=null,this._n=r,this._method=s,Array.isArray(t)){this._words=[null,...new Set(t)],this._wordsNumber=this._words.length;for(let s=1;s<this._wordsNumber;s++)this._wordsIdx[this._words[s]]=s}else this._wordsNumber=t;this._layers=[{type:"input",name:"in"}],this._layers.push({type:"full",out_size:o,name:"reduce"}),this._layers.push({type:"full",out_size:this._wordsNumber}),this._model=NeuralNetwork.fromObject(this._layers,"mse",e),this._epoch=0}get epoch(){return this._epoch}fit(s,r,t,o){const e=[];for(const r of s)this._wordsIdx.hasOwnProperty(r)?e.push(this._wordsIdx[r]):this._wordsNumber<=this._words.length?e.push(0):(this._words.push(r),e.push(this._wordsIdx[r]=this._words.length-1));const h=[],i=[];if("CBOW"===this._method)for(let s=0;s<e.length;s++){const r=Array(this._wordsNumber).fill(0),t=Array(this._wordsNumber).fill(0);for(let t=1;t<=this._n;t++)s-t>=0&&r[e[s-t]]++,s+t<e.length&&r[e[s+t]]++;t[e[s]]=1,h.push(r),i.push(t)}else for(let s=0;s<e.length;s++){const r=Array(this._wordsNumber).fill(0);r[e[s]]=1;for(let t=1;t<=this._n;t++){if(s-t>=0){const o=Array(this._wordsNumber).fill(0);o[e[s-t]]=1,h.push(r),i.push(o)}if(s+t<e.length){const o=Array(this._wordsNumber).fill(0);o[e[s+t]]=1,h.push(r),i.push(o)}}}const l=this._model.fit(h,i,r,t,o);return this._epoch+=r,l[0]}predict(s){const r=[];for(const t of s){const s=Array(this._wordsNumber).fill(0);this._wordsIdx.hasOwnProperty(t)?s[this._wordsIdx[t]]=1:s[0]=1,r.push(s)}return this._model.calc(r).toArray()}reduce(s){const r=[];for(const t of s){const s=Array(this._wordsNumber).fill(0);this._wordsIdx.hasOwnProperty(t)?s[this._wordsIdx[t]]=1:s[0]=1,r.push(s)}return this._model.calc(r,null,["reduce"]).reduce.toArray()}}