var w=Object.defineProperty;var c=(n,o)=>w(n,"name",{value:o,configurable:!0});import p from"./neuralnetwork.js";export default class a{static{c(this,"Word2Vec")}constructor(o,e,d,i,s){if(this._words=[null],this._wordsIdx={},this._wordsNumber=null,this._n=e,this._method=o,Array.isArray(d)){this._words=[null,...new Set(d)],this._wordsNumber=this._words.length;for(let h=1;h<this._wordsNumber;h++)this._wordsIdx[this._words[h]]=h}else this._wordsNumber=d;this._layers=[{type:"input",name:"in"}],this._layers.push({type:"full",out_size:i,name:"reduce"}),this._layers.push({type:"full",out_size:this._wordsNumber}),this._model=p.fromObject(this._layers,"mse",s),this._epoch=0}get epoch(){return this._epoch}fit(o,e,d,i){const s=[];for(const t of o)Object.hasOwn(this._wordsIdx,t)?s.push(this._wordsIdx[t]):this._wordsNumber<=this._words.length?s.push(0):(this._words.push(t),s.push(this._wordsIdx[t]=this._words.length-1));const h=[],u=[];if(this._method==="CBOW")for(let t=0;t<s.length;t++){const _=Array(this._wordsNumber).fill(0),l=Array(this._wordsNumber).fill(0);for(let r=1;r<=this._n;r++)t-r>=0&&_[s[t-r]]++,t+r<s.length&&_[s[t+r]]++;l[s[t]]=1,h.push(_),u.push(l)}else for(let t=0;t<s.length;t++){const _=Array(this._wordsNumber).fill(0);_[s[t]]=1;for(let l=1;l<=this._n;l++){if(t-l>=0){const r=Array(this._wordsNumber).fill(0);r[s[t-l]]=1,h.push(_),u.push(r)}if(t+l<s.length){const r=Array(this._wordsNumber).fill(0);r[s[t+l]]=1,h.push(_),u.push(r)}}}const f=this._model.fit(h,u,e,d,i);return this._epoch+=e,f[0]}predict(o){const e=[];for(const i of o){const s=Array(this._wordsNumber).fill(0);Object.hasOwn(this._wordsIdx,i)?s[this._wordsIdx[i]]=1:s[0]=1,e.push(s)}return this._model.calc(e).toArray()}reduce(o){const e=[];for(const i of o){const s=Array(this._wordsNumber).fill(0);Object.hasOwn(this._wordsIdx,i)?s[this._wordsIdx[i]]=1:s[0]=1,e.push(s)}return this._model.calc(e,null,["reduce"]).reduce.toArray()}}
