var f=Object.defineProperty;var c=(n,o)=>f(n,"name",{value:o,configurable:!0});import p from"./neuralnetwork.js";export default class a{static{c(this,"Word2Vec")}constructor(o,e,l,i,s){if(this._words=[null],this._wordsIdx={},this._wordsNumber=null,this._n=e,this._method=o,Array.isArray(l)){this._words=[null,...new Set(l)],this._wordsNumber=this._words.length;for(let h=1;h<this._wordsNumber;h++)this._wordsIdx[this._words[h]]=h}else this._wordsNumber=l;this._layers=[{type:"input",name:"in"}],this._layers.push({type:"full",out_size:i,name:"reduce"}),this._layers.push({type:"full",out_size:this._wordsNumber}),this._model=p.fromObject(this._layers,"mse",s),this._epoch=0}get epoch(){return this._epoch}fit(o,e,l,i){const s=[];for(const t of o)Object.hasOwn(this._wordsIdx,t)?s.push(this._wordsIdx[t]):this._wordsNumber<=this._words.length?s.push(0):(this._words.push(t),this._wordsIdx[t]=this._words.length-1,s.push(this._wordsIdx[t]));const h=[],u=[];if(this._method==="CBOW")for(let t=0;t<s.length;t++){const _=Array(this._wordsNumber).fill(0),d=Array(this._wordsNumber).fill(0);for(let r=1;r<=this._n;r++)t-r>=0&&_[s[t-r]]++,t+r<s.length&&_[s[t+r]]++;d[s[t]]=1,h.push(_),u.push(d)}else for(let t=0;t<s.length;t++){const _=Array(this._wordsNumber).fill(0);_[s[t]]=1;for(let d=1;d<=this._n;d++){if(t-d>=0){const r=Array(this._wordsNumber).fill(0);r[s[t-d]]=1,h.push(_),u.push(r)}if(t+d<s.length){const r=Array(this._wordsNumber).fill(0);r[s[t+d]]=1,h.push(_),u.push(r)}}}const w=this._model.fit(h,u,e,l,i);return this._epoch+=e,w[0]}predict(o){const e=[];for(const i of o){const s=Array(this._wordsNumber).fill(0);Object.hasOwn(this._wordsIdx,i)?s[this._wordsIdx[i]]=1:s[0]=1,e.push(s)}return this._model.calc(e).toArray()}reduce(o){const e=[];for(const i of o){const s=Array(this._wordsNumber).fill(0);Object.hasOwn(this._wordsIdx,i)?s[this._wordsIdx[i]]=1:s[0]=1,e.push(s)}return this._model.calc(e,null,["reduce"]).reduce.toArray()}}
