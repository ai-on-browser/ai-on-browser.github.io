import NeuralNetwork from"./neuralnetwork.js";export default class Word2Vec{constructor(s,r,t,e,o){if(this._words=[null],this._wordsIdx={},this._wordsNumber=null,this._n=r,this._method=s,Array.isArray(t)){this._words=[null,...new Set(t)],this._wordsNumber=this._words.length;for(let s=1;s<this._wordsNumber;s++)this._wordsIdx[this._words[s]]=s}else this._wordsNumber=t;this._layers=[{type:"input",name:"in"}],this._layers.push({type:"full",out_size:e,name:"reduce"}),this._layers.push({type:"full",out_size:this._wordsNumber}),this._model=NeuralNetwork.fromObject(this._layers,"mse",o),this._epoch=0}get epoch(){return this._epoch}fit(s,r,t,e){const o=[];for(const r of s)Object.hasOwn(this._wordsIdx,r)?o.push(this._wordsIdx[r]):this._wordsNumber<=this._words.length?o.push(0):(this._words.push(r),o.push(this._wordsIdx[r]=this._words.length-1));const h=[],i=[];if("CBOW"===this._method)for(let s=0;s<o.length;s++){const r=Array(this._wordsNumber).fill(0),t=Array(this._wordsNumber).fill(0);for(let t=1;t<=this._n;t++)s-t>=0&&r[o[s-t]]++,s+t<o.length&&r[o[s+t]]++;t[o[s]]=1,h.push(r),i.push(t)}else for(let s=0;s<o.length;s++){const r=Array(this._wordsNumber).fill(0);r[o[s]]=1;for(let t=1;t<=this._n;t++){if(s-t>=0){const e=Array(this._wordsNumber).fill(0);e[o[s-t]]=1,h.push(r),i.push(e)}if(s+t<o.length){const e=Array(this._wordsNumber).fill(0);e[o[s+t]]=1,h.push(r),i.push(e)}}}const l=this._model.fit(h,i,r,t,e);return this._epoch+=r,l[0]}predict(s){const r=[];for(const t of s){const s=Array(this._wordsNumber).fill(0);Object.hasOwn(this._wordsIdx,t)?s[this._wordsIdx[t]]=1:s[0]=1,r.push(s)}return this._model.calc(r).toArray()}reduce(s){const r=[];for(const t of s){const s=Array(this._wordsNumber).fill(0);Object.hasOwn(this._wordsIdx,t)?s[this._wordsIdx[t]]=1:s[0]=1,r.push(s)}return this._model.calc(r,null,["reduce"]).reduce.toArray()}}