import Matrix from"../util/matrix.js";class GaussianKernel{constructor(t=1,s=1,r=.1){this._a=t,this._b=s,this._e=r}_calc(t,s){const r=Matrix.sub(t,s).reduce(((t,s)=>t+s*s),0);return this._a*Math.exp(-r/(2*this._b))}_grad(t,s,r){const i=Matrix.sub(t,s);return i.mult(-this._a*r/this._b),i}calc(t,s){s||(s=t);const r=t.rows,i=s.rows,a=new Matrix(r,i);for(let h=0;h<r;h++){const r=t.row(h);for(let t=0;t<i;t++){const i=this._calc(r,s.row(t));a.set(h,t,i)}}return a}grad(t,s){const r=t.rows,i=new Matrix(r,r);for(let a=0;a<r;a++){const h=t.row(a);for(let e=0;e<r;e++){const r=this._grad(h,t.row(e),s.at(a,e));i.set(a,e,r.value)}}return i}update(t,s,r){if(0===this._e)return;const i=t.rows,a=new Matrix(i,i);for(let r=0;r<i;r++){const h=t.row(r);for(let e=0;e<i;e++){const i=Matrix.sub(h,t.row(e));i.map((t=>t**2));const o=-this._a*i.sum()/(2*this._b**2);a.set(r,e,o*s.at(r,e))}}const h=Matrix.mult(r,a.t).sum();this._b=Math.exp(Math.log(this._b)+this._e/i*h),0===this._b&&(this._b=1e-8)}}export default class GPLVM{constructor(t,s,r=1,i=.005,a=.2,h="gaussian",e=[]){this._rd=t,this._alpha=s,"gaussian"===h&&(this._kernel=new GaussianKernel(...e,a)),this._ez=r,this._ea=i}init(t){this._x=Matrix.fromArray(t),this._z=Matrix.randn(t.length,this._rd,0,.01),this._s=this._x.dot(this._x.t)}fit(){const t=this._x.rows,s=this._kernel.calc(this._z),r=Matrix.add(s,Matrix.eye(t,t,this._alpha)),i=r.inv(),a=i.dot(this._s).dot(i);a.sub(Matrix.mult(i,this._x.cols)),a.div(2);const h=this._kernel.grad(this._z,r),e=new Matrix(t,this._rd);for(let s=0;s<t;s++){const r=Matrix.zeros(1,this._rd);for(let i=0;i<t;i++){const t=new Matrix(1,this._rd,h.at(s,i));t.mult(a.at(s,i)),r.add(t)}e.set(s,0,r)}e.mult(this._ez/t),this._kernel.update(this._z,s,a),this._z.add(e),this._alpha=Math.exp(Math.log(this._alpha)+this._ea/t*a.trace()*this._alpha)}llh(){const t=this._x.rows,s=this._kernel.calc(this._z),r=Matrix.add(s,Matrix.eye(t,t,this._alpha));return-this._x.length*Math.log(2*Math.PI)/2-this._x.cols*Math.log(r.det())/2-this._x.cols*r.solve(this._s).trace()/2}predict(){return this._z.toArray()}reconstruct(t){t=Matrix.fromArray(t);const s=this._z.rows,r=this._kernel.calc(this._z),i=Matrix.add(r,Matrix.eye(s,s,this._alpha));return this._kernel.calc(t,this._z).dot(i.solve(this._x)).toArray()}}