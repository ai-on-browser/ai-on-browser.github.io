var f=Object.defineProperty;var u=(d,t)=>f(d,"name",{value:t,configurable:!0});import r from"../util/matrix.js";class p{static{u(this,"GaussianKernel")}constructor(t=1,i=1,s=.1){this._a=t,this._b=i,this._e=s}_calc(t,i){const s=r.sub(t,i).reduce((h,o)=>h+o*o,0);return this._a*Math.exp(-s/(2*this._b))}_grad(t,i,s){const h=r.sub(t,i);return h.mult(-this._a*s/this._b),h}calc(t,i){i||(i=t);const s=t.rows,h=i.rows,o=new r(s,h);for(let n=0;n<s;n++){const e=t.row(n);for(let a=0;a<h;a++){const _=this._calc(e,i.row(a));o.set(n,a,_)}}return o}grad(t,i){const s=t.rows,h=new r(s,s);for(let o=0;o<s;o++){const n=t.row(o);for(let e=0;e<s;e++){const a=this._grad(n,t.row(e),i.at(o,e));h.set(o,e,a.value)}}return h}update(t,i,s){if(this._e===0)return;const h=t.rows,o=new r(h,h);for(let e=0;e<h;e++){const a=t.row(e);for(let _=0;_<h;_++){const c=r.sub(a,t.row(_));c.map(w=>w**2);const l=-(this._a*c.sum())/(2*this._b**2);o.set(e,_,l*i.at(e,_))}}const n=r.mult(s,o.t).sum();this._b=Math.exp(Math.log(this._b)+this._e/h*n),this._b===0&&(this._b=1e-8)}}export default class g{static{u(this,"GPLVM")}constructor(t,i,s=1,h=.005,o=.2,n="gaussian"){this._rd=t,this._alpha=i,typeof n=="string"&&(n={name:n}),this._kernel=new p(n.a,n.b,o),this._ez=s,this._ea=h}init(t){this._x=r.fromArray(t),this._z=r.randn(t.length,this._rd,0,.01),this._s=this._x.dot(this._x.t)}fit(){const t=this._x.rows,i=this._kernel.calc(this._z),s=r.add(i,r.eye(t,t,this._alpha)),h=s.inv(),o=h.dot(this._s).dot(h);o.sub(r.mult(h,this._x.cols)),o.div(2);const n=this._kernel.grad(this._z,s),e=new r(t,this._rd);for(let a=0;a<t;a++){const _=r.zeros(1,this._rd);for(let c=0;c<t;c++){const l=new r(1,this._rd,n.at(a,c));l.mult(o.at(a,c)),_.add(l)}e.set(a,0,_)}e.mult(this._ez/t),this._kernel.update(this._z,i,o),this._z.add(e),this._alpha=Math.exp(Math.log(this._alpha)+this._ea/t*o.trace()*this._alpha)}llh(){const t=this._x.rows,i=this._kernel.calc(this._z),s=r.add(i,r.eye(t,t,this._alpha));return-this._x.length*Math.log(2*Math.PI)/2-this._x.cols*Math.log(s.det())/2-this._x.cols*s.solve(this._s).trace()/2}predict(){return this._z.toArray()}reconstruct(t){t=r.fromArray(t);const i=this._z.rows,s=this._kernel.calc(this._z),h=r.add(s,r.eye(i,i,this._alpha));return this._kernel.calc(t,this._z).dot(h.solve(this._x)).toArray()}}
