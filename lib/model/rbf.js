var o=Object.defineProperty;var n=(a,e)=>o(a,"name",{value:e,configurable:!0});import u from"../util/matrix.js";const l={linear:n(()=>(a,e)=>Math.sqrt(a.reduce((s,t,r)=>s+(t-e[r])**2,0)),"linear"),gaussian:n(a=>(e,s)=>Math.exp(-e.reduce((t,r,i)=>t+(r-s[i])**2,0)*a**2),"gaussian"),multiquadric:n(a=>(e,s)=>Math.sqrt(1+e.reduce((t,r,i)=>t+(r-s[i])**2,0)*a**2),"multiquadric"),"inverse quadratic":n(a=>(e,s)=>1/(1+e.reduce((t,r,i)=>t+(r-s[i])**2,0)*a**2),"inverse quadratic"),"inverse multiquadric":n(a=>(e,s)=>1/Math.sqrt(1+e.reduce((t,r,i)=>t+(r-s[i])**2,0)*a**2),"inverse multiquadric"),"thin plate":n(()=>(a,e)=>{const s=a.reduce((t,r,i)=>t+(r-e[i])**2,0);return s===0?0:s*Math.log(Math.sqrt(s))},"thin plate"),bump:n(a=>(e,s)=>{const t=e.reduce((r,i,h)=>r+(i-s[h])**2,0);return Math.sqrt(t)<1/a?Math.exp(-1/(1-t*a**2)):0},"bump")};export default class d{static{n(this,"RadialBasisFunctionNetwork")}constructor(e="linear",s=1,t=0){this._f=l[e](s),(e==="linear"||e==="thin plate")&&t===0&&(t=1e-8),this._l=t}fit(e,s){this._x=e,this._w=[];const t=e.length,r=u.zeros(t,t);for(let i=0;i<t;i++)for(let h=i;h<t;h++){const c=this._f(e[i],e[h]);r.set(i,h,c),r.set(h,i,c)}this._l>0&&r.add(u.eye(t,t,this._l)),this._w=r.solve(u.fromArray(s))}predict(e){return e.map(s=>{let t=0;for(let r=0;r<this._x.length;r++)t+=this._w.at(r,0)*this._f(s,this._x[r]);return t})}}
