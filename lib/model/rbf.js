var u=Object.defineProperty;var n=(l,e)=>u(l,"name",{value:e,configurable:!0});import f from"../util/matrix.js";export default class c{static{n(this,"RadialBasisFunctionNetwork")}constructor(e="linear",a=1,r=0){const s=n((t,i)=>t.reduce((h,o,_)=>h+(o-i[_])**2,0),"d2");e==="linear"?(this._f=(t,i)=>Math.sqrt(s(t,i)),r===0&&(r=1e-8)):e==="gaussian"?this._f=(t,i)=>Math.exp(-s(t,i)*a**2):e==="multiquadric"?this._f=(t,i)=>Math.sqrt(1+s(t,i)*a**2):e==="inverse quadratic"?this._f=(t,i)=>1/(1+s(t,i)*a**2):e==="inverse multiquadric"?this._f=(t,i)=>1/Math.sqrt(1+s(t,i)*a**2):e==="thin plate"?(this._f=(t,i)=>{const h=s(t,i);return h===0?0:h*Math.log(Math.sqrt(h))},r===0&&(r=1e-8)):e==="bump"&&(this._f=(t,i)=>{const h=s(t,i);return Math.sqrt(h)<1/a?Math.exp(-1/(1-h*a**2)):0}),this._l=r}fit(e,a){this._x=e,this._w=[];const r=e.length,s=f.zeros(r,r);for(let t=0;t<r;t++)for(let i=t;i<r;i++){const h=this._f(e[t],e[i]);s.set(t,i,h),s.set(i,t,h)}this._l>0&&s.add(f.eye(r,r,this._l)),this._w=s.solve(f.fromArray(a))}predict(e){return e.map(a=>{let r=0;for(let s=0;s<this._x.length;s++)r+=this._w.at(s,0)*this._f(a,this._x[s]);return r})}}
