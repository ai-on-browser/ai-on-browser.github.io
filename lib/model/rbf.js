import Matrix from"../util/matrix.js";export default class RadialBasisFunctionNetwork{constructor(t="linear",s=1,i=0){const r=(t,s)=>t.reduce(((t,i,r)=>t+(i-s[r])**2),0);"linear"===t?(this._f=(t,s)=>Math.sqrt(r(t,s)),0===i&&(i=1e-8)):"gaussian"===t?this._f=(t,i)=>Math.exp(-r(t,i)*s**2):"multiquadric"===t?this._f=(t,i)=>Math.sqrt(1+r(t,i)*s**2):"inverse quadratic"===t?this._f=(t,i)=>1/(1+r(t,i)*s**2):"inverse multiquadric"===t?this._f=(t,i)=>1/Math.sqrt(1+r(t,i)*s**2):"thin plate"===t?(this._f=(t,s)=>{const i=r(t,s);return 0===i?0:i*Math.log(Math.sqrt(i))},0===i&&(i=1e-8)):"bump"===t&&(this._f=(t,i)=>{const e=r(t,i);return Math.sqrt(e)<1/s?Math.exp(-1/(1-e*s**2)):0}),this._l=i}fit(t,s){this._x=t,this._w=[];const i=t.length,r=Matrix.zeros(i,i);for(let s=0;s<i;s++)for(let e=s;e<i;e++){const i=this._f(t[s],t[e]);r.set(s,e,i),r.set(e,s,i)}this._l>0&&r.add(Matrix.eye(i,i,this._l)),this._w=r.solve(Matrix.fromArray(s))}predict(t){return t.map((t=>{let s=0;for(let i=0;i<this._x.length;i++)s+=this._w.at(i,0)*this._f(t,this._x[i]);return s}))}}