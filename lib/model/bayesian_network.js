const logGamma=t=>{let e=0;if(Number.isInteger(t))for(let s=2;s<t;s++)e+=Math.log(s);else if(Number.isInteger(t-.5)){const s=t-.5;e=Math.log(Math.sqrt(Math.PI))-Math.log(2)*s;for(let t=2*s-1;t>0;t-=2)e+=Math.log(t)}else if(t<.5)e=Math.log(Math.PI)-Math.log(Math.sin(Math.PI*t))-logGamma(1-t);else{const s=[676.5203681218851,-1259.1392167224028,771.3234287776531,-176.6150291621406,12.507343278686905,-.13857109526572012,9984369578019572e-21,1.5056327351493116e-7];t-=1,e=.9999999999998099;for(let h=0;h<s.length;h++)e+=s[h]/(t+h+1);const h=t+s.length-.5;e=Math.log(Math.sqrt(2*Math.PI))+Math.log(h)*(t+.5)-h+Math.log(e)}return e};class ArrayKeyMap{constructor(){this._map=new Map}get size(){return this._map.size}_getKey(t){if(this._map.has(t))return t;for(const e of this.keys())if(t.every(((t,s)=>t===e[s])))return e;return null}keys(){return this._map.keys()}has(t){return null!==this._getKey(t)}get(t){return this._map.get(this._getKey(t))}set(t,e){const s=this._getKey(t);return null!==s?this._map.set(s,e):this._map.set(t,e)}}export default class BayesianNetwork{constructor(t){this._th=null,this._graph=null,this._alpha=t,this._ess=1,this._n=0,this._cand=null,this._score_method="bdeu"}fit(t){if(!this._cand){this._n=t[0].length,this._cand=[];for(let e=0;e<this._n;e++)this._cand[e]=[...new Set(t.map((t=>t[e])))]}this._fitStructure(t),this._fitParameter(t)}_fitStructure(t){this._fitStructure_dp(t)}_fitStructure_dp(t){const e=[],s=[];for(let h=0;h<this._n;h++){e[h]=new ArrayKeyMap,s[h]=new ArrayKeyMap;for(let n=0;n<2**(this._n-1);n++){const r=n.toString(2).padStart(this._n-1,"0").split("");r.splice(h,0,"1");const i=r.map((t=>+t)),o=r.map(((t,e)=>[t,e])).filter((t=>"1"===t[0])).map((t=>t[1])),l=t.map((t=>o.map((e=>t[e])))),a=o.map((t=>this._cand[t])),_=[],c=[];for(let t=0;t<o.length;t++)o[t]===h?_[t]=c:(_[t]=[],c.push(t));const g=this._score(l,_,a);e[h].set(i,g);let f=[i,g];for(const t of s[h].keys()){if(t.reduce(((t,e)=>t+e),0)<=1)continue;let e=0;for(let s=0;s<i.length&&e<2;s++)1===i[s]&&0===t[s]?e++:0===i[s]&&1===t[s]&&(e=2);if(1!==e)continue;const n=s[h].get(t);f[1]<n[1]&&(f=n)}s[h].set(i,f)}}const h=new ArrayKeyMap;for(let t=1;t<2**this._n;t++){const e=t.toString(2).padStart(this._n,"0").split("").map((t=>+t)),n=e.reduce(((t,e)=>t+e),0);let r=[null,-1/0];for(let t=0;t<s.length;t++){let i=s[t].get(e)?.[1];if(i){if(n>1){const s=e.concat();s[t]=0,i+=h.get(s)[1]}i>r[1]&&(r=[t,i])}}h.set(e,r)}const n=Array(this._n).fill(1),r=[];for(let t=0;t<this._n;t++){const e=h.get(n)[0];r[t]=e,n[e]=0}this._graph=[];for(let t=r.length-1;t>=0;t--){n[r[t]]=1;const e=s[r[t]].get(n)[0],h=[];for(let s=0;s<e.length;s++)e[s]&&s!==r[t]&&h.push(s);this._graph[r[t]]=h}}_score(t,e=this._graph,s=this._cand){if("bdeu"===this._score_method)return this._bdeu(t,e,s)}_bdeu(t,e=this._graph,s=this._cand,h=!1){return h?this._logBDeu_exact(t,e,s):this._logBDeu_appro(t,e,s)}_logBDeu_exact(t,e=this._graph,s=this._cand){const h=this._count(t,e,s);let n=0;for(let t=0;t<h.length;t++)for(const e of h[t].keys()){const s=h[t].get(e);for(let e=0;e<s.length;e++){const r=this._ess/(h[t].size*s.length);n+=logGamma(r+s[e]),n-=logGamma(r)}const r=s.reduce(((t,e)=>t+e),0),i=this._ess/h[t].size;n+=logGamma(i),n-=logGamma(i+r)}return n}_logBDeu_appro(t,e=this._graph,s=this._cand){const h=this._count(t,e,s);let n=0;for(let t=0;t<h.length;t++)n+=this._ess*Math.log(this._cand[t].length);for(let t=0;t<h.length;t++)for(const e of h[t].keys()){const s=h[t].get(e),r=this._ess/h[t].size,i=s.reduce(((t,e)=>t+e),0);for(let e=0;e<s.length;e++){const o=this._ess/(h[t].size*s.length);n+=(o+s[e])*Math.log((o+s[e])/(r+i)),n-=(s.length-1)/s.length*Math.log(1+s.length*h[t].size*s[e]/this._ess)/2}}return n}_fitParameter(t){this._th=this._count(t);for(let t=0;t<this._th.length;t++)for(const e of this._th[t].keys()){const s=this._th[t].get(e),h=s.reduce(((t,e)=>t+e),0);this._th[t].set(e,s.map((t=>(this._alpha+t)/(this._alpha*s.length+h))))}}_count(t,e=this._graph,s=this._cand){const h=[];for(let n=0;n<e.length;n++){const r=t.map((t=>s[n].indexOf(t[n])));h[n]=new ArrayKeyMap;const i=Array(e[n].length).fill(0);do{const o=Array(s[n].length).fill(0);for(let h=0;h<t.length;h++)e[n].some(((e,n)=>s[e][i[n]]!==t[h][e]))||o[r[h]]++;h[n].set(i.concat(),o);for(let t=0;t<i.length&&(i[t]++,!(i[t]<s[e[n][t]].length));t++)i[t]=0}while(i.reduce(((t,e)=>t+e),0)>0)}return h}probability(t){return t.map((t=>{const e=t.map(((t,e)=>this._cand[e].indexOf(t)));let s=1;for(let t=0;t<this._graph.length;t++){const h=this._graph[t].map((t=>e[t]));s*=this._th[t].get(h)[e[t]]}return s}))}}