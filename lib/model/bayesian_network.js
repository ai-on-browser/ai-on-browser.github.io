var B=Object.defineProperty;var m=(f,t)=>B(f,"name",{value:t,configurable:!0});const p=m(f=>{let t=0;if(Number.isInteger(f))for(let e=2;e<f;e++)t+=Math.log(e);else if(Number.isInteger(f-.5)){const e=f-.5;t=Math.log(Math.sqrt(Math.PI))-Math.log(2)*e;for(let s=2*e-1;s>0;s-=2)t+=Math.log(s)}else if(f<.5)t=Math.log(Math.PI)-Math.log(Math.sin(Math.PI*f))-p(1-f);else{const e=[676.5203681218851,-1259.1392167224028,771.3234287776531,-176.6150291621406,12.507343278686905,-.13857109526572012,9984369578019572e-21,15056327351493116e-23];f-=1,t=.9999999999998099;for(let i=0;i<e.length;i++)t+=e[i]/(f+i+1);const s=f+e.length-.5;t=Math.log(Math.sqrt(2*Math.PI))+Math.log(s)*(f+.5)-s+Math.log(t)}return t},"logGamma");class k{static{m(this,"ArrayKeyMap")}constructor(){this._map=new Map}get size(){return this._map.size}_getKey(t){if(this._map.has(t))return t;for(const e of this.keys())if(t.every((s,i)=>s===e[i]))return e;return null}keys(){return this._map.keys()}has(t){return this._getKey(t)!==null}get(t){return this._map.get(this._getKey(t))}set(t,e){const s=this._getKey(t);return s!==null?this._map.set(s,e):this._map.set(t,e)}}export default class K{static{m(this,"BayesianNetwork")}constructor(t){this._th=null,this._graph=null,this._alpha=t,this._ess=1,this._n=0,this._cand=null,this._score_method="bdeu"}fit(t){if(!this._cand){this._n=t[0].length,this._cand=[];for(let e=0;e<this._n;e++)this._cand[e]=[...new Set(t.map(s=>s[e]))]}this._fitStructure(t),this._fitParameter(t)}_fitStructure(t){this._fitStructure_dp(t)}_fitStructure_dp(t){const e=[],s=[];for(let n=0;n<this._n;n++){e[n]=new k,s[n]=new k;for(let o=0;o<2**(this._n-1);o++){const c=o.toString(2).padStart(this._n-1,"0").split("");c.splice(n,0,"1");const a=c.map(_=>+_),l=c.map((_,u)=>[_,u]).filter(_=>_[0]==="1").map(_=>_[1]),g=t.map(_=>l.map(u=>_[u])),d=l.map(_=>this._cand[_]),y=[],S=[];for(let _=0;_<l.length;_++)l[_]===n?y[_]=S:(y[_]=[],S.push(_));const w=this._score(g,y,d);e[n].set(a,w);let M=[a,w];for(let _=0;_<a.length;_++){if(a[_]===0)continue;const u=a.concat();if(u[_]=0,u.reduce((I,P)=>I+P,0)<=1)continue;const b=s[n].get(u);b&&M[1]<b[1]&&(M=b)}s[n].set(a,M)}}const i=new k;for(let n=1;n<2**this._n;n++){const o=n.toString(2).padStart(this._n,"0").split("").map(l=>+l),c=o.reduce((l,g)=>l+g,0);let a=[null,-1/0];for(let l=0;l<s.length;l++){let g=s[l].get(o)?.[1];if(g){if(c>1){const d=o.concat();d[l]=0,g+=i.get(d)[1]}g>a[1]&&(a=[l,g])}}i.set(o,a)}const h=Array(this._n).fill(1),r=[];for(let n=0;n<this._n;n++){const o=i.get(h)[0];r[n]=o,h[o]=0}this._graph=[];for(let n=r.length-1;n>=0;n--){h[r[n]]=1;const o=s[r[n]].get(h)[0],c=[];for(let a=0;a<o.length;a++)o[a]&&a!==r[n]&&c.push(a);this._graph[r[n]]=c}}_score(t,e=this._graph,s=this._cand){if(this._score_method==="bdeu")return this._bdeu(t,e,s)}_bdeu(t,e=this._graph,s=this._cand,i=!1){return i?this._logBDeu_exact(t,e,s):this._logBDeu_appro(t,e,s)}_logBDeu_exact(t,e=this._graph,s=this._cand){const i=this._count(t,e,s);let h=0;for(let r=0;r<i.length;r++)for(const n of i[r].keys()){const o=i[r].get(n);for(let l=0;l<o.length;l++){const g=this._ess/(i[r].size*o.length);h+=p(g+o[l]),h-=p(g)}const c=o.reduce((l,g)=>l+g,0),a=this._ess/i[r].size;h+=p(a),h-=p(a+c)}return h}_logBDeu_appro(t,e=this._graph,s=this._cand){const i=this._count(t,e,s);let h=0;for(let r=0;r<i.length;r++)h+=this._ess*Math.log(this._cand[r].length);for(let r=0;r<i.length;r++)for(const n of i[r].keys()){const o=i[r].get(n),c=this._ess/i[r].size,a=o.reduce((l,g)=>l+g,0);for(let l=0;l<o.length;l++){const g=this._ess/(i[r].size*o.length);h+=(g+o[l])*Math.log((g+o[l])/(c+a)),h-=(o.length-1)/o.length*Math.log(1+o.length*i[r].size*o[l]/this._ess)/2}}return h}_fitParameter(t){this._th=this._count(t);for(let e=0;e<this._th.length;e++)for(const s of this._th[e].keys()){const i=this._th[e].get(s),h=i.reduce((r,n)=>r+n,0);this._th[e].set(s,i.map(r=>(this._alpha+r)/(this._alpha*i.length+h)))}}_count(t,e=this._graph,s=this._cand){const i=[];for(let h=0;h<e.length;h++){const r=t.map(o=>s[h].indexOf(o[h]));i[h]=new k;const n=Array(e[h].length).fill(0);do{const o=Array(s[h].length).fill(0);for(let c=0;c<t.length;c++)e[h].some((a,l)=>s[a][n[l]]!==t[c][a])||o[r[c]]++;i[h].set(n.concat(),o);for(let c=0;c<n.length&&(n[c]++,!(n[c]<s[e[h][c]].length));c++)n[c]=0}while(n.reduce((o,c)=>o+c,0)>0)}return i}probability(t){return t.map(e=>{const s=e.map((h,r)=>this._cand[r].indexOf(h));let i=1;for(let h=0;h<this._graph.length;h++){const r=this._graph[h].map(n=>s[n]);i*=this._th[h].get(r)?.[s[h]]||0}return i})}}
