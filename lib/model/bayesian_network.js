var j=Object.defineProperty;var d=(g,t)=>j(g,"name",{value:t,configurable:!0});const p=d(g=>{let t=0;if(Number.isInteger(g))for(let s=2;s<g;s++)t+=Math.log(s);else if(Number.isInteger(g-.5)){const s=g-.5;t=Math.log(Math.sqrt(Math.PI))-Math.log(2)*s;for(let i=2*s-1;i>0;i-=2)t+=Math.log(i)}else if(g<.5)t=Math.log(Math.PI)-Math.log(Math.sin(Math.PI*g))-p(1-g);else{const s=[676.5203681218851,-1259.1392167224028,771.3234287776531,-176.6150291621406,12.507343278686905,-.13857109526572012,9984369578019572e-21,15056327351493116e-23];g-=1,t=.9999999999998099;for(let o=0;o<s.length;o++)t+=s[o]/(g+o+1);const i=g+s.length-.5;t=Math.log(Math.sqrt(2*Math.PI))+Math.log(i)*(g+.5)-i+Math.log(t)}return t},"logGamma");class m{static{d(this,"ArrayKeyMap")}constructor(){this._map=new Map}get size(){return this._map.size}_getKey(t){if(this._map.has(t))return t;for(const s of this.keys())if(t.every((i,o)=>i===s[o]))return s;return null}keys(){return this._map.keys()}has(t){return this._getKey(t)!==null}get(t){return this._map.get(this._getKey(t))}set(t,s){const i=this._getKey(t);return i!==null?this._map.set(i,s):this._map.set(t,s)}}export default class A{static{d(this,"BayesianNetwork")}constructor(t){this._th=null,this._graph=null,this._alpha=t,this._ess=1,this._n=0,this._cand=null,this._score_method="bdeu"}fit(t){if(!this._cand){this._n=t[0].length,this._cand=[];for(let s=0;s<this._n;s++)this._cand[s]=[...new Set(t.map(i=>i[s]))]}this._fitStructure(t),this._fitParameter(t)}_fitStructure(t){this._fitStructure_dp(t)}_fitStructure_dp(t){const s=[],i=[];for(let e=0;e<this._n;e++){s[e]=new m,i[e]=new m;const h=Array(this._n).fill(0);h[e]=1;do{const l=[];for(let a=0;a<this._n;a++)h[a]&&l.push(a);const c=t.map(a=>l.map(u=>a[u])),f=l.map(a=>this._cand[a]),y=[],b=[];for(let a=0;a<l.length;a++)l[a]===e?y[a]=b:(y[a]=[],b.push(a));const w=this._score(c,y,f);s[e].set(h.concat(),w);let k=[h.concat(),w];for(let a=0;a<h.length;a++){if(h[a]===0)continue;const u=h.concat();if(u[a]=0,u.reduce((I,S)=>I+S,0)<=1)continue;const M=i[e].get(u);M&&k[1]<M[1]&&(k=M)}i[e].set(h.concat(),k);for(let a=this._n-1;a>=0;a--)if(e!==a){if(!h[a]){h[a]=1;break}h[a]=0}}while(h.some((l,c)=>c!==e&&l===1))}const o=new m,n=Array(this._n).fill(0);n[this._n-1]=1;do{const e=n.reduce((l,c)=>l+c,0);let h=[null,-1/0];for(let l=0;l<i.length;l++){let c=i[l].get(n)?.[1];if(c){if(e>1){const f=n.concat();f[l]=0,c+=o.get(f)[1]}c>h[1]&&(h=[l,c])}}o.set(n.concat(),h);for(let l=this._n-1;l>=0;l--){if(!n[l]){n[l]=1;break}n[l]=0}}while(n.some(e=>e===1));const r=Array(this._n).fill(1),_=[];for(let e=0;e<this._n;e++){const h=o.get(r)[0];_[e]=h,r[h]=0}this._graph=[];for(let e=_.length-1;e>=0;e--){r[_[e]]=1;const h=i[_[e]].get(r)[0],l=[];for(let c=0;c<h.length;c++)h[c]&&c!==_[e]&&l.push(c);this._graph[_[e]]=l}}_score(t,s=this._graph,i=this._cand){if(this._score_method==="bdeu")return this._bdeu(t,s,i)}_bdeu(t,s=this._graph,i=this._cand,o=!1){return o?this._logBDeu_exact(t,s,i):this._logBDeu_appro(t,s,i)}_logBDeu_exact(t,s=this._graph,i=this._cand){const o=this._count(t,s,i);let n=0;for(let r=0;r<o.length;r++)for(const _ of o[r].keys()){const e=o[r].get(_);for(let c=0;c<e.length;c++){const f=this._ess/(o[r].size*e.length);n+=p(f+e[c]),n-=p(f)}const h=e.reduce((c,f)=>c+f,0),l=this._ess/o[r].size;n+=p(l),n-=p(l+h)}return n}_logBDeu_appro(t,s=this._graph,i=this._cand){const o=this._count(t,s,i);let n=0;for(let r=0;r<o.length;r++)n+=this._ess*Math.log(this._cand[r].length);for(let r=0;r<o.length;r++)for(const _ of o[r].keys()){const e=o[r].get(_),h=this._ess/o[r].size,l=e.reduce((c,f)=>c+f,0);for(let c=0;c<e.length;c++){const f=this._ess/(o[r].size*e.length);n+=(f+e[c])*Math.log((f+e[c])/(h+l)),n-=(e.length-1)/e.length*Math.log(1+e.length*o[r].size*e[c]/this._ess)/2}}return n}_fitParameter(t){this._th=this._count(t);for(let s=0;s<this._th.length;s++)for(const i of this._th[s].keys()){const o=this._th[s].get(i),n=o.reduce((r,_)=>r+_,0);this._th[s].set(i,o.map(r=>(this._alpha+r)/(this._alpha*o.length+n)))}}_count(t,s=this._graph,i=this._cand){const o=[];for(let n=0;n<s.length;n++){const r=t.map(e=>i[n].indexOf(e[n]));o[n]=new m;const _=Array(s[n].length).fill(0);do{const e=Array(i[n].length).fill(0);for(let h=0;h<t.length;h++)s[n].some((l,c)=>i[l][_[c]]!==t[h][l])||e[r[h]]++;o[n].set(_.concat(),e);for(let h=0;h<_.length&&(_[h]++,!(_[h]<i[s[n][h]].length));h++)_[h]=0}while(_.reduce((e,h)=>e+h,0)>0)}return o}probability(t){return t.map(s=>{const i=s.map((n,r)=>this._cand[r].indexOf(n));let o=1;for(let n=0;n<this._graph.length;n++){const r=this._graph[n].map(_=>i[_]);o*=this._th[n].get(r)?.[i[n]]||0}return o})}}
