var c=Object.defineProperty;var e=(s,r)=>c(s,"name",{value:r,configurable:!0});import a from"../util/matrix.js";const p={identity:e(s=>s,"identity"),elu:e(s=>s>0?s:Math.exp(s)-1,"elu"),gaussian:e(s=>Math.exp(-(s**2)/2),"gaussian"),leaky_relu:e(s=>s>0?s:.01*s,"leaky_relu"),sigmoid:e(s=>1/(1+Math.exp(-s)),"sigmoid"),softplus:e(s=>Math.log(1+Math.exp(s)),"softplus"),softsign:e(s=>s/(1+Math.abs(s)),"softsign"),tanh:Math.tanh};class h{static{e(this,"ELM")}constructor(r,t){this._size=r,this._activation=t,typeof t=="function"?this._a=t:this._a=p[t],this._w=null,this._b=null}fit(r,t){const n=r.cols;this._w=a.randn(n,this._size),this._b=a.randn(1,this._size);const i=r.dot(this._w);i.add(this._b),i.map(this._a);const o=i.pseudoInv();this._beta=o.dot(t)}predict(r){const t=r.dot(this._w);return t.add(this._b),t.map(this._a),t.dot(this._beta)}}export class ELMClassifier extends h{static{e(this,"ELMClassifier")}constructor(r,t="tanh"){super(r,t),this._classes=null}get categories(){return this._classes}fit(r,t){this._classes=[...new Set(t)];const n=t.map(i=>{const o=Array(this._classes.length).fill(0);return o[this._classes.indexOf(i)]=1,o});super.fit(a.fromArray(r),a.fromArray(n))}probability(r){const t=super.predict(a.fromArray(r));return t.sub(t.max(1)),t.map(Math.exp),t.div(t.sum(1)),t.toArray()}predict(r){return super.predict(a.fromArray(r)).argmax(1).value.map(t=>this._classes[t])}}export class ELMRegressor extends h{static{e(this,"ELMRegressor")}constructor(r,t="tanh"){super(r,t)}fit(r,t){super.fit(a.fromArray(r),a.fromArray(t))}predict(r){return super.predict(a.fromArray(r)).toArray()}}
