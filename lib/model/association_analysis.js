class SetKeyMap{constructor(){this._map=new Map,this._keymap={}}get size(){return this._map.size}_getsamekey(t){(t=t.concat()).sort();let e=this._keymap;for(let s=0;s<t.length-1;s++){const n=e[t[s]];if(!n)return;e=n.c}return e[t[t.length-1]]?.v}clear(){return this._keymap={},this._map.clear()}delete(t){const e=this._getsamekey(t);if(e){let t=this._keymap;for(let s=0;s<e.length&&t[e[s]];s++)s<e.length-1?t=t[e[s]].c:0===Object.keys(t[e[e.length-1]].c).length?delete t[e[e.length-1]]:t[e[e.length-1]].v=void 0;return this._map.delete(e)}return!1}get(t){const e=this._getsamekey(t);if(e)return this._map.get(e)}has(t){return!!this._getsamekey(t)}set(t,e){let s=this._getsamekey(t);if(!s){s=t.concat(),s.sort();let e=this._keymap;for(let t=0;t<s.length-1;t++)e[s[t]]||(e[s[t]]={v:void 0,c:{}}),e=e[s[t]].c;e[s[s.length-1]]={v:s,c:e[s[s.length-1]]?.c||{}}}this._map.set(s,e)}*[Symbol.iterator](){yield*this._map}keys(){return this._map.keys()}values(){return this._map.values()}entries(){return this._map.entries()}forEach(t,e){this._map.forEach(t,e)}}class Apriori{constructor(t){this._minsup=t}predict(t){const e=t.length*this._minsup;let s=new SetKeyMap;for(let e=0;e<t.length;e++)for(const n of t[e]){const t=s.get([n])||new Set;t.add(e),s.set([n],t)}for(const t of s.keys())s.get(t).size<e&&s.delete(t);const n=[s];let r=1;for(;++r;){const t=new SetKeyMap,r=[...s.keys()];for(let n=0;n<r.length;n++){const i=r[n];for(let o=n+1;o<r.length;o++){const n=r[o];let h=0,c=null;for(let t=0;t<i.length;t++)i[t]!==n[t]&&(c=n[t],h++);if(1===h){const r=[...i,c],o=new Set,h=s.get(i);for(let t of s.get(n))h.has(t)&&o.add(t);o.size>=e&&t.set(r,o)}}}if(0===t.size)break;s=t,n.push(s)}return n}}export default class AssociationAnalysis{constructor(t){this._support=t}fit(t){this._x=t;const e=new Apriori(this._support);this._commons=e.predict(this._x)}items(t=1){return this._commons[t-1]?.keys()||[]}support(...t){return(this._commons[t.length-1].get(t)?.size||0)/this._x.length}confidence(t,e){const s=this._commons[1].get([t,e]),n=this._commons[0].get([t]);return(s?.size||0)/(n?.size||1)}lift(t,e){return this.confidence(t,e)/this.support(e)}}