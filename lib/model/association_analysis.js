var z=Object.defineProperty;var f=(h,t)=>z(h,"name",{value:t,configurable:!0});class d{static{f(this,"SetKeyMap")}constructor(){this._map=new Map,this._keymap={}}get size(){return this._map.size}_getsamekey(t){t=t.concat(),t.sort();let s=this._keymap;for(let e=0;e<t.length-1;e++){const n=s[t[e]];if(!n)return;s=n.c}return s[t[t.length-1]]?.v}clear(){return this._keymap={},this._map.clear()}delete(t){const s=this._getsamekey(t);if(s){let e=this._keymap;for(let n=0;n<s.length&&e[s[n]];n++)n<s.length-1?e=e[s[n]].c:Object.keys(e[s[s.length-1]].c).length===0?delete e[s[s.length-1]]:e[s[s.length-1]].v=void 0;return this._map.delete(s)}return!1}get(t){const s=this._getsamekey(t);if(s)return this._map.get(s)}has(t){return!!this._getsamekey(t)}set(t,s){let e=this._getsamekey(t);if(!e){e=t.concat(),e.sort();let n=this._keymap;for(let r=0;r<e.length-1;r++)n[e[r]]||(n[e[r]]={v:void 0,c:{}}),n=n[e[r]].c;n[e[e.length-1]]={v:e,c:n[e[e.length-1]]?.c||{}}}this._map.set(e,s)}*[Symbol.iterator](){yield*this._map}keys(){return this._map.keys()}values(){return this._map.values()}entries(){return this._map.entries()}forEach(t,s){this._map.forEach(t,s)}}class v{static{f(this,"Apriori")}constructor(t){this._minsup=t}predict(t){const s=t.length*this._minsup;let e=new d;for(let i=0;i<t.length;i++)for(const o of t[i]){const c=e.get([o])||new Set;c.add(i),e.set([o],c)}for(const i of e.keys())e.get(i).size<s&&e.delete(i);const n=[e];let r=1;for(;++r;){const i=new d,o=[...e.keys()];for(let c=0;c<o.length;c++){const a=o[c];for(let m=c+1;m<o.length;m++){const p=o[m];let u=0,_=null;for(let l=0;l<a.length;l++)a[l]!==p[l]&&(_=p[l],u++);if(u===1){const l=[...a,_],g=new Set,y=e.get(a);for(let k of e.get(p))y.has(k)&&g.add(k);g.size>=s&&i.set(l,g)}}}if(i.size===0)break;e=i,n.push(e)}return n}}export default class w{static{f(this,"AssociationAnalysis")}constructor(t){this._support=t}fit(t){this._x=t;const s=new v(this._support);this._commons=s.predict(this._x)}items(t=1){return this._commons[t-1]?.keys()||[]}support(...t){return(this._commons[t.length-1].get(t)?.size||0)/this._x.length}confidence(t,s){const e=this._commons[1].get([t,s]),n=this._commons[0].get([t]);return(e?.size||0)/(n?.size||1)}lift(t,s){return this.confidence(t,s)/this.support(s)}}
