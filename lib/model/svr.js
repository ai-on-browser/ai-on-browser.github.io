var y=Object.defineProperty;var u=(r,_)=>y(r,"name",{value:_,configurable:!0});const w={gaussian:(r=1)=>(_,s)=>{let e=_.reduce((t,h,n)=>t+(h-s[n])**2,0);return Math.exp(-e/(2*r*r))},linear:()=>(r,_)=>r.reduce((s,e,t)=>s+e*_[t],0)};export default class O{static{u(this,"SVR")}constructor(_,s=[]){typeof _=="function"?this._kernel=_:this._kernel=w[_](...s),this._C=1,this._eps=.001,this._tolerance=.001}init(_,s){this._x=_,this._t=s.map(t=>t[0]);const e=this._x.length;this._a=Array(e).fill(0),this._b=0,this._alldata=!0,this._err=this._t.map(t=>-t),this._k=[];for(let t=0;t<e;this._k[t++]=[]);for(let t=0;t<e;t++)for(let h=t;h<e;h++)this._k[t][h]=this._k[h][t]=this._kernel(this._x[t],this._x[h])}fit(){const _=this._fitOnce();if(this._alldata){if(this._alldata=!1,_===0)return}else _===0&&(this._alldata=!0)}_fitOnce(){let _=0;const s=this._x.length,e=u(t=>this._eps<t&&t<this._C-this._eps,"between_eps");for(let t=0;t<s;t++){if(!e(this._a[t])&&!this._alldata||(this._a[t]>=this._C-this._eps||this._err[t]>=-this._tolerance)&&(this._a[t]<=this._eps||this._err[t]<=this._tolerance))continue;let h=-1,n=null;for(let i=0;i<s;i++)e(this._a[i])&&(this._err[t]>0?(n===null||n>this._err[t])&&(h=i,n=this._err[t]):(n===null||n<this._err[t])&&(h=i,n=this._err[t]));if(h===-1||h===t){const i=Math.floor(Math.random()*(s+1));for(let l=0;l<s;l++){const o=(l+i)%s;if(o!==t&&e(this._a[o])){h=o;break}}}if(h===-1||h===t){const i=Math.floor(Math.random()*(s+1));for(let l=0;l<s;l++){const o=(l+i)%s;if(o!==t){h=o;break}}}if(h===-1||h===t)continue;const a=h,M=this._a[t],m=this._a[a],f=this._a[t]+this._a[a],x=this._k[t][t],b=this._k[a][a],j=this._k[t][a],k=x+b-2*j,c=2*this._eps/k;let p=0,d=0;for(let i=0;i<s;i++)p+=this._k[t][i]*this._a[i],d+=this._k[a][i]*this._a[i];this._a[t]+=1/k*(this._t[t]-this._t[a]-p+d),this._a[a]=f-this._a[t],this._a[t]*this._a[a]<0&&(Math.abs(this._a[t])>=c&&Math.abs(this._a[a])>=c?this._a[t]-=Math.sign(this._a[t])*c:this._a[t]=Math.abs(this._a[t])-Math.abs(this._a[a])<0?0:f);const g=Math.max(f-this._C,-this._C),C=Math.min(this._C,f+this._C);this._a[t]=Math.min(Math.max(this._a[t],g),C),this._a[a]=f-this._a[t];for(let i=0;i<s;i++)this._err[i]+=(this._a[t]-M)*this._k[t][i]+(this._a[a]-m)*this._k[a][i];_++}return this._b=this._err.reduce((t,h)=>t+h,0)/s,_}predict(_){return _.map(s=>{let e=0;for(let t=0;t<this._x.length;t++)this._a[t]&&(e+=this._a[t]*this._kernel(s,this._x[t]));return e-this._b})}}
