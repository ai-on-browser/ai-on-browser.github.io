const Kernel={gaussian:(t=1)=>(s,i)=>{let h=s.reduce(((t,s,h)=>t+(s-i[h])**2),0);return Math.exp(-h/(2*t*t))},linear:()=>(t,s)=>t.reduce(((t,i,h)=>t+i*s[h]),0)};export default class SVR{constructor(t,s=[]){this._kernel=Kernel[t](...s),this._C=1,this._eps=.001,this._tolerance=.001}init(t,s){this._x=t,this._t=s.map((t=>t[0]));const i=this._x.length;this._a=Array(i).fill(0),this._b=0,this._alldata=!0,this._err=this._t.map((t=>-t)),this._k=[];for(let t=0;t<i;this._k[t++]=[]);for(let t=0;t<i;t++)for(let s=t;s<i;s++)this._k[t][s]=this._k[s][t]=this._kernel(this._x[t],this._x[s])}fit(){const t=this._fitOnce(this._alldata);if(this._alldata){if(this._alldata=!1,0===t)return}else 0===t&&(this._alldata=!0)}_fitOnce(){let t=0;const s=this._x.length,i=t=>this._eps<t&&t<this._C-this._eps;for(let h=0;h<s;h++){if(!i(this._a[h])&&!this._alldata)continue;if((this._a[h]>=this._C-this._eps||this._err[h]>=-this._tolerance)&&(this._a[h]<=this._eps||this._err[h]<=this._tolerance))continue;let _=-1,a=null;for(let t=0;t<s;t++)i(this._a[t])&&(this._err[h]>0?(null===a||a>this._err[h])&&(_=t,a=this._err[h]):(null===a||a<this._err[h])&&(_=t,a=this._err[h]));if(-1===_||_===h){const t=Math.floor(Math.random()*(s+1));for(let a=0;a<s;a++){const e=(a+t)%s;if(e!==h&&i(this._a[e])){_=e;break}}}if(-1===_||_===h){const t=Math.floor(Math.random()*(s+1));for(let i=0;i<s;i++){const a=(i+t)%s;if(a!==h){_=a;break}}}if(-1===_||_===h)continue;const e=_,r=this._a[h],l=this._a[e],n=this._a[h]+this._a[e],o=this._k[h][h]+this._k[e][e]-2*this._k[h][e],c=2*this._eps/o;let f=0,u=0;for(let t=0;t<s;t++)f+=this._k[h][t]*this._a[t],u+=this._k[e][t]*this._a[t];this._a[h]+=1/o*(this._t[h]-this._t[e]-f+u),this._a[e]=n-this._a[h],this._a[h]*this._a[e]<0&&(Math.abs(this._a[h])>=c&&Math.abs(this._a[e])>=c?this._a[h]-=Math.sign(this._a[h])*c:this._a[h]=Math.abs(this._a[h])-Math.abs(this._a[e])<0?0:n);const k=Math.max(n-this._C,-this._C),M=Math.min(this._C,n+this._C);this._a[h]=Math.min(Math.max(this._a[h],k),M),this._a[e]=n-this._a[h];for(let t=0;t<s;t++)this._err[t]+=(this._a[h]-r)*this._k[h][t]+(this._a[e]-l)*this._k[e][t];t++}return this._b=this._err.reduce(((t,s)=>t+s),0)/s,t}predict(t){const s=t=>{let s=0;for(let i=0;i<this._x.length;i++)this._a[i]&&(s+=this._a[i]*this._kernel(t,this._x[i]));return s-this._b};return Array.isArray(t[0])?t.map(s):s(t)}}