var w=Object.defineProperty;var c=(r,i)=>w(r,"name",{value:i,configurable:!0});const M={gaussian:c((r=1)=>(i,_)=>{let a=i.reduce((t,h,n)=>t+(h-_[n])**2,0);return Math.exp(-a/(2*r*r))},"gaussian"),linear:c(()=>(r,i)=>r.reduce((_,a,t)=>_+a*i[t],0),"linear")};export default class O{static{c(this,"SVR")}constructor(i){typeof i=="function"?this._kernel=i:(typeof i=="string"&&(i={name:i}),i.name==="gaussian"?this._kernel=M.gaussian(i.d):this._kernel=M.linear()),this._C=1,this._eps=.001,this._tolerance=.001}init(i,_){this._x=i,this._t=_.map(t=>t[0]);const a=this._x.length;this._a=Array(a).fill(0),this._b=0,this._alldata=!0,this._err=this._t.map(t=>-t),this._k=[];for(let t=0;t<a;this._k[t++]=[]);for(let t=0;t<a;t++)for(let h=t;h<a;h++)this._k[t][h]=this._k[h][t]=this._kernel(this._x[t],this._x[h])}fit(){const i=this._fitOnce();if(this._alldata){if(this._alldata=!1,i===0)return}else i===0&&(this._alldata=!0)}_fitOnce(){let i=0;const _=this._x.length,a=c(t=>this._eps<t&&t<this._C-this._eps,"between_eps");for(let t=0;t<_;t++){if(!a(this._a[t])&&!this._alldata||(this._a[t]>=this._C-this._eps||this._err[t]>=-this._tolerance)&&(this._a[t]<=this._eps||this._err[t]<=this._tolerance))continue;let h=-1,n=null;for(let s=0;s<_;s++)a(this._a[s])&&(this._err[t]>0?(n===null||n>this._err[t])&&(h=s,n=this._err[t]):(n===null||n<this._err[t])&&(h=s,n=this._err[t]));if(h===-1||h===t){const s=Math.floor(Math.random()*(_+1));for(let l=0;l<_;l++){const o=(l+s)%_;if(o!==t&&a(this._a[o])){h=o;break}}}if(h===-1||h===t){const s=Math.floor(Math.random()*(_+1));for(let l=0;l<_;l++){const o=(l+s)%_;if(o!==t){h=o;break}}}if(h===-1||h===t)continue;const e=h,m=this._a[t],g=this._a[e],f=this._a[t]+this._a[e],x=this._k[t][t],b=this._k[e][e],j=this._k[t][e],p=x+b-2*j,u=2*this._eps/p;let d=0,k=0;for(let s=0;s<_;s++)d+=this._k[t][s]*this._a[s],k+=this._k[e][s]*this._a[s];this._a[t]+=1/p*(this._t[t]-this._t[e]-d+k),this._a[e]=f-this._a[t],this._a[t]*this._a[e]<0&&(Math.abs(this._a[t])>=u&&Math.abs(this._a[e])>=u?this._a[t]-=Math.sign(this._a[t])*u:this._a[t]=Math.abs(this._a[t])-Math.abs(this._a[e])<0?0:f);const C=Math.max(f-this._C,-this._C),y=Math.min(this._C,f+this._C);this._a[t]=Math.min(Math.max(this._a[t],C),y),this._a[e]=f-this._a[t];for(let s=0;s<_;s++)this._err[s]+=(this._a[t]-m)*this._k[t][s]+(this._a[e]-g)*this._k[e][s];i++}return this._b=this._err.reduce((t,h)=>t+h,0)/_,i}predict(i){return i.map(_=>{let a=0;for(let t=0;t<this._x.length;t++)this._a[t]&&(a+=this._a[t]*this._kernel(_,this._x[t]));return a-this._b})}}
