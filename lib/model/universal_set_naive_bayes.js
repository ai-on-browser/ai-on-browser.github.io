var o=Object.defineProperty;var p=(n,s)=>o(n,"name",{value:s,configurable:!0});import h from"../util/matrix.js";class m{static{p(this,"Gaussian")}constructor(){this._means=null,this._vars=null}_estimate_prob(s){this._means=s.mean(0),this._vars=s.variance(0)}_data_prob(s){const i=h.sub(s,this._means);return i.mult(i),i.div(this._vars),i.map(t=>Math.exp(-t/2)),i.div(h.map(this._vars,t=>Math.sqrt(2*Math.PI*t))),i.prod(1)}}export default class u{static{p(this,"UniversalSetNaiveBayes")}constructor(s="gaussian"){this._labels=[],this._rate=[],this._ratec=[],s==="gaussian"&&(this._p_class=m),this._p=[],this._pc=[]}fit(s,i){this._labels=[...new Set(i)],this._p=[],this._pc=[],this._rate=[],this._ratec=[];for(let t=0;t<this._labels.length;t++){const a=h.fromArray(s.filter((r,_)=>i[_]===this._labels[t])),e=h.fromArray(s.filter((r,_)=>i[_]!==this._labels[t]));this._p[t]=new this._p_class,this._p[t]._estimate_prob(a),this._pc[t]=new this._p_class,this._pc[t]._estimate_prob(e),this._rate[t]=a.rows/s.length,this._ratec[t]=e.rows/s.length}}predict(s){const i=h.fromArray(s),t=[];for(let a=0;a<this._labels.length;a++){const e=this._p[a]._data_prob(i),r=this._pc[a]._data_prob(i);e.div(r),e.mult(this._rate[a]/this._ratec[a]),t.push(e)}return s.map((a,e)=>{let r=0,_=-1;for(let l=0;l<this._labels.length;l++){const c=t[l].value[e];c>r&&(r=c,_=l)}return this._labels[_]})}}
