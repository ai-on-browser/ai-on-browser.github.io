var o=Object.defineProperty;var n=(p,s)=>o(p,"name",{value:s,configurable:!0});import h from"../util/matrix.js";class m{static{n(this,"Gaussian")}constructor(){this._means=null,this._vars=null}_estimate_prob(s){this._means=s.mean(0),this._vars=s.variance(0)}_data_prob(s){const i=h.sub(s,this._means);return i.mult(i),i.div(this._vars),i.map(t=>Math.exp(-t/2)),i.div(h.map(this._vars,t=>Math.sqrt(2*Math.PI*t))),i.prod(1)}}export default class u{static{n(this,"UniversalSetNaiveBayes")}constructor(s="gaussian"){this._labels=[],this._rate=[],this._ratec=[],s==="gaussian"&&(this._p_class=m),this._p=[],this._pc=[]}fit(s,i){this._labels=[...new Set(i)],this._p=[],this._pc=[],this._rate=[],this._ratec=[];for(let t=0;t<this._labels.length;t++){const e=h.fromArray(s.filter((r,_)=>i[_]===this._labels[t])),a=h.fromArray(s.filter((r,_)=>i[_]!==this._labels[t]));this._p[t]=new this._p_class,this._p[t]._estimate_prob(e),this._pc[t]=new this._p_class,this._pc[t]._estimate_prob(a),this._rate[t]=e.rows/s.length,this._ratec[t]=a.rows/s.length}}predict(s){const i=h.fromArray(s),t=[];for(let e=0;e<this._labels.length;e++){const a=this._p[e]._data_prob(i),r=this._pc[e]._data_prob(i);a.div(r),a.mult(this._rate[e]/this._ratec[e]),t.push(a)}return s.map((e,a)=>{let r=0,_=-1;for(let l=0;l<this._labels.length;l++){let c=t[l].value[a];c>r&&(r=c,_=l)}return this._labels[_]})}}
