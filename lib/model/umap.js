var w=Object.defineProperty;var g=(l,i)=>w(l,"name",{value:i,configurable:!0});import M from"../util/matrix.js";const A=g(l=>{for(let i=l.length-1;i>0;i--){const _=Math.floor(Math.random()*(i+1));[l[i],l[_]]=[l[_],l[i]]}return l},"shuffle");export default class j{static{g(this,"UMAP")}constructor(i,_=10,h=.1){this._rd=i,this._n=_,this._min_dist=h,this._neg_samples=10}init(i){this._x=M.fromArray(i).toArray(),this._init()}_d(i,_){return Math.sqrt(i.reduce((h,n,d)=>h+(n-_[d])**2,0))}_init(){const i=this._x.length,_=[];for(let t=0;t<i;t++){const s=this._x[t],o=this._x.map((a,p)=>[this._d(s,a),p]);o.sort((a,p)=>a[0]-p[0]),o.splice(0,1),o.splice(this._n);const c=o[0][0],e=Math.log2(this._n);let f=1,b=0,u=1/0;for(;;){const a=o.reduce((p,x)=>p+Math.exp(-(x[0]-c)/f),0);if(Math.abs(a-e)<1e-8)break;a<e?(b=f,u===1/0?f*=2:f=(f+u)/2):(u=f,f=(f+b)/2)}_[t]=Array(i).fill(0);for(let a=0;a<o.length;a++){const p=(this._d(s,this._x[o[a][1]])-c)/f;_[t][o[a][1]]=Math.exp(-p)}}for(let t=0;t<i;t++)for(let s=t+1;s<i;s++)_[t][s]=_[s][t]=_[t][s]+_[t][s]-_[t][s]*_[s][t];this._w=M.fromArray(_);let h=this._w.sum(1).value;const n=M.diag(h);n.sub(this._w),h=h.map(t=>Math.sqrt(t));for(let t=0;t<i;t++)for(let s=0;s<i;s++)n.divAt(t,s,Math.sqrt(h[t]*h[s]));const d=n.eigenVectors();d.flip(1),this._y=d.slice(1,this._rd+1,1).toArray(),this._alpha=1,this._epoch=0,this._a=1,this._b=1;const m=.1,r=[];for(let t=0;t<i;t++)for(let s=0;s<i;s++)r.push(this._d(this._y[t],this._y[s]));const y=r.map(t=>t<=this._min_dist?1:Math.exp(this._min_dist-t));for(let t=0;t<1e3;t++){const s=r.map(e=>1/(1+this._a*e**(2*this._b)));let o=0,c=0;for(let e=0;e<h.length;e++)r[e]>0&&(o+=(s[e]-y[e])*-(s[e]**2)*r[e]**(2*this._b),c+=(s[e]-y[e])*-(s[e]**2)*this._a*r[e]**(2*this._b)*Math.log(r[e]**2));if(this._a-=m*o,this._b-=m*c,o**2+c**2<1e-12)break}}fit(){const i=this._x.length,_=1e-4;for(let h=0;h<i;h++)for(let n=h+1;n<i;n++){const d=this._w.at(h,n);if(Math.random()>d)continue;const m=this._d(this._y[h],this._y[n]),r=-2*this._a*this._b*m**(2*(this._b-1))/(1+m**2)*d;this._y[h]=this._y[h].map((t,s)=>t+this._alpha*r*(t-this._y[n][s]));const y=[];for(let t=0;t<i;t++)h!==t&&this._w.at(h,t)===0&&y.push(t);A(y);for(let t=0;t<Math.min(this._neg_samples,y.length);t++){const s=this._d(this._y[h],this._y[t])**2,o=2*this._b/((_+s)*(1+this._a*s**this._b))*(1-this._w.at(h,t));this._y[h]=this._y[h].map((c,e)=>c+this._alpha*o*(c-this._y[t][e]))}}return this._epoch++,this._alpha*=.99,this._y}predict(){return this._y}}
