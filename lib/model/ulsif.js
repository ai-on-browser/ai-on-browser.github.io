import Matrix from"../util/matrix.js";export class RuLSIF{constructor(t,s,a,i){this._sigma_cand=t,this._lambda_cand=s,this._alpha=a,this._kernelNum=i}_kernel_gaussian(t,s,a){const i=[];for(let r=0;r<s.rows;r++){const e=[];for(let i=0;i<t.rows;i++){const o=Matrix.sub(s.row(r),t.row(i));e.push(Math.exp(-o.reduce(((t,s)=>t+s**2),0)/(2*a**2)))}i.push(e)}return Matrix.fromArray(i)}fit(t,s){t=Matrix.fromArray(t),s=Matrix.fromArray(s);const a=t.rows,i=s.rows,r=Math.min(this._kernelNum,a),e=this._centers=t.sample(r)[0];if(this._sigma=this._sigma_cand[0],this._lambda=this._lambda_cand[0],this._sigma_cand.length>1||this._lambda_cand.length>1){const o=Math.min(a,i);let n=1/0;for(const h of this._sigma_cand){let l=this._kernel_gaussian(t,e,h),_=this._kernel_gaussian(s,e,h);const c=l.dot(l.t);c.mult(this._alpha/a);const d=_.dot(_.t);d.mult((1-this._alpha)/i);const m=Matrix.add(c,d),u=l.mean(1);l=l.slice(0,o,1),_=_.slice(0,o,1);for(const t of this._lambda_cand){const s=Matrix.eye(r,r,t*(i-1)/i);s.add(m);const e=s.inv(),c=e.dot(_),d=Matrix.mult(_,c),x=new Matrix(1,o,i);x.sub(d.sum(0));const M=e.dot(u.dot(Matrix.ones(1,o)));M.add(c.dot(Matrix.diag(Matrix.div(u.tDot(c),x).value)));const g=e.dot(l);g.add(c.dot(Matrix.diag(Matrix.div(Matrix.mult(l,c).sum(0),x).value)));const f=Matrix.mult(M,a);f.sub(g),f.mult((i-1)/(i*(a-1))),f.map((t=>t<0?0:t));const p=Matrix.mult(_,f).sum(0).t,w=Matrix.mult(l,f).sum(0).t,k=(p.tDot(p).toScaler()/2-w.sum())/o;k<n&&(n=k,this._sigma=h,this._lambda=t)}}}const o=this._kernel_gaussian(t,e,this._sigma),n=this._kernel_gaussian(s,e,this._sigma),h=o.dot(o.t);h.mult(this._alpha/a);const l=n.dot(n.t);l.mult((1-this._alpha)/i);const _=Matrix.add(h,l),c=o.mean(1),d=Matrix.eye(r,r,this._lambda*(i-1)/i);d.add(_),this._kw=d.inv().dot(c),this._kw.map((t=>t<0?0:t))}predict(t){t=Matrix.fromArray(t);return this._kernel_gaussian(t,this._centers,this._sigma).tDot(this._kw).value}}export class uLSIF extends RuLSIF{constructor(t,s,a){super(t,s,0,a)}}export class uLSIFCPD{constructor(t,s,a){this._window=t,this._take=s||Math.max(1,Math.floor(t/2)),this._lag=a||Math.max(1,Math.floor(this._take/2))}predict(t){const s=[];for(let a=0;a<t.length-this._window+1;a++)s.push(t.slice(a,a+this._window).flat());const a=[];for(let t=0;t<s.length-this._take-this._lag+1;t++){const i=Matrix.fromArray(s.slice(t,t+this._take)),r=Matrix.fromArray(s.slice(t+this._lag,t+this._take+this._lag)),e=new uLSIF([100,10,1,.1,.01,.001],[100,10,1,.1,.01,.001],100);let o=0;e.fit(i,r);let n=e.predict(r);for(let t=0;t<n.length;t++)o+=(n[t]-1)**2/n.length;e.fit(r,i),n=e.predict(i);for(let t=0;t<n.length;t++)o+=(n[t]-1)**2/n.length;a.push(o)}return a}}