var C=Object.defineProperty;var w=(g,s)=>C(g,"name",{value:s,configurable:!0});import t from"../util/matrix.js";export class RuLSIF{static{w(this,"RuLSIF")}constructor(s,a,i,n){this._sigma_cand=s,this._lambda_cand=a,this._alpha=i,this._kernelNum=n}_kernel_gaussian(s,a,i){const n=[];for(let o=0;o<a.rows;o++){const r=[];for(let h=0;h<s.rows;h++){const d=t.sub(a.row(o),s.row(h));r.push(Math.exp(-d.reduce((u,p)=>u+p**2,0)/(2*i**2)))}n.push(r)}return t.fromArray(n)}fit(s,a){s=t.fromArray(s),a=t.fromArray(a);const i=s.rows,n=a.rows,o=Math.min(this._kernelNum,i),r=this._centers=s.sample(o)[0];if(this._sigma=this._sigma_cand[0],this._lambda=this._lambda_cand[0],this._sigma_cand.length>1||this._lambda_cand.length>1){const e=Math.min(i,n);let B=1/0;for(const f of this._sigma_cand){let c=this._kernel_gaussian(s,r,f),m=this._kernel_gaussian(a,r,f);const y=c.dot(c.t);y.mult(this._alpha/i);const H=m.dot(m.t);H.mult((1-this._alpha)/n);const R=t.add(y,H),A=c.mean(1);c=c.slice(0,e,1),m=m.slice(0,e,1);for(const M of this._lambda_cand){const D=t.eye(o,o,M*(n-1)/n);D.add(R);const k=D.inv(),_=k.dot(m),q=t.mult(m,_),b=new t(1,e,n);b.sub(q.sum(0));const I=k.dot(A.dot(t.ones(1,e)));I.add(_.dot(t.diag(t.div(A.tDot(_),b).value)));const S=k.dot(c);S.add(_.dot(t.diag(t.div(t.mult(c,_).sum(0),b).value)));const l=t.mult(I,i);l.sub(S),l.mult((n-1)/(n*(i-1))),l.map(L=>L<0?0:L);const X=t.mult(m,l).sum(0).t,z=t.mult(c,l).sum(0).t,F=(X.tDot(X).toScaler()/2-z.sum())/e;F<B&&(B=F,this._sigma=f,this._lambda=M)}}}const h=this._kernel_gaussian(s,r,this._sigma),d=this._kernel_gaussian(a,r,this._sigma),u=h.dot(h.t);u.mult(this._alpha/i);const p=d.dot(d.t);p.mult((1-this._alpha)/n);const N=t.add(u,p),j=h.mean(1),v=t.eye(o,o,this._lambda*(n-1)/n);v.add(N),this._kw=v.inv().dot(j),this._kw.map(e=>e<0?0:e)}predict(s){return s=t.fromArray(s),this._kernel_gaussian(s,this._centers,this._sigma).tDot(this._kw).value}}export class uLSIF extends RuLSIF{static{w(this,"uLSIF")}constructor(s,a,i){super(s,a,0,i)}}
