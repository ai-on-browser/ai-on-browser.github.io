import{Matrix}from"../util/math.js";export class RuLSIF{constructor(t,s,a,i){this._sigma_cand=t,this._lambda_cand=s,this._alpha=a,this._kernelNum=i}_kernel_gaussian(t,s,a){const i=[];for(let o=0;o<s.rows;o++){const e=[];for(let i=0;i<t.rows;i++){const r=s.row(o).copySub(t.row(i));e.push(Math.exp(-r.reduce(((t,s)=>t+s**2),0)/(2*a**2)))}i.push(e)}return Matrix.fromArray(i)}fit(t,s){t=Matrix.fromArray(t),s=Matrix.fromArray(s);const a=t.rows,i=s.rows,o=Math.min(this._kernelNum,a),e=this._centers=t.sampleRow(o);if(this._sigma=this._sigma_cand[0],this._lambda=this._lambda_cand[0],this._sigma_cand.length>1||this._lambda_cand.length>1){const r=Math.min(a,i);let n=1/0;for(const h of this._sigma_cand){let l=this._kernel_gaussian(t,e,h),c=this._kernel_gaussian(s,e,h);const _=l.tDot(l);_.mult(this._alpha/a);const d=c.tDot(c);d.mult((1-this._alpha)/i);const u=_.copyAdd(d),m=u.mean(0).t;l=l.sliceRow(0,r).t,c=c.sliceRow(0,r).t;for(const t of this._lambda_cand){const s=Matrix.eye(o,o,t*(i-1)/i);s.add(u);const e=s.inv(),_=e.dot(c),d=c.dot(_),p=new Matrix(1,r,i);p.sub(d.sum(0));const g=e.dot(m.dot(Matrix.ones(1,r)));g.add(_.dot(Matrix.diag(m.tDot(_).copyDiv(p).value)));const f=e.dot(l);f.add(_.dot(Matrix.diag(l.copyMult(_).sum(0).copyDiv(p).value)));const M=g.copyMult(a);M.sub(f),M.mult((i-1)/(i*(a-1))),M.map((t=>t<0?0:t));const w=c.copyMult(M).sum(0).t,x=l.copyMult(M).sum(0).t,k=(w.tDot(w).value[0]/2-x.sum())/r;k<n&&(n=k,this._sigma=h,this._lambda=t)}}}const r=this._kernel_gaussian(t,e,this._sigma),n=this._kernel_gaussian(s,e,this._sigma),h=r.tDot(r);h.mult(this._alpha/a);const l=n.tDot(n);l.mult((1-this._alpha)/i);const c=h.copyAdd(l),_=c.mean(0).t,d=Matrix.eye(o,o,this._lambda*(i-1)/i);d.add(c),this._kw=d.inv().dot(_),this._kw.map((t=>t<0?0:t))}predict(t){return this._kernel_gaussian(t,this._centers,this._sigma).dot(this._kw).value}}export class uLSIF extends RuLSIF{constructor(t,s,a){super(t,s,0,a)}}export class uLSIFCPD{constructor(t,s,a){this._window=t,this._take=s||Math.max(1,Math.floor(t/2)),this._lag=a||Math.max(1,Math.floor(this._take/2))}predict(t){const s=[];for(let a=0;a<t.length-this._window+1;a++)s.push(t.slice(a,a+this._window).flat());const a=[];for(let t=0;t<s.length-this._take-this._lag+1;t++){const i=Matrix.fromArray(s.slice(t,t+this._take)),o=Matrix.fromArray(s.slice(t+this._lag,t+this._take+this._lag)),e=new uLSIF([100,10,1,.1,.01,.001],[100,10,1,.1,.01,.001],100);let r=0;e.fit(i,o);let n=e.predict(o);for(let t=0;t<n.length;t++)r+=(n[t]-1)**2/n.length;e.fit(o,i),n=e.predict(i);for(let t=0;t<n.length;t++)r+=(n[t]-1)**2/n.length;a.push(r)}return a}}