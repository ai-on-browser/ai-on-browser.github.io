import Matrix from"../util/matrix.js";export class RuLSIF{constructor(t,s,a,i){this._sigma_cand=t,this._lambda_cand=s,this._alpha=a,this._kernelNum=i}_kernel_gaussian(t,s,a){const i=[];for(let r=0;r<s.rows;r++){const o=[];for(let i=0;i<t.rows;i++){const n=Matrix.sub(s.row(r),t.row(i));o.push(Math.exp(-n.reduce(((t,s)=>t+s**2),0)/(2*a**2)))}i.push(o)}return Matrix.fromArray(i)}fit(t,s){t=Matrix.fromArray(t),s=Matrix.fromArray(s);const a=t.rows,i=s.rows,r=Math.min(this._kernelNum,a),o=this._centers=t.sample(r)[0];if(this._sigma=this._sigma_cand[0],this._lambda=this._lambda_cand[0],this._sigma_cand.length>1||this._lambda_cand.length>1){const n=Math.min(a,i);let e=1/0;for(const _ of this._sigma_cand){let m=this._kernel_gaussian(t,o,_),l=this._kernel_gaussian(s,o,_);const d=m.dot(m.t);d.mult(this._alpha/a);const h=l.dot(l.t);h.mult((1-this._alpha)/i);const u=Matrix.add(d,h),c=m.mean(1);m=m.slice(0,n,1),l=l.slice(0,n,1);for(const t of this._lambda_cand){const s=Matrix.eye(r,r,t*(i-1)/i);s.add(u);const o=s.inv(),d=o.dot(l),h=Matrix.mult(l,d),x=new Matrix(1,n,i);x.sub(h.sum(0));const M=o.dot(c.dot(Matrix.ones(1,n)));M.add(d.dot(Matrix.diag(Matrix.div(c.tDot(d),x).value)));const g=o.dot(m);g.add(d.dot(Matrix.diag(Matrix.div(Matrix.mult(m,d).sum(0),x).value)));const p=Matrix.mult(M,a);p.sub(g),p.mult((i-1)/(i*(a-1))),p.map((t=>t<0?0:t));const f=Matrix.mult(l,p).sum(0).t,k=Matrix.mult(m,p).sum(0).t,b=(f.tDot(f).toScaler()/2-k.sum())/n;b<e&&(e=b,this._sigma=_,this._lambda=t)}}}const n=this._kernel_gaussian(t,o,this._sigma),e=this._kernel_gaussian(s,o,this._sigma),_=n.dot(n.t);_.mult(this._alpha/a);const m=e.dot(e.t);m.mult((1-this._alpha)/i);const l=Matrix.add(_,m),d=n.mean(1),h=Matrix.eye(r,r,this._lambda*(i-1)/i);h.add(l),this._kw=h.inv().dot(d),this._kw.map((t=>t<0?0:t))}predict(t){t=Matrix.fromArray(t);return this._kernel_gaussian(t,this._centers,this._sigma).tDot(this._kw).value}}export class uLSIF extends RuLSIF{constructor(t,s,a){super(t,s,0,a)}}