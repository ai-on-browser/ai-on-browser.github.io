import Matrix from"../util/matrix.js";export class RuLSIF{constructor(t,s,a,i){this._sigma_cand=t,this._lambda_cand=s,this._alpha=a,this._kernelNum=i}_kernel_gaussian(t,s,a){const i=[];for(let o=0;o<s.rows;o++){const r=[];for(let i=0;i<t.rows;i++){const e=s.row(o).copySub(t.row(i));r.push(Math.exp(-e.reduce(((t,s)=>t+s**2),0)/(2*a**2)))}i.push(r)}return Matrix.fromArray(i)}fit(t,s){t=Matrix.fromArray(t),s=Matrix.fromArray(s);const a=t.rows,i=s.rows,o=Math.min(this._kernelNum,a),r=this._centers=t.sample(o);if(this._sigma=this._sigma_cand[0],this._lambda=this._lambda_cand[0],this._sigma_cand.length>1||this._lambda_cand.length>1){const e=Math.min(a,i);let n=1/0;for(const h of this._sigma_cand){let l=this._kernel_gaussian(t,r,h),c=this._kernel_gaussian(s,r,h);const _=l.dot(l.t);_.mult(this._alpha/a);const d=c.dot(c.t);d.mult((1-this._alpha)/i);const u=_.copyAdd(d),m=l.mean(1);l=l.slice(0,e,1),c=c.slice(0,e,1);for(const t of this._lambda_cand){const s=Matrix.eye(o,o,t*(i-1)/i);s.add(u);const r=s.inv(),_=r.dot(c),d=c.copyMult(_),p=new Matrix(1,e,i);p.sub(d.sum(0));const g=r.dot(m.dot(Matrix.ones(1,e)));g.add(_.dot(Matrix.diag(m.tDot(_).copyDiv(p).value)));const M=r.dot(l);M.add(_.dot(Matrix.diag(l.copyMult(_).sum(0).copyDiv(p).value)));const f=g.copyMult(a);f.sub(M),f.mult((i-1)/(i*(a-1))),f.map((t=>t<0?0:t));const x=c.copyMult(f).sum(0).t,y=l.copyMult(f).sum(0).t,w=(x.tDot(x).toScaler()/2-y.sum())/e;w<n&&(n=w,this._sigma=h,this._lambda=t)}}}const e=this._kernel_gaussian(t,r,this._sigma),n=this._kernel_gaussian(s,r,this._sigma),h=e.dot(e.t);h.mult(this._alpha/a);const l=n.dot(n.t);l.mult((1-this._alpha)/i);const c=h.copyAdd(l),_=e.mean(1),d=Matrix.eye(o,o,this._lambda*(i-1)/i);d.add(c),this._kw=d.inv().dot(_),this._kw.map((t=>t<0?0:t))}predict(t){t=Matrix.fromArray(t);return this._kernel_gaussian(t,this._centers,this._sigma).tDot(this._kw).value}}export class uLSIF extends RuLSIF{constructor(t,s,a){super(t,s,0,a)}}export class uLSIFCPD{constructor(t,s,a){this._window=t,this._take=s||Math.max(1,Math.floor(t/2)),this._lag=a||Math.max(1,Math.floor(this._take/2))}predict(t){const s=[];for(let a=0;a<t.length-this._window+1;a++)s.push(t.slice(a,a+this._window).flat());const a=[];for(let t=0;t<s.length-this._take-this._lag+1;t++){const i=Matrix.fromArray(s.slice(t,t+this._take)),o=Matrix.fromArray(s.slice(t+this._lag,t+this._take+this._lag)),r=new uLSIF([100,10,1,.1,.01,.001],[100,10,1,.1,.01,.001],100);let e=0;r.fit(i,o);let n=r.predict(o);for(let t=0;t<n.length;t++)e+=(n[t]-1)**2/n.length;r.fit(o,i),n=r.predict(i);for(let t=0;t<n.length;t++)e+=(n[t]-1)**2/n.length;a.push(e)}return a}}