var K=Object.defineProperty;var j=(m,t)=>K(m,"name",{value:t,configurable:!0});class P{static{j(this,"Point")}constructor(t,s=null){this._p=t,this.value=s}get x(){return this._p[0]}get y(){return this._p[1]}distance(t){return Math.sqrt((this.x-t.x)**2+(this.y-t.y)**2)}}class L{static{j(this,"Circle")}constructor(t,s){this._c=t,this._r=s}contains(t){return(t.x-this._c.x)**2+(t.y-this._c.y)**2<this._r**2}}class S{static{j(this,"Triangle")}constructor(t,s,i){this.p=[t,s,i],this.adjoin=[null,null,null],this._circumcircle=null}get p(){return this._p}set p(t){this._p=t,this._circumcircle=null}get circumcircle(){if(this._circumcircle)return this._circumcircle;const[t,s,i]=this.p,r=2*((s.x-t.x)*(i.y-t.y)-(s.y-t.y)*(i.x-t.x))+1e-12,u=s.x**2-t.x**2+s.y**2-t.y**2,a=i.x**2-t.x**2+i.y**2-t.y**2,f=((i.y-t.y)*u+(t.y-s.y)*a)/r,y=((t.x-i.x)*u+(s.x-t.x)*a)/r;return this._circumcircle=new L(new P([f,y]),Math.sqrt((f-t.x)**2+(y-t.y)**2)),this._circumcircle}get area(){const[t,s,i]=this.p;return Math.abs((t.x-i.x)*(s.y-i.y)-(s.x-i.x)*(t.y-i.y))/2}contains(t){const s=j((r,u,a)=>(r.x-a.x)*(u.y-a.y)-(u.x-a.x)*(r.y-a.y),"outer"),i=[];for(let r=0;r<3;r++){const u=s(t,this.p[r],this.p[(r+1)%3]);if(u!==0){if(i.length>0&&i[i.length-1]!==u<0)return!1;i.push(u<0)}}return!0}contains_circle(t){return this.circumcircle.contains(t)}}export default class Q{static{j(this,"DTSCAN")}constructor(t=5,s=1){this._minPts=t,this._area_threshold=s,this._length_threshold=s}predict(t){const s=t.length;if(t[0].length!==2)throw new Error("Only 2d data can apply for current implementation.");const i=[1/0,1/0],r=[-1/0,-1/0];for(let n=0;n<s;n++)for(let e=0;e<2;e++)i[e]=Math.min(i[e],t[n][e]),r[e]=Math.max(r[e],t[n][e]);for(let n=0;n<2;n++)i[n]-=1,r[n]+=1;const u=[new P([i[0]-(r[1]-i[1]),i[1]]),new P([r[0]+(r[1]-i[1]),i[1]]),new P([(i[0]+r[0])/2,r[1]+(r[0]-i[0])/2])],a=[new S(...u)];for(let n=0;n<s;n++){const e=new P(t[n],n);let l=0;for(;l<a.length&&!a[l].contains(e);l++);const c=a.splice(l,1)[0],d=new S(e,c.p[1],c.p[2]),w=new S(e,c.p[2],c.p[0]),z=new S(e,c.p[0],c.p[1]);d.adjoin=[c.adjoin[0],w,z],w.adjoin=[c.adjoin[1],z,d],z.adjoin=[c.adjoin[2],d,w];const I=[d,w,z];for(let o=0;o<c.adjoin.length;o++){if(!c.adjoin[o])continue;const _=c.adjoin[o].adjoin.indexOf(c);c.adjoin[o].adjoin[_]=I[o]}a.push(...I);const C=I.map(o=>[o,0]);for(;C.length>0;){const[o,_]=C.pop(),h=o.adjoin[_];if(!h)continue;const M=h.adjoin.indexOf(o);if(!o.contains_circle(h.p[M]))continue;const x=(_+1)%3,N=(_+2)%3;let k=(M+1)%3,g=(M+2)%3;(h.p[k].x!==o.p[x].x||h.p[k].y!==o.p[x].y)&&([k,g]=[g,k]);const B=o.p,b=o.adjoin,O=h.adjoin;o.p=[o.p[_],o.p[x],h.p[M]],o.adjoin=[O[g],h,b[N]],O[g]&&(O[g].adjoin[O[g].adjoin.indexOf(h)]=o),h.p=[B[_],B[N],h.p[M]],h.adjoin=[O[k],o,b[x]],b[x]&&(b[x].adjoin[b[x].adjoin.indexOf(o)]=h),C.push([o,0]),C.push([h,0])}}for(let n=a.length-1;n>=0;n--)a[n].p.some(e=>u.some(l=>e.x===l.x&&e.y===l.y))&&a.splice(n,1);const f=[],y=[];for(const n of a){f.push(n.area);const[e,l,c]=n.p;y.push(e.distance(l),l.distance(c),c.distance(e))}const D=f.reduce((n,e)=>n+e,0)/f.length,G=f.reduce((n,e)=>n+(e-D)**2,0)/f.length,H=Math.sqrt(G),q=y.reduce((n,e)=>n+e,0)/y.length,J=y.reduce((n,e)=>n+(e-q)**2,0)/y.length,T=Math.sqrt(J),p=Array.from(t,()=>new Set);for(const n of a){if((n.area-D)/H>=this._area_threshold)continue;const[l,c,d]=n.p;(l.distance(c)-q)/T<this._length_threshold&&(p[l.value].add(c.value),p[c.value].add(l.value)),(c.distance(d)-q)/T<this._length_threshold&&(p[c.value].add(d.value),p[d.value].add(c.value)),(l.distance(d)-q)/T<this._length_threshold&&(p[l.value].add(d.value),p[d.value].add(l.value))}const E=Array(s).fill(-1),A=Array(s).fill(!1);let F=-1;const v=[];for(;;){if(v.length===0){for(let e=0;e<s;e++)if(!A[e]){if(p[e].size<this._minPts){A[e]=!0;continue}v.push(e),F++;break}if(v.length===0)break}const n=v.pop();A[n]||(A[n]=!0,!(p[n].size<this._minPts)&&(E[n]=F,v.push(...p[n])))}return E}}
