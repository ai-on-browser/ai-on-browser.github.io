import{Matrix}from"../util/math.js";export default class KalmanFilter{constructor(){this._d=10,this._F=Matrix.eye(this._d,this._d),this._Q=Matrix.eye(this._d,this._d)}fit(t){const s=t.length,i=t[0].length;t=Matrix.fromArray(t),this._x=[Matrix.randn(this._d,1)],this._P=[this._F.dot(this._F.t)];const h=[],_=[];this._H=Matrix.randn(i,this._d),this._H.mult(.01),this._R=t.cov(),i<=this._d&&(this._x[0]=this._H.solve(t.row(0).t));for(let i=0;i<s;i++){const s=this._F.dot(this._x[i]),o=this._F.dot(this._P[i]).dot(this._F.t);o.add(this._Q),h.push(s),_.push(o);const d=this._H.dot(s);d.isub(t.row(i).t);const r=this._H.dot(o).dot(this._H.t);r.add(this._R);const e=o.dot(this._H.tDot(r.inv()));this._x.push(s.copyAdd(e.dot(d))),this._P.push(Matrix.eye(this._d,this._d).copySub(e.dot(this._H)).dot(o))}let o=this._x[s].copy();const d=[];for(let t=s-1;t>=0;t--){const s=this._P[t].dot(this._F.t).dot(_[t].inv());o=this._x[t].copyAdd(s.dot(o.copySub(h[t]))),d[t]=this._H.dot(o).value}return d}predict(t){const s=[];let i=this._x[this._x.length-1],h=this._P[this._P.length-1];for(let _=0;_<t;_++)i=this._F.dot(i),s.push(this._H.dot(i).value),h=this._F.dot(h).dot(this._F.t);return s}}