var p=Object.defineProperty;var F=(c,s)=>p(c,"name",{value:s,configurable:!0});import i from"../util/matrix.js";export default class H{static{F(this,"KalmanFilter")}constructor(){this._d=10,this._F=i.eye(this._d,this._d),this._Q=i.eye(this._d,this._d)}fit(s){const h=s.length,_=s[0].length;s=i.fromArray(s),this._x=[i.randn(this._d,1)],this._P=[this._F.dot(this._F.t)];const o=[],d=[];this._H=i.randn(_,this._d),this._H.mult(.01),this._R=s.cov(),_<=this._d&&(this._x[0]=this._H.solve(s.row(0).t));for(let t=0;t<h;t++){const e=this._F.dot(this._x[t]),n=this._F.dot(this._P[t]).dot(this._F.t);n.add(this._Q),o.push(e),d.push(n);const a=this._H.dot(e);a.isub(s.row(t).t);const u=this._H.dot(n).dot(this._H.t);u.add(this._R);const x=n.dot(this._H.tDot(u.inv()));this._x.push(i.add(e,x.dot(a))),this._P.push(i.sub(i.eye(this._d,this._d),x.dot(this._H)).dot(n))}let r=this._x[h].copy();const l=[];for(let t=h-1;t>=0;t--){const e=this._P[t].dot(this._F.t).dot(d[t].inv());r=i.add(this._x[t],e.dot(i.sub(r,o[t]))),l[t]=this._H.dot(r).value}return l}predict(s){const h=[];let _=this._x[this._x.length-1],o=this._P[this._P.length-1];for(let d=0;d<s;d++)_=this._F.dot(_),h.push(this._H.dot(_).value),o=this._F.dot(o).dot(this._F.t);return h}}
