export default class NeuralGas{constructor(t=1,e=.99){this._l=t,this._eps=1,this._epoch=0,this._sample_rate=.8,this._m=e,this._centroids=[]}get centroids(){return this._centroids}get size(){return this._centroids.length}_distance(t,e){let s=0;for(let r=t.length-1;r>=0;r--)s+=(t[r]-e[r])**2;return Math.sqrt(s)}add(t){for(;;){const e=t[Math.floor(Math.random()*t.length)];if(Math.min.apply(null,this._centroids.map((t=>this._distance(e,t))))>1e-8){const t=e.concat();return this._centroids.push(t),t}}}clear(){this._centroids=[]}predict(t){if(0===this._centroids.length)throw new Error("Call fit before predict.");return t.map((t=>{let e=1/0,s=-1;for(let r=0;r<this._centroids.length;r++){const i=this._distance(t,this._centroids[r]);i<e&&(e=i,s=r)}return s}))}fit(t){if(0===this._centroids.length||0===t.length)return 0;const e=this._centroids,s=t.filter((()=>Math.random()<this._sample_rate));this._epoch++;const r=this._centroids,i=s.map((t=>{let e=r.map(((e,s)=>[s,this._distance(t,e)]));return e.sort(((t,e)=>t[1]-e[1])),e=e.map(((t,e)=>[t[0],t[1],e])),e.sort(((t,e)=>t[0]-e[0])),e}));this._centroids=r.map(((t,e)=>{const r=Array(s[0].length).fill(0);for(let n=0;n<s.length;n++)for(let h=0;h<s[n].length;h++)r[h]+=(s[n][h]-t[h])*this._eps*Math.exp(-i[n][e][2]/this._l);return r.map(((e,r)=>t[r]+e/s.length))})),this._l*=this._m;return e.reduce(((t,e,s)=>t+this._distance(e,this._centroids[s])),0)}}