var w=Object.defineProperty;var f=(d,e)=>w(d,"name",{value:e,configurable:!0});import u from"../util/matrix.js";export default class m{static{f(this,"LagrangeInterpolation")}constructor(e="weighted"){this._method=e,this._w_type=2}fit(e,n){this._x=e,this._y=n}predict(e){if(this._method==="weighted")return this._weighted(e);if(this._method==="newton")return this._newton(e);const n=this._x,l=this._y;return e.map(r=>n.reduce((i,o,h)=>i+l[h]*n.reduce((s,c,t)=>h===t?s:s*(r-c)/(o-c),1),0))}_weighted(e){const n=this._x,l=this._y,r=n.map((i,o)=>1/n.reduce((h,s,c)=>c===o?h:h*(i-s),1));return this._w_type===1?e.map(i=>{let o=1,h=0;for(let s=0;s<n.length;s++){if(i===n[s])return l[s];o*=i-n[s],h+=l[s]*r[s]/(i-n[s])}return o*h}):e.map(i=>{let o=0,h=0;return n.forEach((s,c)=>{const t=r[c]/(i-s+1e-8);h+=t,o+=l[c]*t}),o/h})}_newton(e){const n=this._x,l=this._y,r=n.length,i=e.length,o=u.zeros(r,r);for(let t=0;t<r;t++)o.set(t,0,1);for(let t=1;t<r;t++)for(let _=t;_<r;_++)o.set(_,t,o.at(_,t-1)*(n[_]-n[t-1]));const h=new u(r,1,l),s=o.solve(h),c=new u(i,r);for(let t=0;t<i;t++)c.set(t,0,1);e=new u(i,1,e);for(let t=1;t<r;t++)c.set(0,t,u.mult(c.col(t-1),u.sub(e,n[t-1])));return c.dot(s).value}}
