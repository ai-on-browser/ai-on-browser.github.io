var f=Object.defineProperty;var w=(d,e)=>f(d,"name",{value:e,configurable:!0});import _ from"../util/matrix.js";export default class m{static{w(this,"LagrangeInterpolation")}constructor(e="weighted"){this._method=e,this._w_type=2}fit(e,n){this._x=e,this._y=n}predict(e){if(this._method==="weighted")return this._weighted(e);if(this._method==="newton")return this._newton(e);const n=this._x,u=this._y;return e.map(o=>n.reduce((c,i,r)=>c+u[r]*n.reduce((h,s,t)=>r===t?h:h*(o-s)/(i-s),1),0))}_weighted(e){const n=this._x,u=this._y,o=n.map((c,i)=>1/n.reduce((r,h,s)=>s===i?r:r*(c-h),1));return this._w_type===1?e.map(c=>{const i=n.reduce((r,h)=>r*(c-h),1);return n.reduce((r,h,s)=>r+u[s]*i*o[s]/(c-h+1e-8),0)}):e.map(c=>{let i=0,r=0;return n.forEach((h,s)=>{const t=o[s]/(c-h+1e-8);r+=t,i+=u[s]*t}),i/r})}_newton(e){const n=this._x,u=this._y,o=n.length,c=e.length,i=_.zeros(o,o);for(let t=0;t<o;t++)i.set(t,0,1);for(let t=1;t<o;t++)for(let l=t;l<o;l++)i.set(l,t,i.at(l,t-1)*(n[l]-n[t-1]));const r=new _(o,1,u),h=i.solve(r),s=new _(c,o);for(let t=0;t<c;t++)s.set(t,0,1);e=new _(c,1,e);for(let t=1;t<o;t++)s.set(0,t,_.mult(s.col(t-1),_.sub(e,n[t-1])));return s.dot(h).value}}
