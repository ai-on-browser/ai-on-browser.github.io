import{Matrix}from"../util/math.js";export default class LagrangeInterpolation{constructor(t="weighted"){this._method=t,this._w_type=2}fit(t,e){this._x=t,this._y=e}predict(t){if("weighted"===this._method)return this._weighted(t);if("newton"===this._method)return this._newton(t);const e=this._x,r=this._y;return t.map((t=>e.reduce(((i,o,s)=>i+r[s]*e.reduce(((e,r,i)=>s===i?e:e*(t-r)/(o-r)),1)),0)))}_weighted(t){const e=this._x,r=this._y,i=e.map(((t,r)=>1/e.reduce(((e,i,o)=>o===r?e:e*(t-i)),1)));return 1===this._w_type?t.map((t=>{const o=e.reduce(((e,r)=>e*(t-r)),1);return e.reduce(((e,s,n)=>e+r[n]*o*i[n]/(t-s+1e-8)),0)})):t.map((t=>{let o=0,s=0;return e.forEach(((e,n)=>{const h=i[n]/(t-e);s+=h,o+=r[n]*h})),o/s}))}_newton(t){const e=this._x,r=this._y,i=e.length,o=t.length,s=Matrix.zeros(i,i);for(let t=0;t<i;t++)s.set(t,0,1);for(let t=1;t<i;t++)for(let r=t;r<i;r++)s.set(r,t,s.at(r,t-1)*(e[r]-e[t-1]));const n=new Matrix(i,1,r),h=s.solve(n),c=new Matrix(o,i);for(let t=0;t<o;t++)c.set(t,0,1);t=new Matrix(o,1,t);for(let r=1;r<i;r++)c.set(0,r,c.col(r-1).copyMult(t.copySub(e[r-1])));return c.dot(h).value}}