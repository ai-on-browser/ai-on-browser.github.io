import{Matrix}from"../util/math.js";export default class LagrangeInterpolation{constructor(t="weighted"){this._method=t,this._w_type=2}fit(t,e){this._x=t,this._y=e}predict(t){const e=this._x,r=this._y;if("weighted"===this._method){const o=e.map(((t,r)=>1/e.reduce(((e,o,s)=>s===r?e:e*(t-o)),1)));return 1===this._w_type?t.map((t=>{const s=e.reduce(((e,r)=>e*(t-r)),1);return e.reduce(((e,i,n)=>e+r[n]*s*o[n]/(t-i+1e-8)),0)})):t.map((t=>{let s=0,i=0;return e.forEach(((e,n)=>{const c=o[n]/(t-e);i+=c,s+=r[n]*c})),s/i}))}if("newton"===this._method){const o=e.length,s=t.length,i=Matrix.zeros(o,o);for(let t=0;t<o;t++)i.set(t,0,1);for(let t=1;t<o;t++)for(let r=t;r<o;r++)i.set(r,t,i.at(r,t-1)*(e[r]-e[t-1]));const n=new Matrix(o,1,r),c=i.solve(n),a=new Matrix(s,o);for(let t=0;t<s;t++)a.set(t,0,1);t=new Matrix(s,1,t);for(let r=1;r<o;r++)a.set(0,r,a.col(r-1).copyMult(t.copySub(e[r-1])));return a.dot(c).value}return t.map((t=>e.reduce(((o,s,i)=>o+r[i]*e.reduce(((e,r,o)=>i===o?e:e*(t-r)/(s-r)),1)),0)))}}