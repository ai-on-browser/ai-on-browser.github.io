import Matrix from"../util/matrix.js";export default class LagrangeInterpolation{constructor(t="weighted"){this._method=t,this._w_type=2}fit(t,e){this._x=t,this._y=e}predict(t){if("weighted"===this._method)return this._weighted(t);if("newton"===this._method)return this._newton(t);const e=this._x,r=this._y;return t.map((t=>e.reduce(((i,s,o)=>i+r[o]*e.reduce(((e,r,i)=>o===i?e:e*(t-r)/(s-r)),1)),0)))}_weighted(t){const e=this._x,r=this._y,i=e.map(((t,r)=>1/e.reduce(((e,i,s)=>s===r?e:e*(t-i)),1)));return 1===this._w_type?t.map((t=>{const s=e.reduce(((e,r)=>e*(t-r)),1);return e.reduce(((e,o,n)=>e+r[n]*s*i[n]/(t-o+1e-8)),0)})):t.map((t=>{let s=0,o=0;return e.forEach(((e,n)=>{const h=i[n]/(t-e+1e-8);o+=h,s+=r[n]*h})),s/o}))}_newton(t){const e=this._x,r=this._y,i=e.length,s=t.length,o=Matrix.zeros(i,i);for(let t=0;t<i;t++)o.set(t,0,1);for(let t=1;t<i;t++)for(let r=t;r<i;r++)o.set(r,t,o.at(r,t-1)*(e[r]-e[t-1]));const n=new Matrix(i,1,r),h=o.solve(n),a=new Matrix(s,i);for(let t=0;t<s;t++)a.set(t,0,1);t=new Matrix(s,1,t);for(let r=1;r<i;r++)a.set(0,r,Matrix.mult(a.col(r-1),Matrix.sub(t,e[r-1])));return a.dot(h).value}}