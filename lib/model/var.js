import{Matrix}from"../util/math.js";export default class VAR{constructor(t){this._p=t}fit(t){this._levinson(t)}_yuleWalker(t){const s=t.length,o=(t=Matrix.fromArray(t)).cols,i=new Matrix(this._p*o,o),e=new Matrix(this._p*o,this._p*o);for(let r=0;r<=this._p;r++){const l=t.slice(0,s-r).tDot(t.slice(r,s));if(l.div(s),r>0&&i.set((r-1)*o,0,l),r<this._p)for(let t=0;t<this._p-r;t++)e.set(t*o,(r+t)*o,l),e.set((r+t)*o,t*o,l)}const r=e.solve(i);this._phi=[];for(let t=0;t<this._p;t++)this._phi[t]=r.slice(t*o,(t+1)*o)}_levinson(t){const s=t.length;t=Matrix.fromArray(t);const o=[];for(let i=0;i<=this._p;i++){const e=t.slice(0,s-i).tDot(t.slice(i,s));e.div(s),o[i]=e}const i=[],e=[];i[0]=e[0]=o[0];let r=[],l=[];for(let t=0;t<this._p;t++){const s=o[t+1].copy();for(let i=0;i<t;i++)s.sub(r[i].dot(o[t-i]));const h=[],c=[];h[t]=s.dot(e[t].inv()),c[t]=s.tDot(i[t].inv());for(let s=0;s<t;s++)h[s]=r[s].copySub(h[t].dot(l[t-s-1])),c[s]=l[s].copySub(c[t].dot(r[t-s-1]));i[t+1]=o[0].copy(),e[t+1]=o[0].copy();for(let s=0;s<t+1;s++)i[t+1].sub(h[s].dot(o[s+1].t)),e[t+1].sub(c[s].dot(o[s+1]));r=h,l=c}this._phi=r}predict(t,s){const o=[],i=t.slice(t.length-this._p);i.reverse();for(let e=0;e<s;e++){const s=Matrix.zeros(t[0].length,1);for(let t=0;t<this._p;t++)s.add(this._phi[t].dot(Matrix.fromArray(i[t])));o.push(s.value),i.unshift(s.value),i.pop()}return o}}