import{Matrix}from"../util/math.js";export default class VAR{constructor(t){this._p=t}fit(t){this._levinson(t)}_yuleWalker(t){const o=t.length,s=(t=Matrix.fromArray(t)).cols,i=new Matrix(this._p*s,s),e=new Matrix(this._p*s,this._p*s);for(let r=0;r<=this._p;r++){const l=t.sliceRow(0,o-r).tDot(t.sliceRow(r,o));if(l.div(o),r>0&&i.set((r-1)*s,0,l),r<this._p)for(let t=0;t<this._p-r;t++)e.set(t*s,(r+t)*s,l),e.set((r+t)*s,t*s,l)}const r=e.solve(i);this._phi=[];for(let t=0;t<this._p;t++)this._phi[t]=r.sliceRow(t*s,(t+1)*s)}_levinson(t){const o=t.length;t=Matrix.fromArray(t);const s=[];for(let i=0;i<=this._p;i++){const e=t.sliceRow(0,o-i).tDot(t.sliceRow(i,o));e.div(o),s[i]=e}const i=[],e=[];i[0]=e[0]=s[0];let r=[],l=[];for(let t=0;t<this._p;t++){const o=s[t+1].copy();for(let i=0;i<t;i++)o.sub(r[i].dot(s[t-i]));const h=[],c=[];h[t]=o.dot(e[t].inv()),c[t]=o.tDot(i[t].inv());for(let o=0;o<t;o++)h[o]=r[o].copySub(h[t].dot(l[t-o-1])),c[o]=l[o].copySub(c[t].dot(r[t-o-1]));i[t+1]=s[0].copy(),e[t+1]=s[0].copy();for(let o=0;o<t+1;o++)i[t+1].sub(h[o].dot(s[o+1].t)),e[t+1].sub(c[o].dot(s[o+1]));r=h,l=c}this._phi=r}predict(t,o){const s=[],i=t.slice(t.length-this._p);i.reverse();for(let e=0;e<o;e++){const o=Matrix.zeros(t[0].length,1);for(let t=0;t<this._p;t++)o.add(this._phi[t].dot(Matrix.fromArray(i[t])));s.push(o.value),i.unshift(o.value),i.pop()}return s}}