import Matrix from"../util/matrix.js";export default class VAR{constructor(t){this._p=t}fit(t){this._levinson(t)}_yuleWalker(t){const s=t.length,i=(t=Matrix.fromArray(t)).cols,o=new Matrix(this._p*i,i),e=new Matrix(this._p*i,this._p*i);for(let r=0;r<=this._p;r++){const l=t.slice(0,s-r).tDot(t.slice(r,s));if(l.div(s),r>0&&o.set((r-1)*i,0,l),r<this._p)for(let t=0;t<this._p-r;t++)e.set(t*i,(r+t)*i,l),e.set((r+t)*i,t*i,l)}const r=e.solve(o);this._phi=[];for(let t=0;t<this._p;t++)this._phi[t]=r.slice(t*i,(t+1)*i)}_levinson(t){const s=t.length;t=Matrix.fromArray(t);const i=[];for(let o=0;o<=this._p;o++){const e=t.slice(0,s-o).tDot(t.slice(o,s));e.div(s),i[o]=e}const o=[],e=[];o[0]=e[0]=i[0];let r=[],l=[];for(let t=0;t<this._p;t++){const s=i[t+1].copy();for(let o=0;o<t;o++)s.sub(r[o].dot(i[t-o]));const h=[],n=[];h[t]=s.dot(e[t].inv()),n[t]=s.tDot(o[t].inv());for(let s=0;s<t;s++)h[s]=Matrix.sub(r[s],h[t].dot(l[t-s-1])),n[s]=Matrix.sub(l[s],n[t].dot(r[t-s-1]));o[t+1]=i[0].copy(),e[t+1]=i[0].copy();for(let s=0;s<t+1;s++)o[t+1].sub(h[s].dot(i[s+1].t)),e[t+1].sub(n[s].dot(i[s+1]));r=h,l=n}this._phi=r}predict(t,s){const i=[],o=t.slice(t.length-this._p);o.reverse();for(let e=0;e<s;e++){const s=Matrix.zeros(t[0].length,1);for(let t=0;t<this._p;t++)s.add(this._phi[t].dot(Matrix.fromArray(o[t])));i.push(s.value),o.unshift(s.value),o.pop()}return i}}