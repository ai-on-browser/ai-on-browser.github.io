import Matrix from"../util/matrix.js";class Gaussian{constructor(){this._means=null,this._vars=null}_estimate_prob(t){this._means=t.mean(0),this._vars=t.variance(0)}_data_prob(t){const s=Matrix.sub(t,this._means);return s.mult(s),s.div(this._vars),s.map((t=>Math.exp(-t/2))),s.div(Matrix.map(this._vars,(t=>Math.sqrt(2*Math.PI*t)))),s.prod(1)}}class ODE{constructor(t=20,s="gaussian"){this._discrete=t,this._m=1,"gaussian"===s&&(this._p_class=Gaussian),this._p=[]}fit(t,s,i){this._k=i,this._labels=[...new Set(s)],this._p=[];const e=Matrix.fromArray(t).col(i),r=e.max(),h=e.min();this._r=[-1/0];for(let t=1;t<this._discrete;t++)this._r[t]=h+(r-h)*t/this._discrete;this._r.push(1/0),this._rate=[];for(let e=0;e<this._labels.length;e++){this._rate[e]=[],this._p[e]=[];for(let r=0;r<this._discrete;r++){const h=t.filter(((t,h)=>s[h]===this._labels[e]&&this._r[r]<=t[i]&&t[i]<this._r[r+1]));h.length>=this._m?(this._p[e][r]=new this._p_class,this._p[e][r]._estimate_prob(Matrix.fromArray(h),e,r),this._rate[e][r]=h.length/t.length):this._rate[e][r]=0}}}probability(t){const s=[];for(let i=0;i<this._labels.length;i++){const e=t.map((t=>{const s=new Matrix(1,t.length,t);for(let e=0;e<this._discrete;e++)if(this._r[e]<=t[this._k]&&t[this._k]<this._r[e+1])return 0===this._rate[i][e]?0:this._p[i][e]._data_prob(s,i,e).toScaler()*this._rate[i][e]}));s.push(e)}return s}predict(t){const s=this.probability(t);return t.map(((t,i)=>{let e=0,r=-1;for(let t=0;t<this._labels.length;t++){let h=s[t][i];h>e&&(e=h,r=t)}return this._labels[r]}))}}export default class AODE{constructor(t=20){this._discrete=t}fit(t,s){const i=t[0].length;this._labels=[...new Set(s)],this._ode=[];for(let e=0;e<i;e++){const i=new ODE(this._discrete);i.fit(t,s,e),this._ode[e]=i}}predict(t){const s=this._ode.map((s=>s.probability(t))),i=[];for(let e=0;e<t.length;e++){let t=-1/0,r=-1;for(let i=0;i<this._labels.length;i++){const h=s.reduce(((t,s)=>t+s[i][e]),0)/this._ode.length;h>t&&(t=h,r=i)}i[e]=t>0?this._labels[r]:null}return i}}