import Matrix from"../util/matrix.js";const logGamma=t=>{if(Number.isInteger(t)&&t>0){let r=0;for(let e=2;e<t;e++)r+=Math.log(e);return r}if(Number.isInteger(t-.5)&&t>0){const r=t-.5;let e=Math.log(Math.sqrt(Math.PI))-Math.log(2)*r;for(let t=2*r-1;t>0;t-=2)e+=Math.log(t);return e}throw""},beta=(t,r)=>Math.exp(logGamma(t)+logGamma(r)-logGamma(t+r)),ibeta=(t,r,e)=>{if(t>(r+1)/(r+e+1))return 1-ibeta(1-t,e,r);let a,o,s,l=-t*(r+e)/(r+1),n=2,i=1+l/n,h=1,f=1+l/h,u=1,M=n/h*u,c=i/f*M;for(let m=1;m<1e3&&!(Math.abs(c-u)<1e-12);m++){const g=2*m*r;a=t*m*(e-m)/(g*(g-1)),l=-t*(r+m)*(r+e+m)/(g*(g+1)),o=i,n=1+a/o,i=1+l/n,s=f,h=1+a/s,f=1+l/h,u=c,M=n/h*u,c=i/f*M}return t**r*(1-t)**e*(c-1)/(r*beta(r,e))},ct=(t,r)=>{if(1===r)return.5+Math.atan(t)/Math.PI;if(2===r)return(1+t/Math.sqrt(2+t**2))/2;const e=Math.sqrt(t**2+r);return ibeta((t+e)/(2*e),r/2,r/2)},qt=(t,r)=>{if(Math.abs(r)>1)throw"absolute of 'a' need less than or equals to 1.";if(1===Math.abs(r))return Math.sign(r)*(1/0);if(r>.5)return-qt(t,1-r);r=1-r;let e=1,a=null,o=0;let s=1e4;for(;s-- >0;){const s=ct(e,t);if(isNaN(s))return s;if(Math.abs(s-r)<1e-5)return e;s<r?(o=e,null===a?e*=2:e=(e+a)/2):(a=e,e=(e+o)/2)}throw"qt not converged."};export default class GeneralizedESD{constructor(t,r){this._alpha=t,this._r=r}predict(t){const r=Matrix.fromArray(t),e=[],a=[],o=r.rows;for(let t=1;t<=this._r;t++){const t=Matrix.sub(r,r.mean(0));t.abs(),t.div(r.std(0));const o=t.max(1),s=o.argmax(0).toScaler();a.push(o.at(s,0)),r.remove(s),e.push(s)}for(let t=e.length-1;t>=0;t--)for(let r=t+1;r<e.length;r++)e[t]<=e[r]&&e[r]++;for(let t=1;t<=this._r;t++){const r=this._alpha/(2*(o-t+1)),s=qt(o-t-1,r),l=(o-t)*s/Math.sqrt((o-t-1+s**2)*(o-t+1));if(a[t-1]<=l){e.splice(t-1,this._r);break}}const s=Array(o).fill(!1);for(let t=0;t<e.length;t++)s[e[t]]=!0;return s}}