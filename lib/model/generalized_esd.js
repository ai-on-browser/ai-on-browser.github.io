import Matrix from"../util/matrix.js";const logGamma=t=>{if(Number.isInteger(t)&&t>0){let r=0;for(let a=2;a<t;a++)r+=Math.log(a);return r}if(Number.isInteger(t-.5)&&t>0){const r=t-.5;let a=Math.log(Math.sqrt(Math.PI))-Math.log(2)*r;for(let t=2*r-1;t>0;t-=2)a+=Math.log(t);return a}throw""},beta=(t,r)=>Math.exp(logGamma(t)+logGamma(r)-logGamma(t+r)),ibeta=(t,r,a)=>{if(t>(r+1)/(r+a+1))return 1-ibeta(1-t,a,r);let e,o,l,s=-t*(r+a)/(r+1),n=2,h=1+s/n,i=1,f=1+s/i,m=1,u=n/i*m,M=h/f*u;for(let c=1;c<1e3&&!(Math.abs(M-m)<1e-12);c++){const g=2*c*r;e=t*c*(a-c)/(g*(g-1)),s=-t*(r+c)*(r+a+c)/(g*(g+1)),o=h,n=1+e/o,h=1+s/n,l=f,i=1+e/l,f=1+s/i,m=M,u=n/i*m,M=h/f*u}return t**r*(1-t)**a*(M-1)/(r*(c=r,g=a,Math.exp(logGamma(c)+logGamma(g)-logGamma(c+g))));var c,g},ct=(t,r)=>{if(1===r)return.5+Math.atan(t)/Math.PI;if(2===r)return(1+t/Math.sqrt(2+t**2))/2;const a=Math.sqrt(t**2+r);return ibeta((t+a)/(2*a),r/2,r/2)},qt=(t,r)=>{if(Math.abs(r)>1)throw"absolute of 'a' need less than or equals to 1.";if(1===Math.abs(r))return Math.sign(r)*(1/0);if(r>.5)return-qt(t,1-r);r=1-r;let a=1,e=null,o=0;let l=1e4;for(;l-- >0;){const l=ct(a,t);if(isNaN(l))return l;if(Math.abs(l-r)<1e-5)return a;l<r?(o=a,null===e?a*=2:a=(a+e)/2):(e=a,a=(a+o)/2)}throw"qt not converged."};export default class GeneralizedESD{constructor(t,r){this._alpha=t,this._r=r}predict(t){const r=Matrix.fromArray(t),a=[],e=[],o=r.rows;for(let t=1;t<=this._r;t++){const t=Matrix.sub(r,r.mean(0));t.abs(),t.div(r.std(0));const o=t.max(1),l=o.argmax(0).toScaler();e.push(o.at(l,0)),r.remove(l),a.push(l)}for(let t=a.length-1;t>=0;t--)for(let r=t+1;r<a.length;r++)a[t]<=a[r]&&a[r]++;for(let t=1;t<=this._r;t++){const r=this._alpha/(2*(o-t+1)),l=qt(o-t-1,r),s=(o-t)*l/Math.sqrt((o-t-1+l**2)*(o-t+1));if(e[t-1]<=s){a.splice(t-1,this._r);break}}const l=Array(o).fill(!1);for(let t=0;t<a.length;t++)l[a[t]]=!0;return l}}