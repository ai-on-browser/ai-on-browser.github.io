export default class CLUES{constructor(t=.05){this._alpha=t,this._m=20,this._eps=1e-4}get size(){const t=this.predict();return new Set(t).size}_d(t,r){return Math.sqrt(t.reduce(((t,e,i)=>t+(e-r[i])**2),0))}fit(t){const r=t.length;let e=Math.max(1,Math.round(this._alpha*r));const i=Math.max(1,Math.round(this._alpha*r)),l=Math.max(1,Math.round(this._alpha*r));let s=-1/0,n=null,o=1/0,h=t;for(let t=1;t<=l;t++){h=this._shrinking(h,e);const a=this._partitioin(h),c=new Set(a).size;if(1===c)break;const f=Array(r).fill(0),d=Array(r).fill(1/0),_=Array(c).fill(0),g=Array.from({length:r},(()=>[]));for(let t=0;t<r;t++){g[t][t]={i:t,d:0};for(let e=t+1;e<r;e++){const r=this._d(h[t],h[e]);g[t][e]={i:e,d:r},g[e][t]={i:t,d:r}}g[t].sort(((t,r)=>t.d-r.d));for(let e=1;e<r;e++)a[t]===a[g[t][e].i]?f[t]+=g[t][e].d:d[t]=Math.min(d[t],g[t][e].d);_[a[t]]++}let u=0;for(let t=0;t<r;t++)f[t]>0&&(f[t]/=_[a[t]]-1),u+=(d[t]-f[t])/Math.max(f[t],d[t]);if(u/=r,1===t)s=u,n=a,o=c;else{if(Math.min(..._)>=l)if(u>s)s=u,n=a,o=c;else if(2===c||2===o)break}e+=i}this._c=n}_shrinking(t,r){const e=t.length,i=t[0].length;let l=t.concat();const s=Array.from({length:e},(()=>[]));for(let t=0;t<this._m;t++){const t=[];let n=0;for(let o=0;o<e;o++){s[o][o]={i:o,d:0};for(let t=o+1;t<e;t++){const r=this._d(l[o],l[t]);s[o][t]={i:t,d:r},s[t][o]={i:o,d:r}}s[o].sort(((t,r)=>t.d-r.d));const h=s[o].slice(1,r+1).map((t=>l[t.i]));t[o]=Array(i);for(let r=0;r<i;r++){const e=h.map((t=>t[r]));e.sort(((t,r)=>t-r)),h.length%2==0?t[o][r]=(e[h.length/2]+e[h.length/2-1])/2:t[o][r]=e[(h.length-1)/2]}for(let r=0;r<t[o].length;r++)n=Math.max(n,Math.abs(t[o][r]-l[o][r]))}if(l=t,n<this._eps)break}return l}_partitioin(t){const r=t.length,e=Array.from({length:r},(()=>[]));for(let i=0;i<r;i++){e[i][i]={i:i,d:0};for(let l=i+1;l<r;l++){const r=this._d(t[i],t[l]);e[i][l]={i:l,d:r},e[l][i]={i:i,d:r}}e[i].sort(((t,r)=>t.d-r.d))}let i=0;const l=[i],s=[0],n=Array(r).fill(!1);for(let t=0;t<r-1;t++){n[i]=!0;for(let t=1;t<r;t++)if(!n[e[i][t].i]){s.push(e[i][t].d),l.push(e[i][t].i),i=e[i][t].i;break}}const o=s.concat();o.sort(((t,r)=>t-r));const h=t=>{const r=(o.length-1)*t,e=Math.floor(r),i=Math.ceil(r);return o[e]+(r-e)*(o[i]-o[e])},a=h(.75)-h(.25),c=s.reduce(((t,r)=>t+r),0)/(r-1)+1.5*a,f=[];let d=0;for(let t=0;t<r;t++)s[t]>c&&d++,f[l[t]]=d;return f}predict(){return this._c}}