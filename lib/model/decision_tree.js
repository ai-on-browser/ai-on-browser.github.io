import Tree from"../util/tree.js";class DecisionTree{constructor(){}get depth(){return this._tree.depth}init(e,t){this._datas=e.map(((e,a)=>({value:e,target:t[a]}))),this._tree=new Tree({datas:this._datas,value:this._calcValue(this._datas),score:this._calcScore(this._datas)}),this._features=e[0].length}fit(){this._tree.scanLeaf((e=>{let t=e.value.score,a=-1,r=-1;for(let s=0;s<this._features;s++){const l=e.value.datas.map((e=>e.value[s]));l.sort(((e,t)=>e-t));for(let c=0;c<l.length-1;c++){let i=(l[c]+l[c+1])/2,u=e.value.datas.filter((e=>e.value[s]<i)),h=e.value.datas.filter((e=>e.value[s]>=i));const n=(this._calcScore(u)*u.length+this._calcScore(h)*h.length)/l.length;n<t&&(t=n,a=s,r=i)}}if(t<e.value.score){e.value.feature=a,e.value.threshold=r;const t=e.value.datas.filter((e=>e.value[a]<r)),s=e.value.datas.filter((e=>e.value[a]>=r));e.push({datas:t,score:this._calcScore(t),value:this._calcValue(t)}),e.push({datas:s,score:this._calcScore(s),value:this._calcValue(s)})}}))}importance(){const e=Array(this._features).fill(0);let t=0;return this._tree.scan((a=>{if(a.isLeaf())return;const r=a.value.datas,s=a.at(0).value.datas,l=a.at(1).value.datas,c=(this._calcScore(r)*r.length-this._calcScore(s)*s.length-this._calcScore(l)*l.length)/this._datas.length;e[a.value.feature]+=c,t+=c})),0===t?e:e.map((e=>e/t))}predict_value(e){return e.map((e=>{let t=this._tree;for(;!t.isLeaf();)t=e[t.value.feature]<t.value.threshold?t.at(0):t.at(1);return t.value.value}))}}export class DecisionTreeClassifier extends DecisionTree{constructor(e){super(),this._method=e}_calcValue(e){return this._classesRate(e)}_calcScore(e){return"ID3"===this._method?this._id3(e):this._gini(e)}_classesRate(e){const t=new Map;return e.forEach((e=>{t.set(e.target,(t.get(e.target)||0)+1)})),t.forEach(((a,r)=>{t.set(r,a/=e.length)})),t}_id3(e){const t=this._classesRate(e);let a=0;return t.forEach((e=>a-=e*Math.log(e))),a}_gini(e){const t=this._classesRate(e);let a=1;return t.forEach((e=>a-=e**2)),a}predict_prob(e){return this.predict_value(e)}predict(e){return this.predict_prob(e).map((e=>{let t=0,a=-1;return e.forEach(((e,r)=>{e>t&&(t=e,a=r)})),a}))}}export class DecisionTreeRegression extends DecisionTree{_calcValue(e){if(0===e.length)return 0;if(Array.isArray(e[0].target)){const t=e[0].target.length;return e.reduce(((e,t)=>e.map(((e,a)=>e+t.target[a]))),Array(t).fill(0)).map((t=>t/e.length))}return e.reduce(((e,t)=>e+t.target),0)/e.length}_calcScore(e){if(0===e.length)return 0;const t=this._calcValue(e);return Array.isArray(e[0].target)?Math.sqrt(e.reduce(((e,a)=>e+a.target.reduce(((e,a,r)=>e+(a-t[r])**2),0)),0)/e.length):Math.sqrt(e.reduce(((e,a)=>e+(a.target-t)**2),0)/e.length)}predict(e){return this.predict_value(e)}}