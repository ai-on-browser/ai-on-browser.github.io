var w=Object.defineProperty;var _=(b,t)=>w(b,"name",{value:t,configurable:!0});import x from"../../util/matrix.js";import{NeuralnetworkException as g}from"../neuralnetwork.js";import m from"./layer/base.js";import{InputLayer as y,OutputLayer as O,ConstLayer as u}from"./layer/index.js";import N from"./onnx/onnx_exporter.js";import $ from"./onnx/onnx_importer.js";class V{static{_(this,"Node")}constructor(t,s,e,n,r){this.name=t,this.layer=s,this.input=e,this._graph=r,this._parent=n}get parents(){if(this._parent)return this._parent;const t=/\[([0-9]+)\]$/,s=/\[([a-zA-Z_][0-9a-zA-Z_]*)\]$/;return this._parent=this.input.map(e=>{if(typeof e=="number")return new u({value:e});const n=e&&e.match(t),r=e&&e.match(s),o=n?+n[1]:r?r[1]:null,i=n||r?e.slice(0,-(n||r)[0].length):e;for(let a=0;a<this._graph._nodes.length;a++)if(this._graph._nodes[a].name===i)return{index:a,subscript:o};throw new g(`Unknown input name '${e}'.`)})}get outputValue(){return this._outputValue}set outputValue(t){this._outputValue=t}get gradientValue(){return this._gradientValue}set gradientValue(t){this._gradientValue=t}toObject(){const t=this.layer.toObject();return this.name&&(t.name=this.name),this.input&&(t.input=this.input),t}}export default class d{static{_(this,"ComputationalGraph")}constructor(){this._nodes=[],this._order=null}get nodes(){return this._nodes}get inputNodes(){const t=[];for(let s=0;s<this._nodes.length;s++)this._nodes[s].layer instanceof y&&t.push(this._nodes[s]);return t}get outputNodes(){const t=[];for(let s=0;s<this._nodes.length;s++)this._nodes[s].layer instanceof O&&t.push(this._nodes[s]);return t}get size(){return this._nodes.length}static fromObject(t){const s=new d;for(const e of t){const n=m.fromObject(e);s.add(n,e.name,e.input)}return s}static async fromONNX(t){return d.fromObject(await $.load(t))}toObject(){return this._nodes.map(t=>t.toObject())}toDot(){let t=`digraph g {
`;const s=new Set;for(let e=0;e<this._nodes.length;e++){const n=this.nodes[e],r=n.layer.constructor.name+(n.name?`\\n${n.name}`:"");t+=`  l${e} [label="${r}"];
`;for(const o of n.parents)o instanceof u?(t+=`  c${o._value} -> l${e};
`,s.add(o._value)):t+=`  l${o.index} -> l${e};
`}for(const e of s)t+=`  c${e} [label="Constant\\n${e}"];
`;return t+"}"}toONNX(){return N.dump(this.toObject())}add(t,s,e=void 0){this._order=null,t instanceof m||(t=m.fromObject(t));let n=null;e==null?(n=[],t.calc.length>0&&this._nodes.length>0&&n.push({index:this._nodes.length-1,subscript:null})):Array.isArray(e)||(e=[e]),t.graph=this;const r=new V(s,t,e,n,this);if(s&&this.getNode(s))throw new g(`Duplicate layer name ${s}`);this._nodes.push(r)}bind(t){for(const s of this._nodes)s.layer.bind(t)}_calcOrder(){if(this._order)return;const t=[],s=Array.from(this._nodes,()=>[]),e=Array(this._nodes.length).fill(0);for(let n=0;n<this._nodes.length;n++){const r=this._nodes[n];for(const o of r.parents)o instanceof u||(s[o.index].push(n),e[n]++);for(const o of r.layer.dependentLayers)for(let i=0;i<this._nodes.length;i++)if(n!==i&&this._nodes[i].name===o&&!s[i].includes(n)){s[i].push(n),e[n]++;break}e[n]===0&&t.push(n)}for(this._order=[];t.length>0;){t.sort((r,o)=>o-r);const n=t.pop();this._order.push(n);for(const r of s[n])e[r]--,e[r]===0&&t.push(r)}if(e.some(n=>n!==0))throw new Error("This graph is not directed acyclic graph.")}calc(t){this._calcOrder();for(let n=0;n<this._nodes.length;n++)this._nodes[n].outputValue=null,this._nodes[n].gradientValue=null;const s=[],e=t?Array(t.length).fill(!1):[];for(const n of this._order)try{const r=this._nodes[n];if(s[n]=r.layer.calc(...r.parents.map(o=>o instanceof u?o.calc():typeof o.subscript=="number"?s[o.index][o.subscript]:o.subscript!==null?this._nodes[o.index].layer[o.subscript]:s[o.index])),r.outputValue=s[n],t){for(let o=0;o<t.length;o++)(typeof t[o]=="number"&&t[o]===n||t[o]===r.name)&&(e[o]=!0);if(e.every(o=>o))return}}catch(r){throw new g(`Error raises at ${n} layer. ${r.stack}`)}}grad(t){this._calcOrder();const s=this._nodes.length,e=Array.from(this._nodes,()=>[]),n=this._nodes[s-1].outputValue?.copy()??new x(1,1);n.fill(1),e[s-1]=[n];let r=null;for(const o of[...this._order].reverse()){const i=this._nodes[o];if(t)if(i.layer instanceof O)e[o]=[t],t=null;else continue;if(e[o].length===0)continue;for(let l=0;l<e[o].length;l++)e[o][l]===void 0&&(e[o][l]=null);i.gradientValue=e[o];let a=i.layer.grad(...e[o]);if(Array.isArray(a)||(a=Array(i.parents.length).fill(a)),a[a.length-1]?.constructor===Object){const l=a.pop();for(let c=0;c<o;c++){const h=l[this._nodes[c].name];h&&(e[c][0]?e[c][0].broadcastOperate(h,(f,p)=>f+p):e[c][0]=h.copy())}}i.parents.forEach((l,c)=>{if(l instanceof u||!a[c])return;const h=l.subscript||0;e[l.index][h]?e[l.index][h].broadcastOperate(a[c],(f,p)=>f+p):e[l.index][h]=a[c].copy()}),i.layer instanceof y&&(r=e[o][0])}return r}getNode(t){for(let s=0;s<this._nodes.length;s++)if(this._nodes[s].name===t)return this._nodes[s]}}
