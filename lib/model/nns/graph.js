import Matrix from"../../util/matrix.js";import{NeuralnetworkException}from"../neuralnetwork.js";import Layer from"./layer/base.js";import{InputLayer,OutputLayer}from"./layer/index.js";let ONNXImporter=null;export default class ComputationalGraph{constructor(){this._nodes=[]}get nodes(){return this._nodes}get inputNodes(){const t=[];for(let e=0;e<this._nodes.length;e++)this._nodes[e].layer instanceof InputLayer&&t.push(this._nodes[e]);return t}get outputNodes(){const t=[];for(let e=0;e<this._nodes.length;e++)this._nodes[e].layer instanceof OutputLayer&&t.push(this._nodes[e]);return t}get size(){return this._nodes.length}static fromObject(t){const e=new ComputationalGraph;for(const n of t){const t=Layer.fromObject(n);e.add(t,n.name,n.input)}return e}static async fromONNX(t){return ONNXImporter||(ONNXImporter=(await import("./onnx/onnx_importer.js")).default),ComputationalGraph.fromObject(await ONNXImporter.load(t))}toObject(){const t=[];for(let e=0;e<this._nodes.length;e++){const n=this._nodes[e],r=n.layer.toObject();n.name&&(r.name=n.name),n.input&&(r.input=n.input),t.push(r)}return t}toDot(){let t="digraph g {\n";for(let e=0;e<this._nodes.length;e++){const n=this.nodes[e];t+=`  l${e} [label="${n.layer.constructor.name}\\n${n.name}"];\n`;for(const r of n.parents)t+=`  l${r.index} -> l${e};\n`}return t+"}"}add(t,e,n=void 0){let r=[];n?("string"==typeof n&&(n=[n]),r=n.map((t=>{const e=t&&t.match(/\[([0-9]+)\]$/),n=e?+e[1]:null,r=e?t.slice(0,-e[0].length):t;for(let t=0;t<this._nodes.length;t++)if(this._nodes[t].name===r)return{index:t,subscript:n};throw new NeuralnetworkException(`Unknown input name '${t}'.`)}))):this._nodes.length>0&&r.push({index:this._nodes.length-1,subscript:null}),t.graph=this;const o={layer:t,name:e,input:n,parents:r,outputValue:null,gradientValue:null,get lastOutputSize(){return this.outputValue.sizes}};if(e&&this.getNode(e))throw new NeuralnetworkException(`Duplicate layer name ${e}`);this._nodes.push(o)}bind(t){for(const e of this._nodes)e.layer.bind(t)}calc(t){for(let t=0;t<this._nodes.length;t++)this._nodes[t].outputValue=null,this._nodes[t].gradientValue=null;const e=[],n=t?Array(t.length).fill(!1):[];for(let r=0;r<this._nodes.length;r++)try{const o=this._nodes[r];if(e[r]=o.layer.calc(...o.parents.map((t=>null!==t.subscript?e[t.index][t.subscript]:e[t.index]))),o.outputValue=e[r],t){for(let e=0;e<t.length;e++)("number"==typeof t[e]&&t[e]===r||t[e]===o.name)&&(n[e]=!0);if(n.every((t=>t)))return}}catch(t){throw new NeuralnetworkException(`Error raises at ${r} layer. ${t.stack}`)}}grad(t){const e=this._nodes.length,n=Array.from(this._nodes,(()=>[])),r=this._nodes[e-1].outputValue?.copy()??new Matrix(1,1);r.fill(1),n[e-1]=[r];let o=null;for(let r=e-1;r>=0;r--){const e=this._nodes[r];if(t){if(!(e.layer instanceof OutputLayer))continue;n[r]=[t],t=null}if(0===n[r].length)continue;for(let t=0;t<n[r].length;t++)void 0===n[r][t]&&(n[r][t]=null);e.gradientValue=n[r];let s=e.layer.grad(...n[r]);if(Array.isArray(s)||(s=Array(e.parents.length).fill(s)),s[s.length-1]?.constructor===Object){const t=s.pop();for(let e=0;e<r;e++){const r=t[this._nodes[e].name];r&&(n[e][0]?n[e][0].broadcastOperate(r,((t,e)=>t+e)):n[e][0]=r.copy())}}e.parents.forEach(((t,e)=>{if(!s[e])return;const r=t.subscript||0;n[t.index][r]?n[t.index][r].broadcastOperate(s[e],((t,e)=>t+e)):n[t.index][r]=s[e].copy()})),e.layer instanceof InputLayer&&(o=n[r][0])}return o}getNode(t){for(let e=0;e<this._nodes.length;e++)if(this._nodes[e].name===t)return this._nodes[e]}}