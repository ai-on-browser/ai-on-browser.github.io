var x=Object.defineProperty;var m=(y,n)=>x(y,"name",{value:n,configurable:!0});import w from"../../util/matrix.js";import{NeuralnetworkException as p}from"../neuralnetwork.js";import O from"./layer/base.js";import{InputLayer as _,OutputLayer as b}from"./layer/index.js";let g=null;export default class h{static{m(this,"ComputationalGraph")}constructor(){this._nodes=[]}get nodes(){return this._nodes}get inputNodes(){const n=[];for(let t=0;t<this._nodes.length;t++)this._nodes[t].layer instanceof _&&n.push(this._nodes[t]);return n}get outputNodes(){const n=[];for(let t=0;t<this._nodes.length;t++)this._nodes[t].layer instanceof b&&n.push(this._nodes[t]);return n}get size(){return this._nodes.length}static fromObject(n){const t=new h;for(const e of n){const o=O.fromObject(e);t.add(o,e.name,e.input)}return t}static async fromONNX(n){return g||(g=(await import("./onnx/onnx_importer.js")).default),h.fromObject(await g.load(n))}toObject(){const n=[];for(let t=0;t<this._nodes.length;t++){const e=this._nodes[t],o=e.layer.toObject();e.name&&(o.name=e.name),e.input&&(o.input=e.input),n.push(o)}return n}toDot(){let n=`digraph g {
`;for(let t=0;t<this._nodes.length;t++){const e=this.nodes[t];n+=`  l${t} [label="${e.layer.constructor.name}\\n${e.name}"];
`;for(const o of e.parents)n+=`  l${o.index} -> l${t};
`}return n+"}"}add(n,t,e=void 0){let o=[];if(!e)this._nodes.length>0&&o.push({index:this._nodes.length-1,subscript:null});else{typeof e=="string"&&(e=[e]);const s=/\[([0-9]+)\]$/,u=/\[([a-zA-Z_][0-9a-zA-Z_]*)\]$/;o=e.map(r=>{const i=r&&r.match(s),l=r&&r.match(u),c=i?+i[1]:l?l[1]:null,f=i||l?r.slice(0,-(i||l)[0].length):r;for(let d=0;d<this._nodes.length;d++)if(this._nodes[d].name===f)return{index:d,subscript:c};throw new p(`Unknown input name '${r}'.`)})}n.graph=this;const a={layer:n,name:t,input:e,parents:o,outputValue:null,gradientValue:null,get lastOutputSize(){return this.outputValue.sizes}};if(t&&this.getNode(t))throw new p(`Duplicate layer name ${t}`);this._nodes.push(a)}bind(n){for(const t of this._nodes)t.layer.bind(n)}calc(n){for(let o=0;o<this._nodes.length;o++)this._nodes[o].outputValue=null,this._nodes[o].gradientValue=null;const t=[],e=n?Array(n.length).fill(!1):[];for(let o=0;o<this._nodes.length;o++)try{const a=this._nodes[o];if(t[o]=a.layer.calc(...a.parents.map(s=>typeof s.subscript=="number"?t[s.index][s.subscript]:s.subscript!==null?this._nodes[s.index].layer[s.subscript]:t[s.index])),a.outputValue=t[o],n){for(let s=0;s<n.length;s++)(typeof n[s]=="number"&&n[s]===o||n[s]===a.name)&&(e[s]=!0);if(e.every(s=>s))return}}catch(a){throw new p(`Error raises at ${o} layer. ${a.stack}`)}}grad(n){const t=this._nodes.length,e=Array.from(this._nodes,()=>[]),o=this._nodes[t-1].outputValue?.copy()??new w(1,1);o.fill(1),e[t-1]=[o];let a=null;for(let s=t-1;s>=0;s--){const u=this._nodes[s];if(n)if(u.layer instanceof b)e[s]=[n],n=null;else continue;if(e[s].length===0)continue;for(let i=0;i<e[s].length;i++)e[s][i]===void 0&&(e[s][i]=null);u.gradientValue=e[s];let r=u.layer.grad(...e[s]);if(Array.isArray(r)||(r=Array(u.parents.length).fill(r)),r[r.length-1]?.constructor===Object){const i=r.pop();for(let l=0;l<s;l++){const c=i[this._nodes[l].name];c&&(e[l][0]?e[l][0].broadcastOperate(c,(f,d)=>f+d):e[l][0]=c.copy())}}u.parents.forEach((i,l)=>{if(!r[l])return;const c=i.subscript||0;e[i.index][c]?e[i.index][c].broadcastOperate(r[l],(f,d)=>f+d):e[i.index][c]=r[l].copy()}),u.layer instanceof _&&(a=e[s][0])}return a}getNode(n){for(let t=0;t<this._nodes.length;t++)if(this._nodes[t].name===n)return this._nodes[t]}}
