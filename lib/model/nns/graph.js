var O=Object.defineProperty;var p=(m,t)=>O(m,"name",{value:t,configurable:!0});import x from"../../util/matrix.js";import{NeuralnetworkException as _}from"../neuralnetwork.js";import g from"./layer/base.js";import{InputLayer as b,OutputLayer as y}from"./layer/index.js";import w from"./onnx/onnx_exporter.js";import N from"./onnx/onnx_importer.js";class V{static{p(this,"Node")}constructor(t,n,e,s,o){this.name=t,this.layer=n,this.input=e,this._graph=o,this._parent=s}get parents(){if(this._parent)return this._parent;const t=/\[([0-9]+)\]$/,n=/\[([a-zA-Z_][0-9a-zA-Z_]*)\]$/;return this._parent=this.input.map(e=>{const s=e&&e.match(t),o=e&&e.match(n),r=s?+s[1]:o?o[1]:null,i=s||o?e.slice(0,-(s||o)[0].length):e;for(let a=0;a<this._graph._nodes.length;a++)if(this._graph._nodes[a].name===i)return{index:a,subscript:r};throw new _(`Unknown input name '${e}'.`)})}get outputValue(){return this._outputValue}set outputValue(t){this._outputValue=t}get gradientValue(){return this._gradientValue}set gradientValue(t){this._gradientValue=t}get lastOutputSize(){return this.outputValue.sizes}toObject(){const t=this.layer.toObject();return this.name&&(t.name=this.name),this.input&&(t.input=this.input),t}}export default class u{static{p(this,"ComputationalGraph")}constructor(){this._nodes=[],this._order=null}get nodes(){return this._nodes}get inputNodes(){const t=[];for(let n=0;n<this._nodes.length;n++)this._nodes[n].layer instanceof b&&t.push(this._nodes[n]);return t}get outputNodes(){const t=[];for(let n=0;n<this._nodes.length;n++)this._nodes[n].layer instanceof y&&t.push(this._nodes[n]);return t}get size(){return this._nodes.length}static fromObject(t){const n=new u;for(const e of t){const s=g.fromObject(e);n.add(s,e.name,e.input)}return n}static async fromONNX(t){return u.fromObject(await N.load(t))}toObject(){return this._nodes.map(t=>t.toObject())}toDot(){let t=`digraph g {
`;for(let n=0;n<this._nodes.length;n++){const e=this.nodes[n],s=e.layer.constructor.name+(e.name?`\\n${e.name}`:"");t+=`  l${n} [label="${s}"];
`;for(const o of e.parents)t+=`  l${o.index} -> l${n};
`}return t+"}"}toONNX(){return w.dump(this.toObject())}add(t,n,e=void 0){this._order=null,t instanceof g||(t=g.fromObject(t));let s=null;e?typeof e=="string"&&(e=[e]):(s=[],t.calc.length>0&&this._nodes.length>0&&s.push({index:this._nodes.length-1,subscript:null})),t.graph=this;const o=new V(n,t,e,s,this);if(n&&this.getNode(n))throw new _(`Duplicate layer name ${n}`);this._nodes.push(o)}bind(t){for(const n of this._nodes)n.layer.bind(t)}_calcOrder(){if(this._order)return;const t=[],n=Array.from(this._nodes,()=>[]),e=Array.from(this._nodes,s=>s.parents.length);for(let s=0;s<this._nodes.length;s++){const o=this._nodes[s];for(const r of o.parents)n[r.index].push(s);for(const r of o.layer.dependentLayers)for(let i=0;i<this._nodes.length;i++)if(s!==i&&this._nodes[i].name===r&&!n[i].includes(s)){n[i].push(s),e[s]++;break}e[s]===0&&t.push(s)}for(this._order=[];t.length>0;){const s=t.pop();this._order.push(s);for(const o of n[s])e[o]--,e[o]===0&&t.push(o)}if(e.some(s=>s!==0))throw new Error("This graph is not directed acyclic graph.")}calc(t){this._calcOrder();for(let s=0;s<this._nodes.length;s++)this._nodes[s].outputValue=null,this._nodes[s].gradientValue=null;const n=[],e=t?Array(t.length).fill(!1):[];for(const s of this._order)try{const o=this._nodes[s];if(n[s]=o.layer.calc(...o.parents.map(r=>typeof r.subscript=="number"?n[r.index][r.subscript]:r.subscript!==null?this._nodes[r.index].layer[r.subscript]:n[r.index])),o.outputValue=n[s],t){for(let r=0;r<t.length;r++)(typeof t[r]=="number"&&t[r]===s||t[r]===o.name)&&(e[r]=!0);if(e.every(r=>r))return}}catch(o){throw new _(`Error raises at ${s} layer. ${o.stack}`)}}grad(t){this._calcOrder();const n=this._nodes.length,e=Array.from(this._nodes,()=>[]),s=this._nodes[n-1].outputValue?.copy()??new x(1,1);s.fill(1),e[n-1]=[s];let o=null;for(const r of[...this._order].reverse()){const i=this._nodes[r];if(t)if(i.layer instanceof y)e[r]=[t],t=null;else continue;if(e[r].length===0)continue;for(let l=0;l<e[r].length;l++)e[r][l]===void 0&&(e[r][l]=null);i.gradientValue=e[r];let a=i.layer.grad(...e[r]);if(Array.isArray(a)||(a=Array(i.parents.length).fill(a)),a[a.length-1]?.constructor===Object){const l=a.pop();for(let h=0;h<r;h++){const c=l[this._nodes[h].name];c&&(e[h][0]?e[h][0].broadcastOperate(c,(d,f)=>d+f):e[h][0]=c.copy())}}i.parents.forEach((l,h)=>{if(!a[h])return;const c=l.subscript||0;e[l.index][c]?e[l.index][c].broadcastOperate(a[h],(d,f)=>d+f):e[l.index][c]=a[h].copy()}),i.layer instanceof b&&(o=e[r][0])}return o}getNode(t){for(let n=0;n<this._nodes.length;n++)if(this._nodes[n].name===t)return this._nodes[n]}}
