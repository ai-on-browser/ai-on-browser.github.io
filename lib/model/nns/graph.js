import Matrix,{MatrixException}from"../../util/matrix.js";import{NeuralnetworkException}from"../neuralnetwork.js";import Layer,{LossLayer}from"./layer/base.js";import{InputLayer,OutputLayer}from"./layer/index.js";export default class ComputationalGraph{constructor(){this._nodes=[]}get nodes(){return this._nodes}get size(){return this._nodes.length}static fromObject(t){const e=new ComputationalGraph;for(const n of t){const t=Layer.fromObject(n);"string"==typeof n.input&&(n.input=[n.input]),e.add(t,n.name,n.input)}return e}toObject(){const t=[];for(let e=0;e<this._nodes.length;e++){const n=this._nodes[e],r=n.layer.toObject();n.name&&(r.name=n.name),n.input&&(r.input=n.input),t.push(r)}return t}add(t,e,n){let r=[];n?("string"==typeof n&&(n=[n]),r=n.map((t=>{const e=t&&t.match(/\[([0-9]+)\]$/),n=e?+e[1]:null,r=e?t.slice(0,-e[0].length):t;for(let t=0;t<this._nodes.length;t++)if(this._nodes[t].name===r)return{index:t,subscript:n};throw new NeuralnetworkException(`Unknown input name '${t}'.`)}))):this._nodes.length>0&&r.push({index:this._nodes.length-1,subscript:null}),t.graph=this;const s={layer:t,name:e,input:n,parents:r,outputValue:null,gradientValue:null,get lastOutputSize(){return this.outputValue.sizes}};if(e&&this.getNode(e))throw new MatrixException(`Duplicate layer name ${e}`);this._nodes.push(s)}bind(t){for(const e of this._nodes)e.layer.bind(t)}calc(t){for(let t=0;t<this._nodes.length;t++)this._nodes[t].outputValue=null,this._nodes[t].gradientValue=null;const e=[],n=t?Array(t.length).fill(!1):[];for(let r=0;r<this._nodes.length;r++)try{const s=this._nodes[r];if(e[r]=s.layer.calc(...s.parents.map((t=>null!==t.subscript?e[t.index][t.subscript]:e[t.index]))),s.outputValue=e[r],t){for(let e=0;e<t.length;e++)("number"==typeof t[e]&&t[e]===r||t[e]===s.name)&&(n[e]=!0);if(n.every((t=>t)))return}}catch(t){throw new Error(`Error raises at ${r} layer. ${t.stack}`)}}grad(t){const e=Array.from({length:this._nodes.length},(()=>[]));let n=null;for(let r=this._nodes.length-1;r>=0;r--){const s=this._nodes[r];if(t){if(!(s.layer instanceof OutputLayer))continue;e[r]=[t],t=null}if(!(s.layer instanceof LossLayer)&&0===e[r].length)continue;for(let t=0;t<e[r].length;t++)void 0===e[r][t]&&(e[r][t]=null);s.gradientValue=e[r];let o=s.layer.grad(...e[r]);Array.isArray(o)||(o=Array(s.parents.length).fill(o)),s.parents.forEach(((t,n)=>{if(!o[n])return;const r=t.subscript||0;e[t.index][r]?e[t.index][r].broadcastOperate(o[n],((t,e)=>t+e)):e[t.index][r]=o[n].copy()})),s.layer instanceof InputLayer&&(n=e[r][0])}return n}getNode(t){for(let e=0;e<this._nodes.length;e++)if(this._nodes[e].name===t)return this._nodes[e]}}