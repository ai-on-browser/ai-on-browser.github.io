var x=Object.defineProperty;var m=(y,e)=>x(y,"name",{value:e,configurable:!0});import O from"../../util/matrix.js";import{NeuralnetworkException as p}from"../neuralnetwork.js";import g from"./layer/base.js";import{InputLayer as _,OutputLayer as b}from"./layer/index.js";import w from"./onnx/onnx_importer.js";export default class h{static{m(this,"ComputationalGraph")}constructor(){this._nodes=[]}get nodes(){return this._nodes}get inputNodes(){const e=[];for(let t=0;t<this._nodes.length;t++)this._nodes[t].layer instanceof _&&e.push(this._nodes[t]);return e}get outputNodes(){const e=[];for(let t=0;t<this._nodes.length;t++)this._nodes[t].layer instanceof b&&e.push(this._nodes[t]);return e}get size(){return this._nodes.length}static fromObject(e){const t=new h;for(const n of e){const o=g.fromObject(n);t.add(o,n.name,n.input)}return t}static async fromONNX(e){return h.fromObject(await w.load(e))}toObject(){const e=[];for(let t=0;t<this._nodes.length;t++){const n=this._nodes[t],o=n.layer.toObject();n.name&&(o.name=n.name),n.input&&(o.input=n.input),e.push(o)}return e}toDot(){let e=`digraph g {
`;for(let t=0;t<this._nodes.length;t++){const n=this.nodes[t];e+=`  l${t} [label="${n.layer.constructor.name}\\n${n.name}"];
`;for(const o of n.parents)e+=`  l${o.index} -> l${t};
`}return e+"}"}add(e,t,n=void 0){e instanceof g||(e=g.fromObject(e));let o=[];if(!n)this._nodes.length>0&&o.push({index:this._nodes.length-1,subscript:null});else{typeof n=="string"&&(n=[n]);const s=/\[([0-9]+)\]$/,u=/\[([a-zA-Z_][0-9a-zA-Z_]*)\]$/;o=n.map(r=>{const i=r&&r.match(s),l=r&&r.match(u),c=i?+i[1]:l?l[1]:null,f=i||l?r.slice(0,-(i||l)[0].length):r;for(let d=0;d<this._nodes.length;d++)if(this._nodes[d].name===f)return{index:d,subscript:c};throw new p(`Unknown input name '${r}'.`)})}e.graph=this;const a={layer:e,name:t,input:n,parents:o,outputValue:null,gradientValue:null,get lastOutputSize(){return this.outputValue.sizes}};if(t&&this.getNode(t))throw new p(`Duplicate layer name ${t}`);this._nodes.push(a)}bind(e){for(const t of this._nodes)t.layer.bind(e)}calc(e){for(let o=0;o<this._nodes.length;o++)this._nodes[o].outputValue=null,this._nodes[o].gradientValue=null;const t=[],n=e?Array(e.length).fill(!1):[];for(let o=0;o<this._nodes.length;o++)try{const a=this._nodes[o];if(t[o]=a.layer.calc(...a.parents.map(s=>typeof s.subscript=="number"?t[s.index][s.subscript]:s.subscript!==null?this._nodes[s.index].layer[s.subscript]:t[s.index])),a.outputValue=t[o],e){for(let s=0;s<e.length;s++)(typeof e[s]=="number"&&e[s]===o||e[s]===a.name)&&(n[s]=!0);if(n.every(s=>s))return}}catch(a){throw new p(`Error raises at ${o} layer. ${a.stack}`)}}grad(e){const t=this._nodes.length,n=Array.from(this._nodes,()=>[]),o=this._nodes[t-1].outputValue?.copy()??new O(1,1);o.fill(1),n[t-1]=[o];let a=null;for(let s=t-1;s>=0;s--){const u=this._nodes[s];if(e)if(u.layer instanceof b)n[s]=[e],e=null;else continue;if(n[s].length===0)continue;for(let i=0;i<n[s].length;i++)n[s][i]===void 0&&(n[s][i]=null);u.gradientValue=n[s];let r=u.layer.grad(...n[s]);if(Array.isArray(r)||(r=Array(u.parents.length).fill(r)),r[r.length-1]?.constructor===Object){const i=r.pop();for(let l=0;l<s;l++){const c=i[this._nodes[l].name];c&&(n[l][0]?n[l][0].broadcastOperate(c,(f,d)=>f+d):n[l][0]=c.copy())}}u.parents.forEach((i,l)=>{if(!r[l])return;const c=i.subscript||0;n[i.index][c]?n[i.index][c].broadcastOperate(r[l],(f,d)=>f+d):n[i.index][c]=r[l].copy()}),u.layer instanceof _&&(a=n[s][0])}return a}getNode(e){for(let t=0;t<this._nodes.length;t++)if(this._nodes[t].name===e)return this._nodes[t]}}
