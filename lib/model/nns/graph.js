var w=Object.defineProperty;var _=(b,t)=>w(b,"name",{value:t,configurable:!0});import x from"../../util/matrix.js";import{NeuralnetworkException as g}from"../neuralnetwork.js";import m from"./layer/base.js";import{InputLayer as y,OutputLayer as O,ConstLayer as u}from"./layer/index.js";import N from"./onnx/onnx_exporter.js";import $ from"./onnx/onnx_importer.js";class V{static{_(this,"Node")}constructor(t,s,e,n,o){this.name=t,this.layer=s,this.input=e,this._graph=o,this._parent=n}get parents(){if(this._parent)return this._parent;const t=/\[([0-9]+)\]$/,s=/\[([a-zA-Z_][0-9a-zA-Z_]*)\]$/;return this._parent=this.input.map(e=>{if(typeof e=="number")return new u({value:e});const n=e&&e.match(t),o=e&&e.match(s),r=n?+n[1]:o?o[1]:null,i=n||o?e.slice(0,-(n||o)[0].length):e;for(let a=0;a<this._graph._nodes.length;a++)if(this._graph._nodes[a].name===i)return{index:a,subscript:r};throw new g(`Unknown input name '${e}'.`)})}get outputValue(){return this._outputValue}set outputValue(t){this._outputValue=t}get gradientValue(){return this._gradientValue}set gradientValue(t){this._gradientValue=t}get lastOutputSize(){return this.outputValue.sizes}toObject(){const t=this.layer.toObject();return this.name&&(t.name=this.name),this.input&&(t.input=this.input),t}}export default class d{static{_(this,"ComputationalGraph")}constructor(){this._nodes=[],this._order=null}get nodes(){return this._nodes}get inputNodes(){const t=[];for(let s=0;s<this._nodes.length;s++)this._nodes[s].layer instanceof y&&t.push(this._nodes[s]);return t}get outputNodes(){const t=[];for(let s=0;s<this._nodes.length;s++)this._nodes[s].layer instanceof O&&t.push(this._nodes[s]);return t}get size(){return this._nodes.length}static fromObject(t){const s=new d;for(const e of t){const n=m.fromObject(e);s.add(n,e.name,e.input)}return s}static async fromONNX(t){return d.fromObject(await $.load(t))}toObject(){return this._nodes.map(t=>t.toObject())}toDot(){let t=`digraph g {
`;const s=new Set;for(let e=0;e<this._nodes.length;e++){const n=this.nodes[e],o=n.layer.constructor.name+(n.name?`\\n${n.name}`:"");t+=`  l${e} [label="${o}"];
`;for(const r of n.parents)r instanceof u?(t+=`  c${r._value} -> l${e};
`,s.add(r._value)):t+=`  l${r.index} -> l${e};
`}for(const e of s)t+=`  c${e} [label="Constant\\n${e}"];
`;return t+"}"}toONNX(){return N.dump(this.toObject())}add(t,s,e=void 0){this._order=null,t instanceof m||(t=m.fromObject(t));let n=null;e==null?(n=[],t.calc.length>0&&this._nodes.length>0&&n.push({index:this._nodes.length-1,subscript:null})):Array.isArray(e)||(e=[e]),t.graph=this;const o=new V(s,t,e,n,this);if(s&&this.getNode(s))throw new g(`Duplicate layer name ${s}`);this._nodes.push(o)}bind(t){for(const s of this._nodes)s.layer.bind(t)}_calcOrder(){if(this._order)return;const t=[],s=Array.from(this._nodes,()=>[]),e=Array(this._nodes.length).fill(0);for(let n=0;n<this._nodes.length;n++){const o=this._nodes[n];for(const r of o.parents)r instanceof u||(s[r.index].push(n),e[n]++);for(const r of o.layer.dependentLayers)for(let i=0;i<this._nodes.length;i++)if(n!==i&&this._nodes[i].name===r&&!s[i].includes(n)){s[i].push(n),e[n]++;break}e[n]===0&&t.push(n)}for(this._order=[];t.length>0;){const n=t.pop();this._order.push(n);for(const o of s[n])e[o]--,e[o]===0&&t.push(o)}if(e.some(n=>n!==0))throw new Error("This graph is not directed acyclic graph.")}calc(t){this._calcOrder();for(let n=0;n<this._nodes.length;n++)this._nodes[n].outputValue=null,this._nodes[n].gradientValue=null;const s=[],e=t?Array(t.length).fill(!1):[];for(const n of this._order)try{const o=this._nodes[n];if(s[n]=o.layer.calc(...o.parents.map(r=>r instanceof u?r.calc():typeof r.subscript=="number"?s[r.index][r.subscript]:r.subscript!==null?this._nodes[r.index].layer[r.subscript]:s[r.index])),o.outputValue=s[n],t){for(let r=0;r<t.length;r++)(typeof t[r]=="number"&&t[r]===n||t[r]===o.name)&&(e[r]=!0);if(e.every(r=>r))return}}catch(o){throw new g(`Error raises at ${n} layer. ${o.stack}`)}}grad(t){this._calcOrder();const s=this._nodes.length,e=Array.from(this._nodes,()=>[]),n=this._nodes[s-1].outputValue?.copy()??new x(1,1);n.fill(1),e[s-1]=[n];let o=null;for(const r of[...this._order].reverse()){const i=this._nodes[r];if(t)if(i.layer instanceof O)e[r]=[t],t=null;else continue;if(e[r].length===0)continue;for(let l=0;l<e[r].length;l++)e[r][l]===void 0&&(e[r][l]=null);i.gradientValue=e[r];let a=i.layer.grad(...e[r]);if(Array.isArray(a)||(a=Array(i.parents.length).fill(a)),a[a.length-1]?.constructor===Object){const l=a.pop();for(let c=0;c<r;c++){const h=l[this._nodes[c].name];h&&(e[c][0]?e[c][0].broadcastOperate(h,(f,p)=>f+p):e[c][0]=h.copy())}}i.parents.forEach((l,c)=>{if(l instanceof u||!a[c])return;const h=l.subscript||0;e[l.index][h]?e[l.index][h].broadcastOperate(a[c],(f,p)=>f+p):e[l.index][h]=a[c].copy()}),i.layer instanceof y&&(o=e[r][0])}return o}getNode(t){for(let s=0;s<this._nodes.length;s++)if(this._nodes[s].name===t)return this._nodes[s]}}
