import{NeuralnetworkException}from"../../neuralnetwork.js";import Layer from"./base.js";import Tensor from"../../../util/tensor.js";export default class AveragePoolLayer extends Layer{constructor({kernel:i,stride:e=null,padding:s=null,channel_dim:t=-1,...n}){if(super(n),this._kernel=i,this._stride=e||i,this._padding=s||0,this._channel_dim=t,-1!==this._channel_dim&&1!==this._channel_dim)throw new NeuralnetworkException("Invalid channel dimension.")}_index(i,e,s){return-1===this._channel_dim?[i,...s,e]:[i,e,...s]}calc(i){if(Array.isArray(this._kernel)||(this._kernel=Array(i.dimension-2).fill(this._kernel)),i.dimension!==this._kernel.length+2)throw new NeuralnetworkException("Invalid kernel size",[this,i]);if(Array.isArray(this._stride)||(this._stride=Array(i.dimension-2).fill(this._stride)),i.dimension!==this._stride.length+2)throw new NeuralnetworkException("Invalid stride size",[this,i]);if(Array.isArray(this._padding)?Array.isArray(this._padding[0])||(this._padding=this._padding.map((i=>[i,i]))):this._padding=Array.from({length:i.dimension-2},(()=>[this._padding,this._padding])),i.dimension!==this._padding.length+2)throw new NeuralnetworkException("Invalid padding size",[this,i]);this._i=i;const e=-1===this._channel_dim?1:2,s=[i.sizes[0],...this._kernel.map(((s,t)=>Math.ceil(Math.max(0,i.sizes[t+e]+this._padding[t][0]+this._padding[t][1]-s)/this._stride[t])+1))];-1===this._channel_dim?s.push(i.sizes[i.dimension-1]):1===this._channel_dim&&s.splice(1,0,i.sizes[1]);const t=-1===this._channel_dim?i.sizes[i.dimension-1]:i.sizes[1];this._o=new Tensor(s);for(let n=0;n<i.sizes[0];n++)for(let r=0;r<t;r++){const t=Array(i.dimension-2).fill(0);do{const h=Array(i.dimension-2).fill(0);let d=0,o=0;do{const s=t.map(((i,e)=>i*this._stride[e]-this._padding[e][0]+h[e]));s.every(((s,t)=>0<=s&&s<i.sizes[t+e]))&&(d+=i.at(this._index(n,r,s)),o++);for(let i=0;i<h.length&&(h[i]++,!(h[i]<this._kernel[i]));i++)h[i]=0}while(h.some((i=>i>0)));this._o.set(this._index(n,r,t),d/o);for(let i=0;i<t.length&&(t[i]++,!(t[i]<s[i+e]));i++)t[i]=0}while(t.some((i=>i>0)))}return this._o}grad(i){this._bo=i,this._bi=new Tensor(this._i.sizes);const e=-1===this._channel_dim?1:2,s=-1===this._channel_dim?this._i.sizes[this._i.dimension-1]:this._i.sizes[1];for(let i=0;i<this._i.sizes[0];i++)for(let t=0;t<s;t++){const s=Array(this._i.dimension-2).fill(0);do{const n=Array(this._i.dimension-2).fill(0),r=[];do{const i=s.map(((i,e)=>i*this._stride[e]-this._padding[e][0]+n[e]));i.every(((i,s)=>0<=i&&i<this._i.sizes[s+e]))&&r.push(i);for(let i=0;i<n.length&&(n[i]++,!(n[i]<this._kernel[i]));i++)n[i]=0}while(n.some((i=>i>0)));for(const e of r)this._bi.operateAt(this._index(i,t,e),(e=>e+this._bo.at(this._index(i,t,s))/r.length));for(let i=0;i<s.length&&(s[i]++,!(s[i]<this._o.sizes[i+e]));i++)s[i]=0}while(s.some((i=>i>0)))}return this._bi}toObject(){return{type:"average_pool",kernel:this._kernel,stride:this._stride,padding:this._padding,channel_dim:this._channel_dim}}}AveragePoolLayer.registLayer();