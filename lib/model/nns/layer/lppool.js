import Layer,{NeuralnetworkLayerException}from"./base.js";import Tensor from"../../../util/tensor.js";export default class LpPoolLayer extends Layer{constructor({p:i=2,kernel:s,stride:e=null,padding:t=null,channel_dim:n=-1,...h}){if(super(h),this._p=i,this._kernel=s,this._stride=e||s,this._padding=t||0,this._channel_dim=n,-1!==this._channel_dim&&1!==this._channel_dim)throw new NeuralnetworkLayerException("Invalid channel dimension.")}_index(i,s,e){return-1===this._channel_dim?[i,...e,s]:[i,s,...e]}calc(i){if(Array.isArray(this._kernel)||(this._kernel=Array(i.dimension-2).fill(this._kernel)),i.dimension!==this._kernel.length+2)throw new NeuralnetworkLayerException("Invalid kernel size",[this,i]);if(Array.isArray(this._stride)||(this._stride=Array(i.dimension-2).fill(this._stride)),i.dimension!==this._stride.length+2)throw new NeuralnetworkLayerException("Invalid stride size",[this,i]);if(Array.isArray(this._padding)?Array.isArray(this._padding[0])||(this._padding=this._padding.map((i=>[i,i]))):this._padding=Array.from({length:i.dimension-2},(()=>[this._padding,this._padding])),i.dimension!==this._padding.length+2)throw new NeuralnetworkLayerException("Invalid padding size",[this,i]);this._i=i;const s=-1===this._channel_dim?1:2,e=[i.sizes[0],...this._kernel.map(((e,t)=>Math.ceil(Math.max(0,i.sizes[t+s]+this._padding[t][0]+this._padding[t][1]-e)/this._stride[t])+1))];-1===this._channel_dim?e.push(i.sizes[i.dimension-1]):1===this._channel_dim&&e.splice(1,0,i.sizes[1]);const t=-1===this._channel_dim?i.sizes[i.dimension-1]:i.sizes[1];this._sp=new Tensor(e);for(let n=0;n<i.sizes[0];n++)for(let h=0;h<t;h++){const t=Array(i.dimension-2).fill(0);do{const r=Array(i.dimension-2).fill(0);let _=0;do{const e=t.map(((i,s)=>i*this._stride[s]-this._padding[s][0]+r[s]));e.every(((e,t)=>0<=e&&e<i.sizes[t+s]))&&(_+=Math.abs(i.at(this._index(n,h,e)))**this._p);for(let i=0;i<r.length&&(r[i]++,!(r[i]<this._kernel[i]));i++)r[i]=0}while(r.some((i=>i>0)));this._sp.set(this._index(n,h,t),_);for(let i=0;i<t.length&&(t[i]++,!(t[i]<e[i+s]));i++)t[i]=0}while(t.some((i=>i>0)))}return this._o=this._sp.copy(),this._o.map((i=>i**(1/this._p))),this._o}grad(i){this._bo=i,this._bi=new Tensor(this._i.sizes);const s=-1===this._channel_dim?1:2,e=-1===this._channel_dim?this._i.sizes[this._i.dimension-1]:this._i.sizes[1];for(let i=0;i<this._i.sizes[0];i++)for(let t=0;t<e;t++){const e=Array(this._i.dimension-2).fill(0);do{const n=Array(this._i.dimension-2).fill(0),h=[];do{const i=e.map(((i,s)=>i*this._stride[s]-this._padding[s][0]+n[s]));i.every(((i,e)=>0<=i&&i<this._i.sizes[e+s]))&&h.push(i);for(let i=0;i<n.length&&(n[i]++,!(n[i]<this._kernel[i]));i++)n[i]=0}while(n.some((i=>i>0)));for(const s of h){const n=this._index(i,t,s),h=this._index(i,t,e);this._bi.operateAt(n,(i=>i+this._bo.at(h)*this._sp.at(h)**(1/this._p-1)*this._i.at(n)**(this._p-1)*Math.sign(this._i.at(n))**this._p))}for(let i=0;i<e.length&&(e[i]++,!(e[i]<this._o.sizes[i+s]));i++)e[i]=0}while(e.some((i=>i>0)))}return this._bi}toObject(){return{type:"lp_pool",p:this._p,kernel:this._kernel,stride:this._stride,padding:this._padding,channel_dim:this._channel_dim}}}LpPoolLayer.registLayer();