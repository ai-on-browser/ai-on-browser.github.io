var o=Object.defineProperty;var n=(h,s)=>o(h,"name",{value:s,configurable:!0});import m from"./base.js";import d from"../../../util/matrix.js";import _ from"../../../util/tensor.js";export default class c extends m{static{n(this,"VarLayer")}constructor({axis:s=-1,keepdims:a=!0,...t}){super(t),this._axis=null,typeof s=="string"?this._axisname=s:this._axis=typeof s=="number"?[s]:s,this._keepdims=a}calc(s){if(this._axisname&&(this._axis=this.graph.getNode(this._axisname).outputValue.toArray()),this._axis.includes(-1))this._size=Array(s.dimension).fill(1);else{this._size=s.sizes.concat();for(let i=0;i<this._axis.length;i++)this._size[this._axis[i]]=1}if(this._i=s,!this._keepdims&&this._axis.includes(-1))return this._m=s.reduce((i,e)=>i+e,0)/s.length,new _([],s.reduce((i,e)=>i+(e-this._m)**2,0)/s.length);!this._keepdims&&s instanceof d&&(s=_.fromArray(s));const a=this._axis.includes(-1)?s.length:this._axis.reduce((i,e)=>i*s.sizes[e],1);this._m=s.reduce((i,e)=>i+e,0,this._axis,!0),this._m.map(i=>i/a);const t=s.copy();t.broadcastOperate(this._m,(i,e)=>i-e);const r=t.reduce((i,e)=>i+e**2,0,this._axis,this._keepdims);return r.map(i=>i/a),r}grad(s){s.reshape(...this._size);const a=this._axis.includes(-1)?this._i.length:this._axis.reduce((r,i)=>r*this._i.sizes[i],1),t=this._i.copy();return t.broadcastOperate(this._m,(r,i)=>2*(r-i)/a),t.broadcastOperate(s,(r,i)=>r*i),t}toObject(){return{type:"variance",axis:this._axis,keepdims:this._keepdims}}}c.registLayer("variance");
