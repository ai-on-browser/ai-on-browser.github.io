var o=Object.defineProperty;var n=(h,s)=>o(h,"name",{value:s,configurable:!0});import m from"./base.js";import d from"../../../util/matrix.js";import _ from"../../../util/tensor.js";export default class c extends m{static{n(this,"VarLayer")}constructor({axis:s=-1,keepdims:a=!0,...t}){super(t),this._axis=null,typeof s=="string"?this._axisname=s:this._axis=typeof s=="number"?[s]:s,this._keepdims=a}get dependentLayers(){const s=[];return this._axisname&&s.push(this._axisname),s}calc(s){if(this._axisname&&(this._axis=this.graph.getNode(this._axisname).outputValue.toArray()),this._axis.includes(-1))this._size=Array(s.dimension).fill(1);else{this._size=s.sizes.concat();for(let e=0;e<this._axis.length;e++)this._size[this._axis[e]]=1}if(this._i=s,!this._keepdims&&this._axis.includes(-1))return this._m=s.reduce((e,i)=>e+i,0)/s.length,new _([],s.reduce((e,i)=>e+(i-this._m)**2,0)/s.length);!this._keepdims&&s instanceof d&&(s=_.fromArray(s));const a=this._axis.includes(-1)?s.length:this._axis.reduce((e,i)=>e*s.sizes[i],1);this._m=s.reduce((e,i)=>e+i,0,this._axis,!0),this._m.map(e=>e/a);const t=s.copy();t.broadcastOperate(this._m,(e,i)=>e-i);const r=t.reduce((e,i)=>e+i**2,0,this._axis,this._keepdims);return r.map(e=>e/a),r}grad(s){s.reshape(...this._size);const a=this._axis.includes(-1)?this._i.length:this._axis.reduce((r,e)=>r*this._i.sizes[e],1),t=this._i.copy();return t.broadcastOperate(this._m,(r,e)=>2*(r-e)/a),t.broadcastOperate(s,(r,e)=>r*e),t}toObject(){return{type:"variance",axis:this._axis,keepdims:this._keepdims}}}c.registLayer("variance");
