var qs=Object.defineProperty;var d=(l,t)=>qs(l,"name",{value:t,configurable:!0});import u from"../../../util/matrix.js";import M from"../../neuralnetwork.js";import p,{FlowLayer as Ss,NeuralnetworkLayerException as g}from"./base.js";import m from"../../../util/tensor.js";class N extends Ss{static{d(this,"AdditiveCoupling")}constructor({d:t=null,net:s=null,...i}){super(i),this._d=t,this._m=s==null?null:s instanceof M?s:M.fromObject(s)}calc(t){this._d||(this._d=Math.floor(t.cols/2)),this._m||(this._m=M.fromObject([{type:"input"},{type:"full",out_size:20,activation:"leaky_relu"},{type:"full",out_size:t.cols-this._d,activation:"leaky_relu"}],null,"adam")),this._o=t.copy();const s=u.zeros(...t.sizes);return s.set(0,this._d,this._m.calc(t.slice(0,this._d,1))),this._o.add(s),this._o}inverse(t){this._o=t.copy();const s=u.zeros(...t.sizes);return s.set(0,this._d,this._m.calc(t.slice(0,this._d,1))),this._o.sub(s),this._o}jacobianDeterminant(){return 1}grad(t){const s=t.copy(),i=u.zeros(...t.sizes),e=this._m.grad(t.slice(this._d,null,1));return i.set(0,0,e),s.add(i),s}update(t){this._m.update(t.lr)}toObject(){return{type:"additive_coupling",net:this._m?.toObject()}}}N.registLayer();class V extends p{static{d(this,"AdaptivePiecewiseLinearLayer")}constructor({s:t=2,a:s=null,b:i=0,...e}){if(super(e),this._s=t,Array.isArray(s))this._a=s;else{this._a=[];for(let h=0;h<t;h++)this._a[h]=s??Math.random()}this._b=Array.isArray(i)?i:Array(t).fill(i),this._l2_decay=.001}calc(t){this._i=t;const s=t.copy();return s.map(i=>this._a.reduce((e,h,_)=>e+h*Math.max(0,this._b[_]-i),Math.max(0,i))),s}grad(t){this._bo=t;const s=t.copy();return s.broadcastOperate(this._i,(i,e)=>i*this._a.reduce((h,_,r)=>h+(this._b[r]-e>0?_:0),e>0?1:0)),s}update(t){const s=Array(this._s).fill(0),i=Array(this._s).fill(0);for(let e=0;e<this._i.length;e++)for(let h=0;h<this._s;h++)this._b[h]-this._i.value[e]>0&&(s[h]+=this._bo.value[e]*(this._b[h]-this._i.value[e]),i[h]+=this._bo.value[e]*this._a[h]);for(let e=0;e<this._s;e++)this._a[e]-=t.delta(`a${e}`,s[e]/this._i.length+this._a[e]*this._l2_decay),this._b[e]-=t.delta(`b${e}`,i[e]/this._i.length+this._b[e]*this._l2_decay)}toObject(){return{type:"apl",s:this._s,a:this._a,b:this._b}}}V.registLayer("apl");class U extends p{static{d(this,"ArandaLayer")}constructor({l:t=2,...s}){super(s),this._l=t}calc(t){this._i=t;const s=t.copy();return s.map(i=>1-1/(1+this._l*Math.exp(i))**(1/this._l)),s}grad(t){this._bo=t;const s=t.copy();return s.broadcastOperate(this._i,(i,e)=>i*Math.exp(e)*(1+this._l*Math.exp(e))**(-1/this._l-1)),s}toObject(){return{type:"aranda",l:this._l}}}U.registLayer("aranda");class D extends p{static{d(this,"ArgmaxLayer")}constructor({axis:t=-1,keepdims:s=!0,...i}){super(i),this._axis=t,this._keepdims=s}calc(t){!this._keepdims&&t instanceof u&&(t=m.fromArray(t)),this._i=t;const s=this._axis<0?this._axis+t.dimension:this._axis;return this._o=this._i.reduce((i,e,h)=>i[0]<e?[e,h[s]]:i,[-1/0,-1],s,this._keepdims),this._o.map(i=>i[1]),this._o}grad(t){const s=this._axis<0?this._axis+this._i.dimension:this._axis;if(this._bo=t.copy(),this._bo.dimension!==this._i.dimension){const o=this._bo.sizes.concat();o.splice(s,0,1),this._bo.reshape(...o)}this._bo.repeat(this._i.sizes[s],s);const i=Array(this._i.dimension).fill(1);i[s]=this._i.sizes[s];const e=new m(i,Array.from({length:this._i.sizes[s]},(o,n)=>n));this._bo.broadcastOperate(e,(o,n)=>o*n);const h=this._i.copy(),_=h.reduce((o,n)=>Math.max(o,n),-1/0,s,!0);h.broadcastOperate(_,(o,n)=>o-n),h.map(Math.exp);const r=h.reduce((o,n)=>o+n,0,s,!0);h.broadcastOperate(r,(o,n)=>o/n),this._bi=this._bo.copy();const a=Array(this._i.dimension).fill(0);do{for(let o=0;o<this._i.sizes[s];o++){a[s]=o;const n=h.at(a);let c=0;const f=a.concat();for(let b=0;b<this._i.sizes[s];b++){f[s]=b;const y=o===b?1-n:-n;c+=h.at(f)*y*this._bo.at(f)}this._bi.set(a,c)}for(let o=0;o<a.length;o++){if(o===s){a[o]=0;continue}if(a[o]++,a[o]<this._i.sizes[o])break;a[o]=0}}while(a.some(o=>o>0));return this._bi}toObject(){return{type:"argmax",axis:this._axis,keepdims:this._keepdims}}}D.registLayer();class R extends p{static{d(this,"ArgminLayer")}constructor({axis:t=-1,keepdims:s=!0,...i}){super(i),this._axis=t,this._keepdims=s}calc(t){!this._keepdims&&t instanceof u&&(t=m.fromArray(t)),this._i=t;const s=this._axis<0?this._axis+t.dimension:this._axis;return this._o=this._i.reduce((i,e,h)=>i[0]>e?[e,h[s]]:i,[1/0,-1],s,this._keepdims),this._o.map(i=>i[1]),this._o}grad(t){const s=this._axis<0?this._axis+this._i.dimension:this._axis;if(this._bo=t.copy(),this._bo.dimension!==this._i.dimension){const o=this._bo.sizes.concat();o.splice(s,0,1),this._bo.reshape(...o)}this._bo.repeat(this._i.sizes[s],s);const i=Array(this._i.dimension).fill(1);i[s]=this._i.sizes[s];const e=new m(i,Array.from({length:this._i.sizes[s]},(o,n)=>n));this._bo.broadcastOperate(e,(o,n)=>o*n);const h=this._i.copy(),_=h.reduce((o,n)=>Math.max(o,n),-1/0,s,!0);h.broadcastOperate(_,(o,n)=>n-o),h.map(Math.exp);const r=h.reduce((o,n)=>o+n,0,s,!0);h.broadcastOperate(r,(o,n)=>o/n),this._bi=this._bo.copy();const a=Array(this._i.dimension).fill(0);do{for(let o=0;o<this._i.sizes[s];o++){a[s]=o;const n=h.at(a);let c=0;const f=a.concat();for(let b=0;b<this._i.sizes[s];b++){f[s]=b;const y=o===b?n-1:n;c+=h.at(f)*y*this._bo.at(f)}this._bi.set(a,c)}for(let o=0;o<a.length;o++){if(o===s){a[o]=0;continue}if(a[o]++,a[o]<this._i.sizes[o])break;a[o]=0}}while(a.some(o=>o>0));return this._bi}toObject(){return{type:"argmin",axis:this._axis,keepdims:this._keepdims}}}R.registLayer();class E extends p{static{d(this,"AttentionLayer")}constructor({dk:t=null,dv:s=null,wq:i=null,wk:e=null,wv:h=null,..._}){super(_),this._dk=t,this._dv=s,this._wq=null,typeof i=="string"?this._wqname=i:i&&(this._wq=u.fromArray(i)),this._wk=null,typeof e=="string"?this._wkname=e:e&&(this._wk=u.fromArray(e)),this._wv=null,typeof h=="string"?this._wvname=h:h&&(this._wv=u.fromArray(h))}get dependentLayers(){const t=[];return this._wqname&&t.push(this._wqname),this._wkname&&t.push(this._wkname),this._wvname&&t.push(this._wvname),t}calc(t,s){this._selfattention=!s,s||(s=t),this._dk??=t.sizes.at(-1),this._wqname&&(this._wq=this.graph.getNode(this._wqname).outputValue),this._wq||(this._wq=u.randn(t.sizes[2],this._dk)),this._wkname&&(this._wk=this.graph.getNode(this._wkname).outputValue),this._wk||(this._wk=u.randn(s.sizes[2],this._dk)),this._dv??=t.sizes.at(-1),this._wvname&&(this._wv=this.graph.getNode(this._wvname).outputValue),this._wv||(this._wv=u.randn(s.sizes[2],this._dv)),this._i=t,this._m=s,this._q=t.dot(this._wq),this._k=s.dot(this._wk),this._v=s.dot(this._wv);const i=this._matmul(this._q,this._k,!1,!0);this._atn=i.copy();for(let h=0;h<i.sizes[0];h++)for(let _=0;_<i.sizes[1];_++){let r=[];for(let n=0;n<i.sizes[2];n++)r[n]=i.at(h,_,n)/Math.sqrt(this._dk);const a=r.reduce((n,c)=>Math.max(n,c),-1/0);let o=0;for(let n=0;n<i.sizes[2];n++)r[n]=Math.exp(r[n]-a),o+=r[n];for(let n=0;n<i.sizes[2];n++)this._atn.set([h,_,n],r[n]/o)}return this._matmul(this._atn,this._v)}_matmul(t,s,i=!1,e=!1){const h=[t.sizes[0],i?t.sizes[2]:t.sizes[1],e?s.sizes[1]:s.sizes[2]],_=i?t.sizes[1]:t.sizes[2],r=new m(h);for(let a=0;a<h[0];a++)for(let o=0;o<h[1];o++)for(let n=0;n<h[2];n++){let c=0;for(let f=0;f<_;f++)c+=(i?t.at(a,f,o):t.at(a,o,f))*(e?s.at(a,n,f):s.at(a,f,n));r.set([a,o,n],c)}return r}grad(t){const s=t.sizes[0],i=this._matmul(this._atn,t,!0),e=this._matmul(this._m,i,!0);this._dwv=e.reduce((b,y)=>b+y,0,0).toMatrix(),this._dwv.map(b=>b/s);const h=this._matmul(t,this._v,!1,!0),_=h.copy();for(let b=0;b<h.sizes[0];b++)for(let y=0;y<h.sizes[1];y++)for(let w=0;w<h.sizes[2];w++){const L=h.at(b,y,w);let k=0;for(let v=0;v<h.sizes[2];v++){const I=w===v?1-L:-L;k+=this._atn.at(b,y,v)*I*h.at(b,y,v)}_.set([b,y,w],k/Math.sqrt(this._dk))}const r=this._matmul(_,this._k),a=this._matmul(this._i,r,!0);this._dwq=a.reduce((b,y)=>b+y,0,0).toMatrix(),this._dwq.map(b=>b/s);const o=r.dot(this._wq.t),n=this._matmul(_,this._q,!0),c=this._matmul(this._m,n,!0);this._dwk=c.reduce((b,y)=>b+y,0,0).toMatrix(),this._dwk.map(b=>b/s);const f=n.dot(this._wk.t);if(f.broadcastOperate(i.dot(this._wv.t),(b,y)=>b+y),this._selfattention&&o.broadcastOperate(f,(b,y)=>b+y),this._wqname||this._wkname||this._wvname){const b={};return this._wqname&&(b[this._wqname]=this._dwq),this._wkname&&(b[this._wkname]=this._dwk),this._wvname&&(b[this._wvname]=this._dwv),this._selfattention?[o,b]:[o,f,b]}return this._selfattention?o:[o,f]}update(t){this._wqname||this._wq.sub(t.delta("wq",this._dwq)),this._wkname||this._wk.sub(t.delta("wk",this._dwk)),this._wvname||this._wv.sub(t.delta("wv",this._dwv))}toObject(){return{type:"attention",dk:this._dk,dv:this._dv,wq:this._wqname||this._wq?.toArray(),wk:this._wkname||this._wk?.toArray(),wv:this._wvname||this._wv?.toArray()}}}E.registLayer();class P extends p{static{d(this,"AveragePoolLayer")}constructor({kernel:t,stride:s=null,padding:i=null,channel_dim:e=-1,...h}){if(super(h),this._kernel=t,this._stride=s||t,this._padding=i||0,this._channel_dim=e,this._channel_dim!==-1&&this._channel_dim!==1)throw new g("Invalid channel dimension.")}_index(t,s,i){return this._channel_dim===-1?[t,...i,s]:[t,s,...i]}calc(t){if(Array.isArray(this._kernel)||(this._kernel=Array(t.dimension-2).fill(this._kernel)),t.dimension!==this._kernel.length+2)throw new g("Invalid kernel size",[this,t]);if(Array.isArray(this._stride)||(this._stride=Array(t.dimension-2).fill(this._stride)),t.dimension!==this._stride.length+2)throw new g("Invalid stride size",[this,t]);if(Array.isArray(this._padding)?Array.isArray(this._padding[0])||(this._padding=this._padding.map(h=>[h,h])):this._padding=Array.from({length:t.dimension-2},()=>[this._padding,this._padding]),t.dimension!==this._padding.length+2)throw new g("Invalid padding size",[this,t]);this._i=t;const s=this._channel_dim===-1?1:2,i=[t.sizes[0],...this._kernel.map((h,_)=>Math.ceil(Math.max(0,t.sizes[_+s]+this._padding[_][0]+this._padding[_][1]-h)/this._stride[_])+1)];this._channel_dim===-1?i.push(t.sizes[t.dimension-1]):this._channel_dim===1&&i.splice(1,0,t.sizes[1]);const e=this._channel_dim===-1?t.sizes[t.dimension-1]:t.sizes[1];this._o=new m(i);for(let h=0;h<t.sizes[0];h++)for(let _=0;_<e;_++){const r=Array(t.dimension-2).fill(0);do{const a=Array(t.dimension-2).fill(0);let o=0,n=0;do{const c=r.map((f,b)=>f*this._stride[b]-this._padding[b][0]+a[b]);c.every((f,b)=>0<=f&&f<t.sizes[b+s])&&(o+=t.at(this._index(h,_,c)),n++);for(let f=0;f<a.length&&(a[f]++,!(a[f]<this._kernel[f]));f++)a[f]=0}while(a.some(c=>c>0));this._o.set(this._index(h,_,r),o/n);for(let c=0;c<r.length&&(r[c]++,!(r[c]<i[c+s]));c++)r[c]=0}while(r.some(a=>a>0))}return this._o}grad(t){this._bo=t,this._bi=new m(this._i.sizes);const s=this._channel_dim===-1?1:2,i=this._channel_dim===-1?this._i.sizes[this._i.dimension-1]:this._i.sizes[1];for(let e=0;e<this._i.sizes[0];e++)for(let h=0;h<i;h++){const _=Array(this._i.dimension-2).fill(0);do{const r=Array(this._i.dimension-2).fill(0),a=[];do{const o=_.map((n,c)=>n*this._stride[c]-this._padding[c][0]+r[c]);o.every((n,c)=>0<=n&&n<this._i.sizes[c+s])&&a.push(o);for(let n=0;n<r.length&&(r[n]++,!(r[n]<this._kernel[n]));n++)r[n]=0}while(r.some(o=>o>0));for(const o of a)this._bi.operateAt(this._index(e,h,o),n=>n+this._bo.at(this._index(e,h,_))/a.length);for(let o=0;o<_.length&&(_[o]++,!(_[o]<this._o.sizes[o+s]));o++)_[o]=0}while(_.some(r=>r>0))}return this._bi}toObject(){return{type:"average_pool",kernel:this._kernel,stride:this._stride,padding:this._padding,channel_dim:this._channel_dim}}}P.registLayer();class T extends p{static{d(this,"BatchNormalizationLayer")}constructor({scale:t=1,offset:s=0,epsilon:i=1e-12,channel_dim:e=-1,input_mean:h,input_var:_,...r}){if(super(r),this._scale=null,typeof t=="string"?this._scalename=t:this._scale=t,this._offset=null,typeof s=="string"?this._offsetname=s:this._offset=s,this._epsilon=i,this._channel_dim=e,this._channel_dim!==-1&&this._channel_dim!==1)throw new g("Invalid channel dimension.");this._input_mean=h,this._input_var=_}get dependentLayers(){const t=[];return this._scalename&&t.push(this._scalename),this._offsetname&&t.push(this._offsetname),typeof this._input_mean=="string"&&t.push(this._input_mean),typeof this._input_var=="string"&&t.push(this._input_var),t}get mean(){return this._mean}get var(){return this._var}calc(t){const s=this._channel_dim<0?this._channel_dim+t.dimension:this._channel_dim,i=Array(t.dimension-s).fill(1);if(i[0]=t.sizes[s],this._scalename?(this._scale=this.graph.getNode(this._scalename).outputValue,this._scale.reshape(...i)):typeof this._scale=="number"?this._scale=new m(i,this._scale):Array.isArray(this._scale)&&(this._scale=m.fromArray(this._scale),this._scale.reshape(...i)),this._offsetname?(this._offset=this.graph.getNode(this._offsetname).outputValue,this._offset.reshape(...i)):typeof this._offset=="number"?this._offset=new m(i,this._offset):Array.isArray(this._offset)&&(this._offset=m.fromArray(this._offset),this._offset.reshape(...i)),typeof this._input_mean=="string"?(this._mean=this.graph.getNode(this._input_mean).outputValue,this._mean.reshape(...i)):Array.isArray(this._input_mean)&&(this._mean=m.fromArray(this._input_mean),this._mean.reshape(...i)),typeof this._input_var=="string"?(this._var=this.graph.getNode(this._input_var).outputValue,this._var.reshape(...i)):Array.isArray(this._input_var)&&(this._var=m.fromArray(this._input_var),this._var.reshape(...i)),!this._input_mean||!this._input_var){const h=Array.from({length:t.dimension},(a,o)=>o);h.splice(s,1);const _=h.reduce((a,o)=>a*t.sizes[o],1),r=t.reduce((a,o)=>a+o/_,0,h,!0);if(this._input_mean||(this._mean=r),!this._input_var){const a=t.copy();a.broadcastOperate(r,(n,c)=>(n-c)**2);const o=a.reduce((n,c)=>n+c/_,0,h,!0);this._var=o}}this._xc=t.copy(),this._xc.broadcastOperate(this._mean,(h,_)=>h-_),this._xh=this._xc.copy(),this._xh.broadcastOperate(this._var,(h,_)=>h/Math.sqrt(_+this._epsilon));const e=this._xh.copy();return e.broadcastOperate(this._scale,(h,_)=>h*_),e.broadcastOperate(this._offset,(h,_)=>h+_),e}grad(t){const s=this._channel_dim<0?this._channel_dim+t.dimension:this._channel_dim;this._bo=t;const i=this._bo.copy();i.broadcastOperate(this._scale,(n,c)=>n*c);const e=this._xc.copy();e.broadcastOperate(i,(n,c)=>n*c);const h=Array.from({length:t.dimension},(n,c)=>c);h.splice(s,1);const _=h.reduce((n,c)=>n*t.sizes[c],1),r=e.reduce((n,c)=>n+c/_,0,h,!0),a=this._xc.copy();a.broadcastOperate(this._var,(n,c)=>n/(c+this._epsilon)),a.broadcastOperate(r,(n,c)=>n*c),a.broadcastOperate(i,(n,c)=>c-n),a.broadcastOperate(this._var,(n,c)=>n/Math.sqrt(c+this._epsilon));const o=a.reduce((n,c)=>n+c/_,0,h,!0);if(a.broadcastOperate(o,(n,c)=>n-c),this._scalename||this._offsetname){const n={};if(this._scalename){const c=this._bo.reduce((f,b,y)=>f+b*this._xh.at(y)/_,0,h,!0);n[this._scalename]=c}if(this._offsetname){const c=this._bo.reduce((f,b)=>f+b/_,0,h,!0);n[this._offsetname]=c}return[a,n]}return a}update(t){if(this._scalename&&this._offsetname)return;const s=this._channel_dim<0?this._channel_dim+this._bo.dimension:this._channel_dim,i=Array.from({length:this._bo.dimension},(h,_)=>_);i.splice(s,1);const e=i.reduce((h,_)=>h*this._bo.sizes[_],1);if(!this._offsetname){const h=this._bo.reduce((_,r)=>_+r/e,0,i,!0);this._offset.broadcastOperate(t.delta("offset",h),(_,r)=>_-r)}if(!this._scalename){const h=this._bo.reduce((_,r,a)=>_+r*this._xh.at(a)/e,0,i,!0);this._scale.broadcastOperate(t.delta("scale",h),(_,r)=>_-r)}}toObject(){return{type:"batch_normalization",scale:this._scalename||this._scale.toArray?.()||this._scale,offset:this._offsetname||this._offset.toArray?.()||this._offset,epsilon:this._epsilon,channel_dim:this._channel_dim,input_mean:this._input_mean,input_var:this._input_var}}}T.registLayer();class F extends p{static{d(this,"BimodalDerivativeAdaptiveActivationLayer")}constructor({alpha:t=1,...s}){super(s),this._alpha=t}calc(t){this._i=t;const s=t.copy();return s.map(i=>(1/(1+Math.exp(-i))-1/(1+Math.exp(-i-this._alpha)))/2),s}grad(t){this._bo=t;const s=t.copy();return s.broadcastOperate(this._i,(i,e)=>i*(Math.exp(-e)/(1+Math.exp(-e))**2-Math.exp(-e-this._alpha)/(1+Math.exp(-e-this._alpha))**2)/2),s}update(t){let s=0;for(let i=0;i<this._i.length;i++)s+=this._bo.value[i]*(-Math.exp(-this._i.value[i]-this._alpha)/(1+Math.exp(-this._i.value[i]-this._alpha))**2)/2;this._alpha-=t.delta("alpha",s/this._i.length)}toObject(){return{type:"bdaa",alpha:this._alpha}}}F.registLayer("bdaa");class G extends p{static{d(this,"BendableLinearUnitLayer")}constructor({beta:t=.1,...s}){super(s),this._beta=t}calc(t){this._i=t;const s=t.copy();return s.map(i=>this._beta*(Math.sqrt(i**2+1)-1)+i),s}grad(t){this._bo=t;const s=t.copy();return s.broadcastOperate(this._i,(i,e)=>i*(this._beta*e/Math.sqrt(e**2+1)+1)),s}update(t){const s=this._bo.reduce((i,e,h)=>i+e*(Math.sqrt(this._i.at(h)**2+1)-1),0)/this._bo.length;this._beta-=t.delta("beta",s),this._beta<-1?this._beta=-1:this._beta>1&&(this._beta=1)}toObject(){return{type:"blu",beta:this._beta}}}G.registLayer("blu");class $ extends p{static{d(this,"BoundedReLULayer")}constructor({a:t=1,...s}){super(s),this._a=t}calc(t){this._i=t;const s=t.copy();return s.map(i=>i<=0?0:i>=this._a?this._a:i),s}grad(t){this._bo=t;const s=t.copy();return s.broadcastOperate(this._i,(i,e)=>0<e&&e<this._a?i:0),s}toObject(){return{type:"brelu",a:this._a}}}$.registLayer("brelu");class C extends p{static{d(this,"ContinuouslyDifferentiableELULayer")}constructor({a:t=1,...s}){super(s),this._a=t}calc(t){this._i=t;const s=t.copy();return s.map(i=>i>0?i:this._a*(Math.exp(i/this._a)-1)),s}grad(t){this._bo=t;const s=t.copy();return s.broadcastOperate(this._i,(i,e)=>i*(e>0?1:Math.exp(e))),s}toObject(){return{type:"celu",a:this._a}}}C.registLayer("celu");class H extends p{static{d(this,"ClipLayer")}constructor({min:t=null,max:s=null,...i}){super(i),this._min=t,this._max=s}get dependentLayers(){const t=[];return typeof this._min=="string"&&t.push(this._min),typeof this._max=="string"&&t.push(this._max),t}calc(t){const s=typeof this._min=="string"?this.graph.getNode(this._min).outputValue.toScaler():this._min,i=typeof this._max=="string"?this.graph.getNode(this._max).outputValue.toScaler():this._max,e=t.copy();return e.map(h=>s!==null&&h<s?s:i!==null&&h>i?i:h),e}grad(t){return t}toObject(){return{type:"clip",min:this._min,max:this._max}}}H.registLayer();class B extends p{static{d(this,"ConcatLayer")}constructor({axis:t=1,...s}){super(s),this._axis=t}calc(...t){let s=t[0].copy(),i=t[0].sizes[this._axis];this._sizes=[0,i];for(let e=1;e<t.length;e++)s.concat(t[e],this._axis),this._sizes.push(i+=t[e].sizes[this._axis]);return s}grad(t){const s=[];for(let i=0;i<this._sizes.length-1;i++)s.push(t.slice(this._sizes[i],this._sizes[i+1],this._axis));return s}toObject(){return{type:"concat",axis:this._axis}}}B.registLayer();class Q extends p{static{d(this,"CondLayer")}calc(...t){this._cond=t[0];const s=t[1],i=t[2];return this._o=this._cond.copy(),this._o.map((e,h)=>e?s.at(h):i.at(h)),this._o}grad(t){const s=[null,t.copy(),t.copy()];return this._cond.forEach((i,e)=>i?s[2].set(e,0):s[1].set(e,0)),s}}Q.registLayer();class J extends p{static{d(this,"ConstLayer")}constructor({value:t,...s}){super(s),this._value=t}calc(){const t=m.fromArray(this._value);return t.dimension===2?t.toMatrix():t}grad(){}toObject(){return{type:"const",value:this._value}}}J.registLayer();class K extends p{static{d(this,"ConvLayer")}constructor({kernel:t,channel:s=null,stride:i=null,padding:e=null,w:h=null,activation:_=null,l2_decay:r=0,l1_decay:a=0,channel_dim:o=-1,...n}){if(super(n),this._in_channel=null,this._out_channel=s,this._kernel=t,this._stride=i||1,this._padding=e||0,this._channel_dim=o,this._channel_dim!==-1&&this._channel_dim!==1)throw new g("Invalid channel dimension.");this._w=null,this._wname=null,typeof h=="string"?this._wname=h:h&&(this._w=m.fromArray(h),this._in_channel=this._w.sizes[1],this._out_channel||(this._out_channel=this._w.sizes[0])),typeof _=="string"?this._activation=p.fromObject({type:_}):_&&(this._activation=p.fromObject(_)),this._l2_decay=r,this._l1_decay=a}get dependentLayers(){const t=[];return this._wname&&t.push(this._wname),this._activation&&t.push(...this._activation.dependentLayers),t}_index(t,s,i){return this._channel_dim===-1?[t,...i,s]:[t,s,...i]}calc(t){if(t.dimension<=2)throw new g("Invalid input.");if(Array.isArray(this._kernel)||(this._kernel=Array(t.dimension-2).fill(this._kernel)),t.dimension!==this._kernel.length+2)throw new g("Invalid kernel size",[this,t]);if(Array.isArray(this._stride)||(this._stride=Array(t.dimension-2).fill(this._stride)),t.dimension!==this._stride.length+2)throw new g("Invalid stride size",[this,t]);if(Array.isArray(this._padding)?Array.isArray(this._padding[0])||(this._padding=this._padding.map(e=>[e,e])):this._padding=Array.from({length:t.dimension-2},()=>[this._padding,this._padding]),t.dimension!==this._padding.length+2)throw new g("Invalid padding size",[this,t]);this._wname&&(this._w=this.graph.getNode(this._wname).outputValue,this._in_channel||(this._in_channel=this._w.sizes[1]),this._out_channel||(this._out_channel=this._w.sizes[0])),this._w||(this._in_channel=t.sizes[this._channel_dim===-1?t.dimension-1:1],this._out_channel||(this._out_channel=this._in_channel*2),this._w=m.randn([this._out_channel,this._in_channel,...this._kernel])),this._i=t;const s=this._channel_dim===-1?1:2,i=[t.sizes[0],...this._kernel.map((e,h)=>Math.ceil(Math.max(0,t.sizes[h+s]+this._padding[h][0]+this._padding[h][1]-e)/this._stride[h])+1)];this._channel_dim===-1?i.push(this._out_channel):this._channel_dim===1&&i.splice(1,0,this._out_channel),this._o=new m(i);for(let e=0;e<t.sizes[0];e++)for(let h=0;h<this._out_channel;h++){const _=Array(this._kernel.length).fill(0);do{let r=0;const a=Array(this._kernel.length).fill(0);do{const o=a.map((n,c)=>_[c]*this._stride[c]-this._padding[c][0]+n);if(o.every((n,c)=>0<=n&&n<t.sizes[c+s]))for(let n=0;n<this._in_channel;n++)r+=t.at(this._index(e,n,o))*this._w.at(h,n,...a);for(let n=0;n<a.length&&(a[n]++,!(a[n]<this._kernel[n]));n++)a[n]=0}while(a.some(o=>o>0));this._o.set(this._index(e,h,_),r);for(let o=0;o<_.length&&(_[o]++,!(_[o]<i[o+s]));o++)_[o]=0}while(_.some(r=>r>0))}return this._activation?this._activation.calc(this._o):this._o}grad(t){this._bo=t,this._activation&&(this._bo=this._activation.grad(t)),this._bi=new m(this._i.sizes),this._dw=new m(this._w.sizes);const s=this._channel_dim===-1?1:2;for(let i=0;i<this._i.sizes[0];i++)for(let e=0;e<this._out_channel;e++){const h=Array(this._kernel.length).fill(0);do{const _=Array(this._kernel.length).fill(0);do{const r=_.map((a,o)=>h[o]*this._stride[o]-this._padding[o][0]+a);if(r.every((a,o)=>0<=a&&a<this._i.sizes[o+s]))for(let a=0;a<this._in_channel;a++)this._bi.operateAt(this._index(i,a,r),o=>o+this._w.at(e,a,..._)*this._bo.at(this._index(i,e,h))),this._dw.operateAt([e,a,..._],o=>o+this._i.at(this._index(i,a,r))*this._bo.at(this._index(i,e,h)));for(let a=0;a<_.length&&(_[a]++,!(_[a]<this._kernel[a]));a++)_[a]=0}while(_.some(r=>r>0));for(let r=0;r<h.length&&(h[r]++,!(h[r]<this._o.sizes[r+s]));r++)h[r]=0}while(h.some(_=>_>0))}return this._wname?[this._bi,{[this._wname]:this._dw}]:this._bi}update(t){this._wname||this._w.broadcastOperate(t.delta("w",this._dw),(s,i)=>s-i)}toObject(){return{type:"conv",w:this._wname||this._w?.toArray(),channel:this._out_channel,kernel:this._kernel,stride:this._stride,padding:this._padding,activation:this._activation?.toObject(),l2_decay:this._l2_decay,l1_decay:this._l1_decay,channel_dim:this._channel_dim}}}K.registLayer();class W extends p{static{d(this,"ConcatenatedReLULayer")}calc(t){this._i=t;const s=t.copy();s.map(e=>e>0?e:0);const i=t.copy();return i.map(e=>e<0?-e:0),s.concat(i,s.dimension-1),s}grad(t){const s=this._i.dimension-1,i=t.slice(0,this._i.sizes[s],s),e=t.slice(this._i.sizes[s],t.sizes[s],s);return i.map((h,_)=>this._i.at(_)>=0?h:-e.at(_)),i}}W.registLayer("crelu");class X extends p{static{d(this,"DropoutLayer")}constructor({drop_rate:t=.5,...s}){super(s),this._drop_rate=t}bind({drop_rate:t}){this._drop_rate=t||this._drop_rate}_shuffle(t){const s=Array.from({length:t},(i,e)=>e);for(let i=t-1;i>0;i--){let e=Math.floor(Math.random()*(i+1));[s[i],s[e]]=[s[e],s[i]]}return s.slice(0,Math.max(1,Math.floor(t*this._drop_rate)))}calc(t){const s=t.length/t.sizes[0];this._drop_index=this._shuffle(s);const i=t.copy();for(let e=0;e<t.sizes[0];e++)for(const h of this._drop_index)i.value[e*s+h]=0;return i.map(e=>e*(s/(s-this._drop_index.length))),i}grad(t){const s=t.copy(),i=s.length/s.sizes[0];for(let e=0;e<t.sizes[0];e++)for(const h of this._drop_index)s.value[e*i+h]=0;return s.map(e=>e*(i/(i-this._drop_index.length))),s}toObject(){return{type:"dropout",drop_rate:this._drop_rate}}}X.registLayer();class Y extends p{static{d(this,"ElasticELULayer")}constructor({k:t=1,alpha:s=1,beta:i=1,...e}){super(e),this._k=t,this._alpha=s,this._beta=i}calc(t){this._i=t;const s=t.copy();return s.map(i=>i>0?this._k*i:this._alpha*(Math.exp(this._beta*i)-1)),s}grad(t){this._bo=t;const s=t.copy();return s.broadcastOperate(this._i,(i,e)=>i*(e>0?this._k:this._alpha*this._beta*Math.exp(this._beta*e))),s}update(t){let s=0,i=0;for(let e=0;e<this._i.length;e++)this._i.value[e]>0||(s+=this._bo.value[e]*(Math.exp(this._beta*this._i.value[e])-1),i+=this._bo.value[e]*(this._alpha*this._i.value[e]*Math.exp(this._beta*this._i.value[e])));this._alpha-=t.delta("alpha",s/this._i.length),this._beta-=t.delta("beta",i/this._i.length)}toObject(){return{type:"eelu",k:this._k,alpha:this._alpha,beta:this._beta}}}Y.registLayer("eelu");class Z extends p{static{d(this,"ELULayer")}constructor({a:t=1,...s}){super(s),this._a=t}calc(t){this._i=t;const s=t.copy();return s.map(i=>i>0?i:this._a*(Math.exp(i)-1)),s}grad(t){const s=t.copy();return s.broadcastOperate(this._i,(i,e)=>i*(e>0?1:this._a*Math.exp(e))),s}toObject(){return{type:"elu",a:this._a}}}Z.registLayer("elu");class tt extends p{static{d(this,"EmbeddingLayer")}constructor({size:t=512,embeddings:s={},...i}){super(i),this._size=t,this._v=s}calc(t){this._i=t;const s=[...t.sizes,this._size],i=s.length===2?new u(...s):new m(s);for(let e=0;e<t.length;e++){this._v[t.value[e]]||(this._v[t.value[e]]=u.randn(1,this._size));for(let h=0;h<this._size;h++)i.value[e*this._size+h]=this._v[t.value[e]].at(0,h)}return i}grad(t){this._dw={};for(let i=0;i<this._i.length;i++)for(let e=0;e<this._size;e++)this._dw[this._i.value[i]]||(this._dw[this._i.value[i]]=u.zeros(1,this._size)),this._dw[this._i.value[i]].add(new u(1,this._size,t.value.slice(i*this._size,(i+1)*this._size)));const s=this._i.copy();return s.fill(0),s}update(t){for(const s of Object.keys(this._dw))this._v[s].sub(t.delta(s,this._dw[s]))}toObject(){return{type:"embedding",size:this._size,embeddings:this._v}}}tt.registLayer();class st extends p{static{d(this,"ElasticReLULayer")}constructor({...t}){super(t),this._r=null,this._training=!1}bind({training:t}){this._training=t}calc(t){this._i=t;const s=t.copy();return this._training?(this._r=m.random(t.sizes.slice(1),0,2),s.map((i,e)=>i>0?i*this._r.at(e.slice(1)):0)):(this._r=m.ones(t.sizes.slice(1)),s.map(i=>i>0?i:0)),s}grad(t){const s=t.copy();return s.map((i,e)=>this._i.at(e)>0?i*this._r.at(e.slice(1)):0),s}}st.registLayer("erelu");class it extends p{static{d(this,"ESwishLayer")}constructor({beta:t=1,...s}){super(s),this._beta=t}calc(t){this._i=t;const s=t.copy();return s.map(i=>this._beta*i/(1+Math.exp(-i))),s}grad(t){this._bo=t;const s=t.copy();return s.broadcastOperate(this._i,(i,e)=>i*this._beta*(1+e*Math.exp(-e)/(1+Math.exp(-e)))/(1+Math.exp(-e))),s}update(t){let s=0;for(let i=0;i<this._i.length;i++)s+=this._bo.value[i]*(this._i.value[i]/(1+Math.exp(-this._i.value[i])));this._beta-=t.delta("beta",s/this._i.length)}toObject(){return{type:"eswish",beta:this._beta}}}it.registLayer("eswish");class et extends p{static{d(this,"FastELULayer")}constructor({alpha:t=1,...s}){super(s),this._alpha=t}calc(t){this._i=t;const s=t.copy();return s.map(i=>i>0?i:this._alpha*(Math.exp(i/Math.log(2))-1)),s}grad(t){this._bo=t;const s=t.copy();return s.broadcastOperate(this._i,(i,e)=>i*(e>0?1:this._alpha/Math.log(2)*Math.exp(e/Math.log(2)))),s}update(t){let s=0;for(let i=0;i<this._i.length;i++)this._i.value[i]>0||(s+=this._bo.value[i]*(Math.exp(this._i.value[i]/Math.log(2))-1));this._alpha-=t.delta("alpha",s/this._i.length)}toObject(){return{type:"felu",alpha:this._alpha}}}et.registLayer("felu");class ht extends p{static{d(this,"FlattenLayer")}calc(t){if(this._in_size=t.sizes.concat(),t instanceof u)return t;const s=t.copy();return s.reshape(s.sizes[0],s.length/s.sizes[0]),s.toMatrix()}grad(t){if(this._in_size.length===2)return t;const s=m.fromArray(t.copy());return s.reshape(...this._in_size),s}}ht.registLayer();class _t extends p{static{d(this,"FlexibleReLULayer")}constructor({b:t=0,...s}){super(s),this._b=t}calc(t){this._i=t;const s=t.copy();return s.map(i=>(i>0?i:0)+this._b),s}grad(t){this._bo=t;const s=t.copy();return s.broadcastOperate(this._i,(i,e)=>e>0?i:0),s}update(t){const s=this._bo.reduce((i,e)=>i+e,0)/this._bo.length;this._b-=t.delta("bias",s)}toObject(){return{type:"frelu",b:this._b}}}_t.registLayer("frelu");class at extends p{static{d(this,"FullyConnected")}constructor({out_size:t,w:s=null,b:i=null,activation:e=null,l2_decay:h=0,l1_decay:_=0,...r}){super(r),this._out_size=t,this._w=null,typeof s=="string"?this._wname=s:s&&(this._w=u.fromArray(s)),this._b=null,typeof i=="string"?this._bname=i:i&&(this._b=u.fromArray(i)),typeof e=="string"?this._activation=p.fromObject({type:e}):e&&(this._activation=p.fromObject(e)),this._l2_decay=h,this._l1_decay=_}get dependentLayers(){const t=[];return this._wname&&t.push(this._wname),this._bname&&t.push(this._bname),this._activation&&t.push(...this._activation.dependentLayers),t}calc(t){if(this._wname&&(this._w=this.graph.getNode(this._wname).outputValue,this._out_size||(this._out_size=this._w.sizes.at(-1))),this._bname&&(this._b=this.graph.getNode(this._bname).outputValue),!this._w||!this._b){const s=typeof this._out_size=="string"?this.graph.getNode(this._out_size).lastOutputSize.at(-1):this._out_size;this._w||(this._w=u.randn(t.sizes.at(-1),s)),this._b||(this._b=u.zeros(1,s))}return this._i=t,this._o=t.dot(this._w),this._o.broadcastOperate(this._b,(s,i)=>s+i),this._activation?this._activation.calc(this._o):this._o}grad(t){this._activation&&(t=this._activation.grad(t));let s=this._i;this._i.dimension!==2&&(s=this._i.copy(),s.reshape(-1,this._w.rows),s=s.toMatrix());let i=t;if(i.dimension!==2&&(i=t.copy(),i.reshape(-1,this._w.cols),i=i.toMatrix()),this._dw=s.tDot(i),this._dw.div(this._i.rows),this._l2_decay>0||this._l1_decay>0)for(let e=0;e<this._dw.rows;e++)for(let h=0;h<this._dw.cols;h++){const _=this._w.at(e,h);this._dw.addAt(e,h,_*this._l2_decay+Math.sign(_)*this._l1_decay)}if(this._db=i.sum(0),this._db.div(this._i.rows),this._bi=t.dot(this._w.t),this._wname||this._bname){const e={};return this._wname&&(e[this._wname]=this._dw),this._bname&&(e[this._bname]=this._db),[this._bi,e]}return this._bi}update(t){this._wname||this._w.sub(t.delta("w",this._dw)),this._bname||this._b.sub(t.delta("b",this._db))}toObject(){return{type:"full",out_size:this._out_size,w:this._wname||this._w?.toArray(),b:this._bname||this._b?.toArray(),activation:this._activation?.toObject(),l2_decay:this._l2_decay,l1_decay:this._l1_decay}}}at.registLayer("full");class nt extends p{static{d(this,"FunctionLayer")}constructor({func:t,...s}){super(s),this._func=t,this._exc=Us(this._func)}calc(t,s){const i=t.copy();return this._unary=!s,this._unary?(i.map(e=>this._exc({x:e})),this._g=i.copy(),this._g.map(e=>e.gx)):(i.broadcastOperate(s,(e,h)=>this._exc({x:e,y:h})),this._gx=i.copy(),this._gx.map(e=>e.gx),this._gy=i.copy(),this._gy.map(e=>e.gy)),i.map(e=>e.v),i}grad(t){if(this._unary){const s=t.copy();return s.broadcastOperate(this._g,(i,e)=>i*e),s}else{const s=t.copy();s.broadcastOperate(this._gx,(e,h)=>e*h);const i=t.copy();return i.broadcastOperate(this._gy,(e,h)=>e*h),[s,i]}}toObject(){return{type:"function",func:this._func}}}nt.registLayer();class O{static{d(this,"OP")}constructor(t,s,i,e){this.name=t,this.p=s,this.f=i,this.g=e}get length(){return this.f.length}}const j={"+":new O("+",4,l=>l,(l,t)=>t),"-":new O("-",4,l=>-l,(l,t)=>-t)},q={"-":new O("-",1,(l,t)=>l-t,(l,t,s,i)=>s-i),"+":new O("+",1,(l,t)=>l+t,(l,t,s,i)=>s+i),"*":new O("*",2,(l,t)=>l*t,(l,t,s,i)=>l*i+s*t),"/":new O("/",2,(l,t)=>l/t,(l,t,s,i)=>(s*t-l*i)/t**2),"**":new O("**",3,(l,t)=>l**t,(l,t,s,i)=>l**t*((i===0?0:i*Math.log(l))+t*(s/l)))},A={abs:{f:Math.abs,g:d((l,t)=>l<0?-t:t,"g")},acos:{f:Math.acos,g:d((l,t)=>-t/(Math.sqrt(1-l**2)+1e-4),"g")},acosh:{f:Math.acosh,g:d((l,t)=>t/(Math.sqrt(l**2-1)+1e-4),"g")},asin:{f:Math.asin,g:d((l,t)=>t/(Math.sqrt(1-l**2)+1e-4),"g")},asinh:{f:Math.asinh,g:d((l,t)=>t/Math.sqrt(1+l**2),"g")},atan:{f:Math.atan,g:d((l,t)=>t/(1+l**2),"g")},atanh:{f:Math.atanh,g:d((l,t)=>t/(1-l**2),"g")},cbrt:{f:Math.cbrt,g:d((l,t)=>t/(3*Math.cbrt(l)**2),"g")},cos:{f:Math.cos,g:d((l,t)=>-t*Math.sin(l),"g")},cosh:{f:Math.cosh,g:d((l,t)=>t*Math.sinh(l),"g")},exp:{f:Math.exp,g:d((l,t)=>t*Math.exp(l),"g")},log:{f:Math.log,g:d((l,t)=>t/l,"g")},log10:{f:Math.log10,g:d((l,t)=>t/(l*Math.LN10),"g")},log2:{f:Math.log2,g:d((l,t)=>t/(l*Math.LN2),"g")},max:{f:Math.max,g:d((l,t,s,i)=>l>=t?s:i,"g")},min:{f:Math.min,g:d((l,t,s,i)=>l<=t?s:i,"g")},sin:{f:Math.sin,g:d((l,t)=>t*Math.cos(l),"g")},sinh:{f:Math.sinh,g:d((l,t)=>t*Math.cosh(l),"g")},sqrt:{f:Math.sqrt,g:d((l,t)=>t/(2*Math.sqrt(l)),"g")},tan:{f:Math.tan,g:d((l,t)=>t/Math.cos(l)**2,"g")},tanh:{f:Math.tanh,g:d((l,t)=>t*(1-Math.tanh(l)**2),"g")}},rt={e:Math.E,ln2:Math.LN2,ln10:Math.LN10,log2e:Math.LOG2E,log10e:Math.LOG10E,pi:Math.PI,sqrt1_2:Math.SQRT1_2,sqrt2:Math.SQRT2},ot=[...Object.keys(q),...Object.keys(j),"(",")",",","[","]"];ot.sort((l,t)=>t.length-l.length);const Is=d(l=>{let t=0;const s=[],i=d(e=>{for(const h of ot)if(h===l.slice(t+e,t+e+h.length))return h;return null},"isToken");for(;t<l.length;){if(l[t]===" "){t++;continue}const e=i(0);if(e){t+=e.length,s.push(e);continue}let h=1;for(;h<l.length-t&&!(l[t+h]===" "||i(h));h++);s.push(l.slice(t,t+h)),t+=h}return s},"tokenize"),Ns=d(l=>{const t=Is(l),s=[],i=[];let e=!1;for(const h of t)if(rt[h])s.push(rt[h]),e=!0;else if(A[h])i.push(h),e=!1;else if(j[h]||q[h]){if(e&&!q[h]||!e&&!j[h])throw new Error(`Invalid operation '${h}'.`);const _=e?q[h]:j[h];for(;;){const r=i[i.length-1];if(r instanceof O&&r.p>=_.p)s.push(i.pop());else break}i.push(_),e=!1}else if(h===","){for(;;){if(i.length===0)throw new Error("Invalid parenthesis");if(i[i.length-1]==="(")break;s.push(i.pop())}e=!1}else if(h==="(")i.push(h),e=!1;else if(h===")"){for(;;){const _=i.pop();if(!_)throw new Error("Invalid parenthesis");if(_==="("){A[i[i.length-1]]&&s.push(i.pop());break}s.push(_)}e=!0}else Number.isFinite(+h)?(s.push(+h),e=!0):(s.push(h),e=!0);for(;i.length>0;)s.push(i.pop());return s},"construct"),Vs=d((l,t)=>{let i=l.length-1;const e=d(()=>{const _=l[i--];if(typeof _=="number")return{v:_,gx:0,gy:0};if(Object.hasOwn(t,_)){if(_==="x")return{v:t[_],gx:1,gy:0};if(_==="y")return{v:t[_],gx:0,gy:1}}if(_ instanceof O){const r=[];for(let c=0;c<_.length;c++)r.unshift(e());const a=_.f(...r.map(c=>c.v)),o=_.g(...r.map(c=>c.v),...r.map(c=>c.gx)),n=_.g(...r.map(c=>c.v),...r.map(c=>c.gy));return{v:a,gx:o,gy:n}}if(A[_]){const r=A[_].f.length,a=[];for(let f=0;f<r;f++)a.unshift(e());const o=A[_].f(...a.map(f=>f.v)),n=A[_].g(...a.map(f=>f.v),...a.map(f=>f.gx)),c=A[_].g(...a.map(f=>f.v),...a.map(f=>f.gy));return{v:o,gx:n,gy:c}}throw new Error(`Invalid token '${_}'.`)},"calc"),h=e();if(i!==-1)throw new Error("Invalid expression.");return h},"execute"),Us=d(l=>{const t=Ns(l);return s=>Vs(t,s)},"stringToFunction");class lt extends p{static{d(this,"GaussianLayer")}calc(t){return this._i=t,this._o=t.copy(),this._o.map(s=>Math.exp(-s*s/2)),this._o}grad(t){const s=this._o.copy();return s.broadcastOperate(this._i,(i,e)=>-i*e),s.broadcastOperate(t,(i,e)=>i*e),s}}lt.registLayer();class ct extends p{static{d(this,"GlobalAveragePoolLayer")}constructor({channel_dim:t=-1,...s}){if(super(s),this._channel_dim=t,this._channel_dim!==-1&&this._channel_dim!==1)throw new g("Invalid channel dimension.")}_index(t,s,i){return this._channel_dim===-1?[t,...i,s]:[t,s,...i]}calc(t){this._i=t;const s=t.sizes.slice(1),i=Array(t.sizes.length).fill(1);i[0]=t.sizes[0],this._channel_dim===-1?(i[t.dimension-1]=t.sizes[t.dimension-1],s.pop()):this._channel_dim===1&&(i[1]=t.sizes[1],s.splice(0,1));const e=this._channel_dim===-1?t.sizes[t.dimension-1]:t.sizes[1];this._o=new m(i);const h=this._i.length/this._o.length;for(let _=0;_<t.sizes[0];_++)for(let r=0;r<e;r++){const a=Array(t.dimension-2).fill(0);let o=0;do{o+=t.at(this._index(_,r,a));for(let n=0;n<a.length&&(a[n]++,!(a[n]<s[n]));n++)a[n]=0}while(a.some(n=>n>0));this._o.set(this._index(_,r,Array(t.dimension-2).fill(0)),o/h)}return this._o}grad(t){this._bo=t,this._bi=new m(this._i.sizes);const s=this._i.sizes.slice(1);this._channel_dim===-1?s.pop():this._channel_dim===1&&s.splice(0,1);const i=this._channel_dim===-1?this._i.sizes[this._i.dimension-1]:this._i.sizes[1],e=this._i.length/this._o.length;for(let h=0;h<this._i.sizes[0];h++)for(let _=0;_<i;_++){const r=Array(this._i.dimension-2).fill(0);do{this._bi.set(this._index(h,_,r),this._bo.at(this._index(h,_,Array(this._i.dimension-2).fill(0)))/e);for(let a=0;a<r.length&&(r[a]++,!(r[a]<s[a]));a++)r[a]=0}while(r.some(a=>a>0))}return this._bi}toObject(){return{type:"global_average_pool",channel_dim:this._channel_dim}}}ct.registLayer();class dt extends p{static{d(this,"GlobalLpPoolLayer")}constructor({p:t=2,channel_dim:s=-1,...i}){if(super(i),this._p=t,this._channel_dim=s,this._channel_dim!==-1&&this._channel_dim!==1)throw new g("Invalid channel dimension.")}_index(t,s,i){return this._channel_dim===-1?[t,...i,s]:[t,s,...i]}calc(t){this._i=t;const s=t.sizes.slice(1),i=Array(t.sizes.length).fill(1);i[0]=t.sizes[0],this._channel_dim===-1?(i[t.dimension-1]=t.sizes[t.dimension-1],s.pop()):this._channel_dim===1&&(i[1]=t.sizes[1],s.splice(0,1));const e=this._channel_dim===-1?t.sizes[t.dimension-1]:t.sizes[1];this._sp=new m(i);for(let h=0;h<t.sizes[0];h++)for(let _=0;_<e;_++){const r=Array(t.dimension-2).fill(0);let a=0;do{a+=t.at(this._index(h,_,r))**this._p;for(let o=0;o<r.length&&(r[o]++,!(r[o]<s[o]));o++)r[o]=0}while(r.some(o=>o>0));this._sp.set(this._index(h,_,Array(t.dimension-2).fill(0)),a)}return this._o=this._sp.copy(),this._o.map(h=>h**(1/this._p)),this._o}grad(t){this._bo=t,this._bi=new m(this._i.sizes);const s=this._i.sizes.slice(1);this._channel_dim===-1?s.pop():this._channel_dim===1&&s.splice(0,1);const i=this._channel_dim===-1?this._i.sizes[this._i.dimension-1]:this._i.sizes[1];for(let e=0;e<this._i.sizes[0];e++)for(let h=0;h<i;h++){const _=Array(this._i.dimension-2).fill(0);do{const r=this._index(e,h,_),a=this._index(e,h,Array(this._i.dimension-2).fill(0));this._bi.set(r,this._bo.at(a)*this._sp.at(a)**(1/this._p-1)*this._i.at(r)**(this._p-1));for(let o=0;o<_.length&&(_[o]++,!(_[o]<s[o]));o++)_[o]=0}while(_.some(r=>r>0))}return this._bi}toObject(){return{type:"global_lp_pool",p:this._p,channel_dim:this._channel_dim}}}dt.registLayer();class ut extends p{static{d(this,"GlobalMaxPoolLayer")}constructor({channel_dim:t=-1,...s}){if(super(s),this._channel_dim=t,this._channel_dim!==-1&&this._channel_dim!==1)throw new g("Invalid channel dimension.")}_index(t,s,i){return this._channel_dim===-1?[t,...i,s]:[t,s,...i]}calc(t){this._i=t;const s=t.sizes.slice(1),i=Array(t.sizes.length).fill(1);i[0]=t.sizes[0],this._channel_dim===-1?(i[t.dimension-1]=t.sizes[t.dimension-1],s.pop()):this._channel_dim===1&&(i[1]=t.sizes[1],s.splice(0,1));const e=this._channel_dim===-1?t.sizes[t.dimension-1]:t.sizes[1];this._o=new m(i);for(let h=0;h<t.sizes[0];h++)for(let _=0;_<e;_++){const r=Array(t.dimension-2).fill(0);let a=-1/0;do{const o=t.at(this._index(h,_,r));a<o&&(a=o);for(let n=0;n<r.length&&(r[n]++,!(r[n]<s[n]));n++)r[n]=0}while(r.some(o=>o>0));this._o.set(this._index(h,_,Array(t.dimension-2).fill(0)),a)}return this._o}grad(t){this._bo=t,this._bi=new m(this._i.sizes);const s=this._i.sizes.slice(1);this._channel_dim===-1?s.pop():this._channel_dim===1&&s.splice(0,1);const i=this._channel_dim===-1?this._i.sizes[this._i.dimension-1]:this._i.sizes[1];for(let e=0;e<this._i.sizes[0];e++)for(let h=0;h<i;h++){const _=Array(this._i.dimension-2).fill(0);let r=-1/0,a=null;do{const o=this._i.at(this._index(e,h,_));r<o&&(r=o,a=_.concat());for(let n=0;n<_.length&&(_[n]++,!(_[n]<s[n]));n++)_[n]=0}while(_.some(o=>o>0));this._bi.set(this._index(e,h,a),this._bo.at(this._index(e,h,_)))}return this._bi}toObject(){return{type:"global_max_pool",channel_dim:this._channel_dim}}}ut.registLayer();class pt extends p{static{d(this,"GraphConvolutionalLayer")}constructor({out_size:t,w:s=null,b:i=null,activation:e=null,l2_decay:h=0,l1_decay:_=0,...r}){super(r),this._out_size=t,this._w=null,typeof s=="string"?this._wname=s:s&&(this._w=u.fromArray(s)),this._b=null,typeof i=="string"?this._bname=i:i&&(this._b=u.fromArray(i)),typeof e=="string"?this._activation=p.fromObject({type:e}):e&&(this._activation=p.fromObject(e)),this._l2_decay=h,this._l1_decay=_,this._aggregate="mean"}get dependentLayers(){const t=[];return this._wname&&t.push(this._wname),this._bname&&t.push(this._bname),this._activation&&t.push(...this._activation.dependentLayers),t}calc(t){this._wname&&(this._w=this.graph.getNode(this._wname).outputValue,this._out_size||(this._out_size=this._w.sizes.at(-1))),this._bname&&(this._b=this.graph.getNode(this._bname).outputValue),this._w||(this._w=u.randn(t.value[0].nodes[0].sizes.at(-1),this._out_size)),this._b||(this._b=u.zeros(1,this._out_size)),this._i=t,this._cum=[],this._o=t.copy();for(let s=0;s<t.length;s++){const i=t.value[s].copy(),e=t.value[s].copy();for(let h=0;h<i.order;h++){const _=t.value[s].getNode(h).copy(),r=t.value[s].adjacencies(h,!0,"in");for(let o=0;o<r.length;o++)_.add(t.value[s].getNode(r[o]));this._aggregate==="mean"&&_.div(r.length+1),e.nodes[h]=_;let a=_.dot(this._w);a.broadcastOperate(this._b,(o,n)=>o+n),this._activation&&(a=this._activation.calc(a)),i.nodes[h]=a}this._cum[s]=e,this._o.value[s]=i}return this._o}grad(t){if(this._activation)for(let i=0;i<t.length;i++)for(let e=0;e<t.value[i].order;e++)t.value[i].nodes[e]=this._activation.grad(t.value[i].nodes[e]);this._dw=null,this._db=null,this._bi=this._i.copy();for(let i=0;i<this._bi.length;i++){const e=this._i.value[i].copy();for(let h=0;h<this._bi.value[i].order;h++)e.nodes[h]=this._i.value[i].nodes[h].copy(),e.nodes[h].fill(0);this._bi.value[i]=e}let s=0;for(let i=0;i<t.length;i++)for(let e=0;e<t.value[i].order;e++){const h=this._cum[i].nodes[e].tDot(t.value[i].nodes[e]),_=t.value[i].nodes[e].sum(0);this._dw?(this._dw.add(h),this._db.add(_)):(this._dw=h,this._db=_),s++;const r=t.value[i].nodes[e].dot(this._w.t),a=this._bi.value[i].adjacencies(e,!0,"in");this._aggregate==="mean"&&r.div(a.length+1),this._bi.value[i].nodes[e].broadcastOperate(r,(o,n)=>o+n);for(let o=0;o<a.length;o++)this._bi.value[i].nodes[a[o]].broadcastOperate(r,(n,c)=>n+c)}if(this._dw.div(s),this._l2_decay>0||this._l1_decay>0)for(let i=0;i<this._dw.rows;i++)for(let e=0;e<this._dw.cols;e++){const h=this._w.at(i,e);this._dw.addAt(i,e,h*this._l2_decay+Math.sign(h)*this._l1_decay)}if(this._db.div(s),this._wname||this._bname){const i={};return this._wname&&(i[this._wname]=this._dw),this._bname&&(i[this._bname]=this._db),[this._bi,i]}return this._bi}update(t){this._wname||this._w.sub(t.delta("w",this._dw)),this._bname||this._b.sub(t.delta("b",this._db))}toObject(){return{type:"graph_conv",out_size:this._out_size,w:this._wname||this._w?.toArray(),b:this._bname||this._b?.toArray(),activation:this._activation?.toObject(),l2_decay:this._l2_decay,l1_decay:this._l1_decay}}}pt.registLayer("graph_conv");class ft extends p{static{d(this,"GraphSAGELayer")}constructor({out_size:t,aggregate:s="mean",w:i=null,b:e=null,activation:h=null,l2_decay:_=0,l1_decay:r=0,...a}){super(a),this._out_size=t,this._w=null,typeof i=="string"?this._wname=i:i&&(this._w=u.fromArray(i)),this._b=null,typeof e=="string"?this._bname=e:e&&(this._b=u.fromArray(e)),typeof h=="string"?this._activation=p.fromObject({type:h}):h&&(this._activation=p.fromObject(h)),this._l2_decay=_,this._l1_decay=r,this._aggregate=s}get dependentLayers(){const t=[];return this._wname&&t.push(this._wname),this._bname&&t.push(this._bname),this._activation&&t.push(...this._activation.dependentLayers),t}calc(t){this._wname&&(this._w=this.graph.getNode(this._wname).outputValue,this._out_size||(this._out_size=this._w.sizes.at(-1))),this._bname&&(this._b=this.graph.getNode(this._bname).outputValue),this._w||(this._w=u.randn(t.value[0].nodes[0].sizes.at(-1)*2,this._out_size)),this._b||(this._b=u.zeros(1,this._out_size)),this._i=t,this._cum=[],this._o=t.copy();for(let s=0;s<t.length;s++){const i=t.value[s].copy(),e=t.value[s].copy();for(let h=0;h<i.order;h++){const _=t.value[s].getNode(h).copy(),r=_.copy();r.fill(0);const a=t.value[s].adjacencies(h,!0,"in");for(let n=0;n<a.length;n++)r.add(t.value[s].getNode(a[n]));this._aggregate==="mean"&&r.div(a.length),_.concat(r,1),e.nodes[h]=_;let o=_.dot(this._w);o.broadcastOperate(this._b,(n,c)=>n+c),this._activation&&(o=this._activation.calc(o)),i.nodes[h]=o}this._cum[s]=e,this._o.value[s]=i}return this._o}grad(t){if(this._activation)for(let i=0;i<t.length;i++)for(let e=0;e<t.value[i].order;e++)t.value[i].nodes[e]=this._activation.grad(t.value[i].nodes[e]);this._dw=null,this._db=null,this._bi=this._i.copy();for(let i=0;i<this._bi.length;i++){const e=this._i.value[i].copy();for(let h=0;h<this._bi.value[i].order;h++)e.nodes[h]=this._i.value[i].nodes[h].copy(),e.nodes[h].fill(0);this._bi.value[i]=e}let s=0;for(let i=0;i<t.length;i++)for(let e=0;e<t.value[i].order;e++){const h=this._cum[i].nodes[e].tDot(t.value[i].nodes[e]),_=t.value[i].nodes[e].sum(0);this._dw?(this._dw.add(h),this._db.add(_)):(this._dw=h,this._db=_),s++;const r=t.value[i].nodes[e].dot(this._w.t),a=r.slice(0,this._i.value[i].nodes[e].sizes[1],1),o=r.slice(this._i.value[i].nodes[e].sizes[1],r.sizes[1],1),n=this._bi.value[i].adjacencies(e,!0,"in");this._aggregate==="mean"&&o.div(n.length),this._bi.value[i].nodes[e].broadcastOperate(a,(c,f)=>c+f);for(let c=0;c<n.length;c++)this._bi.value[i].nodes[n[c]].broadcastOperate(o,(f,b)=>f+b)}if(this._dw.div(s),this._l2_decay>0||this._l1_decay>0)for(let i=0;i<this._dw.rows;i++)for(let e=0;e<this._dw.cols;e++){const h=this._w.at(i,e);this._dw.addAt(i,e,h*this._l2_decay+Math.sign(h)*this._l1_decay)}if(this._db.div(s),this._wname||this._bname){const i={};return this._wname&&(i[this._wname]=this._dw),this._bname&&(i[this._bname]=this._db),[this._bi,i]}return this._bi}update(t){this._wname||this._w.sub(t.delta("w",this._dw)),this._bname||this._b.sub(t.delta("b",this._db))}toObject(){return{type:"graph_sage",out_size:this._out_size,aggregate:this._aggregate,w:this._wname||this._w?.toArray(),b:this._bname||this._b?.toArray(),activation:this._activation?.toObject(),l2_decay:this._l2_decay,l1_decay:this._l1_decay}}}ft.registLayer("graph_sage");class mt extends p{static{d(this,"GRULayer")}constructor({size:t,return_sequences:s=!1,w_z:i=null,w_r:e=null,w_h:h=null,u_z:_=null,u_r:r=null,u_h:a=null,b_z:o=null,b_r:n=null,b_h:c=null,sequence_dim:f=1,...b}){if(super(b),this._size=t,this._unit=new Ds({layer:this,size:t,w_z:i,w_r:e,w_h:h,u_z:_,u_r:r,u_h:a,b_z:o,b_r:n,b_h:c}),this._return_sequences=s,this._sequence_dim=f,this._sequence_dim!==0&&this._sequence_dim!==1)throw new g("Invalid sequence dimension.")}get dependentLayers(){return this._unit.dependentLayers}calc(t){this._sequence_dim===1&&(t=t.transpose(1,0,2)),this._x=[];for(let i=0;i<t.sizes[0];i++)this._x[i]=t.index(i).toMatrix();const s=[];for(let i=0;i<this._x.length;i++)s[i]=this._unit.calc(this._x[i],i);if(this._return_sequences){const i=m.fromArray(s.map(e=>e.toArray()));return this._sequence_dim===1?i.transpose(1,0,2):i}return s[s.length-1]}grad(t){return this._grad_bptt(t)}_grad_bptt(t){const s=this._x.length;if(this._bo=Array(s),this._return_sequences){this._sequence_dim===1&&(t=t.transpose(1,0,2));for(let _=0;_<s;_++)this._bo[_]=t.index(_).toMatrix()}else this._bo[s-1]=t;const i=[];let e=null;for(let _=s-1;_>=0;_--){const r=this._unit.grad(this._bo[_],_);_===0&&Array.isArray(r)?(i[_]=r[0],e=r[1]):i[_]=r}let h=m.fromArray(i.map(_=>_.toArray()));return this._sequence_dim===1&&(h=h.transpose(1,0,2)),e?[h,e]:h}update(t){this._unit.update(t)}toObject(){return{type:"gru",size:this._size,return_sequences:this._return_sequences,sequence_dim:this._sequence_dim,...this._unit.toObject()}}}class Ds extends p{static{d(this,"GRUUnitLayer")}constructor({layer:t,size:s,w_z:i=null,w_r:e=null,w_h:h=null,u_z:_=null,u_r:r=null,u_h:a=null,b_z:o=null,b_r:n=null,b_h:c=null,...f}){super(f),this._size=s,this._w_z=new x(t,i),this._w_r=new x(t,e),this._w_h=new x(t,h),this._u_z=new x(t,_,[this._size,this._size]),this._u_r=new x(t,r,[this._size,this._size]),this._u_h=new x(t,a,[this._size,this._size]),this._b_z=new x(t,o,[1,this._size]),this._b_r=new x(t,n,[1,this._size]),this._b_h=new x(t,c,[1,this._size]),this._s0=u.zeros(1,this._size),this._x=[],this._h=[],this._s=[],this._z=[],this._r=[],this._bo=[],this._dy=[],this._dr=[],this._dz=[],this._dh=[]}get dependentLayers(){const t=[];return this._w_z.name&&t.push(this._w_z.name),this._w_r.name&&t.push(this._w_r.name),this._w_h.name&&t.push(this._w_h.name),this._u_z.name&&t.push(this._u_z.name),this._u_r.name&&t.push(this._u_r.name),this._u_h.name&&t.push(this._u_h.name),this._b_z.name&&t.push(this._b_z.name),this._b_r.name&&t.push(this._b_r.name),this._b_h.name&&t.push(this._b_h.name),t}_sigmoid(t){return u.map(t,s=>1/(1+Math.exp(-s)))}_grad_sigmoid(t){return u.map(t,s=>s*(1-s))}_tanh(t){return u.map(t,Math.tanh)}_grad_tanh(t){return u.map(t,s=>1-s**2)}calc(t,s){s===0&&(this._s=[]),this._x[s]=t;const i=s===0?this._s0:this._s[s-1],e=this._x[s].dot(this._w_z.get(t.cols,this._size));e.add(i.dot(this._u_z.get())),e.add(this._b_z.get());const h=this._sigmoid(e);this._z[s]=h;const _=this._x[s].dot(this._w_r.get(t.cols,this._size));_.add(i.dot(this._u_r.get())),_.add(this._b_r.get());const r=this._sigmoid(_);this._r[s]=r;const a=this._x[s].dot(this._w_h.get(t.cols,this._size));a.add(u.mult(r,i).dot(this._u_h.get())),a.add(this._b_h.get());const o=this._tanh(a);return this._h[s]=o,this._s[s]=u.sub(1,h),this._s[s].mult(o),this._s[s].add(u.mult(h,i)),this._s[s]}grad(t,s){return this._grad_bptt(t,s)}_grad_bptt(t,s){const i=this._s.length;this._bo[s]=t;const e=s===0?this._s0:this._s[s-1];this._dy[s]=this._bo[s]||u.zeros(1,1),s<i-1&&(this._dy[s].add(this._dz[s+1].dot(this._u_z.value.t)),this._dy[s].add(this._dr[s+1].dot(this._u_r.value.t)),this._dy[s].add(u.mult(this._dh[s+1].dot(this._u_h.value.t),this._r[s+1])),this._dy[s].add(u.mult(this._z[s+1],this._dy[s+1]))),this._dz[s]=u.mult(e,this._dy[s]),this._dz[s].sub(u.mult(this._h[s],this._dy[s])),this._dz[s].mult(this._grad_sigmoid(this._z[s])),this._dh[s]=u.sub(1,this._z[s]),this._dh[s].mult(this._dy[s]),this._dh[s].mult(this._grad_tanh(this._h[s])),this._dr[s]=this._dh[s].dot(this._u_h.value.t),this._dr[s].mult(e),this._dr[s].mult(this._grad_sigmoid(this._r[s]));const h=this._dh[s].dot(this._w_h.value.t);if(h.add(this._dz[s].dot(this._w_z.value.t)),h.add(this._dr[s].dot(this._w_r.value.t)),s===0){this._diff_bptt();const _={};if(this._w_r.name&&(_[this._w_r.name]=this._dw_r),this._w_z.name&&(_[this._w_z.name]=this._dw_z),this._w_h.name&&(_[this._w_h.name]=this._dw_h),this._b_r.name&&(_[this._b_r.name]=this._db_r),this._b_z.name&&(_[this._b_z.name]=this._db_z),this._b_h.name&&(_[this._b_h.name]=this._db_h),this._u_r.name&&(_[this._u_r.name]=this._du_r),this._u_z.name&&(_[this._u_z.name]=this._du_z),this._u_h.name&&(_[this._u_h.name]=this._du_h),Object.keys(_).length>0)return[h,_]}return h}_diff_bptt(){const t=this._s.length,s=this._x[0].rows;this._dw_r=u.zeros(...this._w_r.sizes),this._dw_z=u.zeros(...this._w_z.sizes),this._dw_h=u.zeros(...this._w_h.sizes),this._db_r=u.zeros(1,this._size),this._db_z=u.zeros(1,this._size),this._db_h=u.zeros(1,this._size);for(let i=0;i<t;i++){const e=this._x[i].tDot(this._dr[i]);e.div(s),this._dw_r.add(e);const h=this._x[i].tDot(this._dz[i]);h.div(s),this._dw_z.add(h);const _=this._x[i].tDot(this._dh[i]);_.div(s),this._dw_h.add(_),this._db_r.add(this._dr[i].mean(0)),this._db_z.add(this._dz[i].mean(0)),this._db_h.add(this._dh[i].mean(0))}this._du_r=u.zeros(this._size,this._size),this._du_z=u.zeros(this._size,this._size),this._du_h=u.zeros(this._size,this._size);for(let i=0;i<t-1;i++){const e=this._s[i].tDot(this._dr[i+1]);e.div(s),this._du_r.add(e);const h=this._s[i].tDot(this._dz[i+1]);h.div(s),this._du_z.add(h);const _=this._s[i].tDot(this._dh[i+1]);_.div(s),this._du_h.add(_)}}update(t){this._update_bptt(t)}_update_bptt(t){this._w_r.name||this._w_r.value.sub(t.delta("w_r",this._dw_r)),this._w_z.name||this._w_z.value.sub(t.delta("w_z",this._dw_z)),this._w_h.name||this._w_h.value.sub(t.delta("w_h",this._dw_h)),this._b_r.name||this._b_r.value.sub(t.delta("b_r",this._db_r)),this._b_z.name||this._b_z.value.sub(t.delta("b_z",this._db_z)),this._b_h.name||this._b_h.value.sub(t.delta("b_h",this._db_h)),this._u_r.name||this._u_r.value.sub(t.delta("u_r",this._du_r)),this._u_z.name||this._u_z.value.sub(t.delta("u_z",this._du_z)),this._u_h.name||this._u_h.value.sub(t.delta("u_h",this._du_h))}toObject(){return{w_z:this._w_z?.toObject(),w_r:this._w_r?.toObject(),w_h:this._w_h?.toObject(),u_z:this._u_z?.toObject(),u_r:this._u_r?.toObject(),u_h:this._u_h?.toObject(),b_z:this._b_z?.toObject(),b_r:this._b_r?.toObject(),b_h:this._b_h?.toObject()}}}let x=class{static{d(this,"Variable")}constructor(t,s,i){this._layer=t,this._sizes=i,typeof s=="string"?this._name=s:s&&(this._value=u.fromArray(s))}get name(){return this._name}get value(){return this._value}get sizes(){return this._value.sizes}get(...t){return t.length===0&&(t=this._sizes),this._name?this._value=this._layer.graph.getNode(this._name).outputValue:this._value?this._value:this._value=u.randn(...t)}toObject(){return this._name?this._name:this._value?.toArray()}};mt.registLayer("gru");class bt extends p{static{d(this,"HardShrinkLayer")}constructor({l:t=.5,...s}){super(s),this._l=t}calc(t){this._i=t;const s=t.copy();return s.map(i=>i<-this._l||this._l<i?i:0),s}grad(t){this._bo=t;const s=t.copy();return s.broadcastOperate(this._i,(i,e)=>e<-this._l||this._l<e?i:0),s}toObject(){return{type:"hard_shrink",l:this._l}}}bt.registLayer();class yt extends p{static{d(this,"HardSigmoidLayer")}constructor({alpha:t=.2,beta:s=.5,...i}){super(i),this._alpha=t,this._beta=s}calc(t){this._i=t;const s=t.copy();return s.map(i=>Math.max(0,Math.min(1,this._alpha*i+this._beta))),s}grad(t){this._bo=t;const s=t.copy();return s.broadcastOperate(this._i,(i,e)=>i*(e<-this._beta/this._alpha||this._beta/this._alpha<e?0:this._alpha)),s}toObject(){return{type:"hard_sigmoid",alpha:this._alpha,beta:this._beta}}}yt.registLayer();class gt extends p{static{d(this,"HardTanhLayer")}constructor({v:t=1,...s}){super(s),this._v=t}calc(t){this._i=t;const s=t.copy();return s.map(i=>i<-this._v?-this._v:this._v<i?this._v:i),s}grad(t){this._bo=t;const s=t.copy();return s.broadcastOperate(this._i,(i,e)=>i*(e<-this._v||this._v<e?0:1)),s}toObject(){return{type:"hard_tanh",v:this._v}}}gt.registLayer();class zt extends p{static{d(this,"HexpoLayer")}constructor({a:t=1,b:s=1,c:i=1,d:e=1,...h}){super(h),this._a=t,this._b=s,this._c=i,this._d=e}calc(t){this._i=t;const s=this._i.copy();return s.map(i=>i>=0?-this._a*(Math.exp(-i/this._b)-1):this._c*(Math.exp(i/this._d)-1)),s}grad(t){const s=t.copy();return s.broadcastOperate(this._i,(i,e)=>i*(e>=0?this._a/this._b*Math.exp(-e/this._b):this._c/this._d*Math.exp(e/this._d))),s}toObject(){return{type:"hexpo",a:this._a,b:this._b,c:this._c,d:this._d}}}zt.registLayer("hexpo");class wt extends p{static{d(this,"HuberLayer")}bind({supervisor:t}){Array.isArray(t)?(this._t=m.fromArray(t),this._t.dimension===2&&(this._t=this._t.toMatrix())):(t instanceof u||t instanceof m)&&(this._t=t)}calc(t){this._i=t;const s=this._t.copy();return s.broadcastOperate(t,(i,e)=>Math.abs(i-e)),this._cond=s.copy(),this._cond.map(i=>i<1),s.map((i,e)=>this._cond.at(e)?.5*i*i:i-.5),new u(1,1,s.reduce((i,e)=>i+e))}grad(t){return t=t.toScaler(),this._bi=this._cond.copy(),this._bi.map((s,i)=>t*(s?this._i.at(i)-this._t.at(i):Math.sign(this._i.at(i)-this._t.at(i)))),this._bi}}wt.registLayer();class vt extends p{static{d(this,"IncludeLayer")}constructor({net:t,input_to:s=null,train:i=!0,...e}){super(e),this._model=t instanceof M?t:M.fromObject(t),this._input_to=s,this._train=i,this._org_i=null,this._org_t=null}bind({input:t,supervisor:s}){this._org_i=t,this._org_t=s}calc(t){if(!(this._org_i instanceof u)&&this._input_to){const s=t;t=this._org_i,t[this._input_to]=s}return this._model.calc(t)}grad(t){return this._model.grad(t)}update(t){this._train&&this._model.update(t.lr)}toObject(){return{type:"include",net:this._model.toObject(),input_to:this._input_to,train:this._train}}}vt.registLayer();class Ot extends p{static{d(this,"InputLayer")}constructor({name:t=null,size:s=null,value:i,...e}){super(e),this._name=t,this._size=s,this._value=i}bind({input:t}){if(t&&!Array.isArray(t)&&!(t instanceof u)&&!(t instanceof m)&&t[this._name]&&(t=t[this._name]),t==null&&(t=this._value),Array.isArray(t)?(this._o=m.fromArray(t),this._o.dimension===2&&(this._o=this._o.toMatrix())):t instanceof u||t instanceof m?this._o=t:this._o=new u(1,1,t),this._size){const s=this._o.sizes;if(s.length!==this._size.length||this._size.some((i,e)=>i!=null&&i!==s[e]))throw new g("Invalid input size",[this])}}calc(){return this._o}grad(){}toObject(){return{type:"input",name:this._name,size:this._size?.concat(),value:this._value instanceof u||this._value instanceof m?this._value.toArray():this._value}}}Ot.registLayer();class xt extends p{static{d(this,"ImprovedSigmoidLayer")}constructor({a:t=1,alpha:s=1,...i}){super(i),this._a=t,this._alpha=s}calc(t){const s=1/(1+Math.exp(-this._a)),i=1/(1+Math.exp(this._a));return this._i=t,this._o=t.copy(),this._o.map(e=>-this._a<e&&e<this._a?1/(1+Math.exp(-e)):e>=this._a?s+this._alpha*(e-this._a):i+this._alpha*(e+this._a)),this._o}grad(t){const s=1/(1+Math.exp(-this._a)),i=1/(1+Math.exp(this._a)),e=t.copy();return e.broadcastOperate(this._o,(h,_)=>h*(i<_&&_<s?_*(1-_):this._alpha)),e}toObject(){return{type:"isigmoid",a:this._a,alpha:this._alpha}}}xt.registLayer("isigmoid");class Lt extends p{static{d(this,"LayerNormalizationLayer")}constructor({axis:t=-1,epsilon:s=1e-12,scale:i=1,offset:e=0,...h}){super(h),this._axis=t,this._epsilon=s,this._scale=null,typeof i=="string"?this._scalename=i:this._scale=i,this._offset=null,typeof e=="string"?this._offsetname=e:this._offset=e}get dependentLayers(){const t=[];return this._scalename&&t.push(this._scalename),this._offsetname&&t.push(this._offsetname),t}get mean(){return this._mean}get invStdDev(){return this._invStdDev}calc(t){const s=this._axis<0?t.dimension+this._axis:this._axis,i=[];for(let a=s;a<t.dimension;a++)i.push(a);const e=i.map(a=>t.sizes[a]);this._scalename?(this._scale=this.graph.getNode(this._scalename).outputValue,this._scale.reshape(...e)):typeof this._scale=="number"?this._scale=new m(e,this._scale):Array.isArray(this._scale)&&(this._scale=m.fromArray(this._scale),this._scale.reshape(...e)),this._offsetname?(this._offset=this.graph.getNode(this._offsetname).outputValue,this._offset.reshape(...e)):typeof this._offset=="number"?this._offset=new m(e,this._offset):Array.isArray(this._offset)&&(this._offset=m.fromArray(this._offset),this._offset.reshape(...e));const h=i.reduce((a,o)=>a*t.sizes[o],1),_=t.reduce((a,o)=>a+o/h,0,i,!0);this._xc=t.copy(),this._xc.broadcastOperate(_,(a,o)=>a-o),this._var=this._xc.reduce((a,o)=>a+o**2/h,0,i,!0),this._xh=this._xc.copy(),this._xh.broadcastOperate(this._var,(a,o)=>a/Math.sqrt(o+this._epsilon));const r=this._xh.copy();return r.broadcastOperate(this._scale,(a,o)=>a*o),r.broadcastOperate(this._offset,(a,o)=>a+o),this._mean=_,this._invStdDev=this._var.copy(),this._invStdDev.map(a=>1/Math.sqrt(a+this._epsilon)),r}grad(t){this._bo=t;const s=this._bo.copy();s.broadcastOperate(this._scale,(n,c)=>n*c);const i=this._xc.copy();i.broadcastOperate(s,(n,c)=>n*c);const e=this._axis<0?this._bo.dimension+this._axis:this._axis,h=[];for(let n=e;n<this._bo.dimension;n++)h.push(n);const _=h.reduce((n,c)=>n*t.sizes[c],1),r=i.reduce((n,c)=>n+c/_,0,h,!0),a=this._xc.copy();a.broadcastOperate(this._var,(n,c)=>n/(c+this._epsilon)),a.broadcastOperate(r,(n,c)=>n*c),a.broadcastOperate(s,(n,c)=>c-n),a.broadcastOperate(this._var,(n,c)=>n/Math.sqrt(c+this._epsilon));const o=a.reduce((n,c)=>n+c/_,0,h,!0);if(a.broadcastOperate(o,(n,c)=>n-c),this._scalename||this._offsetname){const n=Array.from({length:e},(b,y)=>y),c=n.reduce((b,y)=>b*t.sizes[y],1),f={};if(this._scalename){const b=this._bo.reduce((y,w,L)=>y+w*this._xh.at(L)/c,0,n);f[this._scalename]=b}if(this._offsetname){const b=this._bo.reduce((y,w)=>y+w/c,0,n);f[this._offsetname]=b}return[a,f]}return a}update(t){if(this._scalename&&this._offsetname)return;const s=this._axis<0?this._bo.dimension+this._axis:this._axis,i=Array.from({length:s},(h,_)=>_),e=i.reduce((h,_)=>h*this._bo.sizes[_],1);if(!this._offsetname){const h=this._bo.reduce((_,r)=>_+r/e,0,i);this._offset.broadcastOperate(t.delta("offset",h),(_,r)=>_-r)}if(!this._scalename){const h=this._bo.reduce((_,r,a)=>_+r*this._xh.at(a)/e,0,i);this._scale.broadcastOperate(t.delta("scale",h),(_,r)=>_-r)}}toObject(){return{type:"layer_normalization",axis:this._axis,epsilon:this._epsilon,scale:this._scalename||this._scale.toArray?.()||this._scale,offset:this._offsetname||this._offset.toArray?.()||this._offset}}}Lt.registLayer();class At extends p{static{d(this,"LeakyReLULayer")}constructor({a:t=.1,...s}){super(s),this._a=t}calc(t){return this._i=t,this._o=t.copy(),this._o.map(s=>s>0?s:s*this._a),this._o}grad(t){const s=t.copy();return s.broadcastOperate(this._i,(i,e)=>i*(e>0?1:this._a)),s}toObject(){return{type:"leaky_relu",a:this._a}}}At.registLayer("leaky_relu");class kt extends p{static{d(this,"LogSoftmaxLayer")}constructor({axis:t=-1,...s}){super(s),this._axis=t}calc(t){const s=this._axis<0?this._axis+t.dimension:this._axis;this._s=t.copy();const i=this._s.reduce((h,_)=>Math.max(h,_),-1/0,s,!0);this._s.broadcastOperate(i,(h,_)=>h-_),this._s.map(Math.exp);const e=this._s.reduce((h,_)=>h+_,0,s,!0);return this._s.broadcastOperate(e,(h,_)=>h/_),this._o=this._s.copy(),this._o.map(Math.log),this._o}grad(t){this._bi=t.copy();const s=this._axis<0?this._axis+t.dimension:this._axis,i=Array(t.dimension).fill(0);do{for(let e=0;e<t.sizes[s];e++){i[s]=e;const h=this._s.at(i);let _=0;const r=i.concat();for(let a=0;a<t.sizes[s];a++){r[s]=a;const o=e===a?1-h:-h;_+=o*t.at(r)}this._bi.set(i,_)}for(let e=0;e<i.length;e++){if(e===s){i[e]=0;continue}if(i[e]++,i[e]<t.sizes[e])break;i[e]=0}}while(i.some(e=>e>0));return this._bi}toObject(){return{type:"log_softmax",axis:this._axis}}}kt.registLayer();class Mt extends p{static{d(this,"LpPoolLayer")}constructor({p:t=2,kernel:s,stride:i=null,padding:e=null,channel_dim:h=-1,..._}){if(super(_),this._p=t,this._kernel=s,this._stride=i||s,this._padding=e||0,this._channel_dim=h,this._channel_dim!==-1&&this._channel_dim!==1)throw new g("Invalid channel dimension.")}_index(t,s,i){return this._channel_dim===-1?[t,...i,s]:[t,s,...i]}calc(t){if(Array.isArray(this._kernel)||(this._kernel=Array(t.dimension-2).fill(this._kernel)),t.dimension!==this._kernel.length+2)throw new g("Invalid kernel size",[this,t]);if(Array.isArray(this._stride)||(this._stride=Array(t.dimension-2).fill(this._stride)),t.dimension!==this._stride.length+2)throw new g("Invalid stride size",[this,t]);if(Array.isArray(this._padding)?Array.isArray(this._padding[0])||(this._padding=this._padding.map(h=>[h,h])):this._padding=Array.from({length:t.dimension-2},()=>[this._padding,this._padding]),t.dimension!==this._padding.length+2)throw new g("Invalid padding size",[this,t]);this._i=t;const s=this._channel_dim===-1?1:2,i=[t.sizes[0],...this._kernel.map((h,_)=>Math.ceil(Math.max(0,t.sizes[_+s]+this._padding[_][0]+this._padding[_][1]-h)/this._stride[_])+1)];this._channel_dim===-1?i.push(t.sizes[t.dimension-1]):this._channel_dim===1&&i.splice(1,0,t.sizes[1]);const e=this._channel_dim===-1?t.sizes[t.dimension-1]:t.sizes[1];this._sp=new m(i);for(let h=0;h<t.sizes[0];h++)for(let _=0;_<e;_++){const r=Array(t.dimension-2).fill(0);do{const a=Array(t.dimension-2).fill(0);let o=0;do{const n=r.map((c,f)=>c*this._stride[f]-this._padding[f][0]+a[f]);n.every((c,f)=>0<=c&&c<t.sizes[f+s])&&(o+=Math.abs(t.at(this._index(h,_,n)))**this._p);for(let c=0;c<a.length&&(a[c]++,!(a[c]<this._kernel[c]));c++)a[c]=0}while(a.some(n=>n>0));this._sp.set(this._index(h,_,r),o);for(let n=0;n<r.length&&(r[n]++,!(r[n]<i[n+s]));n++)r[n]=0}while(r.some(a=>a>0))}return this._o=this._sp.copy(),this._o.map(h=>h**(1/this._p)),this._o}grad(t){this._bo=t,this._bi=new m(this._i.sizes);const s=this._channel_dim===-1?1:2,i=this._channel_dim===-1?this._i.sizes[this._i.dimension-1]:this._i.sizes[1];for(let e=0;e<this._i.sizes[0];e++)for(let h=0;h<i;h++){const _=Array(this._i.dimension-2).fill(0);do{const r=Array(this._i.dimension-2).fill(0),a=[];do{const o=_.map((n,c)=>n*this._stride[c]-this._padding[c][0]+r[c]);o.every((n,c)=>0<=n&&n<this._i.sizes[c+s])&&a.push(o);for(let n=0;n<r.length&&(r[n]++,!(r[n]<this._kernel[n]));n++)r[n]=0}while(r.some(o=>o>0));for(const o of a){const n=this._index(e,h,o),c=this._index(e,h,_);this._bi.operateAt(n,f=>f+this._bo.at(c)*this._sp.at(c)**(1/this._p-1)*this._i.at(n)**(this._p-1)*Math.sign(this._i.at(n))**this._p)}for(let o=0;o<_.length&&(_[o]++,!(_[o]<this._o.sizes[o+s]));o++)_[o]=0}while(_.some(r=>r>0))}return this._bi}toObject(){return{type:"lp_pool",p:this._p,kernel:this._kernel,stride:this._stride,padding:this._padding,channel_dim:this._channel_dim}}}Mt.registLayer();class jt extends p{static{d(this,"LRNLayer")}constructor({alpha:t=1e-4,beta:s=.75,k:i=2,n:e,channel_dim:h=-1,..._}){if(super(_),this._alpha=t,this._beta=s,this._k=i,this._n=e,this._channel_dim=h,this._channel_dim!==-1&&this._channel_dim!==1)throw new g("Invalid channel dimension.")}_index(t,s,i){return this._channel_dim===-1?[t,...i,s]:[t,s,...i]}calc(t){this._i=t;const s=this._channel_dim===-1?t.sizes[t.dimension-1]:t.sizes[1],i=[Math.floor((this._n-1)/2),Math.ceil((this._n-1)/2)];this._s=t.copy();const e=this._channel_dim===-1?1:2;for(let _=0;_<t.sizes[0];_++){const r=Array(t.dimension-2).fill(0);do{for(let a=0;a<s;a++){let o=0;for(let n=Math.max(0,a-i[0]);n<Math.min(s,a+i[1]+1);n++)o+=t.at(this._index(_,n,r))**2;this._s.set(this._index(_,a,r),this._k+this._alpha*o)}for(let a=0;a<r.length&&(r[a]++,!(r[a]<t.sizes[a+e]));a++)r[a]=0}while(r.some(a=>a>0))}const h=this._s.copy();return h.broadcastOperate(t,(_,r)=>r/_**this._beta),h}grad(t){const s=this._i.copy();return s.broadcastOperate(this._s,(i,e)=>e**-this._beta-2*this._beta*i**2*e**(-this._beta-1)*this._alpha),s.broadcastOperate(t,(i,e)=>i*e),s}toObject(){return{type:"lrn",alpha:this._alpha,beta:this._beta,k:this._k,n:this._n,channel_dim:this._channel_dim}}}jt.registLayer("lrn");class qt extends p{static{d(this,"LSTMLayer")}constructor({size:t,return_sequences:s=!1,w_z:i=null,w_in:e=null,w_for:h=null,w_out:_=null,r_z:r=null,r_in:a=null,r_for:o=null,r_out:n=null,p_in:c=null,p_for:f=null,p_out:b=null,b_z:y=null,b_in:w=null,b_for:L=null,b_out:k=null,sequence_dim:v=1,...I}){if(super(I),this._size=t,this._unit=new Rs({layer:this,size:t,w_z:i,w_in:e,w_for:h,w_out:_,r_z:r,r_in:a,r_for:o,r_out:n,p_in:c,p_for:f,p_out:b,b_z:y,b_in:w,b_for:L,b_out:k}),this._return_sequences=s,this._sequence_dim=v,this._sequence_dim!==0&&this._sequence_dim!==1)throw new g("Invalid sequence dimension.")}get dependentLayers(){return this._unit.dependentLayers}calc(t){this._sequence_dim===1&&(t=t.transpose(1,0,2)),this._x=[];for(let s=0;s<t.sizes[0];s++)this._x[s]=t.index(s).toMatrix();this._y=[];for(let s=0;s<this._x.length;s++)this._y[s]=this._unit.calc(this._x[s],s);if(this._return_sequences){const s=m.fromArray(this._y.map(i=>i.toArray()));return this._sequence_dim===1?s.transpose(1,0,2):s}return this._y[this._y.length-1]}grad(t){return this._grad_bptt(t)}_grad_bptt(t){const s=this._y.length;if(this._bo=Array(s),this._return_sequences){this._sequence_dim===1&&(t=t.transpose(1,0,2));for(let _=0;_<s;_++)this._bo[_]=t.index(_).toMatrix()}else this._bo[s-1]=t;const i=[];let e=null;for(let _=s-1;_>=0;_--){const r=this._unit.grad(this._bo[_],_);_===0&&Array.isArray(r)?(i[_]=r[0],e=r[1]):i[_]=r}let h=m.fromArray(i.map(_=>_.toArray()));return this._sequence_dim===1&&(h=h.transpose(1,0,2)),e?[h,e]:h}update(t){this._unit.update(t)}toObject(){return{type:"lstm",size:this._size,return_sequences:this._return_sequences,sequence_dim:this._sequence_dim,...this._unit.toObject()}}}class Rs extends p{static{d(this,"LSTMUnitLayer")}constructor({layer:t,size:s,w_z:i=null,w_in:e=null,w_for:h=null,w_out:_=null,r_z:r=null,r_in:a=null,r_for:o=null,r_out:n=null,p_in:c=null,p_for:f=null,p_out:b=null,b_z:y=null,b_in:w=null,b_for:L=null,b_out:k=null,...v}){super(v),this._size=s,this._w_z=new z(t,i),this._w_in=new z(t,e),this._w_for=new z(t,h),this._w_out=new z(t,_),this._r_z=new z(t,r,[this._size,this._size]),this._r_in=new z(t,a,[this._size,this._size]),this._r_for=new z(t,o,[this._size,this._size]),this._r_out=new z(t,n,[this._size,this._size]),this._p_in=new z(t,c,[1,this._size]),this._p_for=new z(t,f,[1,this._size]),this._p_out=new z(t,b,[1,this._size]),this._b_z=new z(t,y,[1,this._size]),this._b_in=new z(t,w,[1,this._size]),this._b_for=new z(t,L,[1,this._size]),this._b_out=new z(t,k,[1,this._size]),this._c0=u.zeros(1,this._size),this._y0=u.zeros(1,this._size),this._x=[],this._c=[],this._y=[],this._ob=[],this._o=[],this._fb=[],this._f=[],this._ib=[],this._i=[],this._zb=[],this._z=[],this._bo=[],this._dy=[],this._do=[],this._dc=[],this._df=[],this._di=[],this._dz=[]}get dependentLayers(){const t=[];return this._w_z.name&&t.push(this._w_z.name),this._w_in.name&&t.push(this._w_in.name),this._w_for.name&&t.push(this._w_for.name),this._w_out.name&&t.push(this._w_out.name),this._r_z.name&&t.push(this._r_z.name),this._r_in.name&&t.push(this._r_in.name),this._r_for.name&&t.push(this._r_for.name),this._r_out.name&&t.push(this._r_out.name),this._p_in.name&&t.push(this._p_in.name),this._p_for.name&&t.push(this._p_for.name),this._p_out.name&&t.push(this._p_out.name),this._b_z.name&&t.push(this._b_z.name),this._b_in.name&&t.push(this._b_in.name),this._b_for.name&&t.push(this._b_for.name),this._b_out.name&&t.push(this._b_out.name),t}_sigmoid(t){return u.map(t,s=>1/(1+Math.exp(-s)))}_grad_sigmoid(t,s){return u.map(s,i=>i*(1-i))}_tanh(t){return u.map(t,Math.tanh)}_grad_tanh(t){return u.map(t,s=>1/Math.cosh(s)**2)}calc(t,s){s===0&&(this._y=[]),this._x[s]=t;const i=s===0?this._y0:this._y[s-1],e=s===0?this._c0:this._c[s-1],h=this._x[s].dot(this._w_z.get(t.cols,this._size));h.add(i.dot(this._r_z.get())),h.add(this._b_z.get()),this._zb[s]=h;const _=this._tanh(h);this._z[s]=_;const r=this._x[s].dot(this._w_in.get(t.cols,this._size));r.add(i.dot(this._r_in.get())),r.add(u.mult(this._p_in.get(),e)),r.add(this._b_in.get()),this._ib[s]=r;const a=this._sigmoid(r);this._i[s]=a;const o=this._x[s].dot(this._w_for.get(t.cols,this._size));o.add(i.dot(this._r_for.get())),o.add(u.mult(this._p_for.get(),e)),o.add(this._b_for.get()),this._fb[s]=o;const n=this._sigmoid(o);this._f[s]=n,this._c[s]=u.mult(a,_),this._c[s].add(u.mult(n,e));const c=this._x[s].dot(this._w_out.get(t.cols,this._size));c.add(i.dot(this._r_out.get())),c.add(u.mult(this._p_out.get(),this._c[s])),c.add(this._b_out.get()),this._ob[s]=c;const f=this._sigmoid(c);return this._o[s]=f,this._y[s]=this._tanh(this._c[s]),this._y[s].mult(f),this._y[s]}grad(t,s){return this._grad_bptt(t,s)}_grad_bptt(t,s){const i=this._y.length;this._bo[s]=t,this._dy[s]=this._bo[s]||u.zeros(1,1),s<i-1&&(this._dy[s].add(this._dz[s+1].dot(this._r_z.value.t)),this._dy[s].add(this._di[s+1].dot(this._r_in.value.t)),this._dy[s].add(this._df[s+1].dot(this._r_for.value.t)),this._dy[s].add(this._do[s+1].dot(this._r_out.value.t))),this._do[s]=this._dy[s].copy(),this._do[s].mult(this._tanh(this._c[s])),this._do[s].mult(this._grad_sigmoid(this._ob[s],this._o[s])),this._dc[s]=this._dy[s].copy(),this._dc[s].mult(this._o[s]),this._dc[s].mult(this._grad_tanh(this._c[s])),this._dc[s].add(u.mult(this._p_out.value,this._do[s])),s<i-1&&(this._dc[s].add(u.mult(this._p_in.value,this._di[s+1])),this._dc[s].add(u.mult(this._p_for.value,this._df[s+1])),this._dc[s].add(u.mult(this._dc[s+1],this._f[s+1]))),this._df[s]=this._dc[s].copy(),this._df[s].mult(s===0?this._c0:this._c[s-1]),this._df[s].mult(this._grad_sigmoid(this._fb[s],this._f[s])),this._di[s]=this._dc[s].copy(),this._di[s].mult(this._z[s]),this._di[s].mult(this._grad_sigmoid(this._ib[s],this._i[s])),this._dz[s]=this._dc[s].copy(),this._dz[s].mult(this._i[s]),this._dz[s].mult(this._grad_tanh(this._zb[s]));const e=this._dz[s].dot(this._w_z.value.t);if(e.add(this._di[s].dot(this._w_in.value.t)),e.add(this._df[s].dot(this._w_for.value.t)),e.add(this._do[s].dot(this._w_out.value.t)),s===0){this._diff_bptt();const h={};if(this._w_z.name&&(h[this._w_z.name]=this._dw_z),this._w_in.name&&(h[this._w_in.name]=this._dw_in),this._w_for.name&&(h[this._w_for.name]=this._dw_for),this._w_out.name&&(h[this._w_out.name]=this._dw_out),this._r_z.name&&(h[this._r_z.name]=this._dr_z),this._r_in.name&&(h[this._r_in.name]=this._dr_in),this._r_for.name&&(h[this._r_for.name]=this._dr_for),this._r_out.name&&(h[this._r_out.name]=this._dr_out),this._p_in.name&&(h[this._p_in.name]=this._dp_in),this._p_for.name&&(h[this._p_for.name]=this._dp_for),this._p_out.name&&(h[this._p_out.name]=this._dp_out),this._b_z.name&&(h[this._b_z.name]=this._db_z),this._b_in.name&&(h[this._b_in.name]=this._db_in),this._b_for.name&&(h[this._b_for.name]=this._db_for),this._b_out.name&&(h[this._b_out.name]=this._db_out),Object.keys(h).length>0)return[e,h]}return e}_diff_bptt(){const t=this._y.length,s=this._x[0].rows;this._dw_z=u.zeros(...this._w_z.sizes),this._dw_in=u.zeros(...this._w_in.sizes),this._dw_out=u.zeros(...this._w_out.sizes),this._dw_for=u.zeros(...this._w_for.sizes),this._db_z=u.zeros(1,this._size),this._db_in=u.zeros(1,this._size),this._db_out=u.zeros(1,this._size),this._db_for=u.zeros(1,this._size),this._dp_out=u.zeros(1,this._size);for(let i=0;i<t;i++){const e=this._x[i].tDot(this._dz[i]);e.div(s),this._dw_z.add(e);const h=this._x[i].tDot(this._di[i]);h.div(s),this._dw_in.add(h);const _=this._x[i].tDot(this._do[i]);_.div(s),this._dw_out.add(_);const r=this._x[i].tDot(this._df[i]);r.div(s),this._dw_for.add(r),this._db_z.add(this._dz[i].mean(0)),this._db_in.add(this._di[i].mean(0)),this._db_out.add(this._do[i].mean(0)),this._db_for.add(this._df[i].mean(0));const a=u.mult(this._dc[i],this._do[i]);this._dp_out.add(a.mean(0))}this._dr_z=u.zeros(this._size,this._size),this._dr_in=u.zeros(this._size,this._size),this._dr_out=u.zeros(this._size,this._size),this._dr_for=u.zeros(this._size,this._size),this._dp_in=u.zeros(1,this._size),this._dp_for=u.zeros(1,this._size);for(let i=0;i<t-1;i++){const e=this._y[i].tDot(this._dz[i+1]);e.div(s),this._dr_z.add(e);const h=this._y[i].tDot(this._di[i+1]);h.div(s),this._dr_in.add(h);const _=this._y[i].tDot(this._do[i+1]);_.div(s),this._dr_out.add(_);const r=this._y[i].tDot(this._df[i+1]);r.div(s),this._dr_for.add(r);const a=u.mult(this._dc[i],this._di[i+1]);this._dp_in.add(a.mean(0));const o=u.mult(this._dc[i],this._df[i+1]);this._dp_for.add(o.mean(0))}}update(t){this._w_z.name||this._w_z.value.sub(t.delta("w_z",this._dw_z)),this._w_in.name||this._w_in.value.sub(t.delta("w_i",this._dw_in)),this._w_out.name||this._w_out.value.sub(t.delta("w_o",this._dw_out)),this._w_for.name||this._w_for.value.sub(t.delta("w_f",this._dw_for)),this._r_z.name||this._r_z.value.sub(t.delta("r_z",this._dr_z)),this._r_in.name||this._r_in.value.sub(t.delta("r_i",this._dr_in)),this._r_out.name||this._r_out.value.sub(t.delta("r_o",this._dr_out)),this._r_for.name||this._r_for.value.sub(t.delta("r_f",this._dr_for)),this._p_out.name||this._p_out.value.sub(t.delta("p_o",this._dp_out)),this._p_in.name||this._p_in.value.sub(t.delta("p_i",this._dp_in)),this._p_for.name||this._p_for.value.sub(t.delta("p_f",this._dp_for)),this._b_z.name||this._b_z.value.sub(t.delta("b_z",this._db_z)),this._b_in.name||this._b_in.value.sub(t.delta("b_i",this._db_in)),this._b_out.name||this._b_out.value.sub(t.delta("b_o",this._db_out)),this._b_for.name||this._b_for.value.sub(t.delta("b_f",this._db_for))}toObject(){return{w_z:this._w_z?.toObject(),w_in:this._w_in?.toObject(),w_for:this._w_for?.toObject(),w_out:this._w_out?.toObject(),r_z:this._r_z?.toObject(),r_in:this._r_in?.toObject(),r_for:this._r_for?.toObject(),r_out:this._r_out?.toObject(),p_in:this._p_in?.toObject(),p_for:this._p_for?.toObject(),p_out:this._p_out?.toObject(),b_z:this._b_z?.toObject(),b_in:this._b_in?.toObject(),b_for:this._b_for?.toObject(),b_out:this._b_out?.toObject()}}}let z=class{static{d(this,"Variable")}constructor(t,s,i){this._layer=t,this._sizes=i,typeof s=="string"?this._name=s:s&&(this._value=u.fromArray(s))}get name(){return this._name}get value(){return this._value}get sizes(){return this._value.sizes}get(...t){return t.length===0&&(t=this._sizes),this._name?this._value=this._layer.graph.getNode(this._name).outputValue:this._value?this._value:this._value=u.randn(...t)}toObject(){return this._name?this._name:this._value?.toArray()}};qt.registLayer("lstm");class St extends p{static{d(this,"MatmulLayer")}calc(...t){this._i=t;let s=t[0];for(let i=1;i<t.length;i++)s=s.dot(t[i]);return s}grad(t){const s=[];for(let i=0;i<this._i.length;i++){let e=null;if(i===0)e=t;else{e=this._i[0];for(let h=1;h<i;h++)e=e.dot(this._i[h]);e=e.tDot(t)}for(let h=this._i.length-1;h>i;h--)e=e.dot(this._i[h].t);s.push(e)}return s}}St.registLayer();class It extends p{static{d(this,"MaxPoolLayer")}constructor({kernel:t,stride:s=null,padding:i=null,channel_dim:e=-1,...h}){if(super(h),this._kernel=t,this._stride=s||t,this._padding=i||0,this._channel_dim=e,this._channel_dim!==-1&&this._channel_dim!==1)throw new g("Invalid channel dimension.")}_index(t,s,i){return this._channel_dim===-1?[t,...i,s]:[t,s,...i]}calc(t){if(Array.isArray(this._kernel)||(this._kernel=Array(t.dimension-2).fill(this._kernel)),t.dimension!==this._kernel.length+2)throw new g("Invalid kernel size",[this,t]);if(Array.isArray(this._stride)||(this._stride=Array(t.dimension-2).fill(this._stride)),t.dimension!==this._stride.length+2)throw new g("Invalid stride size",[this,t]);if(Array.isArray(this._padding)?Array.isArray(this._padding[0])||(this._padding=this._padding.map(h=>[h,h])):this._padding=Array.from({length:t.dimension-2},()=>[this._padding,this._padding]),t.dimension!==this._padding.length+2)throw new g("Invalid padding size",[this,t]);this._i=t;const s=this._channel_dim===-1?1:2,i=[t.sizes[0],...this._kernel.map((h,_)=>Math.ceil(Math.max(0,t.sizes[_+s]+this._padding[_][0]+this._padding[_][1]-h)/this._stride[_])+1)];this._channel_dim===-1?i.push(t.sizes[t.dimension-1]):this._channel_dim===1&&i.splice(1,0,t.sizes[1]);const e=this._channel_dim===-1?t.sizes[t.dimension-1]:t.sizes[1];this._o=new m(i);for(let h=0;h<t.sizes[0];h++)for(let _=0;_<e;_++){const r=Array(t.dimension-2).fill(0);do{const a=Array(t.dimension-2).fill(0);let o=-1/0;do{const n=r.map((c,f)=>c*this._stride[f]-this._padding[f][0]+a[f]);if(n.every((c,f)=>0<=c&&c<t.sizes[f+s])){const c=t.at(this._index(h,_,n));o<c&&(o=c)}for(let c=0;c<a.length&&(a[c]++,!(a[c]<this._kernel[c]));c++)a[c]=0}while(a.some(n=>n>0));this._o.set(this._index(h,_,r),o);for(let n=0;n<r.length&&(r[n]++,!(r[n]<i[n+s]));n++)r[n]=0}while(r.some(a=>a>0))}return this._o}grad(t){this._bo=t,this._bi=new m(this._i.sizes);const s=this._channel_dim===-1?1:2,i=this._channel_dim===-1?this._i.sizes[this._i.dimension-1]:this._i.sizes[1];for(let e=0;e<this._i.sizes[0];e++)for(let h=0;h<i;h++){const _=Array(this._i.dimension-2).fill(0);do{const r=Array(this._i.dimension-2).fill(0);let a=-1/0,o=null;do{const n=_.map((c,f)=>c*this._stride[f]-this._padding[f][0]+r[f]);if(n.every((c,f)=>0<=c&&c<this._i.sizes[f+s])){const c=this._i.at(this._index(e,h,n));a<c&&(a=c,o=n)}for(let c=0;c<r.length&&(r[c]++,!(r[c]<this._kernel[c]));c++)r[c]=0}while(r.some(n=>n>0));this._bi.operateAt(this._index(e,h,o),n=>n+this._bo.at(this._index(e,h,_)));for(let n=0;n<_.length&&(_[n]++,!(_[n]<this._o.sizes[n+s]));n++)_[n]=0}while(_.some(r=>r>0))}return this._bi}toObject(){return{type:"max_pool",kernel:this._kernel,stride:this._stride,padding:this._padding,channel_dim:this._channel_dim}}}It.registLayer();class Nt extends p{static{d(this,"MeanLayer")}constructor({axis:t=-1,keepdims:s=!0,...i}){super(i),this._axis=null,typeof t=="string"?this._axisname=t:this._axis=typeof t=="number"?[t]:t,this._keepdims=s}get dependentLayers(){const t=[];return this._axisname&&t.push(this._axisname),t}calc(t){if(this._axisname&&(this._axis=this.graph.getNode(this._axisname).outputValue.toArray()),this._axis.includes(-1))this._size=Array(t.dimension).fill(1);else{this._size=t.sizes.concat();for(let e=0;e<this._axis.length;e++)this._size[this._axis[e]]=1}if(this._i=t,!this._keepdims&&this._axis.includes(-1))return new m([],t.reduce((e,h)=>e+h,0)/t.length);!this._keepdims&&t instanceof u&&(t=m.fromArray(t));const s=this._axis.includes(-1)?t.length:this._axis.reduce((e,h)=>e*t.sizes[h],1),i=t.reduce((e,h)=>e+h,0,this._axis,this._keepdims);return i.map(e=>e/s),i}grad(t){t.reshape(...this._size);const s=this._axis.includes(-1)?this._i.length:this._axis.reduce((e,h)=>e*this._i.sizes[h],1),i=this._i.copy();return i.broadcastOperate(t,(e,h)=>h/s),i}toObject(){return{type:"mean",axis:this._axisname||this._axis,keepdims:this._keepdims}}}Nt.registLayer();class Vt extends p{static{d(this,"MultipleParametricELULayer")}constructor({alpha:t=1,beta:s=1,...i}){super(i),this._alpha=t,this._beta=s}calc(t){this._i=t;const s=t.copy();return s.map(i=>i>0?i:this._alpha*(Math.exp(this._beta*i)-1)),s}grad(t){this._bo=t;const s=t.copy();return s.broadcastOperate(this._i,(i,e)=>i*(e>0?1:this._alpha*this._beta*Math.exp(this._beta*e))),s}update(t){let s=0,i=0;for(let e=0;e<this._i.length;e++)this._i.value[e]>0||(s+=this._bo.value[e]*(Math.exp(this._beta*this._i.value[e])-1),i+=this._bo.value[e]*(this._alpha*this._i.value[e]*Math.exp(this._beta*this._i.value[e])));this._alpha-=t.delta("alpha",s/this._i.length),this._beta-=t.delta("beta",i/this._i.length)}toObject(){return{type:"mpelu",alpha:this._alpha,beta:this._beta}}}Vt.registLayer("mpelu");class Ut extends p{static{d(this,"MSELayer")}bind({supervisor:t}){Array.isArray(t)?(this._t=m.fromArray(t),this._t.dimension===2&&(this._t=this._t.toMatrix())):(t instanceof u||t instanceof m)&&(this._t=t)}calc(t){this._i=t;const s=t.copy();return s.broadcastOperate(this._t,(i,e)=>(i-e)**2),new u(1,1,s.reduce((i,e)=>i+e,0)/s.length)}grad(t){t=t.toScaler();const s=this._i.copy();return s.broadcastOperate(this._t,(i,e)=>t*(i-e)/2),s}}Ut.registLayer("mse");class Dt extends p{static{d(this,"MultibinTrainableLinearUnitLayer")}constructor({a:t=1,b:s=0,c:i=null,k:e=10,...h}){super(h),this._k=e,this._a=Array.isArray(t)?t:Array(e+1).fill(t),this._b=Array.isArray(s)?s:Array(e+1).fill(s),this._c=i==null||Array.isArray(i)?i:Array(e).fill(i)}calc(t){if(!this._c){this._c=Array(this._k);const i=t.reduce((_,r)=>Math.max(_,r),-1/0),e=t.reduce((_,r)=>Math.min(_,r),1/0),h=(i-e)/(this._k+1);for(let _=0;_<this._k;_++)this._c[_]=e+h*(_+1)}this._i=t;const s=t.copy();return s.map(i=>{if(i<=this._c[0])return this._a[0]*i+this._b[0];for(let e=1;e<this._k;e++)if(i<=this._c[e])return this._a[e]*i+this._b[e];return this._a[this._k]*i+this._b[this._k]}),s}grad(t){this._bo=t;const s=t.copy();return s.broadcastOperate(this._i,(i,e)=>{if(e<=this._c[0])return i*this._a[0];for(let h=1;h<this._k;h++)if(e<=this._c[h])return i*this._a[h];return i*this._a[this._k]}),s}update(t){const s=Array(this._k+1).fill(0),i=Array(this._k+1).fill(0);for(let e=0;e<this._i.length;e++)if(this._i.value[e]<=this._c[0])s[0]+=this._bo.value[e]*this._i.value[e],i[0]+=this._bo.value[e];else if(this._i.value[e]>this._c[this._k-1])s[this._k]+=this._bo.value[e]*this._i.value[e],i[this._k]+=this._bo.value[e];else for(let h=1;h<this._k;h++)if(this._i.value[e]<=this._c[h]){s[h]+=this._bo.value[e]*this._i.value[e],i[h]+=this._bo.value[e];break}for(let e=0;e<=this._k;e++)this._a[e]-=t.delta(`a${e}`,s[e]/this._i.length),this._b[e]-=t.delta(`b${e}`,i[e]/this._i.length)}toObject(){return{type:"mtlu",a:this._a,b:this._b,c:this._c,k:this._k}}}Dt.registLayer("mtlu");class Rt extends p{static{d(this,"NaturalLogarithmReLULayer")}constructor({beta:t=1,...s}){super(s),this._beta=t}calc(t){this._i=t;const s=t.copy();return s.map(i=>Math.log(this._beta*(i>0?i:0)+1)),s}grad(t){const s=t.copy();return s.broadcastOperate(this._i,(i,e)=>e>=0?i*(this._beta/(this._beta*e+1)):0),s}toObject(){return{type:"nlrelu",beta:this._beta}}}Rt.registLayer("nlrelu");class Et extends p{static{d(this,"OnehotLayer")}constructor({class_size:t=null,values:s=[],...i}){super(i),this._c=t,this._values=s}calc(t){if(t.cols!==1)throw new g("Invalid input.",[this,t]);const s=[...new Set(t.value)];this._c||(this._c=s.length),this._i=t;for(let e=0;e<s.length&&this._values.length<this._c;e++)this._values.includes(s[e])||this._values.push(s[e]);const i=u.zeros(t.rows,this._c);for(let e=0;e<t.rows;e++)i.set(e,this._values.indexOf(t.at(e,0)),1);return i}grad(){const t=this._i.copy();return t.fill(0),t}toObject(){return{type:"onehot",class_size:this._c,values:this._values}}}Et.registLayer();class Pt extends p{static{d(this,"OutputLayer")}calc(t){return t}grad(t){return t}}Pt.registLayer();class Tt extends p{static{d(this,"PadeActivationUnitLayer")}constructor({m:t=2,n:s=2,a:i=.1,b:e=0,...h}){super(h),this._m=t,this._n=s,this._a=Array.isArray(i)?i:Array(t+1).fill(i),this._b=Array.isArray(e)?e:Array(s).fill(e),this._l2_decay=.001}calc(t){this._i=t;const s=t.copy();return s.map(i=>this._a.reduce((e,h,_)=>e+h*i**_,0)/(1+Math.abs(this._b.reduce((e,h,_)=>e+h*i**(_+1),0)))),s}grad(t){this._bo=t;const s=t.copy();return s.broadcastOperate(this._i,(i,e)=>{const h=this._a.reduce((a,o,n)=>a+o*e**n,0),_=this._b.reduce((a,o,n)=>a+o*e**(n+1),0),r=1+Math.abs(_);return i*(this._a.reduce((a,o,n)=>a+o*n*e**(n-1),0)/r-Math.sign(_)*this._b.reduce((a,o,n)=>a+o*(n+1)*e**n,0)*(h/r**2))}),s}update(t){const s=Array(this._m+1).fill(0),i=Array(this._n).fill(0);for(let e=0;e<this._i.length;e++){const h=this._a.reduce((a,o,n)=>a+o*this._i.value[e]**n,0),_=this._b.reduce((a,o,n)=>a+o*this._i.value[e]**(n+1),0),r=1+Math.abs(_);for(let a=0;a<this._m;a++)s[a]+=this._bo.value[e]*this._i.value[e]**a;for(let a=0;a<this._n;a++)i[a]+=this._bo.value[e]*(-(this._i.value[e]**(a+1))*Math.sign(_)*(h/r**2))}for(let e=0;e<this._m+1;e++)this._a[e]-=t.delta(`a${e}`,s[e]/this._i.length);for(let e=0;e<this._n;e++)this._b[e]-=t.delta(`b${e+1}`,i[e]/this._i.length)}toObject(){return{type:"pau",m:this._m,n:this._n,a:this._a,b:this._b}}}Tt.registLayer("pau");class Ft extends p{static{d(this,"ParametricDeformableELULayer")}constructor({t=.1,alpha:s=1,...i}){super(i),this._t=t,this._alpha=s}calc(t){this._i=t;const s=t.copy();return s.map(i=>i>0?i:this._alpha*((1+(1-this._t)*i)**(1/(1-this._t))-1)),s}grad(t){this._bo=t;const s=t.copy();return s.broadcastOperate(this._i,(i,e)=>i*(e>0?1:this._alpha*(1+(1-this._t)*e)**(this._t/(1-this._t)))),s}update(t){let s=0;for(let i=0;i<this._i.length;i++)this._i.value[i]>0||(s+=this._bo.value[i]*((1+(1-this._t)*this._i.value[i])**(1/(1-this._t))-1));this._alpha-=t.delta("alpha",s/this._i.length)}toObject(){return{type:"pdelu",t:this._t,alpha:this._alpha}}}Ft.registLayer("pdelu");class Gt extends p{static{d(this,"ParametricELULayer")}constructor({a:t=1,b:s=1,...i}){super(i),this._a=t,this._b=s}calc(t){this._i=t;const s=t.copy();return s.map(i=>this._a*(i>=0?i/this._b:Math.exp(i/this._b)-1)),s}grad(t){this._bo=t;const s=t.copy();return s.broadcastOperate(this._i,(i,e)=>i*this._a/this._b*(e>=0?1:Math.exp(e/this._b))),s}update(t){let s=0,i=0;for(let e=0;e<this._i.length;e++)this._i.value[e]>=0?(s+=this._bo.value[e]*(this._i.value[e]/this._b),i+=this._bo.value[e]*(-this._a*this._i.value[e]/this._b**2)):(s+=this._bo.value[e]*(Math.exp(this._i.value[e]/this._b)-1),i+=this._bo.value[e]*(this._a*Math.exp(this._i.value[e]/this._b)*(-this._i.value[e]/this._b**2)));this._a-=t.delta("a",s/this._i.length),this._a<.1&&(this._a=.1),this._b-=t.delta("b",i/this._i.length),this._b<.1&&(this._b=.1)}toObject(){return{type:"pelu",a:this._a,b:this._b}}}Gt.registLayer("pelu");class $t extends p{static{d(this,"PiecewiseLinearUnitLayer")}constructor({alpha:t=.1,c:s=1,...i}){super(i),this._alpha=t,this._c=s}calc(t){this._i=t;const s=t.copy();return s.map(i=>Math.max(this._alpha*(i+this._c)-this._c,Math.min(this._alpha*(i-this._c)+this._c,i))),s}grad(t){const s=t.copy();return s.broadcastOperate(this._i,(i,e)=>i*(e<this._alpha*(e+this._c)-this._c||this._alpha*(e-this._c)+this._c<e?this._alpha:1)),s}toObject(){return{type:"plu",alpha:this._alpha,c:this._c}}}$t.registLayer("plu");class Ct extends p{static{d(this,"ParametricReLULayer")}constructor({a:t=.25,...s}){super(s),this._a=null,this._da=0,typeof t=="string"?this._aname=t:Array.isArray(t)?(this._a=m.fromArray(t),this._da=this._a.copy(),this._da.fill(0)):this._a=t}get dependentLayers(){const t=[];return this._aname&&t.push(this._aname),t}calc(t){return this._i=t,this._o=t.copy(),this._aname&&(this._a=this.graph.getNode(this._aname).outputValue),this._o.broadcastOperate(this._a,(s,i)=>s>0?s:i*s),this._o}grad(t){const s=this._i.copy();if(s.broadcastOperate(this._a,(i,e)=>i>0?1:e),s.broadcastOperate(t,(i,e)=>i*e),typeof this._a=="number"){this._da0=0;for(let i=0;i<this._i.length;i++)this._i.value[i]<0&&(this._da0+=t.value[i]*this._i.value[i])}else{this._da0=this._a.copy(),this._da0.fill(0);const i=this._i.dimension-this._a.dimension,e=Array(this._i.dimension).fill(0);do{const h=this._i.at(e);h>0&&this._da0.operateAt(e.slice(i),_=>_+h*t.at(e));for(let _=0;_<e.length&&(e[_]++,!(e[_]<this._i.sizes[_]));_++)e[_]=0}while(e.some(h=>h>0))}return this._aname?[s,{[this._aname]:this._da0}]:s}update(t){this._aname||(typeof this._a=="number"?(this._da=.1*this._da+t.lr*this._da0/this._i.length,this._a-=this._da):(this._da.broadcastOperate(this._da0,(i,e)=>.1*i+t.lr*e/this._i.length),this._a.broadcastOperate(this._da,(i,e)=>i-e)))}toObject(){return{type:"prelu",a:this._aname||this._a}}}Ct.registLayer("prelu");class Ht extends p{static{d(this,"ParametricRectifiedExponentialUnitLayer")}constructor({alpha:t=1,beta:s=1,...i}){super(i),this._alpha=t,this._beta=s}calc(t){this._i=t;const s=t.copy();return s.map(i=>this._alpha*i*(i>0?1:Math.exp(this._beta*i))),s}grad(t){this._bo=t;const s=t.copy();return s.broadcastOperate(this._i,(i,e)=>i*this._alpha*(e>0?1:(1+e*this._beta)*Math.exp(this._beta*e))),s}update(t){let s=0,i=0;for(let e=0;e<this._i.length;e++)this._i.value[e]>0?s+=this._bo.value[e]*this._i.value[e]:(s+=this._bo.value[e]*(this._i.value[e]*Math.exp(this._beta*this._i.value[e])),i+=this._bo.value[e]*(this._alpha*this._i.value[e]**2*Math.exp(this._beta*this._i.value[e])));this._alpha-=t.delta("alpha",s/this._i.length),this._beta-=t.delta("beta",i/this._i.length)}toObject(){return{type:"preu",alpha:this._alpha,beta:this._beta}}}Ht.registLayer("preu");class Bt extends p{static{d(this,"ProdLayer")}constructor({axis:t=-1,keepdims:s=!0,...i}){super(i),this._axis=typeof t=="number"?[t]:t,this._keepdims=s}get dependentLayers(){const t=[];return typeof this._axis=="string"&&t.push(this._axis),t}calc(t){const s=typeof this._axis=="string"?this.graph.getNode(this._axis).outputValue.toArray():this._axis;if(s.includes(-1))this._size=Array(t.dimension).fill(1);else{this._size=t.sizes.concat();for(let i=0;i<s.length;i++)this._size[s[i]]=1}if(this._i=t,!this._keepdims&&s.includes(-1))return this._o=t.reduce((i,e)=>i*e,1),new m([],this._o);if(!this._keepdims&&t instanceof u&&(t=m.fromArray(t)),this._o=t.reduce((i,e)=>i*e,1,s,!0),!this._keepdims){const i=this._o.copy();return i.reshape(...i.sizes.filter((e,h)=>!s.includes(h))),i}return this._o}grad(t){t.reshape(...this._size);const s=this._i.copy();return s.broadcastOperate(this._o,(i,e)=>e/i),s.broadcastOperate(t,(i,e)=>i*e),s}toObject(){return{type:"prod",axis:this._axis,keepdims:this._keepdims}}}Bt.registLayer();class Qt extends p{static{d(this,"ParametricSigmoidFunctionLayer")}constructor({m:t=2,...s}){super(s),this._m=t}calc(t){this._s=t.copy(),this._s.map(i=>1/(1+Math.exp(-i)));const s=this._s.copy();return s.map(i=>i**this._m),s}grad(t){const s=t.copy();return s.broadcastOperate(this._s,(i,e)=>i*(this._m*e**this._m*(1-e))),s}toObject(){return{type:"psf",m:this._m}}}Qt.registLayer("psf");class Jt extends p{static{d(this,"PenalizedTanhLayer")}constructor({a:t=.25,...s}){super(s),this._a=t}calc(t){return this._o=t.copy(),this._o.map(s=>Math.tanh(s)*(s<0?this._a:1)),this._o}grad(t){const s=t.copy();return s.broadcastOperate(this._o,(i,e)=>i*(1-e**2)*(e<0?this._a:1)),s}toObject(){return{type:"ptanh",a:this._a}}}Jt.registLayer("ptanh");class Kt extends p{static{d(this,"ParametricTanhLinearUnitLayer")}constructor({alpha:t=1,beta:s=1,...i}){super(i),this._alpha=t,this._beta=s}calc(t){this._i=t;const s=t.copy();return s.map(i=>i>0?i:this._alpha*Math.tanh(this._beta*i)),s}grad(t){this._bo=t;const s=t.copy();return s.broadcastOperate(this._i,(i,e)=>i*(e>0?1:this._alpha*this._beta*(1-Math.tanh(this._beta*e)**2))),s}update(t){let s=0,i=0;for(let e=0;e<this._i.length;e++){if(this._i.value[e]>0)continue;const h=Math.tanh(this._beta*this._i.value[e]);s+=this._bo.value[e]*h,i+=this._bo.value[e]*this._alpha*(1-h**2)}this._alpha-=t.delta("alpha",s/this._i.length),this._alpha<0&&(this._alpha=0),this._beta-=t.delta("beta",i/this._i.length),this._beta<0&&(this._beta=0)}toObject(){return{type:"ptelu",alpha:this._alpha,beta:this._beta}}}Kt.registLayer("ptelu");class Wt extends p{static{d(this,"RandomLayer")}constructor({size:t,mean:s=0,variance:i=1,...e}){super(e),this._size=t,this._mean=s,this._variance=i,this._rows=1}get dependentLayers(){const t=[];return typeof this._size=="string"&&t.push(this._size),t}bind({n:t}){this._rows=t}calc(){if(typeof this._size=="string"){const t=this.graph.getNode(this._size).lastOutputSize;return t.length===2?u.randn(t[0],t[1],this._mean,this._variance):m.randn(t,this._mean,this._variance)}return Array.isArray(this._size)?m.randn([this._rows,...this._size],this._mean,this._variance):u.randn(this._rows,this._size,this._mean,this._variance)}grad(){}toObject(){return{type:"random",size:this._size}}}Wt.registLayer();class Xt extends p{static{d(this,"ReadoutLayer")}constructor({method:t="mean",...s}){super(s),this._method=t}calc(t){this._i=t;const s=t.value[0].nodes[0].sizes.concat();for(;s[0]===1;)s.splice(0,1);const i=[...t.sizes,...s];i.length===2?this._o=u.zeros(...i):this._o=m.zeros(i);const e=Array(t.dimension).fill(0);do{const h=t.at(e);let _=null;for(let a=0;a<h.order;a++)_?_.broadcastOperate(h.nodes[a],(o,n)=>o+n):_=h.nodes[a].copy();_=m.fromArray(_),_.reshape(...s),this._method==="mean"&&_.map(a=>a/h.order);const r=Array(s.length).fill(0);do{this._o.set([...e,...r],_.at(r));for(let a=0;a<r.length&&(r[a]++,!(r[a]<s[a]));a++)r[a]=0}while(r.some(a=>a>0));for(let a=0;a<e.length&&(e[a]++,!(e[a]<t.sizes[a]));a++)e[a]=0}while(e.some(h=>h>0));return this._o}grad(t){t=m.fromArray(t);const s=this._i.value[0].nodes[0].sizes;this._bi=this._i.copy();const i=Array(this._i.dimension).fill(0);do{const e=t.index(i),h=this._i.at(i).copy();for(let _=0;_<h.order;_++)h.nodes[_]=e.copy(),this._method==="mean"&&h.nodes[_].map(r=>r/h.order),h.nodes[_].reshape(...s),s.length===2&&(h.nodes[_]=h.nodes[_].toMatrix());this._bi.set(i,h);for(let _=0;_<i.length&&(i[_]++,!(i[_]<this._i.sizes[_]));_++)i[_]=0}while(i.some(e=>e>0));return this._bi}toObject(){return{type:"readout",method:this._method}}}Xt.registLayer();class Yt extends p{static{d(this,"ReduceMaxLayer")}constructor({axis:t=-1,keepdims:s=!0,...i}){super(i),this._axis=typeof t=="number"?[t]:t,this._keepdims=s}get dependentLayers(){const t=[];return typeof this._axis=="string"&&t.push(this._axis),t}calc(t){const s=typeof this._axis=="string"?this.graph.getNode(this._axis).outputValue.toArray():this._axis;if(s.includes(-1))this._size=Array(t.dimension).fill(1);else{this._size=t.sizes.concat();for(let i=0;i<s.length;i++)this._size[s[i]]=1}if(this._i=t,!this._keepdims&&s.includes(-1))return this._o=t.reduce((i,e)=>Math.max(i,e),-1/0),new m([],this._o);if(!this._keepdims&&t instanceof u&&(t=m.fromArray(t)),this._o=t.reduce((i,e)=>Math.max(i,e),-1/0,s,!0),!this._keepdims){const i=this._o.copy();return i.reshape(...i.sizes.filter((e,h)=>!s.includes(h))),i}return this._o}grad(t){t.reshape(...this._size);const s=this._i.copy();return s.broadcastOperate(this._o,(i,e)=>e===i?1:0),s.broadcastOperate(t,(i,e)=>i*e),s}toObject(){return{type:"reduce_max",axis:this._axis,keepdims:this._keepdims}}}Yt.registLayer();class Zt extends p{static{d(this,"ReduceMinLayer")}constructor({axis:t=-1,keepdims:s=!0,...i}){super(i),this._axis=typeof t=="number"?[t]:t,this._keepdims=s}get dependentLayers(){const t=[];return typeof this._axis=="string"&&t.push(this._axis),t}calc(t){const s=typeof this._axis=="string"?this.graph.getNode(this._axis).outputValue.toArray():this._axis;if(s.includes(-1))this._size=Array(t.dimension).fill(1);else{this._size=t.sizes.concat();for(let i=0;i<s.length;i++)this._size[s[i]]=1}if(this._i=t,!this._keepdims&&s.includes(-1))return this._o=t.reduce((i,e)=>Math.min(i,e),1/0),new m([],this._o);if(!this._keepdims&&t instanceof u&&(t=m.fromArray(t)),this._o=t.reduce((i,e)=>Math.min(i,e),1/0,s,!0),!this._keepdims){const i=this._o.copy();return i.reshape(...i.sizes.filter((e,h)=>!s.includes(h))),i}return this._o}grad(t){t.reshape(...this._size);const s=this._i.copy();return s.broadcastOperate(this._o,(i,e)=>e===i?1:0),s.broadcastOperate(t,(i,e)=>i*e),s}toObject(){return{type:"reduce_min",axis:this._axis,keepdims:this._keepdims}}}Zt.registLayer();class ts extends p{static{d(this,"RectifiedPowerUnitLayer")}constructor({s:t=2,...s}){super(s),this._s=t}calc(t){this._i=t;const s=t.copy();return s.map(i=>i>=0?i**this._s:0),s}grad(t){this._bo=t;const s=t.copy();return s.broadcastOperate(this._i,(i,e)=>i*(e>=0?this._s*e**(this._s-1):0)),s}toObject(){return{type:"repu",s:this._s}}}ts.registLayer("repu");class ss extends p{static{d(this,"ReshapeLayer")}constructor({size:t,...s}){super(s),this._size=t}get dependentLayers(){const t=[];return typeof this._size=="string"&&t.push(this._size),t}calc(t){if(this._in_size=t.sizes.concat(),typeof this._size=="string"){const i=this.graph.getNode(this._size).lastOutputSize;this._out_size=i}else this._out_size=this._size;(this._out_size.length===1||this._in_size.slice(1).reduce((i,e)=>i*e,1)===this._out_size.reduce((i,e)=>i*e,1))&&(this._out_size=[t.sizes[0],...this._out_size]);const s=this._out_size.length===2?t.copy():m.fromArray(t.copy());return s.reshape(...this._out_size),s instanceof m&&s.dimension===2?s.toMatrix():s}grad(t){let s=t.copy();return s instanceof u&&this._in_size.length>2&&(s=m.fromArray(s)),s.reshape(...this._in_size),s instanceof m&&this._in_size.length===2&&(s=s.toMatrix()),s}toObject(){return{type:"reshape",size:this._size}}}ss.registLayer();class is extends p{static{d(this,"ReverseLayer")}constructor({axis:t=1,...s}){super(s),this._axis=t}calc(t){const s=t.copy();return s.flip(this._axis),s}grad(t){const s=t.copy();return s.flip(this._axis),s}toObject(){return{type:"reverse",axis:this._axis}}}is.registLayer();class es extends p{static{d(this,"RNNLayer")}constructor({size:t,activation:s="tanh",return_sequences:i=!1,w_x:e=null,w_h:h=null,b_x:_=null,b_h:r=null,sequence_dim:a=1,...o}){if(super(o),this._size=t,this._unit=new Es({layer:this,size:t,activation:s,w_x:e,w_h:h,b_x:_,b_h:r}),this._return_sequences=i,this._sequence_dim=a,this._sequence_dim!==0&&this._sequence_dim!==1)throw new g("Invalid sequence dimension.")}get dependentLayers(){return this._unit.dependentLayers}calc(t){this._sequence_dim===1&&(t=t.transpose(1,0,2)),this._i=[];for(let s=0;s<t.sizes[0];s++)this._i[s]=t.index(s).toMatrix();this._o=[];for(let s=0;s<this._i.length;s++)this._o[s]=this._unit.calc(this._i[s],s);if(this._return_sequences){const s=m.fromArray(this._o.map(i=>i.toArray()));return this._sequence_dim===1?s.transpose(1,0,2):s}return this._o[this._o.length-1]}grad(t){return this._grad_bptt(t)}_grad_bptt(t){const s=this._o.length;if(this._bo=Array(s),this._return_sequences){this._sequence_dim===1&&(t=t.transpose(1,0,2));for(let _=0;_<s;_++)this._bo[_]=t.index(_).toMatrix()}else this._bo[s-1]=t;const i=[];let e=null;for(let _=s-1;_>=0;_--){const r=this._unit.grad(this._bo[_],_);_===0&&Array.isArray(r)?(i[_]=r[0],e=r[1]):i[_]=r}let h=m.fromArray(i.map(_=>_.toArray()));return this._sequence_dim===1&&(h=h.transpose(1,0,2)),e?[h,e]:h}update(t){this._unit.update(t)}toObject(){return{type:"rnn",size:this._size,return_sequences:this._return_sequences,sequence_dim:this._sequence_dim,...this._unit.toObject()}}}class Es extends p{static{d(this,"RNNUnitLayer")}constructor({layer:t,size:s,activation:i="sigmoid",w_x:e=null,w_h:h=null,b_x:_=null,b_h:r=null,...a}){super(a),this._size=s,this._w_x=new S(t,e),this._w_h=new S(t,h,[s,s]),this._b_x=new S(t,_,[1,s]),this._b_h=new S(t,r,[1,s]),this._z0=u.zeros(1,s),this._i=[],this._z=[],this._u=[],this._bo=[],this._bh=[],typeof i=="string"?this._activation=p.fromObject({type:i}):i&&(this._activation=p.fromObject(i))}get dependentLayers(){const t=[];return this._w_x.name&&t.push(this._w_x.name),this._w_h.name&&t.push(this._w_h.name),this._b_x.name&&t.push(this._b_x.name),this._b_h.name&&t.push(this._b_h.name),this._activation&&t.push(...this._activation.dependentLayers),t}calc(t,s){s===0&&(this._z=[]),this._i[s]=t,this._z[s]=t.dot(this._w_x.get(t.cols,this._size));const i=s===0?this._z0:this._z[s-1];return this._z[s].add(i.dot(this._w_h.get())),this._z[s].add(this._b_x.get()),this._z[s].add(this._b_h.get()),this._activation&&(this._u[s]=this._z[s],this._z[s]=this._activation.calc(this._z[s])),this._z[s]}grad(t,s){return this._grad_bptt(t,s)}_grad_bptt(t,s){const i=this._z.length;this._bo[s]=t,this._bh[s]=this._bo[s]||u.zeros(1,1),s<i-1&&this._bh[s].add(this._bh[s+1].dot(this._w_h.value.t)),this._activation&&(this._activation.calc(this._u[s]),this._bh[s]=this._activation.grad(this._bh[s]));const e=this._bh[s].dot(this._w_x.value.t);if(s===0){this._diff_bptt();const h={};if(this._w_x.name&&(h[this._w_x.name]=this._dw_x),this._w_h.name&&(h[this._w_h.name]=this._dw_h),this._b_x.name&&(h[this._b_x.name]=this._db_x),this._b_h.name&&(h[this._b_h.name]=this._db_h),Object.keys(h).length>0)return[e,h]}return e}_diff_bptt(){const t=this._z.length;this._dw_x=u.zeros(...this._w_x.sizes),this._db_x=u.zeros(1,this._size);for(let s=0;s<t;s++){const i=this._i[s].tDot(this._bh[s]);i.div(this._i[s].rows),this._dw_x.add(i),this._db_x.add(this._bh[s].mean(0))}this._dw_x.div(t),this._db_x.div(t),this._dw_h=u.zeros(this._size,this._size),this._db_h=u.zeros(1,this._size);for(let s=0;s<t-1;s++){const i=this._z[s].tDot(this._bh[s+1]);i.div(this._z[s].rows),this._dw_h.add(i),this._db_h.add(this._bh[s+1].mean(0))}this._dw_h.div(t-1),this._db_h.div(t-1)}update(t){this._update_bptt(t)}_update_bptt(t){this._w_x.name||this._w_x.value.sub(t.delta("w_x",this._dw_x)),this._b_x.name||this._b_x.value.sub(t.delta("b_x",this._db_x)),this._w_h.name||this._w_h.value.sub(t.delta("w_h",this._dw_h)),this._b_h.name||this._b_h.value.sub(t.delta("b_h",this._db_h))}toObject(){return{w_x:this._w_x?.toObject(),w_h:this._w_h?.toObject(),b_x:this._b_x?.toObject(),b_h:this._b_h?.toObject(),activation:this._activation?.toObject()}}}class S{static{d(this,"Variable")}constructor(t,s,i){this._layer=t,this._sizes=i,typeof s=="string"?this._name=s:s&&(this._value=u.fromArray(s))}get name(){return this._name}get value(){return this._value}get sizes(){return this._value.sizes}get(...t){return t.length===0&&(t=this._sizes),this._name?this._value=this._layer.graph.getNode(this._name).outputValue:this._value?this._value:this._value=u.randn(...t)}toObject(){return this._name?this._name:this._value?.toArray()}}es.registLayer("rnn");class hs extends p{static{d(this,"RandomizedReLULayer")}constructor({l:t=1/8,u:s=1/3,...i}){super(i),this._l=t,this._u=s,this._r=null,this._training=!1}bind({training:t}){this._training=t}calc(t){this._training?this._r=m.random(t.sizes.slice(1),this._l,this._u):this._r=new m(t.sizes.slice(1),(this._l+this._u)/2),this._i=t;const s=t.copy();return s.map((i,e)=>i>0?i:i*this._r.at(e.slice(1))),s}grad(t){const s=t.copy();return s.map((i,e)=>this._i.at(e)>0?i:i*this._r.at(e.slice(1))),s}toObject(){return{type:"rrelu",l:this._l,u:this._u}}}hs.registLayer("rrelu");class _s extends p{static{d(this,"RandomTranslationReLULayer")}constructor({...t}){super(t),this._r=null,this._training=!1}bind({training:t}){this._training=t}calc(t){this._i=t;const s=t.copy();return this._training?(this._r=m.randn(t.sizes.slice(1)),s.map((i,e)=>Math.max(0,i+this._r.at(e.slice(1))))):(this._r=m.zeros(t.sizes.slice(1)),s.map(i=>i>0?i:0)),s}grad(t){const s=t.copy();return s.map((i,e)=>this._i.at(e)+this._r.at(e.slice(1))>0?i:0),s}}_s.registLayer("rtrelu");class as extends p{static{d(this,"ScaledELULayer")}constructor({a:t=1.6732631921768188,g:s=1.0507010221481323,...i}){super(i),this._a=t,this._g=s}calc(t){this._i=t;const s=t.copy();return s.map(i=>this._g*(i>0?i:this._a*(Math.exp(i)-1))),s}grad(t){this._bo=t;const s=t.copy();return s.broadcastOperate(this._i,(i,e)=>i*this._g*(e>0?1:this._a*Math.exp(e))),s}toObject(){return{type:"selu",a:this._a}}}as.registLayer("selu");class ns extends p{static{d(this,"SigmoidLayer")}constructor({a:t=1,...s}){super(s),this._a=t}calc(t){return this._o=t.copy(),this._o.map(s=>1/(1+Math.exp(-this._a*s))),this._o}grad(t){const s=t.copy();return s.broadcastOperate(this._o,(i,e)=>i*e*(1-e)),s}toObject(){return{type:"sigmoid",a:this._a}}}ns.registLayer();class rs extends p{static{d(this,"SelfLearnableAFLayer")}constructor({n:t=3,a:s=1,...i}){super(i),this._n=t,Array.isArray(s)?this._a=s:this._a=Array(t).fill(s)}calc(t){this._i=t;const s=t.copy();return s.map(i=>this._a.reduce((e,h,_)=>e+h*i**_,0)),s}grad(t){this._bo=t;const s=t.copy();return s.broadcastOperate(this._i,(i,e)=>i*this._a.reduce((h,_,r)=>h+r*_*e**(r-1),0)),s}update(t){const s=Array(this._n).fill(0);for(let i=0;i<this._i.length;i++)for(let e=0;e<this._n;e++)s[e]+=this._bo.value[i]*this._i.value[i]**e;for(let i=0;i<this._n;i++)this._a[i]-=t.delta(`a${i}`,s[i]/this._i.length)}toObject(){return{type:"slaf",n:this._n,a:this._a}}}rs.registLayer("slaf");class os extends p{static{d(this,"SoftplusLinearUnitLayer")}constructor({alpha:t=1,beta:s=1,gamma:i=0,...e}){super(e),this._alpha=t,this._beta=s,this._gamma=i}calc(t){this._i=t;const s=t.copy();return s.map(i=>i>=0?this._alpha*i:this._beta*Math.log(Math.exp(i)+1)-this._gamma),s}grad(t){this._bo=t;const s=t.copy();return s.broadcastOperate(this._i,(i,e)=>i*(e>=0?this._alpha:this._beta*Math.exp(e)/(Math.exp(e)+1))),s}update(t){let s=0,i=0,e=0;for(let h=0;h<this._i.length;h++)this._i.value[h]>=0?s+=this._bo.value[h]*this._i.value[h]:(i+=this._bo.value[h]*Math.log(Math.exp(this._i.value[h])+1),e+=this._bo.value[h]);this._alpha-=t.delta("alpha",s/this._i.length),this._beta-=t.delta("beta",i/this._i.length),this._gamma-=t.delta("gamma",e/this._i.length)}toObject(){return{type:"slu",alpha:this._alpha,beta:this._beta,gamma:this._gamma}}}os.registLayer("slu");class ls extends p{static{d(this,"SoftShrinkLayer")}constructor({l:t=.5,...s}){super(s),this._l=t}calc(t){this._i=t;const s=t.copy();return s.map(i=>i<-this._l?i+this._l:this._l<i?i-this._l:0),s}grad(t){this._bo=t;const s=t.copy();return s.broadcastOperate(this._i,(i,e)=>e<-this._l||this._l<e?i:0),s}toObject(){return{type:"soft_shrink",l:this._l}}}ls.registLayer();class cs extends p{static{d(this,"SoftargmaxLayer")}constructor({beta:t=1e4,...s}){super(s),this._beta=t}calc(t){this._i=t,this._o=u.map(this._i,i=>this._beta*i),this._o.sub(this._o.max(1)),this._o.map(Math.exp),this._o.div(this._o.sum(1));const s=u.zeros(1,this._o.cols);for(let i=0;i<s.cols;i++)s.set(0,i,i);return u.mult(this._o,s).sum(1)}grad(t){this._bo=new u(this._o.rows,this._o.cols);for(let i=0;i<this._o.cols;i++)this._bo.set(0,i,u.mult(t,i));const s=this._i.copy();s.sub(s.max(1)),s.map(Math.exp),s.div(s.sum(1)),this._bi=new u(this._o.rows,this._o.cols);for(let i=0;i<this._bo.rows;i++)for(let e=0;e<this._bo.cols;e++){const h=s.at(i,e);let _=0;for(let r=0;r<this._bo.cols;r++){const a=e===r?1-h:-h;_+=s.at(i,r)*a*this._bo.at(i,r)}this._bi.set(i,e,_)}return this._bi}toObject(){return{type:"softargmax",beta:this._beta}}}cs.registLayer();class ds extends p{static{d(this,"SoftmaxLayer")}constructor({axis:t=-1,...s}){super(s),this._axis=t}calc(t){const s=this._axis<0?this._axis+t.dimension:this._axis;this._o=t.copy();const i=this._o.reduce((h,_)=>Math.max(h,_),-1/0,s,!0);this._o.broadcastOperate(i,(h,_)=>h-_),this._o.map(Math.exp);const e=this._o.reduce((h,_)=>h+_,0,s,!0);return this._o.broadcastOperate(e,(h,_)=>h/_),this._o}grad(t){this._bi=t.copy();const s=this._axis<0?this._axis+t.dimension:this._axis,i=Array(t.dimension).fill(0);do{for(let e=0;e<t.sizes[s];e++){i[s]=e;const h=this._o.at(i);let _=0;const r=i.concat();for(let a=0;a<t.sizes[s];a++){r[s]=a;const o=e===a?1-h:-h;_+=this._o.at(r)*o*t.at(r)}this._bi.set(i,_)}for(let e=0;e<i.length;e++){if(e===s){i[e]=0;continue}if(i[e]++,i[e]<t.sizes[e])break;i[e]=0}}while(i.some(e=>e>0));return this._bi}toObject(){return{type:"softmax",axis:this._axis}}}ds.registLayer();class us extends p{static{d(this,"SoftminLayer")}constructor({axis:t=-1,...s}){super(s),this._axis=t}calc(t){const s=this._axis<0?this._axis+t.dimension:this._axis;this._o=t.copy();const i=this._o.reduce((h,_)=>Math.min(h,_),1/0,s,!0);this._o.broadcastOperate(i,(h,_)=>_-h),this._o.map(Math.exp);const e=this._o.reduce((h,_)=>h+_,0,s,!0);return this._o.broadcastOperate(e,(h,_)=>h/_),this._o}grad(t){this._bi=t.copy();const s=this._axis<0?this._axis+t.dimension:this._axis,i=Array(t.dimension).fill(0);do{for(let e=0;e<t.sizes[s];e++){i[s]=e;const h=this._o.at(i);let _=0;const r=i.concat();for(let a=0;a<t.sizes[s];a++){r[s]=a;const o=e===a?h-1:h;_+=this._o.at(r)*o*t.at(r)}this._bi.set(i,_)}for(let e=0;e<i.length;e++){if(e===s){i[e]=0;continue}if(i[e]++,i[e]<t.sizes[e])break;i[e]=0}}while(i.some(e=>e>0));return this._bi}toObject(){return{type:"softmin",axis:this._axis}}}us.registLayer();class ps extends p{static{d(this,"SoftplusLayer")}constructor({beta:t=1,...s}){super(s),this._beta=t}calc(t){this._i=t;const s=t.copy();return s.map(i=>Math.log(1+Math.exp(this._beta*i))/this._beta),s}grad(t){const s=t.copy();return s.broadcastOperate(this._i,(i,e)=>i/(1+Math.exp(this._beta*e))),s}toObject(){return{type:"softplus",beta:this._beta}}}ps.registLayer();class fs extends p{static{d(this,"SparseLayer")}constructor({rho:t,beta:s,...i}){super(i),this._rho=t,this._beta=s}bind({rho:t}){this._rho=t||this._rho}calc(t){return this._rho_hat=t.mean(0),t}grad(t){const s=u.div(-this._rho,this._rho_hat);return s.add(u.div(1-this._rho,u.sub(1,this._rho_hat))),s.mult(this._beta),u.add(t,s)}toObject(){return{type:"sparsity",rho:this._rho,beta:this._beta}}}fs.registLayer("sparsity");class ms extends p{static{d(this,"SplitLayer")}constructor({axis:t=1,size:s,...i}){super(i),this._axis=t,this._size=s}calc(t){let s=0;if(this._o=[],typeof this._size=="number"){const i=t.sizes[this._axis]/this._size;for(let e=0;e<this._size;e++){const h=Math.round((e+1)*i);this._o.push(t.slice(s,h,this._axis)),s=h}}else for(let i=0;i<this._size.length;i++)this._o.push(t.slice(s,s+this._size[i],this._axis)),s+=this._size[i];return this._o}grad(...t){for(let i=0;i<this._o.length;i++)t[i]||(t[i]=this._o[i].copy(),t[i].fill(0));let s=t[0];for(let i=1;i<t.length;i++)s.concat(t[i],this._axis);return s}toObject(){return{type:"split",axis:this._axis,size:this._size}}}ms.registLayer();class bs extends p{static{d(this,"ShiftedReLULayer")}constructor({d:t=0,...s}){super(s),this._d=t}calc(t){this._i=t;const s=t.copy();return s.map(i=>i>this._d?i:this._d),s}grad(t){this._bo=t;const s=t.copy();return s.broadcastOperate(this._i,(i,e)=>e>this._d?i:0),s}update(t){let s=0;for(let i=0;i<this._i.length;i++)this._i.value[i]>0||(s+=this._bo.value[i]);this._d-=t.delta("delta",s)}toObject(){return{type:"srelu",d:this._d}}}bs.registLayer("srelu");class ys extends p{static{d(this,"SoftRootSignLayer")}constructor({alpha:t=3,beta:s=2,...i}){super(i),this._alpha=t,this._beta=s}calc(t){this._i=t;const s=t.copy();return s.map(i=>i/(i/this._alpha+Math.exp(-i/this._beta))),s}grad(t){const s=t.copy();return s.broadcastOperate(this._i,(i,e)=>i*((1+e/this._beta)*Math.exp(-e/this._beta)/(e/this._alpha+Math.exp(-e/this._beta))**2)),s}toObject(){return{type:"srs",alpha:this._alpha,beta:this._beta}}}ys.registLayer("srs");class gs extends p{static{d(this,"ScaledTanhLayer")}constructor({a:t=1,b:s=1,...i}){super(i),this._a=t,this._b=s}calc(t){return this._o=t.copy(),this._o.map(s=>this._a*Math.tanh(this._b*s)),this._o}grad(t){const s=t.copy();return s.broadcastOperate(this._o,(i,e)=>i*(this._a*this._b-this._b/this._a*e**2)),s}toObject(){return{type:"stanh",a:this._a,b:this._b}}}gs.registLayer("stanh");class zs extends p{static{d(this,"StdLayer")}constructor({axis:t=-1,keepdims:s=!0,...i}){super(i),this._axis=null,typeof t=="string"?this._axisname=t:this._axis=typeof t=="number"?[t]:t,this._keepdims=s}get dependentLayers(){const t=[];return this._axisname&&t.push(this._axisname),t}calc(t){if(this._axisname&&(this._axis=this.graph.getNode(this._axisname).outputValue.toArray()),this._axis.includes(-1))this._size=Array(t.dimension).fill(1);else{this._size=t.sizes.concat();for(let e=0;e<this._axis.length;e++)this._size[this._axis[e]]=1}if(this._i=t,!this._keepdims&&this._axis.includes(-1))return this._m=t.reduce((e,h)=>e+h,0)/t.length,this._o=Math.sqrt(t.reduce((e,h)=>e+(h-this._m)**2,0)/t.length),new m([],this._o);!this._keepdims&&t instanceof u&&(t=m.fromArray(t));const s=this._axis.includes(-1)?t.length:this._axis.reduce((e,h)=>e*t.sizes[h],1);this._m=t.reduce((e,h)=>e+h,0,this._axis,!0),this._m.map(e=>e/s);const i=t.copy();if(i.broadcastOperate(this._m,(e,h)=>e-h),this._o=i.reduce((e,h)=>e+h**2,0,this._axis,!0),this._o.map(e=>Math.sqrt(e/s)),!this._keepdims){const e=this._o.copy();return e.reshape(...e.sizes.filter((h,_)=>!this._axis.includes(_))),e}return this._o}grad(t){t.reshape(...this._size);const s=this._axis.includes(-1)?this._i.length:this._axis.reduce((e,h)=>e*this._i.sizes[h],1),i=this._i.copy();return i.broadcastOperate(this._m,(e,h)=>(e-h)/s),i.broadcastOperate(this._o,(e,h)=>e/h),i.broadcastOperate(t,(e,h)=>e*h),i}toObject(){return{type:"std",axis:this._axis,keepdims:this._keepdims}}}zs.registLayer("std");class ws extends p{static{d(this,"SumLayer")}constructor({axis:t=-1,keepdims:s=!0,...i}){super(i),this._axis=typeof t=="number"?[t]:t,this._keepdims=s}get dependentLayers(){const t=[];return typeof this._axis=="string"&&t.push(this._axis),t}calc(t){const s=typeof this._axis=="string"?this.graph.getNode(this._axis).outputValue.toArray():this._axis;if(s.includes(-1))this._size=Array(t.dimension).fill(1);else{this._size=t.sizes.concat();for(let i=0;i<s.length;i++)this._size[s[i]]=1}return this._i=t,!this._keepdims&&s.includes(-1)?new m([],t.reduce((i,e)=>i+e,0)):(!this._keepdims&&t instanceof u&&(t=m.fromArray(t)),t.reduce((i,e)=>i+e,0,s,this._keepdims))}grad(t){t.reshape(...this._size);const s=this._i.copy();return s.broadcastOperate(t,(i,e)=>e),s}toObject(){return{type:"sum",axis:this._axis,keepdims:this._keepdims}}}ws.registLayer();class vs extends p{static{d(this,"SupervisorLayer")}bind({supervisor:t}){Array.isArray(t)?(this._o=m.fromArray(t),this._o.dimension===2&&(this._o=this._o.toMatrix())):(t instanceof u||t instanceof m)&&(this._o=t)}calc(){return this._o}grad(){}}vs.registLayer();class Os extends p{static{d(this,"SwishLayer")}constructor({beta:t=1,...s}){super(s),this._beta=t}calc(t){this._i=t;const s=t.copy();return s.map(i=>i/(1+Math.exp(-this._beta*i))),s}grad(t){this._bo=t;const s=t.copy();return s.broadcastOperate(this._i,(i,e)=>i*(1+e*this._beta*Math.exp(-this._beta*e)/(1+Math.exp(-this._beta*e)))/(1+Math.exp(-this._beta*e))),s}update(t){let s=0;for(let i=0;i<this._i.length;i++)s+=this._bo.value[i]*(this._i.value[i]*Math.exp(-this._beta*this._i.value[i])/(1+Math.exp(-this._beta*this._i.value[i]))**2);this._beta-=t.delta("beta",s/this._i.length)}toObject(){return{type:"swish",beta:this._beta}}}Os.registLayer();class xs extends p{static{d(this,"TrainableAFLayer")}constructor({a:t=0,b:s=0,...i}){super(i),this._a=t,this._b=s}calc(t){this._i=t;const s=t.copy();return s.map(i=>Math.sqrt((i-this._a)**2+this._b**2)),s}grad(t){this._bo=t;const s=t.copy();return s.broadcastOperate(this._i,(i,e)=>i*(e-this._a)/Math.sqrt((e-this._a)**2+this._b**2)),s}update(t){let s=0,i=0;for(let e=0;e<this._i.length;e++)s+=this._bo.value[e]*((this._a-this._i.value[e])/Math.sqrt((this._i.value[e]-this._a)**2+this._b**2)),i+=this._bo.value[e]*(this._b/Math.sqrt((this._i.value[e]-this._a)**2+this._b**2));this._a-=t.delta("a",s/this._i.length),this._b-=t.delta("b",i/this._i.length)}toObject(){return{type:"taf",a:this._a,b:this._b}}}xs.registLayer("taf");class Ls extends p{static{d(this,"ThresholdedReLULayer")}constructor({a:t=1,...s}){super(s),this._a=t}calc(t){this._i=t;const s=t.copy();return s.map(i=>i>this._a?i:0),s}grad(t){this._bo=t;const s=t.copy();return s.broadcastOperate(this._i,(i,e)=>i*(e>this._a?1:0)),s}toObject(){return{type:"thresholded_relu",a:this._a}}}Ls.registLayer("thresholded_relu");class As extends p{static{d(this,"TransposeLayer")}constructor({axis:t,...s}){super(s),this._axis=t}calc(t){return t.transpose(...this._axis)}grad(t){const s=[];for(let i=0;i<this._axis.length;i++)s.push(this._axis.indexOf(i));return t.transpose(...s)}toObject(){return{type:"transpose",axis:this._axis}}}As.registLayer();class ks extends p{static{d(this,"UpSamplingLayer")}constructor({size:t,channel_dim:s=-1,...i}){if(super(i),this._size=t,this._channel_dim=s,this._channel_dim!==-1&&this._channel_dim!==1)throw new g("Invalid channel dimension.")}_index(t,s,i){return this._channel_dim===-1?[t,...i,s]:[t,s,...i]}calc(t){if(Array.isArray(this._size)||(this._size=Array(t.dimension-2).fill(this._size)),t.dimension!==this._size.length+2)throw new g("Invalid size",[this,t]);this._i=t;const s=this._channel_dim===-1?1:2,i=[t.sizes[0],...this._size.map((h,_)=>t.sizes[_+s]*h)];this._channel_dim===-1?i.push(t.sizes[t.dimension-1]):this._channel_dim===1&&i.splice(1,0,t.sizes[1]);const e=this._channel_dim===-1?t.sizes[t.dimension-1]:t.sizes[1];this._o=new m(i);for(let h=0;h<t.sizes[0];h++)for(let _=0;_<e;_++){const r=Array(t.dimension-2).fill(0);do{const a=Array(t.dimension-2).fill(0);do{const o=r.map((n,c)=>n*this._size[c]+a[c]);this._o.set(this._index(h,_,o),t.at(this._index(h,_,r)));for(let n=0;n<a.length&&(a[n]++,!(a[n]<this._size[n]));n++)a[n]=0}while(a.some(o=>o>0));for(let o=0;o<r.length&&(r[o]++,!(r[o]<this._i.sizes[o+s]));o++)r[o]=0}while(r.some(a=>a>0))}return this._o}grad(t){this._bo=t,this._bi=new m(this._i.sizes);const s=this._channel_dim===-1?1:2,i=this._channel_dim===-1?this._i.sizes[this._i.dimension-1]:this._i.sizes[1];for(let e=0;e<this._i.sizes[0];e++)for(let h=0;h<i;h++){const _=Array(this._i.dimension-2).fill(0);do{const r=Array(this._i.dimension-2).fill(0);let a=0;do{const o=_.map((n,c)=>n*this._size[c]+r[c]);a+=this._bo.at(this._index(e,h,o));for(let n=0;n<r.length&&(r[n]++,!(r[n]<this._size[n]));n++)r[n]=0}while(r.some(o=>o>0));this._bi.set(this._index(e,h,_),a);for(let o=0;o<_.length&&(_[o]++,!(_[o]<this._i.sizes[o+s]));o++)_[o]=0}while(_.some(r=>r>0))}return this._bi}toObject(){return{type:"up_sampling",size:this._size,channel_dim:this._channel_dim}}}ks.registLayer();class Ms extends p{static{d(this,"VariableLayer")}constructor({size:t,l2_decay:s=0,l1_decay:i=0,value:e=null,...h}){super(h),this._size=t,this._v=null,e?this._v=m.fromArray(e):typeof t!="string"&&(this._v=m.randn(t)),this._v&&this._v.dimension===2&&(this._v=this._v.toMatrix()),this._l2_decay=s,this._l1_decay=i,this._n=1}get dependentLayers(){const t=[];return typeof this._size=="string"&&t.push(this._size),t}bind({n:t}){this._n=t}calc(){if(!this._v){const t=this.graph.getNode(this._size).lastOutputSize;this._v=m.randn(t),this._v.dimension===2&&(this._v=this._v.toMatrix())}return this._v}grad(t){this._bo=t}update(t){const s=this._bo.copy();s.map(i=>i/this._n),(this._l2_decay>0||this._l1_decay>0)&&s.map((i,e)=>{const h=this._v.at(e);return i+h*this._l2_decay+Math.sign(h)*this._l1_decay}),this._v.broadcastOperate(t.delta("v",s),(i,e)=>i-e)}toObject(){return{type:"variable",size:this._size,l2_decay:this._l2_decay,l1_decay:this._l1_decay,value:this._v?.toArray()}}}Ms.registLayer();class js extends p{static{d(this,"VarLayer")}constructor({axis:t=-1,keepdims:s=!0,...i}){super(i),this._axis=null,typeof t=="string"?this._axisname=t:this._axis=typeof t=="number"?[t]:t,this._keepdims=s}get dependentLayers(){const t=[];return this._axisname&&t.push(this._axisname),t}calc(t){if(this._axisname&&(this._axis=this.graph.getNode(this._axisname).outputValue.toArray()),this._axis.includes(-1))this._size=Array(t.dimension).fill(1);else{this._size=t.sizes.concat();for(let h=0;h<this._axis.length;h++)this._size[this._axis[h]]=1}if(this._i=t,!this._keepdims&&this._axis.includes(-1))return this._m=t.reduce((h,_)=>h+_,0)/t.length,new m([],t.reduce((h,_)=>h+(_-this._m)**2,0)/t.length);!this._keepdims&&t instanceof u&&(t=m.fromArray(t));const s=this._axis.includes(-1)?t.length:this._axis.reduce((h,_)=>h*t.sizes[_],1);this._m=t.reduce((h,_)=>h+_,0,this._axis,!0),this._m.map(h=>h/s);const i=t.copy();i.broadcastOperate(this._m,(h,_)=>h-_);const e=i.reduce((h,_)=>h+_**2,0,this._axis,this._keepdims);return e.map(h=>h/s),e}grad(t){t.reshape(...this._size);const s=this._axis.includes(-1)?this._i.length:this._axis.reduce((e,h)=>e*this._i.sizes[h],1),i=this._i.copy();return i.broadcastOperate(this._m,(e,h)=>2*(e-h)/s),i.broadcastOperate(t,(e,h)=>e*h),i}toObject(){return{type:"variance",axis:this._axis,keepdims:this._keepdims}}}js.registLayer("variance");export{V as AdaptivePiecewiseLinearLayer,N as AdditiveCoupling,U as ArandaLayer,D as ArgmaxLayer,R as ArgminLayer,E as AttentionLayer,P as AveragePoolLayer,T as BatchNormalizationLayer,G as BendableLinearUnitLayer,F as BimodalDerivativeAdaptiveActivationLayer,$ as BoundedReLULayer,H as ClipLayer,B as ConcatLayer,W as ConcatenatedReLULayer,Q as CondLayer,J as ConstLayer,C as ContinuouslyDifferentiableELULayer,K as ConvLayer,X as DropoutLayer,Z as ELULayer,it as ESwishLayer,Y as ElasticELULayer,st as ElasticReLULayer,tt as EmbeddingLayer,et as FastELULayer,ht as FlattenLayer,_t as FlexibleReLULayer,at as FullyConnected,nt as FunctionLayer,mt as GRULayer,lt as GaussianLayer,ct as GlobalAveragePoolLayer,dt as GlobalLpPoolLayer,ut as GlobalMaxPoolLayer,pt as GraphConvolutionalLayer,ft as GraphSAGELayer,bt as HardShrinkLayer,yt as HardSigmoidLayer,gt as HardTanhLayer,zt as HexpoLayer,wt as HuberLayer,xt as ImprovedSigmoidLayer,vt as IncludeLayer,Ot as InputLayer,jt as LRNLayer,qt as LSTMLayer,Lt as LayerNormalizationLayer,At as LeakyReLULayer,kt as LogSoftmaxLayer,Mt as LpPoolLayer,Ut as MSELayer,St as MatmulLayer,It as MaxPoolLayer,Nt as MeanLayer,Dt as MultibinTrainableLinearUnitLayer,Vt as MultipleParametricELULayer,Rt as NaturalLogarithmReLULayer,Et as OnehotLayer,Pt as OutputLayer,Tt as PadeActivationUnitLayer,Ft as ParametricDeformableELULayer,Gt as ParametricELULayer,Ct as ParametricReLULayer,Ht as ParametricRectifiedExponentialUnitLayer,Qt as ParametricSigmoidFunctionLayer,Kt as ParametricTanhLinearUnitLayer,Jt as PenalizedTanhLayer,$t as PiecewiseLinearUnitLayer,Bt as ProdLayer,es as RNNLayer,Wt as RandomLayer,_s as RandomTranslationReLULayer,hs as RandomizedReLULayer,Xt as ReadoutLayer,ts as RectifiedPowerUnitLayer,Yt as ReduceMaxLayer,Zt as ReduceMinLayer,ss as ReshapeLayer,is as ReverseLayer,as as ScaledELULayer,gs as ScaledTanhLayer,rs as SelfLearnableAFLayer,bs as ShiftedReLULayer,ns as SigmoidLayer,ys as SoftRootSignLayer,ls as SoftShrinkLayer,cs as SoftargmaxLayer,ds as SoftmaxLayer,us as SoftminLayer,ps as SoftplusLayer,os as SoftplusLinearUnitLayer,fs as SparseLayer,ms as SplitLayer,zs as StdLayer,ws as SumLayer,vs as SupervisorLayer,Os as SwishLayer,Ls as ThresholdedReLULayer,xs as TrainableAFLayer,As as TransposeLayer,ks as UpSamplingLayer,js as VarLayer,Ms as VariableLayer};
