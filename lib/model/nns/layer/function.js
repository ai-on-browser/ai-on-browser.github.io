var _=Object.defineProperty;var g=(s,t)=>_(s,"name",{value:t,configurable:!0});import v from"./base.js";export default class b extends v{static{g(this,"FunctionLayer")}constructor({func:t,...e}){super(e),this._func=t,this._exc=q(this._func)}calc(t,e){const n=t.copy();return this._unary=!e,this._unary?(n.map(a=>this._exc({x:a})),this._g=n.copy(),this._g.map(a=>a.gx)):(n.broadcastOperate(e,(a,h)=>this._exc({x:a,y:h})),this._gx=n.copy(),this._gx.map(a=>a.gx),this._gy=n.copy(),this._gy.map(a=>a.gy)),n.map(a=>a.v),n}grad(t){if(this._unary){const e=t.copy();return e.broadcastOperate(this._g,(n,a)=>n*a),e}else{const e=t.copy();e.broadcastOperate(this._gx,(a,h)=>a*h);const n=t.copy();return n.broadcastOperate(this._gy,(a,h)=>a*h),[e,n]}}toObject(){return{type:"function",func:this._func}}}b.registLayer();class f{static{g(this,"OP")}constructor(t,e,n,a){this.name=t,this.p=e,this.f=n,this.g=a}get length(){return this.f.length}}const u={"+":new f("+",4,s=>s,(s,t)=>t),"-":new f("-",4,s=>-s,(s,t)=>-t)},M={"-":new f("-",1,(s,t)=>s-t,(s,t,e,n)=>e-n),"+":new f("+",1,(s,t)=>s+t,(s,t,e,n)=>e+n),"*":new f("*",2,(s,t)=>s*t,(s,t,e,n)=>s*n+e*t),"/":new f("/",2,(s,t)=>s/t,(s,t,e,n)=>(e*t-s*n)/t**2),"**":new f("**",3,(s,t)=>s**t,(s,t,e,n)=>s**t*((n===0?0:n*Math.log(s))+t*(e/s)))},p={abs:{f:Math.abs,g:(s,t)=>s<0?-t:t},acos:{f:Math.acos,g:(s,t)=>-t/(Math.sqrt(1-s**2)+1e-4)},acosh:{f:Math.acosh,g:(s,t)=>-t/(Math.sqrt(s**2-1)+1e-4)},asin:{f:Math.asin,g:(s,t)=>t/(Math.sqrt(1-s**2)+1e-4)},asinh:{f:Math.asinh,g:(s,t)=>t/Math.sqrt(1+s**2)},atan:{f:Math.atan,g:(s,t)=>t/(1+s**2)},atanh:{f:Math.atanh,g:(s,t)=>t/(1-s**2)},cbrt:{f:Math.cbrt,g:(s,t)=>t/(3*Math.cbrt(s)**2)},cos:{f:Math.cos,g:(s,t)=>-t*Math.sin(s)},cosh:{f:Math.cosh,g:(s,t)=>t*Math.sinh(s)},exp:{f:Math.exp,g:(s,t)=>t*Math.exp(s)},log:{f:Math.log,g:(s,t)=>t/s},log10:{f:Math.log10,g:(s,t)=>t/(s*Math.LN10)},log2:{f:Math.log2,g:(s,t)=>t/(s*Math.LN2)},max:{f:Math.max,g:(s,t,e,n)=>s>=t?e:n},min:{f:Math.min,g:(s,t,e,n)=>s<=t?e:n},sin:{f:Math.sin,g:(s,t)=>t*Math.cos(s)},sinh:{f:Math.sinh,g:(s,t)=>t*Math.cosh(s)},sqrt:{f:Math.sqrt,g:(s,t)=>t/(2*Math.sqrt(s))},tan:{f:Math.tan,g:(s,t)=>t/Math.cos(s)**2},tanh:{f:Math.tanh,g:(s,t)=>t*(1-Math.tanh(s)**2)}},m={e:Math.E,ln2:Math.LN2,ln10:Math.LN10,log2e:Math.LOG2E,log10e:Math.LOG10E,pi:Math.PI,sqrt1_2:Math.SQRT1_2,sqrt2:Math.SQRT2},w=[...Object.keys(M),...Object.keys(u),"(",")",",","[","]"];w.sort((s,t)=>t.length-s.length);const k=g(s=>{let t=0;const e=[],n=g(a=>{for(const h of w)if(h===s.slice(t+a,t+a+h.length))return h;return null},"isToken");for(;t<s.length;){if(s[t]===" "){t++;continue}const a=n(0);if(a){t+=a.length,e.push(a);continue}let h=1;for(;h<s.length-t&&!(s[t+h]===" "||n(h));h++);e.push(s.slice(t,t+h)),t+=h}return e},"tokenize"),d=g(s=>{const t=k(s),e=[],n=[];let a=!1;for(const h of t)if(m[h])e.push(m[h]),a=!0;else if(p[h])n.push(h),a=!1;else if(u[h]||M[h]){if(a&&!M[h]||!a&&!u[h])throw new Error(`Invalid operation '${h}'.`);const o=a?M[h]:u[h];for(;;){const c=n[n.length-1];if(c instanceof f&&c.p>=o.p)e.push(n.pop());else break}n.push(o),a=!1}else if(h===","){for(;;){if(n.length===0)throw new Error("Invalid parenthesis");if(n[n.length-1]==="(")break;e.push(n.pop())}a=!1}else if(h==="(")n.push(h),a=!1;else if(h===")"){for(;;){const o=n.pop();if(!o)throw new Error("Invalid parenthesis");if(o==="("){p[n[n.length-1]]&&e.push(n.pop());break}e.push(o)}a=!0}else Number.isFinite(+h)?(e.push(+h),a=!0):(e.push(h),a=!0);for(;n.length>0;)e.push(n.pop());return e},"construct"),O=g((s,t)=>{let n=s.length-1;const a=g(()=>{const o=s[n--];if(typeof o=="number")return{v:o,gx:0,gy:0};if(Object.hasOwn(t,o)){if(o==="x")return{v:t[o],gx:1,gy:0};if(o==="y")return{v:t[o],gx:0,gy:1}}if(o instanceof f){const c=[];for(let r=0;r<o.length;r++)c.unshift(a());const l=o.f(...c.map(r=>r.v)),y=o.g(...c.map(r=>r.v),...c.map(r=>r.gx)),x=o.g(...c.map(r=>r.v),...c.map(r=>r.gy));return{v:l,gx:y,gy:x}}if(p[o]){const c=p[o].f.length,l=[];for(let i=0;i<c;i++)l.unshift(a());const y=p[o].f(...l.map(i=>i.v)),x=p[o].g(...l.map(i=>i.v),...l.map(i=>i.gx)),r=p[o].g(...l.map(i=>i.v),...l.map(i=>i.gy));return{v:y,gx:x,gy:r}}throw new Error(`Invalid token '${o}'.`)},"calc"),h=a();if(n!==-1)throw new Error("Invalid expression.");return h},"execute"),q=g(s=>{const t=d(s);return e=>O(t,e)},"stringToFunction");
