var _=Object.defineProperty;var o=(s,t)=>_(s,"name",{value:t,configurable:!0});import v from"./base.js";export default class b extends v{static{o(this,"FunctionLayer")}constructor({func:t,...e}){super(e),this._func=t,this._exc=q(this._func)}calc(t,e){const n=t.copy();return this._unary=!e,this._unary?(n.map(a=>this._exc({x:a})),this._g=n.copy(),this._g.map(a=>a.gx)):(n.broadcastOperate(e,(a,h)=>this._exc({x:a,y:h})),this._gx=n.copy(),this._gx.map(a=>a.gx),this._gy=n.copy(),this._gy.map(a=>a.gy)),n.map(a=>a.v),n}grad(t){if(this._unary){const e=t.copy();return e.broadcastOperate(this._g,(n,a)=>n*a),e}else{const e=t.copy();e.broadcastOperate(this._gx,(a,h)=>a*h);const n=t.copy();return n.broadcastOperate(this._gy,(a,h)=>a*h),[e,n]}}toObject(){return{type:"function",func:this._func}}}b.registLayer();class f{static{o(this,"OP")}constructor(t,e,n,a){this.name=t,this.p=e,this.f=n,this.g=a}get length(){return this.f.length}}const u={"+":new f("+",4,s=>s,(s,t)=>t),"-":new f("-",4,s=>-s,(s,t)=>-t)},M={"-":new f("-",1,(s,t)=>s-t,(s,t,e,n)=>e-n),"+":new f("+",1,(s,t)=>s+t,(s,t,e,n)=>e+n),"*":new f("*",2,(s,t)=>s*t,(s,t,e,n)=>s*n+e*t),"/":new f("/",2,(s,t)=>s/t,(s,t,e,n)=>(e*t-s*n)/t**2),"**":new f("**",3,(s,t)=>s**t,(s,t,e,n)=>s**t*((n===0?0:n*Math.log(s))+t*(e/s)))},p={abs:{f:Math.abs,g:o((s,t)=>s<0?-t:t,"g")},acos:{f:Math.acos,g:o((s,t)=>-t/(Math.sqrt(1-s**2)+1e-4),"g")},acosh:{f:Math.acosh,g:o((s,t)=>t/(Math.sqrt(s**2-1)+1e-4),"g")},asin:{f:Math.asin,g:o((s,t)=>t/(Math.sqrt(1-s**2)+1e-4),"g")},asinh:{f:Math.asinh,g:o((s,t)=>t/Math.sqrt(1+s**2),"g")},atan:{f:Math.atan,g:o((s,t)=>t/(1+s**2),"g")},atanh:{f:Math.atanh,g:o((s,t)=>t/(1-s**2),"g")},cbrt:{f:Math.cbrt,g:o((s,t)=>t/(3*Math.cbrt(s)**2),"g")},cos:{f:Math.cos,g:o((s,t)=>-t*Math.sin(s),"g")},cosh:{f:Math.cosh,g:o((s,t)=>t*Math.sinh(s),"g")},exp:{f:Math.exp,g:o((s,t)=>t*Math.exp(s),"g")},log:{f:Math.log,g:o((s,t)=>t/s,"g")},log10:{f:Math.log10,g:o((s,t)=>t/(s*Math.LN10),"g")},log2:{f:Math.log2,g:o((s,t)=>t/(s*Math.LN2),"g")},max:{f:Math.max,g:o((s,t,e,n)=>s>=t?e:n,"g")},min:{f:Math.min,g:o((s,t,e,n)=>s<=t?e:n,"g")},sin:{f:Math.sin,g:o((s,t)=>t*Math.cos(s),"g")},sinh:{f:Math.sinh,g:o((s,t)=>t*Math.cosh(s),"g")},sqrt:{f:Math.sqrt,g:o((s,t)=>t/(2*Math.sqrt(s)),"g")},tan:{f:Math.tan,g:o((s,t)=>t/Math.cos(s)**2,"g")},tanh:{f:Math.tanh,g:o((s,t)=>t*(1-Math.tanh(s)**2),"g")}},m={e:Math.E,ln2:Math.LN2,ln10:Math.LN10,log2e:Math.LOG2E,log10e:Math.LOG10E,pi:Math.PI,sqrt1_2:Math.SQRT1_2,sqrt2:Math.SQRT2},w=[...Object.keys(M),...Object.keys(u),"(",")",",","[","]"];w.sort((s,t)=>t.length-s.length);const k=o(s=>{let t=0;const e=[],n=o(a=>{for(const h of w)if(h===s.slice(t+a,t+a+h.length))return h;return null},"isToken");for(;t<s.length;){if(s[t]===" "){t++;continue}const a=n(0);if(a){t+=a.length,e.push(a);continue}let h=1;for(;h<s.length-t&&!(s[t+h]===" "||n(h));h++);e.push(s.slice(t,t+h)),t+=h}return e},"tokenize"),d=o(s=>{const t=k(s),e=[],n=[];let a=!1;for(const h of t)if(m[h])e.push(m[h]),a=!0;else if(p[h])n.push(h),a=!1;else if(u[h]||M[h]){if(a&&!M[h]||!a&&!u[h])throw new Error(`Invalid operation '${h}'.`);const r=a?M[h]:u[h];for(;;){const g=n[n.length-1];if(g instanceof f&&g.p>=r.p)e.push(n.pop());else break}n.push(r),a=!1}else if(h===","){for(;;){if(n.length===0)throw new Error("Invalid parenthesis");if(n[n.length-1]==="(")break;e.push(n.pop())}a=!1}else if(h==="(")n.push(h),a=!1;else if(h===")"){for(;;){const r=n.pop();if(!r)throw new Error("Invalid parenthesis");if(r==="("){p[n[n.length-1]]&&e.push(n.pop());break}e.push(r)}a=!0}else Number.isFinite(+h)?(e.push(+h),a=!0):(e.push(h),a=!0);for(;n.length>0;)e.push(n.pop());return e},"construct"),O=o((s,t)=>{let n=s.length-1;const a=o(()=>{const r=s[n--];if(typeof r=="number")return{v:r,gx:0,gy:0};if(Object.hasOwn(t,r)){if(r==="x")return{v:t[r],gx:1,gy:0};if(r==="y")return{v:t[r],gx:0,gy:1}}if(r instanceof f){const g=[];for(let i=0;i<r.length;i++)g.unshift(a());const l=r.f(...g.map(i=>i.v)),y=r.g(...g.map(i=>i.v),...g.map(i=>i.gx)),x=r.g(...g.map(i=>i.v),...g.map(i=>i.gy));return{v:l,gx:y,gy:x}}if(p[r]){const g=p[r].f.length,l=[];for(let c=0;c<g;c++)l.unshift(a());const y=p[r].f(...l.map(c=>c.v)),x=p[r].g(...l.map(c=>c.v),...l.map(c=>c.gx)),i=p[r].g(...l.map(c=>c.v),...l.map(c=>c.gy));return{v:y,gx:x,gy:i}}throw new Error(`Invalid token '${r}'.`)},"calc"),h=a();if(n!==-1)throw new Error("Invalid expression.");return h},"execute"),q=o(s=>{const t=d(s);return e=>O(t,e)},"stringToFunction");
