var _=Object.defineProperty;var l=(d,o)=>_(d,"name",{value:o,configurable:!0});import p from"./base.js";import y from"../../../util/matrix.js";import h from"../../../util/tensor.js";export default class c extends p{static{l(this,"ReadoutLayer")}constructor({method:o="mean",...r}){super(r),this._method=o}calc(o){this._i=o;const r=o.value[0].nodes[0].sizes.concat();for(;r[0]===1;)r.splice(0,1);const i=[...o.sizes,...r];i.length===2?this._o=y.zeros(...i):this._o=h.zeros(i);const n=Array(o.dimension).fill(0);do{const t=o.at(n);let e=null;for(let s=0;s<t.order;s++)e?e.broadcastOperate(t.nodes[s],(m,f)=>m+f):e=t.nodes[s].copy();e=h.fromArray(e),e.reshape(...r),this._method==="mean"&&e.map(s=>s/t.order);const a=Array(r.length).fill(0);do{this._o.set([...n,...a],e.at(a));for(let s=0;s<a.length&&(a[s]++,!(a[s]<r[s]));s++)a[s]=0}while(a.some(s=>s>0));for(let s=0;s<n.length&&(n[s]++,!(n[s]<o.sizes[s]));s++)n[s]=0}while(n.some(t=>t>0));return this._o}grad(o){o=h.fromArray(o);const r=this._i.value[0].nodes[0].sizes;this._bi=this._i.copy();const i=Array(this._i.dimension).fill(0);do{const n=o.index(i),t=this._i.at(i).copy();for(let e=0;e<t.order;e++)t.nodes[e]=n.copy(),this._method==="mean"&&t.nodes[e].map(a=>a/t.order),t.nodes[e].reshape(...r),r.length===2&&(t.nodes[e]=t.nodes[e].toMatrix());this._bi.set(i,t);for(let e=0;e<i.length&&(i[e]++,!(i[e]<this._i.sizes[e]));e++)i[e]=0}while(i.some(n=>n>0));return this._bi}toObject(){return{type:"readout",method:this._method}}}c.registLayer();
