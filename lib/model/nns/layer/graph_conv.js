var v=Object.defineProperty;var c=(u,i)=>v(u,"name",{value:i,configurable:!0});import d from"./base.js";import r from"../../../util/matrix.js";export default class f extends d{static{c(this,"GraphConvolutionalLayer")}constructor({out_size:i,w:a=null,b:t=null,activation:e=null,l2_decay:s=0,l1_decay:_=0,...n}){super(n),this._out_size=i,this._w=null,typeof a=="string"?this._wname=a:a&&(this._w=r.fromArray(a)),this._b=null,typeof t=="string"?this._bname=t:t&&(this._b=r.fromArray(t)),typeof e=="string"?this._activation=d.fromObject({type:e}):e&&(this._activation=d.fromObject(e)),this._l2_decay=s,this._l1_decay=_,this._aggregate="mean"}get dependentLayers(){const i=[];return this._wname&&i.push(this._wname),this._bname&&i.push(this._bname),this._activation&&i.push(...this._activation.dependentLayers),i}calc(i){this._wname&&(this._w=this.graph.getNode(this._wname).outputValue,this._out_size||(this._out_size=this._w.sizes.at(-1))),this._bname&&(this._b=this.graph.getNode(this._bname).outputValue),this._w||(this._w=r.randn(i.value[0].nodes[0].sizes.at(-1),this._out_size)),this._b||(this._b=r.zeros(1,this._out_size)),this._i=i,this._cum=[],this._o=i.copy();for(let a=0;a<i.length;a++){const t=i.value[a].copy(),e=i.value[a].copy();for(let s=0;s<t.order;s++){const _=i.value[a].getNode(s).copy(),n=i.value[a].adjacencies(s,!0,"in");for(let h=0;h<n.length;h++)_.add(i.value[a].getNode(n[h]));this._aggregate==="mean"&&_.div(n.length+1),e.nodes[s]=_;let o=_.dot(this._w);o.broadcastOperate(this._b,(h,l)=>h+l),this._activation&&(o=this._activation.calc(o)),t.nodes[s]=o}this._cum[a]=e,this._o.value[a]=t}return this._o}grad(i){if(this._activation)for(let t=0;t<i.length;t++)for(let e=0;e<i.value[t].order;e++)i.value[t].nodes[e]=this._activation.grad(i.value[t].nodes[e]);this._dw=null,this._db=null,this._bi=this._i.copy();for(let t=0;t<this._bi.length;t++){const e=this._i.value[t].copy();for(let s=0;s<this._bi.value[t].order;s++)e.nodes[s]=this._i.value[t].nodes[s].copy(),e.nodes[s].fill(0);this._bi.value[t]=e}let a=0;for(let t=0;t<i.length;t++)for(let e=0;e<i.value[t].order;e++){const s=this._cum[t].nodes[e].tDot(i.value[t].nodes[e]),_=i.value[t].nodes[e].sum(0);this._dw?(this._dw.add(s),this._db.add(_)):(this._dw=s,this._db=_),a++;const n=i.value[t].nodes[e].dot(this._w.t),o=this._bi.value[t].adjacencies(e,!0,"in");this._aggregate==="mean"&&n.div(o.length+1),this._bi.value[t].nodes[e].broadcastOperate(n,(h,l)=>h+l);for(let h=0;h<o.length;h++)this._bi.value[t].nodes[o[h]].broadcastOperate(n,(l,g)=>l+g)}if(this._dw.div(a),this._l2_decay>0||this._l1_decay>0)for(let t=0;t<this._dw.rows;t++)for(let e=0;e<this._dw.cols;e++){const s=this._w.at(t,e);this._dw.addAt(t,e,s*this._l2_decay+Math.sign(s)*this._l1_decay)}if(this._db.div(a),this._wname||this._bname){const t={};return this._wname&&(t[this._wname]=this._dw),this._bname&&(t[this._bname]=this._db),[this._bi,t]}return this._bi}update(i){this._wname||this._w.sub(i.delta("w",this._dw)),this._bname||this._b.sub(i.delta("b",this._db))}toObject(){return{type:"graph_conv",out_size:this._out_size,w:this._wname||this._w?.toArray(),b:this._bname||this._b?.toArray(),activation:this._activation?.toObject(),l2_decay:this._l2_decay,l1_decay:this._l1_decay}}}f.registLayer("graph_conv");
