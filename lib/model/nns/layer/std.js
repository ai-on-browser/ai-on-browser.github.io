import Layer from"./base.js";import Matrix from"../../../util/matrix.js";import Tensor from"../../../util/tensor.js";export default class StdLayer extends Layer{constructor({axis:s=-1,keepdims:i=!0,...t}){super(t),this._axis=null,"string"==typeof s?this._axisname=s:this._axis="number"==typeof s?[s]:s,this._keepdims=i}calc(s){if(this._axisname&&(this._axis=this.graph.getNode(this._axisname).outputValue.toArray()),this._axis.includes(-1))this._size=Array(s.dimension).fill(1);else{this._size=s.sizes.concat();for(let s=0;s<this._axis.length;s++)this._size[this._axis[s]]=1}if(this._i=s,!this._keepdims&&this._axis.includes(-1))return this._m=s.reduce(((s,i)=>s+i),0)/s.length,this._o=Math.sqrt(s.reduce(((s,i)=>s+(i-this._m)**2),0)/s.length),new Tensor([],this._o);!this._keepdims&&s instanceof Matrix&&(s=Tensor.fromArray(s));const i=this._axis.includes(-1)?s.length:this._axis.reduce(((i,t)=>i*s.sizes[t]),1);this._m=s.reduce(((s,i)=>s+i),0,this._axis,!0),this._m.map((s=>s/i));const t=s.copy();if(t.broadcastOperate(this._m,((s,i)=>s-i)),this._o=t.reduce(((s,i)=>s+i**2),0,this._axis,!0),this._o.map((s=>Math.sqrt(s/i))),!this._keepdims){const s=this._o.copy();return s.reshape(...s.sizes.filter(((s,i)=>!this._axis.includes(i)))),s}return this._o}grad(s){s.reshape(...this._size);const i=this._axis.includes(-1)?this._i.length:this._axis.reduce(((s,i)=>s*this._i.sizes[i]),1),t=this._i.copy();return t.broadcastOperate(this._m,((s,t)=>(s-t)/i)),t.broadcastOperate(this._o,((s,i)=>s/i)),t.broadcastOperate(s,((s,i)=>s*i)),t}toObject(){return{type:"std",axis:this._axis,keepdims:this._keepdims}}}StdLayer.registLayer("std");