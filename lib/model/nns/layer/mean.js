var o=Object.defineProperty;var n=(a,s)=>o(a,"name",{value:s,configurable:!0});import c from"./base.js";import m from"../../../util/matrix.js";import h from"../../../util/tensor.js";export default class _ extends c{static{n(this,"MeanLayer")}constructor({axis:s=-1,keepdims:r=!0,...t}){super(t),this._axis=null,typeof s=="string"?this._axisname=s:this._axis=typeof s=="number"?[s]:s,this._keepdims=r}get dependentLayers(){const s=[];return this._axisname&&s.push(this._axisname),s}calc(s){if(this._axisname&&(this._axis=this.graph.getNode(this._axisname).outputValue.toArray()),this._axis.includes(-1))this._size=Array(s.dimension).fill(1);else{this._size=s.sizes.concat();for(let e=0;e<this._axis.length;e++)this._size[this._axis[e]]=1}if(this._i=s,!this._keepdims&&this._axis.includes(-1))return new h([],s.reduce((e,i)=>e+i,0)/s.length);!this._keepdims&&s instanceof m&&(s=h.fromArray(s));const r=this._axis.includes(-1)?s.length:this._axis.reduce((e,i)=>e*s.sizes[i],1),t=s.reduce((e,i)=>e+i,0,this._axis,this._keepdims);return t.map(e=>e/r),t}grad(s){s.reshape(...this._size);const r=this._axis.includes(-1)?this._i.length:this._axis.reduce((e,i)=>e*this._i.sizes[i],1),t=this._i.copy();return t.broadcastOperate(s,(e,i)=>i/r),t}toObject(){return{type:"mean",axis:this._axisname||this._axis,keepdims:this._keepdims}}}_.registLayer();
