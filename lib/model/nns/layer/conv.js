import{NeuralnetworkException}from"../../neuralnetwork.js";import Layer from"./base.js";import Tensor from"../../../util/tensor.js";export default class ConvLayer extends Layer{constructor({kernel:t,channel:i=null,stride:e=null,padding:s=null,w:n=null,activation:h=null,l2_decay:_=0,l1_decay:l=0,activation_params:a={},...r}){super(r),this._in_channel=null,this._out_channel=i,this._kernel=t,this._stride=e||1,this._padding=s||0,this._w=null,n&&(this._w=Tensor.fromArray(n),this._in_channel=this._w.sizes[0],this._out_channel||(this._out_channel=this._w.sizes[this._w.dimension-1])),this._activation=h,h&&(this._activation_func=Layer.fromObject({type:h,...a})),this._l2_decay=_,this._l1_decay=l}calc(t){if(Array.isArray(this._kernel)||(this._kernel=Array(t.dimension-2).fill(this._kernel)),t.dimension!==this._kernel.length+2)throw new NeuralnetworkException("Invalid kernel size",[this,t]);this._w||(this._in_channel=t.sizes[t.dimension-1],this._out_channel||(this._out_channel=2*this._in_channel),this._w=Tensor.randn([this._in_channel,...this._kernel,this._out_channel])),this._i=t;const i=[t.sizes[0],...this._kernel.map(((i,e)=>Math.ceil((t.sizes[e+1]+2*this._padding-i)/this._stride)+1)),this._out_channel];this._o=new Tensor(i);for(let e=0;e<t.sizes[0];e++)for(let s=0;s<this._out_channel;s++){const n=Array(this._kernel.length).fill(0);do{let h=0;const _=Array(this._kernel.length).fill(0);do{const i=_.map(((t,i)=>n[i]*this._stride-this._padding+t));if(i.every(((i,e)=>0<=i&&i<t.sizes[e+1])))for(let n=0;n<this._in_channel;n++)h+=t.at(e,...i,n)*this._w.at(n,..._,s);for(let t=0;t<_.length&&(_[t]++,!(_[t]<this._kernel[t]));t++)_[t]=0}while(_.some((t=>t>0)));this._o.set([e,...n,s],h);for(let t=0;t<n.length&&(n[t]++,!(n[t]<i[t+1]));t++)n[t]=0}while(n.some((t=>t>0)))}return this._activation_func?this._activation_func.calc(this._o):this._o}grad(t){this._bo=t,this._activation_func&&(this._bo=this._activation_func.grad(t)),this._bi=new Tensor(this._i.sizes),this._dw=new Tensor(this._w.sizes);for(let i=0;i<this._i.sizes[0];i++)for(let e=0;e<this._out_channel;e++){const s=Array(this._kernel.length).fill(0);do{let n=0;const h=Array(this._kernel.length).fill(0);do{const n=h.map(((t,i)=>s[i]*this._stride-this._padding+t));if(n.every(((t,i)=>0<=t&&t<this._i.sizes[i+1])))for(let _=0;_<this._in_channel;_++){const l=this._bi.at(i,...n,_);this._bi.set([i,...n,_],l+this._w.at(_,...h,e)*t.at(i,...s,e));const a=this._dw.at(_,...h,e);this._dw.set([_,...h,e],a+this._i.at(i,...n,_)*this._bo.at(i,...s,e))}for(let t=0;t<h.length&&(h[t]++,!(h[t]<this._kernel[t]));t++)h[t]=0}while(h.some((t=>t>0)));this._o.set([i,...s,e],n);for(let t=0;t<s.length&&(s[t]++,!(s[t]<this._o.sizes[t+1]));t++)s[t]=0}while(s.some((t=>t>0)))}return this._bi}update(t){this._dw.reshape(this._dw.sizes[0],this._dw.length/this._dw.sizes[0]);const i=t.delta("w",this._dw.toMatrix());for(let t=0;t<this._w.length;t++)this._w.value[t]-=i.value[t]}toObject(){return{type:"conv",w:this._w?.toArray(),channel:this._out_channel,kernel:this._kernel,stride:this._stride,padding:this._padding,activation:this._activation,l2_decay:this._l2_decay,l1_decay:this._l1_decay,activation_params:this._activation_func?.toObject()}}}ConvLayer.registLayer();