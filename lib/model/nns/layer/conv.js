import{NeuralnetworkException}from"../../neuralnetwork.js";import Layer from"./base.js";import Tensor from"../../../util/tensor.js";import ActivationLayer from"./activation.js";export default class ConvLayer extends Layer{constructor({kernel:t,channel:i=null,stride:s=null,padding:e=null,w:n=null,activation:_=null,l2_decay:h=0,l1_decay:a=0,activation_params:r={},...o}){super(o),this._in_channel=null,this._out_channel=i,this._kernel=t,this._stride=s||1,this._padding=e||0,this._w=null,n&&(this._w=Tensor.fromArray(n),this._in_channel=this._w.sizes[0],this._out_channel||(this._out_channel=this._w.sizes[this._w.dimension-1])),this._activation=_,_&&(this._activation_func=new ActivationLayer({activation:_,...r})),this._l2_decay=h,this._l1_decay=a}calc(t){if(Array.isArray(this._kernel)||(this._kernel=Array(t.dimension-2).fill(this._kernel)),t.dimension!==this._kernel.length+2)throw new NeuralnetworkException("Invalid kernel size",[this,t]);this._w||(this._in_channel=t.sizes[t.dimension-1],this._out_channel||(this._out_channel=2*this._in_channel),this._w=Tensor.randn([this._in_channel,...this._kernel,this._out_channel])),this._i=t;const i=[t.sizes[0],...this._kernel.map(((i,s)=>Math.ceil((t.sizes[s+1]+2*this._padding)/this._stride)+1-i)),this._out_channel];this._o=new Tensor(i);for(let s=0;s<t.sizes[0];s++)for(let e=0;e<this._in_channel;e++)for(let n=0;n<this._out_channel;n++){if(2!==this._kernel.length)throw new NeuralnetworkException("Invalid dimension.");for(let _=0;_<i[1];_++)for(let h=0;h<i[2];h++){let i=0;for(let a=0;a<this._kernel[0];a++)if(!(_-this._padding+a<0||_-this._padding+a>=t.sizes[1]))for(let r=0;r<this._kernel[1];r++)h-this._padding+r<0||h-this._padding+r>=t.sizes[2]||(i+=t.at(s,_-this._padding+a,h-this._padding+r,e)*this._w.at(e,a,r,n));this._o.set([s,_,h,n],i)}}return this._activation_func?this._activation_func.calc(this._o):this._o}grad(t){this._bo=t,this._activation_func&&(this._bo=this._activation_func.grad(t)),this._bi=new Tensor(this._i.sizes),this._dw=new Tensor(this._w.sizes);for(let i=0;i<this._i.sizes[0];i++)for(let s=0;s<this._in_channel;s++)for(let e=0;e<this._out_channel;e++){if(2!==this._kernel.length)throw new NeuralnetworkException("Invalid dimension.");for(let n=0;n<t.sizes[1];n++)for(let _=0;_<t.sizes[2];_++)for(let h=0;h<this._kernel[0];h++){const a=n-this._padding+h;if(!(a<0||a>=this._i.sizes[1]))for(let r=0;r<this._kernel[1];r++){const o=_-this._padding+r;if(o<0||o>=this._i.sizes[2])continue;const l=this._bi.at(i,a,o,s);this._bi.set([i,a,o,s],l+this._w.at(s,h,r,e)*t.at(i,n,_,e));const c=this._dw.at(s,h,r,e);this._dw.set([s,h,r,e],c+this._i.at(i,a,o,s)*this._bo.at(i,n,_,e))}}}return this._bi}update(t){this._dw.reshape(this._dw.sizes[0],this._dw.length/this._dw.sizes[0]);const i=t.delta("w",this._dw.toMatrix());for(let t=0;t<this._w.length;t++)this._w.value[t]-=i.value[t]}toObject(){return{type:"conv",w:this._w?.toArray(),channel:this._out_channel,kernel:this._kernel,stride:this._stride,padding:this._padding,activation:this._activation,l2_decay:this._l2_decay,l1_decay:this._l1_decay,activation_params:this._activation_func?.toObject()}}}ConvLayer.registLayer();