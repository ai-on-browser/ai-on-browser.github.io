var O=Object.defineProperty;var b=(u,i)=>O(u,"name",{value:i,configurable:!0});import p from"../../../util/tensor.js";import v from"./base.js";export default class x extends v{static{b(this,"LayerNormalizationLayer")}constructor({axis:i=-1,epsilon:n=1e-12,scale:o=1,offset:r=0,...h}){super(h),this._axis=i,this._epsilon=n,this._scale=null,typeof o=="string"?this._scalename=o:this._scale=o,this._offset=null,typeof r=="string"?this._offsetname=r:this._offset=r}get mean(){return this._mean}get invStdDev(){return this._invStdDev}calc(i){const n=this._axis<0?i.dimension+this._axis:this._axis,o=[];for(let s=n;s<i.dimension;s++)o.push(s);const r=o.map(s=>i.sizes[s]);this._scalename?(this._scale=this.graph.getNode(this._scalename).outputValue,this._scale.reshape(...r)):typeof this._scale=="number"?this._scale=new p(r,this._scale):Array.isArray(this._scale)&&(this._scale=p.fromArray(this._scale),this._scale.reshape(...r)),this._offsetname?(this._offset=this.graph.getNode(this._offsetname).outputValue,this._offset.reshape(...r)):typeof this._offset=="number"?this._offset=new p(r,this._offset):Array.isArray(this._offset)&&(this._offset=p.fromArray(this._offset),this._offset.reshape(...r));const h=o.reduce((s,_)=>s*i.sizes[_],1),a=i.reduce((s,_)=>s+_/h,0,o,!0);this._xc=i.copy(),this._xc.broadcastOperate(a,(s,_)=>s-_),this._var=this._xc.reduce((s,_)=>s+_**2/h,0,o,!0),this._xh=this._xc.copy(),this._xh.broadcastOperate(this._var,(s,_)=>s/Math.sqrt(_+this._epsilon));const c=this._xh.copy();return c.broadcastOperate(this._scale,(s,_)=>s*_),c.broadcastOperate(this._offset,(s,_)=>s+_),this._mean=a,this._invStdDev=this._var.copy(),this._invStdDev.map(s=>1/Math.sqrt(s+this._epsilon)),c}grad(i){this._bo=i;const n=this._bo.copy();n.broadcastOperate(this._scale,(t,e)=>t*e);const o=this._xc.copy();o.broadcastOperate(n,(t,e)=>t*e);const r=this._axis<0?this._bo.dimension+this._axis:this._axis,h=[];for(let t=r;t<this._bo.dimension;t++)h.push(t);const a=h.reduce((t,e)=>t*i.sizes[e],1),c=o.reduce((t,e)=>t+e/a,0,h,!0),s=this._xc.copy();s.broadcastOperate(this._var,(t,e)=>t/(e+this._epsilon)),s.broadcastOperate(c,(t,e)=>t*e),s.broadcastOperate(n,(t,e)=>e-t),s.broadcastOperate(this._var,(t,e)=>t/Math.sqrt(e+this._epsilon));const _=s.reduce((t,e)=>t+e/a,0,h,!0);if(s.broadcastOperate(_,(t,e)=>t-e),this._scalename||this._offsetname){const t=Array.from({length:r},(l,f)=>f),e=t.reduce((l,f)=>l*i.sizes[f],1),d={};if(this._scalename){const l=this._bo.reduce((f,m,y)=>f+m*this._xh.at(y)/e,0,t);d[this._scalename]=l}if(this._offsetname){const l=this._bo.reduce((f,m)=>f+m/e,0,t);d[this._offsetname]=l}return[s,d]}return s}update(i){if(this._scalename&&this._offsetname)return;const n=this._axis<0?this._bo.dimension+this._axis:this._axis,o=Array.from({length:n},(h,a)=>a),r=o.reduce((h,a)=>h*this._bo.sizes[a],1);if(!this._offsetname){const h=this._bo.reduce((a,c)=>a+c/r,0,o);this._offset.broadcastOperate(i.delta("offset",h),(a,c)=>a-c)}if(!this._scalename){const h=this._bo.reduce((a,c,s)=>a+c*this._xh.at(s)/r,0,o);this._scale.broadcastOperate(i.delta("scale",h),(a,c)=>a-c)}}toObject(){return{type:"layer_normalization",axis:this._axis,epsilon:this._epsilon,scale:this._scalename||this._scale.toArray?.()||this._scale,offset:this._offsetname||this._offset.toArray?.()||this._offset}}}x.registLayer();
