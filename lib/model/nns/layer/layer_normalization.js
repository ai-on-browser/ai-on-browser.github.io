import Tensor from"../../../util/tensor.js";import Layer from"./base.js";export default class LayerNormalizationLayer extends Layer{constructor({axis:s=-1,epsilon:t=1e-12,scale:e=1,offset:i=0,...a}){super(a),this._axis=s,this._epsilon=t,this._scale=null,"string"==typeof e?this._scalename=e:this._scale=e,this._offset=null,"string"==typeof i?this._offsetname=i:this._offset=i}get mean(){return this._mean}get invStdDev(){return this._invStdDev}calc(s){const t=[];for(let e=this._axis<0?s.dimension+this._axis:this._axis;e<s.dimension;e++)t.push(e);const e=t.map((t=>s.sizes[t]));this._scalename?(this._scale=this.graph.getNode(this._scalename).outputValue,this._scale.reshape(...e)):"number"==typeof this._scale?this._scale=new Tensor(e,this._scale):Array.isArray(this._scale)&&(this._scale=Tensor.fromArray(this._scale),this._scale.reshape(...e)),this._offsetname?(this._offset=this.graph.getNode(this._offsetname).outputValue,this._offset.reshape(...e)):"number"==typeof this._offset?this._offset=new Tensor(e,this._offset):Array.isArray(this._offset)&&(this._offset=Tensor.fromArray(this._offset),this._offset.reshape(...e));const i=t.reduce(((t,e)=>t*s.sizes[e]),1),a=s.reduce(((s,t)=>s+t/i),0,t,!0);this._xc=s.copy(),this._xc.broadcastOperate(a,((s,t)=>s-t)),this._var=this._xc.reduce(((s,t)=>s+t**2/i),0,t,!0),this._xh=this._xc.copy(),this._xh.broadcastOperate(this._var,((s,t)=>s/Math.sqrt(t+this._epsilon)));const r=this._xh.copy();return r.broadcastOperate(this._scale,((s,t)=>s*t)),r.broadcastOperate(this._offset,((s,t)=>s+t)),this._mean=a,this._invStdDev=this._var.copy(),this._invStdDev.map((s=>1/Math.sqrt(s+this._epsilon))),r}grad(s){this._bo=s;const t=this._bo.copy();t.broadcastOperate(this._scale,((s,t)=>s*t));const e=this._xc.copy();e.broadcastOperate(t,((s,t)=>s*t));const i=this._axis<0?this._bo.dimension+this._axis:this._axis,a=[];for(let s=i;s<this._bo.dimension;s++)a.push(s);const r=a.reduce(((t,e)=>t*s.sizes[e]),1),o=e.reduce(((s,t)=>s+t/r),0,a,!0),h=this._xc.copy();h.broadcastOperate(this._var,((s,t)=>s/(t+this._epsilon))),h.broadcastOperate(o,((s,t)=>s*t)),h.broadcastOperate(t,((s,t)=>t-s)),h.broadcastOperate(this._var,((s,t)=>s/Math.sqrt(t+this._epsilon)));const _=h.reduce(((s,t)=>s+t/r),0,a,!0);if(h.broadcastOperate(_,((s,t)=>s-t)),this._scalename||this._offsetname){const t=Array.from({length:i},((s,t)=>t)),e=t.reduce(((t,e)=>t*s.sizes[e]),1),a={};if(this._scalename){const s=this._bo.reduce(((s,t,i)=>s+t*this._xh.at(i)/e),0,t);a[this._scalename]=s}if(this._offsetname){const s=this._bo.reduce(((s,t)=>s+t/e),0,t);a[this._offsetname]=s}return[h,a]}return h}update(s){if(this._scalename&&this._offsetname)return;const t=this._axis<0?this._bo.dimension+this._axis:this._axis,e=Array.from({length:t},((s,t)=>t)),i=e.reduce(((s,t)=>s*this._bo.sizes[t]),1);if(!this._offsetname){const t=this._bo.reduce(((s,t)=>s+t/i),0,e);this._offset.broadcastOperate(s.delta("offset",t),((s,t)=>s-t))}if(!this._scalename){const t=this._bo.reduce(((s,t,e)=>s+t*this._xh.at(e)/i),0,e);this._scale.broadcastOperate(s.delta("scale",t),((s,t)=>s-t))}}toObject(){return{type:"layer_normalization",axis:this._axis,epsilon:this._epsilon,scale:this._scalename||this._scale.toArray?.()||this._scale,offset:this._offsetname||this._offset.toArray?.()||this._offset}}}LayerNormalizationLayer.registLayer();