import Tensor from"../../../util/tensor.js";import Layer from"./base.js";export default class LayerNormalizationLayer extends Layer{constructor({axis:s=-1,epsilon:t=1e-12,scale:e=1,offset:a=0,...i}){super(i),this._axis=s,this._epsilon=t,this._scale=null,"string"==typeof e?this._scalename=e:this._scale=e,this._offset=null,"string"==typeof a?this._offsetname=a:this._offset=a}calc(s){const t=[];for(let e=this._axis<0?s.dimension+this._axis:this._axis;e<s.dimension;e++)t.push(e);const e=t.map((t=>s.sizes[t]));this._scalename?(this._scale=this.graph.getNode(this._scalename).outputValue,this._scale.reshape(...e)):"number"==typeof this._scale?this._scale=new Tensor(e,this._scale):Array.isArray(this._scale)&&(this._scale=Tensor.fromArray(this._scale),this._scale.reshape(...e)),this._offsetname?(this._offset=this.graph.getNode(this._offsetname).outputValue,this._offset.reshape(...e)):"number"==typeof this._offset?this._offset=new Tensor(e,this._offset):Array.isArray(this._offset)&&(this._offset=Tensor.fromArray(this._offset),this._offset.reshape(...e));const a=t.reduce(((t,e)=>t*s.sizes[e]),1),i=s.reduce(((s,t)=>s+t/a),0,t,!0);this._xc=s.copy(),this._xc.broadcastOperate(i,((s,t)=>s-t)),this._var=this._xc.reduce(((s,t)=>s+t**2/a),0,t,!0),this._xh=this._xc.copy(),this._xh.broadcastOperate(this._var,((s,t)=>s/Math.sqrt(t+this._epsilon)));const o=this._xh.copy();return o.broadcastOperate(this._scale,((s,t)=>s*t)),o.broadcastOperate(this._offset,((s,t)=>s+t)),o}grad(s){this._bo=s;const t=this._bo.copy();t.broadcastOperate(this._scale,((s,t)=>s*t));const e=this._xc.copy();e.broadcastOperate(t,((s,t)=>s*t));const a=this._axis<0?this._bo.dimension+this._axis:this._axis,i=[];for(let s=a;s<this._bo.dimension;s++)i.push(s);const o=i.reduce(((t,e)=>t*s.sizes[e]),1),r=e.reduce(((s,t)=>s+t/o),0,i,!0),h=this._xc.copy();h.broadcastOperate(this._var,((s,t)=>s/(t+this._epsilon))),h.broadcastOperate(r,((s,t)=>s*t)),h.broadcastOperate(t,((s,t)=>t-s)),h.broadcastOperate(this._var,((s,t)=>s/Math.sqrt(t+this._epsilon)));const _=h.reduce(((s,t)=>s+t/o),0,i,!0);if(h.broadcastOperate(_,((s,t)=>s-t)),this._scalename||this._offsetname){const t=Array.from({length:a},((s,t)=>t)),e=t.reduce(((t,e)=>t*s.sizes[e]),1),i={};if(this._scalename){const s=this._bo.reduce(((s,t,a)=>s+t*this._xh.at(a)/e),0,t);i[this._scalename]=s}if(this._offsetname){const s=this._bo.reduce(((s,t)=>s+t/e),0,t);i[this._offsetname]=s}return[h,i]}return h}update(s){if(this._scalename&&this._offsetname)return;const t=this._axis<0?this._bo.dimension+this._axis:this._axis,e=Array.from({length:t},((s,t)=>t)),a=e.reduce(((s,t)=>s*this._bo.sizes[t]),1);if(!this._offsetname){const t=this._bo.reduce(((s,t)=>s+t/a),0,e);this._offset.broadcastOperate(s.delta("offset",t),((s,t)=>s-t))}if(!this._scalename){const t=this._bo.reduce(((s,t,e)=>s+t*this._xh.at(e)/a),0,e);this._scale.broadcastOperate(s.delta("scale",t),((s,t)=>s-t))}}toObject(){return{type:"layer_normalization",axis:this._axis,epsilon:this._epsilon,scale:this._scalename||this._scale.toArray?.()||this._scale,offset:this._offsetname||this._offset.toArray?.()||this._offset}}}LayerNormalizationLayer.registLayer();