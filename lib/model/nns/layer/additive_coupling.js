var _=Object.defineProperty;var l=(r,t)=>_(r,"name",{value:t,configurable:!0});import e from"../../../util/matrix.js";import o from"../../neuralnetwork.js";import{FlowLayer as n}from"./base.js";export default class a extends n{static{l(this,"AdditiveCoupling")}constructor({d:t=null,net:s=null,...i}){super(i),this._d=t,this._m=s==null?null:s instanceof o?s:o.fromObject(s)}calc(t){this._d||(this._d=Math.floor(t.cols/2)),this._m||(this._m=o.fromObject([{type:"input"},{type:"full",out_size:20,activation:"leaky_relu"},{type:"full",out_size:t.cols-this._d,activation:"leaky_relu"}],null,"adam")),this._o=t.copy();const s=e.zeros(...t.sizes);return s.set(0,this._d,this._m.calc(t.slice(0,this._d,1))),this._o.add(s),this._o}inverse(t){this._o=t.copy();const s=e.zeros(...t.sizes);return s.set(0,this._d,this._m.calc(t.slice(0,this._d,1))),this._o.sub(s),this._o}jacobianDeterminant(){return 1}grad(t){const s=t.copy(),i=e.zeros(...t.sizes),c=this._m.grad(t.slice(this._d,null,1));return i.set(0,0,c),s.add(i),s}update(t){this._m.update(t.lr)}toObject(){return{type:"additive_coupling",net:this._m?.toObject()}}}a.registLayer();
