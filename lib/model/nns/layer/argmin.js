var u=Object.defineProperty;var d=(c,e)=>u(c,"name",{value:e,configurable:!0});import y from"./base.js";import z from"../../../util/matrix.js";import p from"../../../util/tensor.js";export default class f extends y{static{d(this,"ArgminLayer")}constructor({axis:e=-1,keepdims:s=!0,...r}){super(r),this._axis=e,this._keepdims=s}calc(e){!this._keepdims&&e instanceof z&&(e=p.fromArray(e)),this._i=e;const s=this._axis<0?this._axis+e.dimension:this._axis;return this._o=this._i.reduce((r,n,a)=>r[0]>n?[n,a[s]]:r,[1/0,-1],s,this._keepdims),this._o.map(r=>r[1]),this._o}grad(e){const s=this._axis<0?this._axis+this._i.dimension:this._axis;if(this._bo=e.copy(),this._bo.dimension!==this._i.dimension){const i=this._bo.sizes.concat();i.splice(s,0,1),this._bo.reshape(...i)}this._bo.repeat(this._i.sizes[s],s);const r=Array(this._i.dimension).fill(1);r[s]=this._i.sizes[s];const n=new p(r,Array.from({length:this._i.sizes[s]},(i,t)=>t));this._bo.broadcastOperate(n,(i,t)=>i*t);const a=this._i.copy(),b=a.reduce((i,t)=>Math.max(i,t),-1/0,s,!0);a.broadcastOperate(b,(i,t)=>t-i),a.map(Math.exp);const l=a.reduce((i,t)=>i+t,0,s,!0);a.broadcastOperate(l,(i,t)=>i/t),this._bi=this._bo.copy();const o=Array(this._i.dimension).fill(0);do{for(let i=0;i<this._i.sizes[s];i++){o[s]=i;const t=a.at(o);let m=0;const _=o.concat();for(let h=0;h<this._i.sizes[s];h++){_[s]=h;const x=i===h?t-1:t;m+=a.at(_)*x*this._bo.at(_)}this._bi.set(o,m)}for(let i=0;i<o.length;i++){if(i===s){o[i]=0;continue}if(o[i]++,o[i]<this._i.sizes[i])break;o[i]=0}}while(o.some(i=>i>0));return this._bi}toObject(){return{type:"argmin",axis:this._axis,keepdims:this._keepdims}}}f.registLayer();
