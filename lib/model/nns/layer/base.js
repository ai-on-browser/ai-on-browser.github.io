var L=Object.defineProperty;var t=(a,e)=>L(a,"name",{value:e,configurable:!0});import"../../../util/matrix.js";import"../../../util/tensor.js";const u={};export class NeuralnetworkLayerException extends Error{static{t(this,"NeuralnetworkLayerException")}constructor(e,c){super(e),this.value=c,this.name="NeuralnetworkLayerException"}}export default class p{static{t(this,"Layer")}constructor({}){}static fromObject(e){const c=u[e.type];if(!c)throw new NeuralnetworkLayerException(`Invalid layer type: ${e.type}`);return new c(e)}static registLayer(e,c){if(c||=this,!e&&c!==p&&(e=this.name.replace(/Layer$/,"").replace(/[A-Z]/g,n=>"_"+n.toLowerCase()).slice(1),c=this),u[e])throw new NeuralnetworkLayerException(`Layer name '${e}' already exists.`);u[e]=c}get dependentLayers(){return[]}bind(e){}calc(...e){throw new NeuralnetworkLayerException("Not impleneted",this)}grad(...e){throw new NeuralnetworkLayerException("Not impleneted",this)}update(e){}toObject(){for(const e of Object.keys(u))if(this.constructor===u[e])return{type:e};return{}}}export class FlowLayer extends p{static{t(this,"FlowLayer")}inverse(...e){throw new NeuralnetworkLayerException("Not impleneted",this)}jacobianDeterminant(){throw new NeuralnetworkLayerException("Not impleneted",this)}}const q=t((a,e,c)=>{class n extends p{static{t(this,"TempLayer")}calc(s){return this._i=s,e?(this._o=s.copy(),this._o.map(e),this._o):this._o=s}grad(s){if(!c)return s;const h=s.copy();for(let o=0;o<h.length;o++)h.value[o]*=c(this._i.value[o],this._o.value[o]);return h}}Object.defineProperty(n,"name",{value:a.split("_").reduce((r,s)=>r+s[0].toUpperCase()+s.substring(1).toLowerCase(),"")+"Layer"}),n.registLayer(a)},"buildUnaryLayer"),m={abs:{calc:Math.abs,grad:t(a=>a<0?-1:1,"grad")},acos:{calc:Math.acos,grad:t(a=>-1/(Math.sqrt(1-a**2)+1e-4),"grad")},acosh:{calc:Math.acosh,grad:t(a=>1/(Math.sqrt(a**2-1)+1e-4),"grad")},asin:{calc:Math.asin,grad:t(a=>1/(Math.sqrt(1-a**2)+1e-4),"grad")},asinh:{calc:Math.asinh,grad:t(a=>1/Math.sqrt(1+a**2),"grad")},atan:{calc:Math.atan,grad:t(a=>1/(1+a**2),"grad")},atanh:{calc:Math.atanh,grad:t(a=>1/(1-a**2),"grad")},bent_identity:{calc:t(a=>(Math.sqrt(a**2+1)-1)/2+a,"calc"),grad:t(a=>a/(2*Math.sqrt(a**2+1))+1,"grad")},bitwise_not:{calc:t(a=>~a,"calc"),grad:t(()=>0,"grad")},ceil:{calc:Math.ceil},cloglog:{calc:t(a=>1-Math.exp(-Math.exp(a)),"calc"),grad:t((a,e)=>Math.exp(a)*(1-e),"grad")},cloglogm:{calc:t(a=>1-2*Math.exp(-.7*Math.exp(a)),"calc"),grad:t(a=>1.4*Math.exp(a-.7*Math.exp(a)),"grad")},cos:{calc:Math.cos,grad:t(a=>-Math.sin(a),"grad")},cosh:{calc:Math.cosh,grad:t(a=>Math.sinh(a),"grad")},detach:{grad:t(()=>0,"grad")},elish:{calc:t(a=>(a>=0?a:Math.exp(a)-1)/(1+Math.exp(-a)),"calc"),grad:t((a,e)=>((a>=0?1:Math.exp(a))+e*Math.exp(-a))/(1+Math.exp(-a)),"grad")},elliott:{calc:t(a=>a/(2*(1+Math.abs(a)))+.5,"calc"),grad:t(a=>1/(2*(1+Math.abs(a))**2),"grad")},erf:{calc:t(a=>{const e=.3275911,c=.254829592,n=-.284496736,r=1.421413741,s=-1.453152027,h=1.061405429,o=a<0?-1:1,d=1/(1+e*Math.abs(a)),l=1-((((h*d+s)*d+r)*d+n)*d+c)*d*Math.exp(-a*a);return o*l},"calc"),grad:t(a=>2*Math.exp(-(a**2))/Math.sqrt(Math.PI),"grad")},exp:{calc:Math.exp,grad:t((a,e)=>e,"grad")},floor:{calc:Math.floor},gelu:{calc:t(a=>a*(1+t(c=>{const n=.3275911,r=.254829592,s=-.284496736,h=1.421413741,o=-1.453152027,d=1.061405429,l=c<0?-1:1,g=1/(1+n*Math.abs(c)),f=1-((((d*g+o)*g+h)*g+s)*g+r)*g*Math.exp(-c*c);return l*f},"erf")(a/Math.sqrt(2)))/2,"calc"),grad:t((a,e)=>(a===0?.5:e/a)+a*Math.exp(-((a/Math.sqrt(2))**2))/Math.sqrt(2*Math.PI),"grad")},hard_elish:{calc:t(a=>Math.max(0,Math.min(1,(a+1)/2))*(a>=0?a:Math.exp(a)-1),"calc"),grad:t(a=>a<=-1?0:a>=1?a>=0?1:Math.exp(a):a>=0?a:(1+a)*Math.exp(a)/2,"grad")},hard_swish:{calc:t(a=>a<=-3?0:3<=a?a:a*(a+3)/6,"calc"),grad:t(a=>a<=-3?0:3<=a?1:(2*a+3)/6,"grad")},identity:{},is_inf:{calc:t(a=>a===1/0||a===-1/0,"calc"),grad:t(()=>0,"grad")},is_nan:{calc:t(a=>Number.isNaN(a),"calc"),grad:t(()=>0,"grad")},lisht:{calc:t(a=>a*Math.tanh(a),"calc"),grad:t(a=>Math.tanh(a)+a*(1-Math.tanh(a)**2),"grad")},log:{calc:Math.log,grad:t(a=>1/a,"grad")},loglog:{calc:t(a=>Math.exp(-Math.exp(-a)),"calc"),grad:t((a,e)=>Math.exp(-a)*e,"grad")},logsigmoid:{calc:t(a=>Math.log(1/(1+Math.exp(-a))),"calc"),grad:t(a=>1/(1+Math.exp(a)),"grad")},mish:{calc:t(a=>a*Math.tanh(Math.log(1+Math.exp(a))),"calc"),grad:t(a=>Math.exp(a)*(4*(a+1)+4*Math.exp(2*a)+Math.exp(3*a)+Math.exp(a)*(4*a+6))/(2*Math.exp(a)+Math.exp(2*a)+2)**2,"grad")},negative:{calc:t(a=>-a,"calc"),grad:t(()=>-1,"grad")},not:{calc:t(a=>!a,"calc"),grad:t(()=>0,"grad")},reciprocal:{calc:t(a=>1/a,"calc"),grad:t(a=>-1/a**2,"grad")},relu:{calc:t(a=>a>0?a:0,"calc"),grad:t(a=>a>0?1:0,"grad")},resech:{calc:t(a=>a/Math.cosh(a),"calc"),grad:t((a,e)=>1/Math.cosh(a)-e*Math.tanh(a),"grad")},reu:{calc:t(a=>a>0?a:a*Math.exp(a),"calc"),grad:t((a,e)=>a>0?1:Math.exp(a)+e,"grad")},rootsig:{calc:t(a=>a/(1+Math.sqrt(1+a**2)),"calc"),grad:t(a=>1/(Math.sqrt(a**2+1)+a**2+1),"grad")},round:{calc:Math.round},sign:{calc:Math.sign},silu:{calc:t(a=>a/(1+Math.exp(-a)),"calc"),grad:t((a,e)=>1/(1+Math.exp(-a))+e*(1-e/a),"grad")},sin:{calc:Math.sin,grad:t(a=>Math.cos(a),"grad")},sinh:{calc:Math.sinh,grad:t(a=>Math.cosh(a),"grad")},softsign:{calc:t(a=>a/(1+Math.abs(a)),"calc"),grad:t(a=>1/(1+Math.abs(a))**2,"grad")},sqrt:{calc:Math.sqrt,grad:t((a,e)=>1/(2*e),"grad")},square:{calc:t(a=>a**2,"calc"),grad:t(a=>a*2,"grad")},ssigmoid:{calc:t(a=>4/(1+Math.exp(-a))-2,"calc"),grad:t(a=>4*Math.exp(-a)/(1+Math.exp(-a))**2,"grad")},tan:{calc:Math.tan,grad:t(a=>1/Math.cos(a)**2,"grad")},tanh:{calc:Math.tanh,grad:t((a,e)=>1-e**2,"grad")},tanhexp:{calc:t(a=>a*Math.tanh(Math.exp(a)),"calc"),grad:t(a=>Math.tanh(Math.exp(a))-a*Math.exp(a)*(Math.tanh(Math.exp(a))**2-1),"grad")},tanhshrink:{calc:t(a=>a-Math.tanh(a),"calc"),grad:t(a=>Math.tanh(a)**2,"grad")}};for(const a of Object.keys(m))q(a,m[a].calc,m[a].grad);const F=t((a,e,c)=>{class n extends p{static{t(this,"TempLayer")}calc(...s){this._i=s,this._o=s[0].copy();for(let h=1;h<s.length;h++)this._o.broadcastOperate(s[h],e);return this._o}grad(s){const h=Array(s.dimension).fill(0),o=this._i.map(l=>{const g=l.copy();return g.fill(0),g}),d=this._i.map(l=>s.dimension-l.dimension);do{const l=this._i.map((i,M)=>h.slice(d[M]).map((y,w)=>y%i.sizes[w])),g=this._i.map((i,M)=>i.at(l[M])),f=s.at(h),b=this._o.at(h);o.forEach((i,M)=>{i.operateAt(l[M],y=>y+c(M,g,b)*f)});for(let i=0;i<h.length&&(h[i]++,!(h[i]<s.sizes[i]));i++)h[i]=0}while(h.some(l=>l>0));return o}}Object.defineProperty(n,"name",{value:a.split("_").reduce((r,s)=>r+s[0].toUpperCase()+s.substring(1).toLowerCase(),"")+"Layer"}),n.registLayer(a)},"buildBinaryLayer"),x={add:{calc:t((a,e)=>a+e,"calc"),gradFunc:t(()=>1,"gradFunc")},and:{calc:t((a,e)=>a&&e,"calc"),gradFunc:t(()=>0,"gradFunc")},bitwise_and:{calc:t((a,e)=>a&e,"calc"),gradFunc:t(()=>0,"gradFunc")},bitwise_or:{calc:t((a,e)=>a|e,"calc"),gradFunc:t(()=>0,"gradFunc")},bitwise_xor:{calc:t((a,e)=>a^e,"calc"),gradFunc:t(()=>0,"gradFunc")},div:{calc:t((a,e)=>a/e,"calc"),gradFunc:t((a,e)=>{const c=e.slice(1).reduce((r,s)=>r*s,1);if(a===0)return 1/c;let n=-e[0]/c**2;for(let r=1;r<e.length;r++)r!==a&&(n*=e[r]);return n},"gradFunc")},left_bitshift:{calc:t((a,e)=>a<<e,"calc"),gradFunc:t(()=>0,"gradFunc")},max:{calc:Math.max,gradFunc:t((a,e)=>{let c=-1/0,n=-1;for(let r=0;r<e.length;r++)c<e[r]&&(c=e[r],n=r);return n===a?1:0},"gradFunc")},min:{calc:Math.min,gradFunc:t((a,e)=>{let c=1/0,n=-1;for(let r=0;r<e.length;r++)c>e[r]&&(c=e[r],n=r);return n===a?1:0},"gradFunc")},mod:{calc:t((a,e)=>a%e,"calc"),gradFunc:t(()=>0,"gradFunc")},mult:{calc:t((a,e)=>a*e,"calc"),gradFunc:t((a,e)=>{let c=1;for(let n=0;n<e.length;n++)n!==a&&(c*=e[n]);return c},"gradFunc")},or:{calc:t((a,e)=>a||e,"calc"),gradFunc:t(()=>0,"gradFunc")},power:{calc:t((a,e)=>a**e,"calc"),gradFunc:t((a,[e,c])=>a===0?c*e**(c-1):e**c*Math.log(e),"gradFunc")},right_bitshift:{calc:t((a,e)=>a>>e,"calc"),gradFunc:t(()=>0,"gradFunc")},sub:{calc:t((a,e)=>a-e,"calc"),gradFunc:t(a=>a===0?1:-1,"gradFunc")},xor:{calc:t((a,e)=>(a||e)&&!(a&&e),"calc"),gradFunc:t(()=>0,"gradFunc")}};for(const a of Object.keys(x))F(a,x[a].calc,x[a].gradFunc);const O=t((a,e)=>{class c extends p{static{t(this,"TempLayer")}calc(...r){this._i=r,this._o=r[0].copy(),this._o.map(()=>!0);for(let s=1;s<r.length;s++){const h=r[s-1].copy();h.broadcastOperate(r[s],e),this._o.broadcastOperate(h,(o,d)=>o&&d)}return this._o}grad(){return this._i.map(s=>{const h=s.copy();return h.fill(0),h})}}Object.defineProperty(c,"name",{value:a.split("_").reduce((n,r)=>n+r[0].toUpperCase()+r.substring(1).toLowerCase(),"")+"Layer"}),c.registLayer(a)},"buildCompareLayer"),_={equal:{calc:t((a,e)=>a===e,"calc")},greater:{calc:t((a,e)=>a>e,"calc")},greater_or_equal:{calc:t((a,e)=>a>=e,"calc")},less:{calc:t((a,e)=>a<e,"calc")},less_or_equal:{calc:t((a,e)=>a<=e,"calc")}};for(const a of Object.keys(_))O(a,_[a].calc);
