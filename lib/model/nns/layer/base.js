import Matrix from"../../../util/matrix.js";import Tensor from"../../../util/tensor.js";const layerClasses={};export class NeuralnetworkLayerException extends Error{constructor(a,t){super(a),this.value=t,this.name="NeuralnetworkLayerException"}}export default class Layer{constructor({}){}static fromObject(a){const t=layerClasses[a.type];if(!t)throw new NeuralnetworkLayerException(`Invalid layer type: ${a.type}`);return new t(a)}static registLayer(a,t){if(t||=this,a||t===Layer||(a=this.name.replace(/Layer$/,"").replace(/[A-Z]/g,(a=>"_"+a.toLowerCase())).slice(1),t=this),layerClasses[a])throw new NeuralnetworkLayerException(`Layer name '${a}' already exists.`);layerClasses[a]=t}bind(a){}calc(...a){throw new NeuralnetworkLayerException("Not impleneted",this)}grad(...a){throw new NeuralnetworkLayerException("Not impleneted",this)}update(a){}toObject(){for(const a of Object.keys(layerClasses))if(this.constructor===layerClasses[a])return{type:a};return{}}}export class FlowLayer extends Layer{inverse(...a){throw new NeuralnetworkLayerException("Not impleneted",this)}jacobianDeterminant(){throw new NeuralnetworkLayerException("Not impleneted",this)}}const buildLayer=(a,t,e)=>{class r extends Layer{calc(a){return this._i=a,this._o=a.copy(),this._o.map(t),this._o}grad(a){const t=a.copy();for(let a=0;a<t.length;a++)t.value[a]*=e(this._i.value[a],this._o.value[a]);return t}}Object.defineProperty(r,"name",{value:a.split("_").reduce(((a,t)=>a+t[0].toUpperCase()+t.substring(1).toLowerCase()),"")+"Layer"}),r.registLayer(a)},simpleLayers={abs:{calc:Math.abs,grad:a=>a<0?-1:1},acos:{calc:Math.acos,grad:a=>-1/(Math.sqrt(1-a**2)+1e-4)},acosh:{calc:Math.acosh,grad:a=>1/(Math.sqrt(a**2-1)+1e-4)},asin:{calc:Math.asin,grad:a=>1/(Math.sqrt(1-a**2)+1e-4)},asinh:{calc:Math.asinh,grad:a=>1/Math.sqrt(1+a**2)},atan:{calc:Math.atan,grad:a=>1/(1+a**2)},atanh:{calc:Math.atanh,grad:a=>1/(1-a**2)},bent_identity:{calc:a=>(Math.sqrt(a**2+1)-1)/2+a,grad:a=>a/(2*Math.sqrt(a**2+1))+1},bitwise_not:{calc:a=>~a,grad:()=>0},ceil:{calc:Math.ceil,grad:()=>1},cloglog:{calc:a=>1-Math.exp(-Math.exp(a)),grad:(a,t)=>Math.exp(a)*(1-t)},cloglogm:{calc:a=>1-2*Math.exp(-.7*Math.exp(a)),grad:a=>1.4*Math.exp(a-.7*Math.exp(a))},cos:{calc:Math.cos,grad:a=>-Math.sin(a)},cosh:{calc:Math.cosh,grad:a=>Math.sinh(a)},elish:{calc:a=>(a>=0?a:Math.exp(a)-1)/(1+Math.exp(-a)),grad:(a,t)=>((a>=0?1:Math.exp(a))+t*Math.exp(-a))/(1+Math.exp(-a))},elliott:{calc:a=>a/(2*(1+Math.abs(a)))+.5,grad:a=>1/(2*(1+Math.abs(a))**2)},erf:{calc:a=>{const t=a<0?-1:1,e=1/(1+.3275911*Math.abs(a));return t*(1-((((1.061405429*e-1.453152027)*e+1.421413741)*e-.284496736)*e+.254829592)*e*Math.exp(-a*a))},grad:a=>2*Math.exp(-(a**2))/Math.sqrt(Math.PI)},exp:{calc:Math.exp,grad:(a,t)=>t},floor:{calc:Math.floor,grad:()=>1},geru:{calc:a=>a*(1+(a=>{const t=a<0?-1:1,e=1/(1+.3275911*Math.abs(a));return t*(1-((((1.061405429*e-1.453152027)*e+1.421413741)*e-.284496736)*e+.254829592)*e*Math.exp(-a*a))})(a/Math.sqrt(2)))/2,grad:(a,t)=>(0===a?0:t/a)+a*Math.exp(-((a/Math.sqrt(2))**2))/Math.sqrt(2*Math.PI)},hard_elish:{calc:a=>Math.max(0,Math.min(1,(a+1)/2))*(a>=0?a:Math.exp(a)-1),grad:a=>a<=-1?0:a>=1?a>=0?1:Math.exp(a):a>=0?a:(1+a)*Math.exp(a)/2},hard_swish:{calc:a=>a<=-3?0:3<=a?a:a*(a+3)/6,grad:a=>a<=-3?0:3<=a?1:(2*a+3)/6},is_inf:{calc:a=>a===1/0||a===-1/0,grad:()=>0},is_nan:{calc:a=>Number.isNaN(a),grad:()=>0},lisht:{calc:a=>a*Math.tanh(a),grad:a=>Math.tanh(a)+a*(1-Math.tanh(a)**2)},log:{calc:Math.log,grad:a=>1/a},loglog:{calc:a=>Math.exp(-Math.exp(-a)),grad:(a,t)=>Math.exp(-a)*t},logsigmoid:{calc:a=>Math.log(1/(1+Math.exp(-a))),grad:a=>1/(1+Math.exp(a))},mish:{calc:a=>a*Math.tanh(Math.log(1+Math.exp(a))),grad:a=>Math.exp(a)*(4*(a+1)+4*Math.exp(2*a)+Math.exp(3*a)+Math.exp(a)*(4*a+6))/(2*Math.exp(a)+Math.exp(2*a)+2)**2},negative:{calc:a=>-a,grad:()=>-1},not:{calc:a=>!a,grad:()=>0},relu:{calc:a=>a>0?a:0,grad:a=>a>0?1:0},resech:{calc:a=>a/Math.cosh(a),grad:(a,t)=>1/Math.cosh(a)-t*Math.tanh(a)},reu:{calc:a=>a>0?a:a*Math.exp(a),grad:(a,t)=>a>0?1:Math.exp(a)+t},rootsig:{calc:a=>a/(1+Math.sqrt(1+a**2)),grad:a=>1/(Math.sqrt(a**2+1)+a**2+1)},round:{calc:Math.round,grad:()=>1},sign:{calc:Math.sign,grad:()=>1},silu:{calc:a=>a/(1+Math.exp(-a)),grad:(a,t)=>1/(1+Math.exp(-a))+t*(1-t/a)},sin:{calc:Math.sin,grad:a=>Math.cos(a)},sinh:{calc:Math.sinh,grad:a=>Math.cosh(a)},softsign:{calc:a=>a/(1+Math.abs(a)),grad:a=>1/(1+Math.abs(a))**2},sqrt:{calc:Math.sqrt,grad:(a,t)=>1/(2*t)},square:{calc:a=>a**2,grad:a=>2*a},ssigmoid:{calc:a=>4/(1+Math.exp(-a))-2,grad:a=>4*Math.exp(-a)/(1+Math.exp(-a))**2},tan:{calc:Math.tan,grad:a=>1/Math.cos(a)**2},tanh:{calc:Math.tanh,grad:(a,t)=>1-t**2},tanhexp:{calc:a=>a*Math.tanh(Math.exp(a)),grad:a=>Math.tanh(Math.exp(a))-a*Math.exp(a)*(Math.tanh(Math.exp(a))**2-1)},tanhshrink:{calc:a=>a-Math.tanh(a),grad:a=>Math.tanh(a)**2}};for(const a of Object.keys(simpleLayers))buildLayer(a,simpleLayers[a].calc,simpleLayers[a].grad);