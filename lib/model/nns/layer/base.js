var w=Object.defineProperty;var t=(a,c)=>w(a,"name",{value:c,configurable:!0});import"../../../util/matrix.js";import"../../../util/tensor.js";const u={};export class NeuralnetworkLayerException extends Error{static{t(this,"NeuralnetworkLayerException")}constructor(c,e){super(c),this.value=e,this.name="NeuralnetworkLayerException"}}export default class p{static{t(this,"Layer")}constructor({}){}static fromObject(c){const e=u[c.type];if(!e)throw new NeuralnetworkLayerException(`Invalid layer type: ${c.type}`);return new e(c)}static registLayer(c,e){if(e||=this,!c&&e!==p&&(c=this.name.replace(/Layer$/,"").replace(/[A-Z]/g,n=>"_"+n.toLowerCase()).slice(1),e=this),u[c])throw new NeuralnetworkLayerException(`Layer name '${c}' already exists.`);u[c]=e}bind(c){}calc(...c){throw new NeuralnetworkLayerException("Not impleneted",this)}grad(...c){throw new NeuralnetworkLayerException("Not impleneted",this)}update(c){}toObject(){for(const c of Object.keys(u))if(this.constructor===u[c])return{type:c};return{}}}export class FlowLayer extends p{static{t(this,"FlowLayer")}inverse(...c){throw new NeuralnetworkLayerException("Not impleneted",this)}jacobianDeterminant(){throw new NeuralnetworkLayerException("Not impleneted",this)}}const F=t((a,c,e)=>{class n extends p{static{t(this,"TempLayer")}calc(s){return this._i=s,c?(this._o=s.copy(),this._o.map(c),this._o):this._o=s}grad(s){if(!e)return s;const h=s.copy();for(let l=0;l<h.length;l++)h.value[l]*=e(this._i.value[l],this._o.value[l]);return h}}Object.defineProperty(n,"name",{value:a.split("_").reduce((r,s)=>r+s[0].toUpperCase()+s.substring(1).toLowerCase(),"")+"Layer"}),n.registLayer(a)},"buildUnaryLayer"),y={abs:{calc:Math.abs,grad:t(a=>a<0?-1:1,"grad")},acos:{calc:Math.acos,grad:t(a=>-1/(Math.sqrt(1-a**2)+1e-4),"grad")},acosh:{calc:Math.acosh,grad:t(a=>1/(Math.sqrt(a**2-1)+1e-4),"grad")},asin:{calc:Math.asin,grad:t(a=>1/(Math.sqrt(1-a**2)+1e-4),"grad")},asinh:{calc:Math.asinh,grad:t(a=>1/Math.sqrt(1+a**2),"grad")},atan:{calc:Math.atan,grad:t(a=>1/(1+a**2),"grad")},atanh:{calc:Math.atanh,grad:t(a=>1/(1-a**2),"grad")},bent_identity:{calc:t(a=>(Math.sqrt(a**2+1)-1)/2+a,"calc"),grad:t(a=>a/(2*Math.sqrt(a**2+1))+1,"grad")},bitwise_not:{calc:t(a=>~a,"calc"),grad:t(()=>0,"grad")},ceil:{calc:Math.ceil},cloglog:{calc:t(a=>1-Math.exp(-Math.exp(a)),"calc"),grad:t((a,c)=>Math.exp(a)*(1-c),"grad")},cloglogm:{calc:t(a=>1-2*Math.exp(-.7*Math.exp(a)),"calc"),grad:t(a=>1.4*Math.exp(a-.7*Math.exp(a)),"grad")},cos:{calc:Math.cos,grad:t(a=>-Math.sin(a),"grad")},cosh:{calc:Math.cosh,grad:t(a=>Math.sinh(a),"grad")},detach:{grad:t(()=>0,"grad")},elish:{calc:t(a=>(a>=0?a:Math.exp(a)-1)/(1+Math.exp(-a)),"calc"),grad:t((a,c)=>((a>=0?1:Math.exp(a))+c*Math.exp(-a))/(1+Math.exp(-a)),"grad")},elliott:{calc:t(a=>a/(2*(1+Math.abs(a)))+.5,"calc"),grad:t(a=>1/(2*(1+Math.abs(a))**2),"grad")},erf:{calc:t(a=>{const c=.3275911,e=.254829592,n=-.284496736,r=1.421413741,s=-1.453152027,h=1.061405429,l=a<0?-1:1,g=1/(1+c*Math.abs(a)),o=1-((((h*g+s)*g+r)*g+n)*g+e)*g*Math.exp(-a*a);return l*o},"calc"),grad:t(a=>2*Math.exp(-(a**2))/Math.sqrt(Math.PI),"grad")},exp:{calc:Math.exp,grad:t((a,c)=>c,"grad")},floor:{calc:Math.floor},gelu:{calc:t(a=>a*(1+t(e=>{const n=.3275911,r=.254829592,s=-.284496736,h=1.421413741,l=-1.453152027,g=1.061405429,o=e<0?-1:1,d=1/(1+n*Math.abs(e)),f=1-((((g*d+l)*d+h)*d+s)*d+r)*d*Math.exp(-e*e);return o*f},"erf")(a/Math.sqrt(2)))/2,"calc"),grad:t((a,c)=>(a===0?.5:c/a)+a*Math.exp(-((a/Math.sqrt(2))**2))/Math.sqrt(2*Math.PI),"grad")},hard_elish:{calc:t(a=>Math.max(0,Math.min(1,(a+1)/2))*(a>=0?a:Math.exp(a)-1),"calc"),grad:t(a=>a<=-1?0:a>=1?a>=0?1:Math.exp(a):a>=0?a:(1+a)*Math.exp(a)/2,"grad")},hard_swish:{calc:t(a=>a<=-3?0:3<=a?a:a*(a+3)/6,"calc"),grad:t(a=>a<=-3?0:3<=a?1:(2*a+3)/6,"grad")},identity:{},is_inf:{calc:t(a=>a===1/0||a===-1/0,"calc"),grad:t(()=>0,"grad")},is_nan:{calc:t(a=>Number.isNaN(a),"calc"),grad:t(()=>0,"grad")},lisht:{calc:t(a=>a*Math.tanh(a),"calc"),grad:t(a=>Math.tanh(a)+a*(1-Math.tanh(a)**2),"grad")},log:{calc:Math.log,grad:t(a=>1/a,"grad")},loglog:{calc:t(a=>Math.exp(-Math.exp(-a)),"calc"),grad:t((a,c)=>Math.exp(-a)*c,"grad")},logsigmoid:{calc:t(a=>Math.log(1/(1+Math.exp(-a))),"calc"),grad:t(a=>1/(1+Math.exp(a)),"grad")},mish:{calc:t(a=>a*Math.tanh(Math.log(1+Math.exp(a))),"calc"),grad:t(a=>Math.exp(a)*(4*(a+1)+4*Math.exp(2*a)+Math.exp(3*a)+Math.exp(a)*(4*a+6))/(2*Math.exp(a)+Math.exp(2*a)+2)**2,"grad")},negative:{calc:t(a=>-a,"calc"),grad:t(()=>-1,"grad")},not:{calc:t(a=>!a,"calc"),grad:t(()=>0,"grad")},reciprocal:{calc:t(a=>1/a,"calc"),grad:t(a=>-1/a**2,"grad")},relu:{calc:t(a=>a>0?a:0,"calc"),grad:t(a=>a>0?1:0,"grad")},resech:{calc:t(a=>a/Math.cosh(a),"calc"),grad:t((a,c)=>1/Math.cosh(a)-c*Math.tanh(a),"grad")},reu:{calc:t(a=>a>0?a:a*Math.exp(a),"calc"),grad:t((a,c)=>a>0?1:Math.exp(a)+c,"grad")},rootsig:{calc:t(a=>a/(1+Math.sqrt(1+a**2)),"calc"),grad:t(a=>1/(Math.sqrt(a**2+1)+a**2+1),"grad")},round:{calc:Math.round},sign:{calc:Math.sign},silu:{calc:t(a=>a/(1+Math.exp(-a)),"calc"),grad:t((a,c)=>1/(1+Math.exp(-a))+c*(1-c/a),"grad")},sin:{calc:Math.sin,grad:t(a=>Math.cos(a),"grad")},sinh:{calc:Math.sinh,grad:t(a=>Math.cosh(a),"grad")},softsign:{calc:t(a=>a/(1+Math.abs(a)),"calc"),grad:t(a=>1/(1+Math.abs(a))**2,"grad")},sqrt:{calc:Math.sqrt,grad:t((a,c)=>1/(2*c),"grad")},square:{calc:t(a=>a**2,"calc"),grad:t(a=>a*2,"grad")},ssigmoid:{calc:t(a=>4/(1+Math.exp(-a))-2,"calc"),grad:t(a=>4*Math.exp(-a)/(1+Math.exp(-a))**2,"grad")},tan:{calc:Math.tan,grad:t(a=>1/Math.cos(a)**2,"grad")},tanh:{calc:Math.tanh,grad:t((a,c)=>1-c**2,"grad")},tanhexp:{calc:t(a=>a*Math.tanh(Math.exp(a)),"calc"),grad:t(a=>Math.tanh(Math.exp(a))-a*Math.exp(a)*(Math.tanh(Math.exp(a))**2-1),"grad")},tanhshrink:{calc:t(a=>a-Math.tanh(a),"calc"),grad:t(a=>Math.tanh(a)**2,"grad")}};for(const a of Object.keys(y))F(a,y[a].calc,y[a].grad);const L=t((a,c,e)=>{class n extends p{static{t(this,"TempLayer")}calc(...s){this._i=s,this._o=s[0].copy();for(let h=1;h<s.length;h++)this._o.broadcastOperate(s[h],c);return this._o}grad(s){const h=Array(s.dimension).fill(0),l=this._i.map(o=>{const d=o.copy();return d.fill(0),d}),g=this._i.map(o=>s.dimension-o.dimension);do{const o=this._i.map((i,M)=>h.slice(g[M]).map((x,b)=>x%i.sizes[b])),d=this._i.map((i,M)=>i.at(o[M])),f=s.at(h),_=this._o.at(h);l.forEach((i,M)=>{i.operateAt(o[M],x=>x+e(M,d,_)*f)});for(let i=0;i<h.length&&(h[i]++,!(h[i]<s.sizes[i]));i++)h[i]=0}while(h.some(o=>o>0));return l}}Object.defineProperty(n,"name",{value:a.split("_").reduce((r,s)=>r+s[0].toUpperCase()+s.substring(1).toLowerCase(),"")+"Layer"}),n.registLayer(a)},"buildBinaryLayer"),m={add:{calc:t((a,c)=>a+c,"calc"),gradFunc:t(()=>1,"gradFunc")},and:{calc:t((a,c)=>a&&c,"calc"),gradFunc:t(()=>0,"gradFunc")},bitwise_and:{calc:t((a,c)=>a&c,"calc"),gradFunc:t(()=>0,"gradFunc")},bitwise_or:{calc:t((a,c)=>a|c,"calc"),gradFunc:t(()=>0,"gradFunc")},bitwise_xor:{calc:t((a,c)=>a^c,"calc"),gradFunc:t(()=>0,"gradFunc")},div:{calc:t((a,c)=>a/c,"calc"),gradFunc:t((a,c)=>{const e=c.slice(1).reduce((r,s)=>r*s,1);if(a===0)return 1/e;let n=-c[0]/e**2;for(let r=1;r<c.length;r++)r!==a&&(n*=c[r]);return n},"gradFunc")},equal:{calc:t((a,c)=>a===c,"calc"),gradFunc:t(()=>0,"gradFunc")},greater:{calc:t((a,c)=>a>c,"calc"),gradFunc:t(()=>0,"gradFunc")},greater_or_equal:{calc:t((a,c)=>a>=c,"calc"),gradFunc:t(()=>0,"gradFunc")},left_bitshift:{calc:t((a,c)=>a<<c,"calc"),gradFunc:t(()=>0,"gradFunc")},less:{calc:t((a,c)=>a<c,"calc"),gradFunc:t(()=>0,"gradFunc")},less_or_equal:{calc:t((a,c)=>a<=c,"calc"),gradFunc:t(()=>0,"gradFunc")},max:{calc:Math.max,gradFunc:t((a,c)=>{let e=-1/0,n=-1;for(let r=0;r<c.length;r++)e<c[r]&&(e=c[r],n=r);return n===a?1:0},"gradFunc")},min:{calc:Math.min,gradFunc:t((a,c)=>{let e=1/0,n=-1;for(let r=0;r<c.length;r++)e>c[r]&&(e=c[r],n=r);return n===a?1:0},"gradFunc")},mod:{calc:t((a,c)=>a%c,"calc"),gradFunc:t(()=>0,"gradFunc")},mult:{calc:t((a,c)=>a*c,"calc"),gradFunc:t((a,c)=>{let e=1;for(let n=0;n<c.length;n++)n!==a&&(e*=c[n]);return e},"gradFunc")},or:{calc:t((a,c)=>a||c,"calc"),gradFunc:t(()=>0,"gradFunc")},power:{calc:t((a,c)=>a**c,"calc"),gradFunc:t((a,[c,e])=>a===0?e*c**(e-1):c**e*Math.log(c),"gradFunc")},right_bitshift:{calc:t((a,c)=>a>>c,"calc"),gradFunc:t(()=>0,"gradFunc")},sub:{calc:t((a,c)=>a-c,"calc"),gradFunc:t(a=>a===0?1:-1,"gradFunc")},xor:{calc:t((a,c)=>(a||c)&&!(a&&c),"calc"),gradFunc:t(()=>0,"gradFunc")}};for(const a of Object.keys(m))L(a,m[a].calc,m[a].gradFunc);
