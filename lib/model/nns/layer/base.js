var w=Object.defineProperty;var g=(a,t)=>w(a,"name",{value:t,configurable:!0});import"../../../util/matrix.js";import"../../../util/tensor.js";const u={};export class NeuralnetworkLayerException extends Error{static{g(this,"NeuralnetworkLayerException")}constructor(t,c){super(t),this.value=c,this.name="NeuralnetworkLayerException"}}export default class p{static{g(this,"Layer")}constructor({}){}static fromObject(t){const c=u[t.type];if(!c)throw new NeuralnetworkLayerException(`Invalid layer type: ${t.type}`);return new c(t)}static registLayer(t,c){if(c||=this,!t&&c!==p&&(t=this.name.replace(/Layer$/,"").replace(/[A-Z]/g,s=>"_"+s.toLowerCase()).slice(1),c=this),u[t])throw new NeuralnetworkLayerException(`Layer name '${t}' already exists.`);u[t]=c}bind(t){}calc(...t){throw new NeuralnetworkLayerException("Not impleneted",this)}grad(...t){throw new NeuralnetworkLayerException("Not impleneted",this)}update(t){}toObject(){for(const t of Object.keys(u))if(this.constructor===u[t])return{type:t};return{}}}export class FlowLayer extends p{static{g(this,"FlowLayer")}inverse(...t){throw new NeuralnetworkLayerException("Not impleneted",this)}jacobianDeterminant(){throw new NeuralnetworkLayerException("Not impleneted",this)}}const F=g((a,t,c)=>{class s extends p{static{g(this,"TempLayer")}calc(r){return this._i=r,t?(this._o=r.copy(),this._o.map(t),this._o):this._o=r}grad(r){if(!c)return r;const n=r.copy();for(let h=0;h<n.length;h++)n.value[h]*=c(this._i.value[h],this._o.value[h]);return n}}Object.defineProperty(s,"name",{value:a.split("_").reduce((e,r)=>e+r[0].toUpperCase()+r.substring(1).toLowerCase(),"")+"Layer"}),s.registLayer(a)},"buildUnaryLayer"),y={abs:{calc:Math.abs,grad:a=>a<0?-1:1},acos:{calc:Math.acos,grad:a=>-1/(Math.sqrt(1-a**2)+1e-4)},acosh:{calc:Math.acosh,grad:a=>1/(Math.sqrt(a**2-1)+1e-4)},asin:{calc:Math.asin,grad:a=>1/(Math.sqrt(1-a**2)+1e-4)},asinh:{calc:Math.asinh,grad:a=>1/Math.sqrt(1+a**2)},atan:{calc:Math.atan,grad:a=>1/(1+a**2)},atanh:{calc:Math.atanh,grad:a=>1/(1-a**2)},bent_identity:{calc:a=>(Math.sqrt(a**2+1)-1)/2+a,grad:a=>a/(2*Math.sqrt(a**2+1))+1},bitwise_not:{calc:a=>~a,grad:()=>0},ceil:{calc:Math.ceil},cloglog:{calc:a=>1-Math.exp(-Math.exp(a)),grad:(a,t)=>Math.exp(a)*(1-t)},cloglogm:{calc:a=>1-2*Math.exp(-.7*Math.exp(a)),grad:a=>1.4*Math.exp(a-.7*Math.exp(a))},cos:{calc:Math.cos,grad:a=>-Math.sin(a)},cosh:{calc:Math.cosh,grad:a=>Math.sinh(a)},detach:{grad:()=>0},elish:{calc:a=>(a>=0?a:Math.exp(a)-1)/(1+Math.exp(-a)),grad:(a,t)=>((a>=0?1:Math.exp(a))+t*Math.exp(-a))/(1+Math.exp(-a))},elliott:{calc:a=>a/(2*(1+Math.abs(a)))+.5,grad:a=>1/(2*(1+Math.abs(a))**2)},erf:{calc:a=>{const t=.3275911,c=.254829592,s=-.284496736,e=1.421413741,r=-1.453152027,n=1.061405429,h=a<0?-1:1,d=1/(1+t*Math.abs(a)),l=1-((((n*d+r)*d+e)*d+s)*d+c)*d*Math.exp(-a*a);return h*l},grad:a=>2*Math.exp(-(a**2))/Math.sqrt(Math.PI)},exp:{calc:Math.exp,grad:(a,t)=>t},floor:{calc:Math.floor},gelu:{calc:a=>a*(1+g(c=>{const s=.3275911,e=.254829592,r=-.284496736,n=1.421413741,h=-1.453152027,d=1.061405429,l=c<0?-1:1,i=1/(1+s*Math.abs(c)),f=1-((((d*i+h)*i+n)*i+r)*i+e)*i*Math.exp(-c*c);return l*f},"erf")(a/Math.sqrt(2)))/2,grad:(a,t)=>(a===0?.5:t/a)+a*Math.exp(-((a/Math.sqrt(2))**2))/Math.sqrt(2*Math.PI)},hard_elish:{calc:a=>Math.max(0,Math.min(1,(a+1)/2))*(a>=0?a:Math.exp(a)-1),grad:a=>a<=-1?0:a>=1?a>=0?1:Math.exp(a):a>=0?a:(1+a)*Math.exp(a)/2},hard_swish:{calc:a=>a<=-3?0:3<=a?a:a*(a+3)/6,grad:a=>a<=-3?0:3<=a?1:(2*a+3)/6},identity:{},is_inf:{calc:a=>a===1/0||a===-1/0,grad:()=>0},is_nan:{calc:a=>Number.isNaN(a),grad:()=>0},lisht:{calc:a=>a*Math.tanh(a),grad:a=>Math.tanh(a)+a*(1-Math.tanh(a)**2)},log:{calc:Math.log,grad:a=>1/a},loglog:{calc:a=>Math.exp(-Math.exp(-a)),grad:(a,t)=>Math.exp(-a)*t},logsigmoid:{calc:a=>Math.log(1/(1+Math.exp(-a))),grad:a=>1/(1+Math.exp(a))},mish:{calc:a=>a*Math.tanh(Math.log(1+Math.exp(a))),grad:a=>Math.exp(a)*(4*(a+1)+4*Math.exp(2*a)+Math.exp(3*a)+Math.exp(a)*(4*a+6))/(2*Math.exp(a)+Math.exp(2*a)+2)**2},negative:{calc:a=>-a,grad:()=>-1},not:{calc:a=>!a,grad:()=>0},reciprocal:{calc:a=>1/a,grad:a=>-1/a**2},relu:{calc:a=>a>0?a:0,grad:a=>a>0?1:0},resech:{calc:a=>a/Math.cosh(a),grad:(a,t)=>1/Math.cosh(a)-t*Math.tanh(a)},reu:{calc:a=>a>0?a:a*Math.exp(a),grad:(a,t)=>a>0?1:Math.exp(a)+t},rootsig:{calc:a=>a/(1+Math.sqrt(1+a**2)),grad:a=>1/(Math.sqrt(a**2+1)+a**2+1)},round:{calc:Math.round},sign:{calc:Math.sign},silu:{calc:a=>a/(1+Math.exp(-a)),grad:(a,t)=>1/(1+Math.exp(-a))+t*(1-t/a)},sin:{calc:Math.sin,grad:a=>Math.cos(a)},sinh:{calc:Math.sinh,grad:a=>Math.cosh(a)},softsign:{calc:a=>a/(1+Math.abs(a)),grad:a=>1/(1+Math.abs(a))**2},sqrt:{calc:Math.sqrt,grad:(a,t)=>1/(2*t)},square:{calc:a=>a**2,grad:a=>a*2},ssigmoid:{calc:a=>4/(1+Math.exp(-a))-2,grad:a=>4*Math.exp(-a)/(1+Math.exp(-a))**2},tan:{calc:Math.tan,grad:a=>1/Math.cos(a)**2},tanh:{calc:Math.tanh,grad:(a,t)=>1-t**2},tanhexp:{calc:a=>a*Math.tanh(Math.exp(a)),grad:a=>Math.tanh(Math.exp(a))-a*Math.exp(a)*(Math.tanh(Math.exp(a))**2-1)},tanhshrink:{calc:a=>a-Math.tanh(a),grad:a=>Math.tanh(a)**2}};for(const a of Object.keys(y))F(a,y[a].calc,y[a].grad);const L=g((a,t,c)=>{class s extends p{static{g(this,"TempLayer")}calc(...r){this._i=r,this._o=r[0].copy();for(let n=1;n<r.length;n++)this._o.broadcastOperate(r[n],t);return this._o}grad(r){const n=Array(r.dimension).fill(0),h=this._i.map(l=>{const i=l.copy();return i.fill(0),i}),d=this._i.map(l=>r.dimension-l.dimension);do{const l=this._i.map((o,M)=>n.slice(d[M]).map((x,b)=>x%o.sizes[b])),i=this._i.map((o,M)=>o.at(l[M])),f=r.at(n),_=this._o.at(n);h.forEach((o,M)=>{o.operateAt(l[M],x=>x+c(M,i,_)*f)});for(let o=0;o<n.length&&(n[o]++,!(n[o]<r.sizes[o]));o++)n[o]=0}while(n.some(l=>l>0));return h}}Object.defineProperty(s,"name",{value:a.split("_").reduce((e,r)=>e+r[0].toUpperCase()+r.substring(1).toLowerCase(),"")+"Layer"}),s.registLayer(a)},"buildBinaryLayer"),m={add:{calc:(a,t)=>a+t,gradFunc:()=>1},and:{calc:(a,t)=>a&&t,gradFunc:()=>0},bitwise_and:{calc:(a,t)=>a&t,gradFunc:()=>0},bitwise_or:{calc:(a,t)=>a|t,gradFunc:()=>0},bitwise_xor:{calc:(a,t)=>a^t,gradFunc:()=>0},div:{calc:(a,t)=>a/t,gradFunc:(a,t)=>{const c=t.slice(1).reduce((e,r)=>e*r,1);if(a===0)return 1/c;let s=-t[0]/c**2;for(let e=1;e<t.length;e++)e!==a&&(s*=t[e]);return s}},equal:{calc:(a,t)=>a===t,gradFunc:()=>0},greater:{calc:(a,t)=>a>t,gradFunc:()=>0},greater_or_equal:{calc:(a,t)=>a>=t,gradFunc:()=>0},left_bitshift:{calc:(a,t)=>a<<t,gradFunc:()=>0},less:{calc:(a,t)=>a<t,gradFunc:()=>0},less_or_equal:{calc:(a,t)=>a<=t,gradFunc:()=>0},max:{calc:Math.max,gradFunc:(a,t)=>{let c=-1/0,s=-1;for(let e=0;e<t.length;e++)c<t[e]&&(c=t[e],s=e);return s===a?1:0}},min:{calc:Math.min,gradFunc:(a,t)=>{let c=1/0,s=-1;for(let e=0;e<t.length;e++)c>t[e]&&(c=t[e],s=e);return s===a?1:0}},mod:{calc:(a,t)=>a%t,gradFunc:()=>0},mult:{calc:(a,t)=>a*t,gradFunc:(a,t)=>{let c=1;for(let s=0;s<t.length;s++)s!==a&&(c*=t[s]);return c}},or:{calc:(a,t)=>a||t,gradFunc:()=>0},power:{calc:(a,t)=>a**t,gradFunc:(a,[t,c])=>a===0?c*t**(c-1):t**c*Math.log(t)},right_bitshift:{calc:(a,t)=>a>>t,gradFunc:()=>0},sub:{calc:(a,t)=>a-t,gradFunc:a=>a===0?1:-1},xor:{calc:(a,t)=>(a||t)&&!(a&&t),gradFunc:()=>0}};for(const a of Object.keys(m))L(a,m[a].calc,m[a].gradFunc);
