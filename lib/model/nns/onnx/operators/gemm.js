import{onnx}from"../onnx_importer.js";import{loadTensor,loadAttribute}from"../utils.js";import Matrix from"../../../../util/matrix.js";export default{import(t,a){const i={alpha:1,beta:1};for(const t of a.attributeList)i[t.name]=loadAttribute(t);const n=[];let s=a.inputList[0];i.transA&&n.push({type:"transpose",input:[s],name:s+="_t",axis:[1,0]});const p={};for(const n of t.graph.initializerList)if(n.name===a.inputList[1])p.w=Matrix.fromArray(loadTensor(n)),i.transB&&(p.w=p.w.t),p.w.mult(i.alpha),p.w=p.w.toArray();else if(n.name===a.inputList[2]){const t=loadTensor(n);Array.isArray(t)?Array.isArray(t[0])?(p.b=Matrix.fromArray(t),p.b.mult(i.beta),p.b=p.b.toArray()):p.b=[t.map((t=>t*i.beta))]:p.b=t*i.beta}let r=a.inputList[1];p.w||(i.transB&&(n.push({type:"transpose",input:[r],name:a.inputList[1]+"_t",axis:[1,0]}),r=a.inputList[1]+"_t"),1!==i.alpha&&(n.push({type:"const",value:[i.alpha],name:a.inputList[1]+"_alpha"}),n.push({type:"mult",input:[r,a.inputList[1]+"_alpha"],name:a.inputList[1]+"_mul_a"}),r=a.inputList[1]+"_mul_a"));let u=a.inputList[2];return u&&!p.b&&1!==i.beta&&(n.push({type:"const",value:[i.beta],name:a.inputList[2]+"_beta"}),n.push({type:"mult",input:[u,a.inputList[2]+"_beta"],name:a.inputList[2]+"_mul_b"}),u=a.inputList[2]+"_mul_b"),n.push({type:"full",input:[s],name:a.outputList[0],w:p.w||r,b:p.b||u}),n}};