import{onnx}from"../onnx_importer.js";import{loadTensor,loadAttribute}from"../utils.js";import Matrix from"../../../../util/matrix.js";export default{import(t,a){const e={alpha:1,beta:1};for(const t of a.getAttributeList())e[t.getName()]=loadAttribute(t);const r=a.getInputList(),s=[];let o=r[0];e.transA&&s.push({type:"transpose",input:[o],name:o+="_t",axis:[1,0]});const p={};for(const a of t.getGraph().getInitializerList())if(a.getName()===r[1])p.w=Matrix.fromArray(loadTensor(a)),e.transB&&(p.w=p.w.t),p.w.mult(e.alpha),p.w=p.w.toArray();else if(a.getName()===r[2]){const t=loadTensor(a);Array.isArray(t)?Array.isArray(t[0])?(p.b=Matrix.fromArray(t),p.b.mult(e.beta),p.b=p.b.toArray()):p.b=[t.map((t=>t*e.beta))]:p.b=t*e.beta}let n=r[1];p.w||(e.transB&&(s.push({type:"transpose",input:[n],name:r[1]+"_t",axis:[1,0]}),n=r[1]+"_t"),1!==e.alpha&&(s.push({type:"const",value:[e.alpha],name:r[1]+"_alpha"}),s.push({type:"mult",input:[n,r[1]+"_alpha"],name:r[1]+"_mul_a"}),n=r[1]+"_mul_a"));let u=r[2];return u&&!p.b&&1!==e.beta&&(s.push({type:"const",value:[e.beta],name:r[2]+"_beta"}),s.push({type:"mult",input:[u,r[2]+"_beta"],name:r[2]+"_mul_b"}),u=r[2]+"_mul_b"),s.push({type:"full",input:[o],name:a.getOutputList()[0],w:p.w||n,b:p.b||u}),s}};