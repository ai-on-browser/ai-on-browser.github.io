import{onnx}from"../onnx_importer.js";import{loadTensor,loadAttribute}from"../utils.js";import Tensor from"../../../../util/tensor.js";export default{import(t,e){const r={};for(const t of e.attributeList)r[t.name]=loadAttribute(t);const s={};let a=null;for(const o of t.graph.initializerList)if(o.name===e.inputList[1]){s.w=loadTensor(o);const t=Tensor.fromArray(s.w);r.kernel_shape||(r.kernel_shape=t.sizes.slice(2)),a=t.sizes[0]}else o.name===e.inputList[2]&&(s.b=loadTensor(o));if(r.group&&1!==r.group)throw new Error(`Invalid attribute 'group' value ${r.group}.`);if(r.strides&&r.strides.some((t=>t!==r.strides[0])))throw new Error(`Invalid attribute 'strides' value ${r.strides}.`);if("SAME_UPPER"===r.auto_pad)r.pads=r.kernel_shape.map((t=>[Math.floor((t-1)/2),Math.ceil((t-1)/2)]));else if("SAME_LOWER"===r.auto_pad)r.pads=r.kernel_shape.map((t=>[Math.ceil((t-1)/2),Math.floor((t-1)/2)]));else{if(r.auto_pad&&"NOTSET"!==r.auto_pad)throw new Error(`Invalid attribute 'auto_pad' value ${r.auto_pad}.`);if(r.pads){const t=[];for(let e=0;e<r.pads.length/2;e++)t.push([r.pads[e],r.pads[e+r.pads.length/2]]);r.pads=t}}return[{type:"conv",input:[e.inputList[0]],name:e.outputList[0],kernel:r.kernel_shape,channel:a,padding:r.pads||0,stride:r.strides?r.strides[0]:null,w:s.w||e.inputList[1],channel_dim:1}]}};