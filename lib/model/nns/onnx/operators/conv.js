import"../onnx_importer.js";import{loadTensor as n,loadAttribute as l}from"../utils.js";import d from"../../../../util/tensor.js";export default{import(p,s){const t={};for(const e of s.getAttributeList())t[e.getName()]=l(e);const a=s.getInputList(),i={};let o=null;for(const e of p.getGraph().getInitializerList())if(e.getName()===a[1]){i.w=n(e);const r=d.fromArray(i.w);t.kernel_shape||(t.kernel_shape=r.sizes.slice(2)),o=r.sizes[0]}else e.getName()===a[2]&&(i.b=n(e));if(t.group&&t.group!==1)throw new Error(`Invalid attribute 'group' value ${t.group}.`);if(t.strides&&t.strides.some(e=>e!==t.strides[0]))throw new Error(`Invalid attribute 'strides' value ${t.strides}.`);if(t.auto_pad==="SAME_UPPER")t.pads=t.kernel_shape.map(e=>[Math.floor((e-1)/2),Math.ceil((e-1)/2)]);else if(t.auto_pad==="SAME_LOWER")t.pads=t.kernel_shape.map(e=>[Math.ceil((e-1)/2),Math.floor((e-1)/2)]);else{if(t.auto_pad&&t.auto_pad!=="NOTSET")throw new Error(`Invalid attribute 'auto_pad' value ${t.auto_pad}.`);if(t.pads){const e=[];for(let r=0;r<t.pads.length/2;r++)e.push([t.pads[r],t.pads[r+t.pads.length/2]]);t.pads=e}}return[{type:"conv",input:[a[0]],name:s.getOutputList()[0],kernel:t.kernel_shape,channel:o,padding:t.pads||0,stride:t.strides?t.strides[0]:null,w:i.w||a[1],channel_dim:1}]}};
