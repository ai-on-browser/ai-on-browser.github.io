import{onnx}from"../onnx_importer.js";import{loadTensor,loadAttribute}from"../utils.js";import Tensor from"../../../../util/tensor.js";export default{import(e,t){const r={};for(const e of t.getAttributeList())r[e.getName()]=loadAttribute(e);const s=t.getInputList(),a={};let o=null;for(const t of e.getGraph().getInitializerList())if(t.getName()===s[1]){a.w=loadTensor(t);const e=Tensor.fromArray(a.w);r.kernel_shape||(r.kernel_shape=e.sizes.slice(2)),o=e.sizes[0]}else t.getName()===s[2]&&(a.b=loadTensor(t));if(r.group&&1!==r.group)throw new Error(`Invalid attribute 'group' value ${r.group}.`);if(r.strides&&r.strides.some((e=>e!==r.strides[0])))throw new Error(`Invalid attribute 'strides' value ${r.strides}.`);if("SAME_UPPER"===r.auto_pad)r.pads=r.kernel_shape.map((e=>[Math.floor((e-1)/2),Math.ceil((e-1)/2)]));else if("SAME_LOWER"===r.auto_pad)r.pads=r.kernel_shape.map((e=>[Math.ceil((e-1)/2),Math.floor((e-1)/2)]));else{if(r.auto_pad&&"NOTSET"!==r.auto_pad)throw new Error(`Invalid attribute 'auto_pad' value ${r.auto_pad}.`);if(r.pads){const e=[];for(let t=0;t<r.pads.length/2;t++)e.push([r.pads[t],r.pads[t+r.pads.length/2]]);r.pads=e}}return[{type:"conv",input:[s[0]],name:t.getOutputList()[0],kernel:r.kernel_shape,channel:o,padding:r.pads||0,stride:r.strides?r.strides[0]:null,w:a.w||s[1],channel_dim:1}]}};