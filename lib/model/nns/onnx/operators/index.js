import"../onnx_importer.js";import{loadAttribute as n,loadTensor as o}from"../utils.js";import _ from"../../../../util/tensor.js";import L from"../../../../util/matrix.js";var c={import(r,t){return[{type:"abs",input:[t.getInputList()[0]],name:t.getOutputList()[0]}]}},h={import(r,t){return[{type:"acos",input:[t.getInputList()[0]],name:t.getOutputList()[0]}]}},d={import(r,t){return[{type:"acosh",input:[t.getInputList()[0]],name:t.getOutputList()[0]}]}},v={import(r,t){return[{type:"add",input:t.getInputList(),name:t.getOutputList()[0]}]}},y={import(r,t){return[{type:"and",input:t.getInputList(),name:t.getOutputList()[0]}]}},b={import(r,t){const e={axis:0,keepdims:1,select_last_index:0};for(const i of t.getAttributeList())e[i.getName()]=n(i);if(e.select_last_index)throw new Error(`Invalid attribute 'select_last_index' value ${e.select_last_index}.`);return[{type:"argmax",input:[t.getInputList()[0]],name:t.getOutputList()[0],axis:e.axis,keepdims:!!e.keepdims}]}},I={import(r,t){const e={axis:0,keepdims:1,select_last_index:0};for(const i of t.getAttributeList())e[i.getName()]=n(i);if(e.select_last_index)throw new Error(`Invalid attribute 'select_last_index' value ${e.select_last_index}.`);return[{type:"argmin",input:[t.getInputList()[0]],name:t.getOutputList()[0],axis:e.axis,keepdims:!!e.keepdims}]}},x={import(r,t){return[{type:"asin",input:[t.getInputList()[0]],name:t.getOutputList()[0]}]}},w={import(r,t){return[{type:"asinh",input:[t.getInputList()[0]],name:t.getOutputList()[0]}]}},O={import(r,t){return[{type:"atan",input:[t.getInputList()[0]],name:t.getOutputList()[0]}]}},N={import(r,t){return[{type:"atanh",input:[t.getInputList()[0]],name:t.getOutputList()[0]}]}},z={import(r,t){const e={};for(const i of t.getAttributeList())e[i.getName()]=n(i);if(e.strides&&e.strides.some(i=>i!==e.strides[0]))throw new Error(`Invalid attribute 'strides' value ${e.strides}.`);if(e.auto_pad&&e.auto_pad!=="NOTSET")throw new Error(`Invalid attribute 'auto_pad' value ${e.auto_pad}.`);if(e.pads){const i=[];for(let s=0;s<e.pads.length/2;s++)i.push([e.pads[s],e.pads[s+e.pads.length/2]]);e.pads=i}return[{type:"average_pool",input:[t.getInputList()[0]],name:t.getOutputList()[0],kernel:e.kernel_shape,padding:e.pads||0,stride:e.strides?e.strides[0]:1,channel_dim:1}]}},k={import(r,t){const e={epsilon:1e-5,momentum:.9,training_mode:0};for(const u of t.getAttributeList())e[u.getName()]=n(u);const i=t.getInputList(),s={};for(const u of r.getGraph().getInitializerList())u.getName()===i[1]?s.scale=o(u):u.getName()===i[2]?s.b=o(u):u.getName()===i[3]?s.inputMean=o(u):u.getName()===i[4]&&(s.inputVar=o(u));if(e.training_mode)throw new Error(`Invalid attribute 'training_mode' value ${e.training_mode}.`);const a=t.getOutputList(),p=[{type:"batch_normalization",input:[i[0]],name:a[0],scale:s.scale??i[1],offset:s.b??i[2],epsilon:e.epsilon??1e-5,input_mean:s.b??i[3],input_var:s.b??i[4],channel_dim:1}];return a.length>=2&&p.push({type:"identity",input:[`${a[0]}[mean]`],name:a[1]}),a.length>=3&&p.push({type:"identity",input:[`${a[0]}[var]`],name:a[2]}),p}},A={import(r,t){const e={};for(const i of t.getAttributeList())e[i.getName()]=n(i);return[{type:e.direction==="RIGHT"?"right_bitshift":"left_bitshift",input:t.getInputList(),name:t.getOutputList()[0]}]}},E={import(r,t){return[{type:"bitwise_and",input:t.getInputList(),name:t.getOutputList()[0]}]}},$={import(r,t){return[{type:"bitwise_not",input:t.getInputList(),name:t.getOutputList()[0]}]}},G={import(r,t){return[{type:"bitwise_or",input:t.getInputList(),name:t.getOutputList()[0]}]}},q={import(r,t){return[{type:"bitwise_xor",input:t.getInputList(),name:t.getOutputList()[0]}]}},T={import(r,t){return[{type:"ceil",input:[t.getInputList()[0]],name:t.getOutputList()[0]}]}},M={import(r,t){const e={};for(const i of t.getAttributeList())e[i.getName()]=n(i);return[{type:"celu",input:t.getInputList(),name:t.getOutputList()[0],a:e.alpha}]}},S={import(r,t){const e=t.getInputList(),i={};for(const s of r.getGraph().getInitializerList())s.getName()===e[1]&&(i.min=o(s)),s.getName()===e[2]&&(i.max=o(s));return[{type:"clip",input:[e[0]],name:t.getOutputList()[0],min:i.min??(e[1]?.length>0?e[1]:void 0),max:i.max??(e[2]?.length>0?e[2]:void 0)}]}},R={import(r,t){const e={};for(const i of t.getAttributeList())e[i.getName()]=n(i);return[{type:"concat",input:t.getInputList(),name:t.getOutputList()[0],axis:e.axis}]}},B={import(r,t){const e={};for(const s of t.getAttributeList())e[s.getName()]=n(s);let i=null;return e.value!=null?i=e.value:e.sparse_value!=null?i=e.sparse_value:e.value_float!=null?i=e.value_float:e.value_floats!=null?i=e.value_floats:e.value_int!=null?i=e.value_int:e.value_ints!=null?i=e.value_ints:e.value_string!=null?i=e.value_string:e.value_strings!=null&&(i=e.value_strings),[{type:"const",value:i,name:t.getOutputList()[0]}]}},P={import(r,t){const e={};for(const p of t.getAttributeList())e[p.getName()]=n(p);const i=t.getInputList(),s={};let a=null;for(const p of r.getGraph().getInitializerList())if(p.getName()===i[1]){s.w=o(p);const u=_.fromArray(s.w);e.kernel_shape||(e.kernel_shape=u.sizes.slice(2)),a=u.sizes[0]}else p.getName()===i[2]&&(s.b=o(p));if(e.group&&e.group!==1)throw new Error(`Invalid attribute 'group' value ${e.group}.`);if(e.strides&&e.strides.some(p=>p!==e.strides[0]))throw new Error(`Invalid attribute 'strides' value ${e.strides}.`);if(e.auto_pad==="SAME_UPPER")e.pads=e.kernel_shape.map(p=>[Math.floor((p-1)/2),Math.ceil((p-1)/2)]);else if(e.auto_pad==="SAME_LOWER")e.pads=e.kernel_shape.map(p=>[Math.ceil((p-1)/2),Math.floor((p-1)/2)]);else{if(e.auto_pad&&e.auto_pad!=="NOTSET")throw new Error(`Invalid attribute 'auto_pad' value ${e.auto_pad}.`);if(e.pads){const p=[];for(let u=0;u<e.pads.length/2;u++)p.push([e.pads[u],e.pads[u+e.pads.length/2]]);e.pads=p}}return[{type:"conv",input:[i[0]],name:t.getOutputList()[0],kernel:e.kernel_shape,channel:a,padding:e.pads||0,stride:e.strides?e.strides[0]:null,w:s.w||i[1],channel_dim:1}]}},D={import(r,t){return[{type:"cos",input:[t.getInputList()[0]],name:t.getOutputList()[0]}]}},H={import(r,t){return[{type:"cosh",input:[t.getInputList()[0]],name:t.getOutputList()[0]}]}},J={import(r,t){return[{type:"div",input:t.getInputList(),name:t.getOutputList()[0]}]}},U={import(r,t){const e={};for(const a of t.getAttributeList())e[a.getName()]=n(a);const i=t.getInputList(),s={};for(const a of r.getGraph().getInitializerList())a.getName()===i[1]?s.ratio=o(a):a.getName()===i[2]&&(s.training_mode=o(a));return[{type:"dropout",input:[i[0]],name:t.getOutputList()[0],drop_rate:s.ratio}]}},V={import(r,t){const e={};for(const i of t.getAttributeList())e[i.getName()]=n(i);return[{type:"elu",input:t.getInputList(),name:t.getOutputList()[0],a:e.alpha}]}},W={import(r,t){return[{type:"equal",input:t.getInputList(),name:t.getOutputList()[0]}]}},j={import(r,t){return[{type:"erf",input:[t.getInputList()[0]],name:t.getOutputList()[0]}]}},C={import(r,t){return[{type:"exp",input:[t.getInputList()[0]],name:t.getOutputList()[0]}]}},F={import(r,t){const e={};for(const i of t.getAttributeList())e[i.getName()]=n(i);if(e.axis&&e.axis!==1)throw new Error(`Invalid attribute 'axis' value ${e.axis}.`);return[{type:"flatten",input:t.getInputList(),name:t.getOutputList()[0]}]}},K={import(r,t){return[{type:"floor",input:[t.getInputList()[0]],name:t.getOutputList()[0]}]}},Q={import(r,t){const e={alpha:1,beta:1};for(const m of t.getAttributeList())e[m.getName()]=n(m);const i=t.getInputList(),s=[];let a=i[0];e.transA&&s.push({type:"transpose",input:[a],name:a+="_t",axis:[1,0]});const p={};for(const m of r.getGraph().getInitializerList())if(m.getName()===i[1])p.w=L.fromArray(o(m)),e.transB&&(p.w=p.w.t),p.w.mult(e.alpha),p.w=p.w.toArray();else if(m.getName()===i[2]){const l=o(m);Array.isArray(l)?Array.isArray(l[0])?(p.b=L.fromArray(l),p.b.mult(e.beta),p.b=p.b.toArray()):p.b=[l.map(f=>f*e.beta)]:p.b=l*e.beta}let u=i[1];p.w||(e.transB&&(s.push({type:"transpose",input:[u],name:i[1]+"_t",axis:[1,0]}),u=i[1]+"_t"),e.alpha!==1&&(s.push({type:"mult",input:[u,e.alpha],name:i[1]+"_mul_a"}),u=i[1]+"_mul_a"));let g=i[2];return g&&!p.b&&e.beta!==1&&(s.push({type:"mult",input:[g,e.beta],name:i[2]+"_mul_b"}),g=i[2]+"_mul_b"),s.push({type:"full",input:[a],name:t.getOutputList()[0],w:p.w||u,b:p.b||g}),s}},X={import(r,t){return[{type:"global_average_pool",input:t.getInputList(),name:t.getOutputList()[0],channel_dim:1}]}},Y={import(r,t){const e={};for(const i of t.getAttributeList())e[i.getName()]=n(i);return[{type:"global_lp_pool",input:t.getInputList(),name:t.getOutputList()[0],p:e.p,channel_dim:1}]}},Z={import(r,t){return[{type:"global_max_pool",input:t.getInputList(),name:t.getOutputList()[0],channel_dim:1}]}},tt={import(r,t){return[{type:"greater",input:t.getInputList(),name:t.getOutputList()[0]}]}},et={import(r,t){return[{type:"greater_or_equal",input:t.getInputList(),name:t.getOutputList()[0]}]}},it={import(r,t){const e={};for(const i of t.getAttributeList())e[i.getName()]=n(i);return[{type:"hard_sigmoid",input:t.getInputList(),name:t.getOutputList()[0],alpha:e.alpha,beta:e.beta}]}},rt={import(r,t){return[{type:"hard_swish",input:[t.getInputList()[0]],name:t.getOutputList()[0]}]}},at={import(r,t){return[{type:"identity",input:[t.getInputList()[0]],name:t.getOutputList()[0]}]}},st={import(r,t){return[{type:"input",name:t.getName()}]}},pt={import(r,t){const e={};for(const i of t.getAttributeList())e[i.getName()]=n(i);if(e.detect_negative===0)throw new Error(`Invalid attribute 'detect_negative' value ${e.detect_negative}.`);if(e.detect_positive===0)throw new Error(`Invalid attribute 'detect_positive' value ${e.detect_positive}.`);return[{type:"is_inf",input:t.getInputList(),name:t.getOutputList()[0]}]}},nt={import(r,t){return[{type:"is_nan",input:t.getInputList(),name:t.getOutputList()[0]}]}},ut={import(r,t){const e={axis:-1,epsilon:1e-5};for(const u of t.getAttributeList())e[u.getName()]=n(u);const i=t.getInputList(),s={};for(const u of r.getGraph().getInitializerList())u.getName()===i[1]?s.scale=o(u):u.getName()===i[2]&&(s.b=o(u));const a=t.getOutputList(),p=[{type:"layer_normalization",input:[i[0]],name:a[0],scale:s.scale??i[1],offset:s.b??i[2],epsilon:e.epsilon??1e-5,axis:e.axis}];return a.length>=2&&p.push({type:"identity",input:[`${a[0]}[mean]`],name:a[1]}),a.length>=3&&p.push({type:"identity",input:[`${a[0]}[invStdDev]`],name:a[2]}),p}},ot={import(r,t){const e={};for(const i of t.getAttributeList())e[i.getName()]=n(i);return[{type:"leaky_relu",input:t.getInputList(),name:t.getOutputList()[0],a:e.alpha??.01}]}},mt={import(r,t){return[{type:"less",input:t.getInputList(),name:t.getOutputList()[0]}]}},lt={import(r,t){return[{type:"less_or_equal",input:t.getInputList(),name:t.getOutputList()[0]}]}},gt={import(r,t){return[{type:"log",input:[t.getInputList()[0]],name:t.getOutputList()[0]}]}},Lt={import(r,t){const e={axis:-1};for(const i of t.getAttributeList())e[i.getName()]=n(i);return[{type:"log_softmax",input:[t.getInputList()[0]],name:t.getOutputList()[0],axis:e.axis}]}},ft={import(r,t){const e={};for(const i of t.getAttributeList())e[i.getName()]=n(i);if(e.strides&&e.strides.some(i=>i!==e.strides[0]))throw new Error(`Invalid attribute 'strides' value ${e.strides}.`);if(e.auto_pad&&e.auto_pad!=="NOTSET")throw new Error(`Invalid attribute 'auto_pad' value ${e.auto_pad}.`);if(e.pads){const i=[];for(let s=0;s<e.pads.length/2;s++)i.push([e.pads[s],e.pads[s+e.pads.length/2]]);e.pads=i}return[{type:"lp_pool",input:[t.getInputList()[0]],name:t.getOutputList()[0],p:e.p,kernel:e.kernel_shape,padding:e.pads||0,stride:e.strides?e.strides[0]:1,channel_dim:1}]}},_t={import(r,t){const e={};for(const i of t.getAttributeList())e[i.getName()]=n(i);return[{type:"lrn",input:[t.getInputList()[0]],name:t.getOutputList()[0],alpha:e.alpha||1e-4,beta:e.beta||.75,k:e.bias||1,n:e.size,channel_dim:1}]}},ct={import(r,t){return[{type:"matmul",input:t.getInputList(),name:t.getOutputList()[0]}]}},ht={import(r,t){return[{type:"max",input:t.getInputList(),name:t.getOutputList()[0]}]}},dt={import(r,t){const e={};for(const i of t.getAttributeList())e[i.getName()]=n(i);if(e.strides&&e.strides.some(i=>i!==e.strides[0]))throw new Error(`Invalid attribute 'strides' value ${e.strides}.`);if(e.auto_pad&&e.auto_pad!=="NOTSET")throw new Error(`Invalid attribute 'auto_pad' value ${e.auto_pad}.`);if(e.pads){const i=[];for(let s=0;s<e.pads.length/2;s++)i.push([e.pads[s],e.pads[s+e.pads.length/2]]);e.pads=i}return[{type:"max_pool",input:[t.getInputList()[0]],name:t.getOutputList()[0],kernel:e.kernel_shape,padding:e.pads||0,stride:e.strides?e.strides[0]:1,channel_dim:1}]}},vt={import(r,t){const e=t.getOutputList()[0];return[{type:"add",input:t.getInputList(),name:e+"_sum"},{type:"div",input:[e+"_sum",t.getInputList().length],name:e}]}},yt={import(r,t){return[{type:"min",input:t.getInputList(),name:t.getOutputList()[0]}]}},bt={import(r,t){return[{type:"mish",input:[t.getInputList()[0]],name:t.getOutputList()[0]}]}},It={import(r,t){const e={};for(const i of t.getAttributeList())e[i.getName()]=n(i);if(e.fmod===1)throw new Error(`Invalid attribute 'fmod' value ${e.fmod}.`);return[{type:"mod",input:t.getInputList(),name:t.getOutputList()[0]}]}},xt={import(r,t){return[{type:"mult",input:t.getInputList(),name:t.getOutputList()[0]}]}},wt={import(r,t){return[{type:"negative",input:[t.getInputList()[0]],name:t.getOutputList()[0]}]}},Ot={import(r,t){return[{type:"not",input:t.getInputList(),name:t.getOutputList()[0]}]}},Nt={import(r,t){return[{type:"or",input:t.getInputList(),name:t.getOutputList()[0]}]}},zt={import(r,t){return[{type:"output",input:t.getName()}]}},kt={import(r,t){const e=t.getInputList(),i={};for(const a of r.getGraph().getInitializerList())a.getName()===e[1]&&(i.exponent=o(a));const s=[];return i.exponent&&s.push({type:"const",input:[],name:e[1],value:i.exponent}),s.push({type:"power",input:e,name:t.getOutputList()[0]}),s}},At={import(r,t){const e=t.getInputList(),i={};for(const s of r.getGraph().getInitializerList())s.getName()===e[1]&&(i.slope=o(s));return[{type:"prelu",input:[e[0]],name:t.getOutputList()[0],a:i.slope||e[1]}]}},Et={import(r,t){return[{type:"reciprocal",input:[t.getInputList()[0]],name:t.getOutputList()[0]}]}},$t={import(r,t){const e={keepdims:1,noop_with_empty_axes:0};for(const a of t.getAttributeList())e[a.getName()]=n(a);if(e.noop_with_empty_axes!==0)throw new Error(`Invalid noop_with_empty_axes value ${e.noop_with_empty_axes}.`);const i=t.getInputList(),s={};for(const a of r.getGraph().getInitializerList())a.getName()===i[1]&&(s.axis=o(a));return[{type:"abs",input:[i[0]]},{type:"sum",name:t.getOutputList()[0],axis:s.axis||i[1]||-1,keepdims:!!e.keepdims}]}},Gt={import(r,t){const e={keepdims:1,noop_with_empty_axes:0};for(const a of t.getAttributeList())e[a.getName()]=n(a);if(e.noop_with_empty_axes!==0)throw new Error(`Invalid noop_with_empty_axes value ${e.noop_with_empty_axes}.`);const i=t.getInputList(),s={};for(const a of r.getGraph().getInitializerList())a.getName()===i[1]&&(s.axis=o(a));return[{type:"square",input:[i[0]]},{type:"sum",axis:s.axis||i[1]||-1,keepdims:!!e.keepdims},{type:"sqrt",name:t.getOutputList()[0]}]}},qt={import(r,t){const e={keepdims:1,noop_with_empty_axes:0};for(const a of t.getAttributeList())e[a.getName()]=n(a);if(e.noop_with_empty_axes!==0)throw new Error(`Invalid noop_with_empty_axes value ${e.noop_with_empty_axes}.`);const i=t.getInputList(),s={};for(const a of r.getGraph().getInitializerList())a.getName()===i[1]&&(s.axis=o(a));return[{type:"sum",input:[i[0]],axis:s.axis||i[1]||-1,keepdims:!!e.keepdims},{type:"log",name:t.getOutputList()[0]}]}},Tt={import(r,t){const e={keepdims:1,noop_with_empty_axes:0};for(const a of t.getAttributeList())e[a.getName()]=n(a);if(e.noop_with_empty_axes!==0)throw new Error(`Invalid noop_with_empty_axes value ${e.noop_with_empty_axes}.`);const i=t.getInputList(),s={};for(const a of r.getGraph().getInitializerList())a.getName()===i[1]&&(s.axis=o(a));return[{type:"exp",input:[i[0]]},{type:"sum",axis:s.axis||i[1]||-1,keepdims:!!e.keepdims},{type:"log",name:t.getOutputList()[0]}]}},Mt={import(r,t){const e={keepdims:1,noop_with_empty_axes:0};for(const a of t.getAttributeList())e[a.getName()]=n(a);if(e.noop_with_empty_axes!==0)throw new Error(`Invalid noop_with_empty_axes value ${e.noop_with_empty_axes}.`);const i=t.getInputList(),s={};for(const a of r.getGraph().getInitializerList())a.getName()===i[1]&&(s.axis=o(a));return[{type:"reduce_max",input:[i[0]],name:t.getOutputList()[0],axis:s.axis||i[1]||-1,keepdims:!!e.keepdims}]}},St={import(r,t){const e={keepdims:1,noop_with_empty_axes:0};for(const a of t.getAttributeList())e[a.getName()]=n(a);if(e.noop_with_empty_axes!==0)throw new Error(`Invalid noop_with_empty_axes value ${e.noop_with_empty_axes}.`);const i=t.getInputList(),s={};for(const a of r.getGraph().getInitializerList())a.getName()===i[1]&&(s.axis=o(a));return[{type:"mean",input:[i[0]],name:t.getOutputList()[0],axis:s.axis||i[1]||-1,keepdims:!!e.keepdims}]}},Rt={import(r,t){const e={keepdims:1,noop_with_empty_axes:0};for(const a of t.getAttributeList())e[a.getName()]=n(a);if(e.noop_with_empty_axes!==0)throw new Error(`Invalid noop_with_empty_axes value ${e.noop_with_empty_axes}.`);const i=t.getInputList(),s={};for(const a of r.getGraph().getInitializerList())a.getName()===i[1]&&(s.axis=o(a));return[{type:"reduce_min",input:[i[0]],name:t.getOutputList()[0],axis:s.axis||i[1]||-1,keepdims:!!e.keepdims}]}},Bt={import(r,t){const e={keepdims:1,noop_with_empty_axes:0};for(const a of t.getAttributeList())e[a.getName()]=n(a);if(e.noop_with_empty_axes!==0)throw new Error(`Invalid noop_with_empty_axes value ${e.noop_with_empty_axes}.`);const i=t.getInputList(),s={};for(const a of r.getGraph().getInitializerList())a.getName()===i[1]&&(s.axis=o(a));return[{type:"prod",input:[i[0]],name:t.getOutputList()[0],axis:s.axis||i[1]||-1,keepdims:!!e.keepdims}]}},Pt={import(r,t){const e={keepdims:1,noop_with_empty_axes:0};for(const a of t.getAttributeList())e[a.getName()]=n(a);if(e.noop_with_empty_axes!==0)throw new Error(`Invalid noop_with_empty_axes value ${e.noop_with_empty_axes}.`);const i=t.getInputList(),s={};for(const a of r.getGraph().getInitializerList())a.getName()===i[1]&&(s.axis=o(a));return[{type:"sum",input:[i[0]],name:t.getOutputList()[0],axis:s.axis||i[1]||-1,keepdims:!!e.keepdims}]}},Dt={import(r,t){const e={keepdims:1,noop_with_empty_axes:0};for(const a of t.getAttributeList())e[a.getName()]=n(a);if(e.noop_with_empty_axes!==0)throw new Error(`Invalid noop_with_empty_axes value ${e.noop_with_empty_axes}.`);const i=t.getInputList(),s={};for(const a of r.getGraph().getInitializerList())a.getName()===i[1]&&(s.axis=o(a));return[{type:"square",input:[i[0]]},{type:"sum",name:t.getOutputList()[0],axis:s.axis||i[1]||-1,keepdims:!!e.keepdims}]}},Ht={import(r,t){return[{type:"relu",input:[t.getInputList()[0]],name:t.getOutputList()[0]}]}},Jt={import(r,t){const e={};for(const a of t.getAttributeList())e[a.getName()]=n(a);const i=t.getInputList(),s={};for(const a of r.getGraph().getInitializerList())a.getName()===i[1]&&(s.shape=o(a));if(s.shape[0]===-1)s.shape=s.shape.slice(1);else if(s.shape.some(a=>a===-1))throw new Error(`Invalid shape value ${JSON.stringify(s.shape)}.`);return[{type:"reshape",input:[i[0]],name:t.getOutputList()[0],size:s.shape}]}},Ut={import(r,t){return[{type:"round",input:[t.getInputList()[0]],name:t.getOutputList()[0]}]}},Vt={import(r,t){const e={};for(const i of t.getAttributeList())e[i.getName()]=n(i);return[{type:"selu",input:t.getInputList(),name:t.getOutputList()[0],a:e.alpha,g:e.gamma}]}},Wt={import(r,t){const e={};for(const i of t.getAttributeList())e[i.getName()]=n(i);if(e.start!=null&&e.start!==0)throw new Error(`Invalid attribute 'start' value ${e.start}.`);if(e.end!=null)throw new Error(`Invalid attribute 'end' value ${e.end}.`);return[{type:"shape",input:t.getInputList(),name:t.getOutputList()[0]}]}},jt={import(r,t){const e={bias:0,lambd:.5};for(const i of t.getAttributeList())e[i.getName()]=n(i);if(e.bias===0)return[{type:"hard_shrink",input:t.getInputList(),name:t.getOutputList()[0],l:e.lambd}];if(e.bias===e.lambd)return[{type:"soft_shrink",input:t.getInputList(),name:t.getOutputList()[0],l:e.lambd}];throw new Error(`Invalid attribute 'bias' value ${e.bias}.`)}},Ct={import(r,t){return[{type:"sigmoid",input:[t.getInputList()[0]],name:t.getOutputList()[0]}]}},Ft={import(r,t){return[{type:"sign",input:[t.getInputList()[0]],name:t.getOutputList()[0]}]}},Kt={import(r,t){return[{type:"sin",input:[t.getInputList()[0]],name:t.getOutputList()[0]}]}},Qt={import(r,t){return[{type:"sinh",input:[t.getInputList()[0]],name:t.getOutputList()[0]}]}},Xt={import(r,t){const e={axis:-1};for(const i of t.getAttributeList())e[i.getName()]=n(i);return[{type:"softmax",input:[t.getInputList()[0]],name:t.getOutputList()[0],axis:e.axis}]}},Yt={import(r,t){return[{type:"softplus",input:[t.getInputList()[0]],name:t.getOutputList()[0],beta:1}]}},Zt={import(r,t){return[{type:"softsign",input:[t.getInputList()[0]],name:t.getOutputList()[0]}]}},te={import(r,t){return[{type:"sqrt",input:[t.getInputList()[0]],name:t.getOutputList()[0]}]}},ee={import(r,t){return[{type:"sub",input:t.getInputList(),name:t.getOutputList()[0]}]}},ie={import(r,t){return[{type:"add",input:t.getInputList(),name:t.getOutputList()[0]}]}},re={import(r,t){return[{type:"tan",input:[t.getInputList()[0]],name:t.getOutputList()[0]}]}},ae={import(r,t){return[{type:"tanh",input:[t.getInputList()[0]],name:t.getOutputList()[0]}]}},se={import(r,t){const e={};for(const i of t.getAttributeList())e[i.getName()]=n(i);return[{type:"thresholded_relu",input:t.getInputList(),name:t.getOutputList()[0],a:e.alpha}]}},pe={import(r,t){const e={};for(const i of t.getAttributeList())e[i.getName()]=n(i);return[{type:"transpose",input:[t.getInputList()[0]],name:t.getOutputList()[0],axis:e.perm}]}},ne={import(r,t){return[{type:"cond",input:t.getInputList(),name:t.getOutputList()[0]}]}},ue={import(r,t){return[{type:"xor",input:t.getInputList(),name:t.getOutputList()[0]}]}};export{c as abs,h as acos,d as acosh,v as add,y as and,b as argmax,I as argmin,x as asin,w as asinh,O as atan,N as atanh,z as averagepool,k as batchnormalization,A as bitshift,E as bitwiseand,$ as bitwisenot,G as bitwiseor,q as bitwisexor,T as ceil,M as celu,S as clip,R as concat,B as constant,P as conv,D as cos,H as cosh,J as div,U as dropout,V as elu,W as equal,j as erf,C as exp,F as flatten,K as floor,Q as gemm,X as globalaveragepool,Y as globallppool,Z as globalmaxpool,tt as greater,et as greaterorequal,it as hardsigmoid,rt as hardswish,at as identity,st as input,pt as isinf,nt as isnan,ut as layernormalization,ot as leakyrelu,mt as less,lt as lessorequal,gt as log,Lt as logsoftmax,ft as lppool,_t as lrn,ct as matmul,ht as max,dt as maxpool,vt as mean,yt as min,bt as mish,It as mod,xt as mul,wt as neg,Ot as not,Nt as or,zt as output,kt as pow,At as prelu,Et as reciprocal,$t as reducel1,Gt as reducel2,qt as reducelogsum,Tt as reducelogsumexp,Mt as reducemax,St as reducemean,Rt as reducemin,Bt as reduceprod,Pt as reducesum,Dt as reducesumsquare,Ht as relu,Jt as reshape,Ut as round,Vt as selu,Wt as shape,jt as shrink,Ct as sigmoid,Ft as sign,Kt as sin,Qt as sinh,Xt as softmax,Yt as softplus,Zt as softsign,te as sqrt,ee as sub,ie as sum,re as tan,ae as tanh,se as thresholdedrelu,pe as transpose,ne as where,ue as xor};
