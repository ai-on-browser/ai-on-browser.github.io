import{onnx as t}from"../onnx_exporter.js";const i=[t.TensorProto.DataType.INT8,t.TensorProto.DataType.INT16,t.TensorProto.DataType.INT32,t.TensorProto.DataType.INT64,t.TensorProto.DataType.UINT8,t.TensorProto.DataType.UINT16,t.TensorProto.DataType.UINT32,t.TensorProto.DataType.UINT64];export default{export(T,o,u){if(!Array.isArray(o.input))throw new Error(`Invalid attribute 'input' value ${o.input}.`);const p=T.getGraph(),a=new t.NodeProto;if(o.input.length===1){a.setOpType("Identity"),a.addInput(o.input[0]),a.addOutput(o.name),p.addNode(a);return}const r=[];for(const n of o.input)if(i.includes(u[n].type))r.push(n);else{const e=new t.NodeProto;e.setOpType("Cast"),e.addInput(n),e.addOutput(`${o.name}_${n}_cast`);const d=new t.AttributeProto;d.setName("to"),d.setType(t.AttributeProto.AttributeType.INT),d.setI(t.TensorProto.DataType.INT32),e.addAttribute(d),p.addNode(e),r.push(`${o.name}_${n}_cast`)}let s=r[0];for(let n=1;n<r.length-1;n++){const e=new t.NodeProto;e.setOpType("BitwiseAnd"),e.addInput(s),e.addInput(r[n]),e.addOutput(s=o.name+`_bitwiseand_${n-1}`),p.addNode(e)}return a.setOpType("BitwiseAnd"),a.addInput(s),a.addInput(r.at(-1)),a.addOutput(o.name),p.addNode(a),{type:t.TensorProto.DataType.INT32}}};
