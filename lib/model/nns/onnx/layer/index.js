var V=Object.defineProperty;var q=(u,t)=>V(u,"name",{value:t,configurable:!0});import K,{onnx as e}from"../onnx_exporter.js";import{getConstNodeName as O}from"../utils.js";import U from"../../../../util/tensor.js";import C from"../../../../util/matrix.js";var W={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("Abs"),n.addInput(r),n.addOutput(t.name),u.getGraph().addNode(n)}},H={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("Acos"),n.addInput(r),n.addOutput(t.name),u.getGraph().addNode(n)}},X={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("Acosh"),n.addInput(r),n.addOutput(t.name),u.getGraph().addNode(n)}},J={export(u,t){if(!Array.isArray(t.input))throw new Error(`Invalid attribute 'input' value ${t.input}.`);const r=new e.NodeProto;r.setOpType(t.input.length===2?"Add":"Sum");for(const d of t.input)r.addInput(d);r.addOutput(t.name),u.getGraph().addNode(r)}},Q={export(u,t,r){if(!Array.isArray(t.input))throw new Error(`Invalid attribute 'input' value ${t.input}.`);const n=u.getGraph(),d=new e.NodeProto;if(t.input.length===1){d.setOpType("Identity"),d.addInput(t.input[0]),d.addOutput(t.name),n.addNode(d);return}const a=[];for(const s of t.input)if(r[s].type===e.TensorProto.DataType.BOOL)a.push(s);else{const o=new e.NodeProto;o.setOpType("Cast"),o.addInput(s),o.addOutput(`${t.name}_${s}_cast`);const i=new e.AttributeProto;i.setName("to"),i.setType(e.AttributeProto.AttributeType.INT),i.setI(e.TensorProto.DataType.BOOL),o.addAttribute(i),n.addNode(o),a.push(`${t.name}_${s}_cast`)}let p=a[0];for(let s=1;s<a.length-1;s++){const o=new e.NodeProto;o.setOpType("And"),o.addInput(p),o.addInput(a[s]),o.addOutput(p=t.name+`_and_${s-1}`),n.addNode(o)}return d.setOpType("And"),d.addInput(p),d.addInput(a.at(-1)),d.addOutput(t.name),n.addNode(d),{type:e.TensorProto.DataType.BOOL}}},Y={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("Relu"),n.addInput(r),n.addOutput(t.name+"_base");const d=u.getGraph();d.addNode(n);const a=new e.NodeProto;a.setOpType("Sum"),a.addInput(t.name+"_base");const p=t.s??2,s=Array.isArray(t.a)?t.a:Array(p).fill(t.a??.1),o=Array.isArray(t.b)?t.b:Array(p).fill(t.b??0);for(let i=0;i<p;i++){const m=new e.TensorProto;m.setName(t.name+"_a_"+i),m.setDataType(e.TensorProto.DataType.FLOAT),m.setDimsList([1]),m.setFloatDataList([s[i]]);const T=new e.TensorProto;T.setName(t.name+"_b_"+i),T.setDataType(e.TensorProto.DataType.FLOAT),T.setDimsList([1]),T.setFloatDataList([o[i]]);const y=new e.NodeProto;y.setOpType("Sub"),y.addInput(t.name+"_b_"+i),y.addInput(r),y.addOutput(t.name+"_sub_"+i);const c=new e.NodeProto;c.setOpType("Relu"),c.addInput(t.name+"_sub_"+i),c.addOutput(t.name+"_relu_"+i);const _=new e.NodeProto;_.setOpType("Mul"),_.addInput(t.name+"_relu_"+i),_.addInput(t.name+"_a_"+i),_.addOutput(t.name+"_mul_"+i),a.addInput(t.name+"_mul_"+i),d.addInitializer(m),d.addInitializer(T),d.addNode(y),d.addNode(c),d.addNode(_)}a.addOutput(t.name),d.addNode(a)}},Z={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("Exp"),n.addInput(r),n.addOutput(t.name+"_exp");const d=new e.TensorProto;d.setName(t.name+"_l"),d.setDataType(e.TensorProto.DataType.FLOAT),d.setDimsList([1]),d.setFloatDataList([t.l??2]);const a=O(u,1),p=new e.NodeProto;p.setOpType("Mul"),p.addInput(t.name+"_exp"),p.addInput(t.name+"_l"),p.addOutput(t.name+"_mult");const s=new e.NodeProto;s.setOpType("Add"),s.addInput(t.name+"_mult"),s.addInput(a),s.addOutput(t.name+"_add");const o=new e.NodeProto;o.setOpType("Reciprocal"),o.addInput(t.name+"_add"),o.addOutput(t.name+"_reciprocal");const i=new e.NodeProto;i.setOpType("Reciprocal"),i.addInput(t.name+"_l"),i.addOutput(t.name+"_reciprocal_pow");const m=new e.NodeProto;m.setOpType("Pow"),m.addInput(t.name+"_reciprocal"),m.addInput(t.name+"_reciprocal_pow"),m.addOutput(t.name+"_pow");const T=new e.NodeProto;T.setOpType("Sub"),T.addInput(a),T.addInput(t.name+"_pow"),T.addOutput(t.name);const y=u.getGraph();y.addInitializer(d),y.addNode(n),y.addNode(p),y.addNode(s),y.addNode(o),y.addNode(i),y.addNode(m),y.addNode(T)}},b={export(u,t,r){const n=u.getGraph(),d=Array.isArray(t.input)?t.input[0]:t.input,a=new e.NodeProto;a.setOpType("ArgMax"),a.addInput(d),a.addOutput(t.name);const p=new e.AttributeProto;p.setName("axis"),p.setType(e.AttributeProto.AttributeType.INT),p.setI(t.axis??-1),a.addAttribute(p);const s=new e.AttributeProto;s.setName("keepdims"),s.setType(e.AttributeProto.AttributeType.INT),s.setI(t.keepdims??!0?1:0),a.addAttribute(s),n.addNode(a);const o=r[d].size.concat(),i=p.getI()<0?p.getI()+o.length:p.getI();return t.keepdims??!0?o[i]=1:o.splice(i,1),{type:e.TensorProto.DataType.INT64,size:o}}},j={export(u,t,r){const n=u.getGraph(),d=Array.isArray(t.input)?t.input[0]:t.input,a=new e.NodeProto;a.setOpType("ArgMin"),a.addInput(d),a.addOutput(t.name);const p=new e.AttributeProto;p.setName("axis"),p.setType(e.AttributeProto.AttributeType.INT),p.setI(t.axis??-1),a.addAttribute(p);const s=new e.AttributeProto;s.setName("keepdims"),s.setType(e.AttributeProto.AttributeType.INT),s.setI(t.keepdims??!0?1:0),a.addAttribute(s),n.addNode(a);const o=r[d].size.concat(),i=p.getI()<0?p.getI()+o.length:p.getI();return t.keepdims??!0?o[i]=1:o.splice(i,1),{type:e.TensorProto.DataType.INT64,size:o}}},tt={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("Asin"),n.addInput(r),n.addOutput(t.name),u.getGraph().addNode(n)}},et={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("Asinh"),n.addInput(r),n.addOutput(t.name),u.getGraph().addNode(n)}},nt={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("Atan"),n.addInput(r),n.addOutput(t.name),u.getGraph().addNode(n)}},at={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("Atanh"),n.addInput(r),n.addOutput(t.name),u.getGraph().addNode(n)}},dt={export(u,t,r){const n=u.getGraph(),d=Array.isArray(t.input)?t.input[0]:t.input,a=r[d].size.concat(),p=new e.NodeProto;p.setOpType("AveragePool");const s=Array(a.length).fill(null);if(s[0]=a[0],t.channel_dim===1)p.addInput(d),p.addOutput(t.name),s[1]=a[1];else if(t.channel_dim==null||t.channel_dim===-1){const c=new e.NodeProto;c.setOpType("Transpose"),c.addInput(d),c.addOutput(t.name+"_t1");const _=new e.AttributeProto;_.setName("perm"),_.setType(e.AttributeProto.AttributeType.INTS);const l=Array.from(a,(w,h)=>h-1);l[0]=0,l[1]=a.length-1,_.setIntsList(l),c.addAttribute(_),n.addNode(c),p.addInput(t.name+"_t1"),p.addOutput(t.name+"_ap");const N=new e.NodeProto;N.setOpType("Transpose"),N.addInput(t.name+"_ap"),N.addOutput(t.name);const I=new e.AttributeProto;I.setName("perm"),I.setType(e.AttributeProto.AttributeType.INTS);const A=Array.from(a,(w,h)=>h+1);A[0]=0,A[A.length-1]=1,I.setIntsList(A),N.addAttribute(I),n.addNode(N),s[a.length-1]=a[a.length-1]}else throw new Error(`Not implemented value of attribute 'channel_dim' ${t.channel_dim}.`);const o=Array.isArray(t.kernel)?t.kernel:Array(a.length-2).fill(t.kernel),i=new e.AttributeProto;i.setName("kernel_shape"),i.setType(e.AttributeProto.AttributeType.INTS),i.setIntsList(o),p.addAttribute(i);const m=t.stride??t.kernel,T=Array.isArray(m)?m:Array(o.length).fill(m??1),y=new e.AttributeProto;if(y.setName("strides"),y.setType(e.AttributeProto.AttributeType.INTS),y.setIntsList(T),p.addAttribute(y),t.padding!=null){const c=new e.AttributeProto;c.setName("pads"),c.setType(e.AttributeProto.AttributeType.INTS),c.setIntsList(Array.isArray(t.padding)?Array.isArray(t.padding[0])?[...t.padding.map(_=>_[0]),...t.padding.map(_=>_[1])]:[].concat(t.padding,t.padding):Array(o.length*2).fill(t.padding)),p.addAttribute(c)}else{const c=t.channel_dim===1?a.slice(2):a.slice(1,-1);if(c.some(_=>_==null)){const _=new e.AttributeProto;_.setName("auto_pad"),_.setType(e.AttributeProto.AttributeType.STRING),_.setS(new TextEncoder().encode("VALID")),p.addAttribute(_)}else{const _=c.map((N,I)=>(N-o[I])%T[I]),l=new e.AttributeProto;l.setName("pads"),l.setType(e.AttributeProto.AttributeType.INTS),l.setIntsList([...Array(o.length).fill(0),..._]),p.addAttribute(l)}}return n.addNode(p),{size:s}}},pt={export(u,t,r){const n=u.getGraph(),d=Array.isArray(t.input)?t.input[0]:t.input,a=r[d].size.concat(),p=new e.NodeProto;if(p.setOpType("BatchNormalization"),t.channel_dim===1)p.addInput(d),p.addOutput(t.name);else if(t.channel_dim==null||t.channel_dim===-1){const T=new e.NodeProto;T.setOpType("Transpose"),T.addInput(d),T.addOutput(t.name+"_t1");const y=new e.AttributeProto;y.setName("perm"),y.setType(e.AttributeProto.AttributeType.INTS);const c=Array.from(a,(I,A)=>A-1);c[0]=0,c[1]=a.length-1,y.setIntsList(c),T.addAttribute(y),n.addNode(T),p.addInput(t.name+"_t1"),p.addOutput(t.name+"_ap");const _=new e.NodeProto;_.setOpType("Transpose"),_.addInput(t.name+"_ap"),_.addOutput(t.name);const l=new e.AttributeProto;l.setName("perm"),l.setType(e.AttributeProto.AttributeType.INTS);const N=Array.from(a,(I,A)=>A+1);N[0]=0,N[N.length-1]=1,l.setIntsList(N),_.addAttribute(l),n.addNode(_)}else throw new Error(`Not implemented value of attribute 'channel_dim' ${t.channel_dim}.`);const s=new e.AttributeProto;s.setName("training_mode"),s.setType(e.AttributeProto.AttributeType.INT),s.setI(0),p.addAttribute(s);const o=t.channel_dim===1?1:a.length-1;if(typeof t.scale=="string")p.addInput(t.scale);else{if(!Array.isArray(t.scale)&&a[o]==null)throw new Error("Size of channel dim must be specified if scale is scalar.");const T=Array.isArray(t.scale)?t.scale:Array(a[o]).fill(t.scale??1),y=new e.TensorProto;y.setName(t.name+"_scale"),y.setDataType(e.TensorProto.DataType.FLOAT),y.setDimsList([T.length]),y.setFloatDataList(T),n.addInitializer(y),p.addInput(t.name+"_scale")}if(typeof t.offset=="string")p.addInput(t.offset);else{if(!Array.isArray(t.offset)&&a[o]==null)throw new Error("Size of channel dim must be specified if offset is scalar.");const T=Array.isArray(t.offset)?t.offset:Array(a[o]).fill(t.offset??0),y=new e.TensorProto;y.setName(t.name+"_offset"),y.setDataType(e.TensorProto.DataType.FLOAT),y.setDimsList([T.length]),y.setFloatDataList(T),n.addInitializer(y),p.addInput(t.name+"_offset")}let i=null;const m=q(()=>{if(i)return;const T=Array.from(a,(y,c)=>c);T.splice(o,1),i=new e.TensorProto,i.setName(t.name+"_reduce_axis"),i.setDataType(e.TensorProto.DataType.INT64),i.setDimsList([T.length]),i.setInt64DataList(T),n.addInitializer(i)},"readyReduceAxisTensor");if(typeof t.input_mean=="string")p.addInput(t.input_mean);else if(t.input_mean){const T=new e.TensorProto;T.setName(t.name+"_input_mean"),T.setDataType(e.TensorProto.DataType.FLOAT),T.setDimsList([t.input_mean.length]),T.setFloatDataList(t.input_mean),n.addInitializer(T),p.addInput(t.name+"_input_mean")}else{m();const T=new e.NodeProto;T.setOpType("ReduceMean"),T.addInput(d),T.addInput(t.name+"_reduce_axis"),T.addOutput(t.name+"_input_mean");const y=new e.AttributeProto;y.setName("keepdims"),y.setType(e.AttributeProto.AttributeType.INT),y.setI(0),T.addAttribute(y),n.addNode(T),p.addInput(t.name+"_input_mean")}if(typeof t.input_var=="string")p.addInput(t.input_var);else if(t.input_var){const T=new e.TensorProto;T.setName(t.name+"_input_var"),T.setDataType(e.TensorProto.DataType.FLOAT),T.setDimsList([t.input_var.length]),T.setFloatDataList(t.input_var),n.addInitializer(T),p.addInput(t.name+"_input_var")}else{m();const T=new e.AttributeProto;T.setName("keepdims"),T.setType(e.AttributeProto.AttributeType.INT),T.setI(0);const y=new e.NodeProto;y.setOpType("ReduceMean"),y.addInput(d),y.addInput(t.name+"_reduce_axis"),y.addOutput(t.name+"_input_var_mean"),n.addNode(y);const c=new e.NodeProto;c.setOpType("Sub"),c.addInput(d),c.addInput(t.name+"_input_var_mean"),c.addOutput(t.name+"_input_var_sub"),n.addNode(c);const _=new e.NodeProto;_.setOpType("Mul"),_.addInput(t.name+"_input_var_sub"),_.addInput(t.name+"_input_var_sub"),_.addOutput(t.name+"_input_var_mul"),n.addNode(_);const l=new e.NodeProto;l.setOpType("ReduceMean"),l.addInput(t.name+"_input_var_mul"),l.addInput(t.name+"_reduce_axis"),l.addOutput(t.name+"_input_var"),l.addAttribute(T),n.addNode(l),p.addInput(t.name+"_input_var")}n.addNode(p)}},rt={export(u,t){const r=O(u,1),n=O(u,2),d=new e.TensorProto;d.setName(t.name+"_alpha"),d.setDataType(e.TensorProto.DataType.FLOAT),d.setDimsList([1]),d.setFloatDataList([t.alpha??1]);const a=Array.isArray(t.input)?t.input[0]:t.input,p=new e.NodeProto;p.setOpType("Neg"),p.addInput(a),p.addOutput(t.name+"_neg");const s=new e.NodeProto;s.setOpType("Exp"),s.addInput(t.name+"_neg"),s.addOutput(t.name+"_neg_exp");const o=new e.NodeProto;o.setOpType("Add"),o.addInput(r),o.addInput(t.name+"_neg_exp"),o.addOutput(t.name+"_neg_exp_add1");const i=new e.NodeProto;i.setOpType("Reciprocal"),i.addInput(t.name+"_neg_exp_add1"),i.addOutput(t.name+"_term1");const m=new e.NodeProto;m.setOpType("Sub"),m.addInput(t.name+"_neg"),m.addInput(t.name+"_alpha"),m.addOutput(t.name+"_neg_sub");const T=new e.NodeProto;T.setOpType("Exp"),T.addInput(t.name+"_neg_sub"),T.addOutput(t.name+"_neg_sub_exp");const y=new e.NodeProto;y.setOpType("Add"),y.addInput(r),y.addInput(t.name+"_neg_sub_exp"),y.addOutput(t.name+"_neg_sub_exp_add1");const c=new e.NodeProto;c.setOpType("Reciprocal"),c.addInput(t.name+"_neg_sub_exp_add1"),c.addOutput(t.name+"_term2");const _=new e.NodeProto;_.setOpType("Sub"),_.addInput(t.name+"_term1"),_.addInput(t.name+"_term2"),_.addOutput(t.name+"_sub");const l=new e.NodeProto;l.setOpType("Div"),l.addInput(t.name+"_sub"),l.addInput(n),l.addOutput(t.name);const N=u.getGraph();N.addInitializer(d),N.addNode(p),N.addNode(s),N.addNode(o),N.addNode(i),N.addNode(m),N.addNode(T),N.addNode(y),N.addNode(c),N.addNode(_),N.addNode(l)}},st={export(u,t){const r=O(u,1),n=O(u,2),d=Array.isArray(t.input)?t.input[0]:t.input,a=new e.NodeProto;a.setOpType("Pow"),a.addInput(d),a.addInput(n),a.addOutput(t.name+"_pow");const p=new e.NodeProto;p.setOpType("Add"),p.addInput(t.name+"_pow"),p.addInput(r),p.addOutput(t.name+"_add1");const s=new e.NodeProto;s.setOpType("Sqrt"),s.addInput(t.name+"_add1"),s.addOutput(t.name+"_sqrt");const o=new e.NodeProto;o.setOpType("Sub"),o.addInput(t.name+"_sqrt"),o.addInput(r),o.addOutput(t.name+"_sub1");const i=new e.NodeProto;i.setOpType("Div"),i.addInput(t.name+"_sub1"),i.addInput(n),i.addOutput(t.name+"_div");const m=new e.NodeProto;m.setOpType("Add"),m.addInput(d),m.addInput(t.name+"_div"),m.addOutput(t.name);const T=u.getGraph();T.addNode(a),T.addNode(p),T.addNode(s),T.addNode(o),T.addNode(i),T.addNode(m)}};const ot=[e.TensorProto.DataType.INT8,e.TensorProto.DataType.INT16,e.TensorProto.DataType.INT32,e.TensorProto.DataType.INT64,e.TensorProto.DataType.UINT8,e.TensorProto.DataType.UINT16,e.TensorProto.DataType.UINT32,e.TensorProto.DataType.UINT64];var ut={export(u,t,r){if(!Array.isArray(t.input))throw new Error(`Invalid attribute 'input' value ${t.input}.`);const n=u.getGraph(),d=new e.NodeProto;if(t.input.length===1){d.setOpType("Identity"),d.addInput(t.input[0]),d.addOutput(t.name),n.addNode(d);return}const a=[];for(const s of t.input)if(ot.includes(r[s].type))a.push(s);else{const o=new e.NodeProto;o.setOpType("Cast"),o.addInput(s),o.addOutput(`${t.name}_${s}_cast`);const i=new e.AttributeProto;i.setName("to"),i.setType(e.AttributeProto.AttributeType.INT),i.setI(e.TensorProto.DataType.INT32),o.addAttribute(i),n.addNode(o),a.push(`${t.name}_${s}_cast`)}let p=a[0];for(let s=1;s<a.length-1;s++){const o=new e.NodeProto;o.setOpType("BitwiseAnd"),o.addInput(p),o.addInput(a[s]),o.addOutput(p=t.name+`_bitwiseand_${s-1}`),n.addNode(o)}return d.setOpType("BitwiseAnd"),d.addInput(p),d.addInput(a.at(-1)),d.addOutput(t.name),n.addNode(d),{type:e.TensorProto.DataType.INT32}}},it={export(u,t,r){const n=u.getGraph(),d=new e.NodeProto;d.setOpType("BitwiseNot");const a=Array.isArray(t.input)?t.input[0]:t.input;let p=e.TensorProto.DataType.INT32;if([e.TensorProto.DataType.INT8,e.TensorProto.DataType.INT16,e.TensorProto.DataType.INT32,e.TensorProto.DataType.INT64,e.TensorProto.DataType.UINT8,e.TensorProto.DataType.UINT16,e.TensorProto.DataType.UINT32,e.TensorProto.DataType.UINT64].includes(r[a].type))d.addInput(a),p=r[a].type;else{const s=new e.NodeProto;s.setOpType("Cast"),s.addInput(a),s.addOutput(`${t.name}_${a}_cast`);const o=new e.AttributeProto;o.setName("to"),o.setType(e.AttributeProto.AttributeType.INT),o.setI(e.TensorProto.DataType.INT32),s.addAttribute(o),n.addNode(s),d.addInput(`${t.name}_${a}_cast`)}return d.addOutput(t.name),n.addNode(d),{type:p}}};const mt=[e.TensorProto.DataType.INT8,e.TensorProto.DataType.INT16,e.TensorProto.DataType.INT32,e.TensorProto.DataType.INT64,e.TensorProto.DataType.UINT8,e.TensorProto.DataType.UINT16,e.TensorProto.DataType.UINT32,e.TensorProto.DataType.UINT64];var Tt={export(u,t,r){if(!Array.isArray(t.input))throw new Error(`Invalid attribute 'input' value ${t.input}.`);const n=u.getGraph(),d=new e.NodeProto;if(t.input.length===1){d.setOpType("Identity"),d.addInput(t.input[0]),d.addOutput(t.name),n.addNode(d);return}const a=[];for(const s of t.input)if(mt.includes(r[s].type))a.push(s);else{const o=new e.NodeProto;o.setOpType("Cast"),o.addInput(s),o.addOutput(`${t.name}_${s}_cast`);const i=new e.AttributeProto;i.setName("to"),i.setType(e.AttributeProto.AttributeType.INT),i.setI(e.TensorProto.DataType.INT32),o.addAttribute(i),n.addNode(o),a.push(`${t.name}_${s}_cast`)}let p=a[0];for(let s=1;s<a.length-1;s++){const o=new e.NodeProto;o.setOpType("BitwiseOr"),o.addInput(p),o.addInput(a[s]),o.addOutput(p=t.name+`_bitwiseor_${s-1}`),n.addNode(o)}return d.setOpType("BitwiseOr"),d.addInput(p),d.addInput(a.at(-1)),d.addOutput(t.name),n.addNode(d),{type:e.TensorProto.DataType.INT32}}};const yt=[e.TensorProto.DataType.INT8,e.TensorProto.DataType.INT16,e.TensorProto.DataType.INT32,e.TensorProto.DataType.INT64,e.TensorProto.DataType.UINT8,e.TensorProto.DataType.UINT16,e.TensorProto.DataType.UINT32,e.TensorProto.DataType.UINT64];var _t={export(u,t,r){if(!Array.isArray(t.input))throw new Error(`Invalid attribute 'input' value ${t.input}.`);const n=u.getGraph(),d=new e.NodeProto;if(t.input.length===1){d.setOpType("Identity"),d.addInput(t.input[0]),d.addOutput(t.name),n.addNode(d);return}const a=[];for(const s of t.input)if(yt.includes(r[s].type))a.push(s);else{const o=new e.NodeProto;o.setOpType("Cast"),o.addInput(s),o.addOutput(`${t.name}_${s}_cast`);const i=new e.AttributeProto;i.setName("to"),i.setType(e.AttributeProto.AttributeType.INT),i.setI(e.TensorProto.DataType.INT32),o.addAttribute(i),n.addNode(o),a.push(`${t.name}_${s}_cast`)}let p=a[0];for(let s=1;s<a.length-1;s++){const o=new e.NodeProto;o.setOpType("BitwiseXor"),o.addInput(p),o.addInput(a[s]),o.addOutput(p=t.name+`_bitwisexor_${s-1}`),n.addNode(o)}return d.setOpType("BitwiseXor"),d.addInput(p),d.addInput(a.at(-1)),d.addOutput(t.name),n.addNode(d),{type:e.TensorProto.DataType.INT32}}},ct={export(u,t){const r=O(u,1),n=O(u,2),d=new e.TensorProto;d.setName(t.name+"_beta"),d.setDataType(e.TensorProto.DataType.FLOAT),d.setDimsList([1]),d.setFloatDataList([t.beta??.1]);const a=Array.isArray(t.input)?t.input[0]:t.input,p=new e.NodeProto;p.setOpType("Pow"),p.addInput(a),p.addInput(n),p.addOutput(t.name+"_pow");const s=new e.NodeProto;s.setOpType("Add"),s.addInput(t.name+"_pow"),s.addInput(r),s.addOutput(t.name+"_add1");const o=new e.NodeProto;o.setOpType("Sqrt"),o.addInput(t.name+"_add1"),o.addOutput(t.name+"_sqrt");const i=new e.NodeProto;i.setOpType("Sub"),i.addInput(t.name+"_sqrt"),i.addInput(r),i.addOutput(t.name+"_sub1");const m=new e.NodeProto;m.setOpType("Mul"),m.addInput(t.name+"_beta"),m.addInput(t.name+"_sub1"),m.addOutput(t.name+"_mul");const T=new e.NodeProto;T.setOpType("Add"),T.addInput(a),T.addInput(t.name+"_mul"),T.addOutput(t.name);const y=u.getGraph();y.addInitializer(d),y.addNode(p),y.addNode(s),y.addNode(o),y.addNode(i),y.addNode(m),y.addNode(T)}},lt={export(u,t){const r=O(u,t.a??1),n=Array.isArray(t.input)?t.input[0]:t.input,d=new e.NodeProto;d.setOpType("HardSigmoid"),d.addInput(n),d.addOutput(t.name+"_hardsigmoid");const a=new e.AttributeProto;a.setName("alpha"),a.setType(e.AttributeProto.AttributeType.FLOAT),a.setF(1/(t.a??1));const p=new e.AttributeProto;p.setName("beta"),p.setType(e.AttributeProto.AttributeType.FLOAT),p.setF(0),d.setAttributeList([a,p]);const s=new e.NodeProto;s.setOpType("Mul"),s.addInput(r),s.addInput(t.name+"_hardsigmoid"),s.addOutput(t.name);const o=u.getGraph();o.addNode(d),o.addNode(s)}},Nt={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("Ceil"),n.addInput(r),n.addOutput(t.name),u.getGraph().addNode(n)}},It={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("LeakyRelu"),n.addInput(r),n.addOutput(t.name+"_lrelu");const d=new e.AttributeProto;d.setName("alpha"),d.setType(e.AttributeProto.AttributeType.FLOAT),d.setF(1/(t.a??1)),n.addAttribute(d);const a=new e.NodeProto;a.setOpType("Elu"),a.addInput(t.name+"_lrelu"),a.addOutput(t.name);const p=new e.AttributeProto;p.setName("alpha"),p.setType(e.AttributeProto.AttributeType.FLOAT),p.setF(t.a??1),a.addAttribute(p);const s=u.getGraph();s.addNode(n),s.addNode(a)}},At={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("Clip"),n.addInput(r),n.addOutput(t.name);const d=u.getGraph();if(d.addNode(n),typeof t.min=="string")n.addInput(t.min);else if(t.min!=null){const a=new e.TensorProto;a.setName(t.name+"_min"),a.setDataType(e.TensorProto.DataType.FLOAT),a.setDimsList([1]),a.setFloatDataList([t.min]),n.addInput(t.name+"_min"),d.addInitializer(a)}if(typeof t.max=="string")n.addInput(t.max);else if(t.max!=null){const a=new e.TensorProto;a.setName(t.name+"_max"),a.setDataType(e.TensorProto.DataType.FLOAT),a.setDimsList([1]),a.setFloatDataList([t.max]),t.min==null&&n.addInput(""),n.addInput(t.name+"_max"),d.addInitializer(a)}}},Ot={export(u,t){const r=O(u,1),n=Array.isArray(t.input)?t.input[0]:t.input,d=new e.NodeProto;d.setOpType("Exp"),d.addInput(n),d.addOutput(t.name+"_exp");const a=new e.NodeProto;a.setOpType("Neg"),a.addInput(t.name+"_exp"),a.addOutput(t.name+"_neg");const p=new e.NodeProto;p.setOpType("Exp"),p.addInput(t.name+"_neg"),p.addOutput(t.name+"_exp2");const s=new e.NodeProto;s.setOpType("Sub"),s.addInput(r),s.addInput(t.name+"_exp2"),s.addOutput(t.name);const o=u.getGraph();o.addNode(d),o.addNode(a),o.addNode(p),o.addNode(s)}},Pt={export(u,t){const r=O(u,1),n=O(u,2),d=O(u,-.7),a=Array.isArray(t.input)?t.input[0]:t.input,p=new e.NodeProto;p.setOpType("Exp"),p.addInput(a),p.addOutput(t.name+"_exp");const s=new e.NodeProto;s.setOpType("Mul"),s.addInput(d),s.addInput(t.name+"_exp"),s.addOutput(t.name+"_mul");const o=new e.NodeProto;o.setOpType("Exp"),o.addInput(t.name+"_mul"),o.addOutput(t.name+"_exp2");const i=new e.NodeProto;i.setOpType("Mul"),i.addInput(n),i.addInput(t.name+"_exp2"),i.addOutput(t.name+"_mul2");const m=new e.NodeProto;m.setOpType("Sub"),m.addInput(r),m.addInput(t.name+"_mul2"),m.addOutput(t.name);const T=u.getGraph();T.addNode(p),T.addNode(s),T.addNode(o),T.addNode(i),T.addNode(m)}},ht={export(u,t,r){if(!Array.isArray(t.input))throw new Error(`Invalid attribute 'input' value ${t.input}.`);const n=new e.NodeProto;n.setOpType("Concat");for(const o of t.input)n.addInput(o);n.addOutput(t.name);const d=t.axis??1,a=new e.AttributeProto;a.setName("axis"),a.setType(e.AttributeProto.AttributeType.INT),a.setI(t.axis??1),n.addAttribute(a),u.getGraph().addNode(n);const s=r[t.input[0]].size.concat();if(s[d]!=null)for(let o=1;o<t.input.length;o++){if(r[t.input[o]].size[d]==null){s[d]=null;break}s[d]+=r[t.input[o]].size[d]}return{size:s}}},wt={export(u,t,r){if(!Array.isArray(t.input)||t.input.length!==3)throw new Error(`Invalid attribute 'input' value ${t.input}.`);const n=u.getGraph(),d=new e.NodeProto;if(d.setOpType("Where"),r[t.input[0]].type===e.TensorProto.DataType.BOOL)d.addInput(t.input[0]);else{const a=new e.NodeProto;a.setOpType("Cast"),a.addInput(t.input[0]),a.addOutput(`${t.name}_cast`);const p=new e.AttributeProto;p.setName("to"),p.setType(e.AttributeProto.AttributeType.INT),p.setI(e.TensorProto.DataType.BOOL),a.addAttribute(p),n.addNode(a),d.addInput(`${t.name}_cast`)}return d.addInput(t.input[1]),d.addInput(t.input[2]),d.addOutput(t.name),n.addNode(d),{type:r[t.input[1]].type}}},gt={export(u,t){const r=new e.NodeProto;r.setOpType("Constant");const n=new e.TensorProto;n.setDataType(e.TensorProto.DataType.FLOAT);const d=U.fromArray(t.value);n.setDimsList(d.sizes),n.setFloatDataList(d.value);const a=new e.AttributeProto;a.setName("value"),a.setType(e.AttributeProto.AttributeType.TENSOR),a.setT(n),r.addAttribute(a),r.addOutput(t.name),u.getGraph().addNode(r)}},ft={export(u,t,r){const n=u.getGraph(),d=Array.isArray(t.input)?t.input[0]:t.input,a=r[d].size.concat(),p=new e.NodeProto;p.setOpType("Conv");const s=t.channel_dim===1?1:a.length-1;if(t.channel_dim===1)p.addInput(d),p.addOutput(t.name);else if(t.channel_dim==null||t.channel_dim===-1){const c=new e.NodeProto;c.setOpType("Transpose"),c.addInput(d),c.addOutput(t.name+"_t1");const _=new e.AttributeProto;_.setName("perm"),_.setType(e.AttributeProto.AttributeType.INTS);const l=Array.from(a,(w,h)=>h-1);l[0]=0,l[1]=a.length-1,_.setIntsList(l),c.addAttribute(_),n.addNode(c),p.addInput(t.name+"_t1"),p.addOutput(t.name+"_ap");const N=new e.NodeProto;N.setOpType("Transpose"),N.addInput(t.name+"_ap"),N.addOutput(t.name);const I=new e.AttributeProto;I.setName("perm"),I.setType(e.AttributeProto.AttributeType.INTS);const A=Array.from(a,(w,h)=>h+1);A[0]=0,A[A.length-1]=1,I.setIntsList(A),N.addAttribute(I),n.addNode(N)}else throw new Error(`Not implemented value of attribute 'channel_dim' ${t.channel_dim}.`);const o=Array.isArray(t.kernel)?t.kernel:Array(a.length-2).fill(t.kernel),i=new e.AttributeProto;i.setName("kernel_shape"),i.setType(e.AttributeProto.AttributeType.INTS),i.setIntsList(o),p.addAttribute(i);const m=Array.isArray(t.stride)?t.stride:Array(o.length).fill(t.stride??1),T=new e.AttributeProto;if(T.setName("strides"),T.setType(e.AttributeProto.AttributeType.INTS),T.setIntsList(m),p.addAttribute(T),t.padding!=null){const c=new e.AttributeProto;c.setName("pads"),c.setType(e.AttributeProto.AttributeType.INTS),c.setIntsList(Array.isArray(t.padding)?Array.isArray(t.padding[0])?[...t.padding.map(_=>_[0]),...t.padding.map(_=>_[1])]:[].concat(t.padding,t.padding):Array(o.length*2).fill(t.padding)),p.addAttribute(c)}else{const c=t.channel_dim===1?a.slice(2):a.slice(1,-1);if(c.some(_=>_==null)){const _=new e.AttributeProto;_.setName("auto_pad"),_.setType(e.AttributeProto.AttributeType.STRING),_.setS(new TextEncoder().encode("VALID")),p.addAttribute(_)}else{const _=c.map((N,I)=>(N-o[I])%m[I]),l=new e.AttributeProto;l.setName("pads"),l.setType(e.AttributeProto.AttributeType.INTS),l.setIntsList([...Array(o.length).fill(0),..._]),p.addAttribute(l)}}const y=Array(a.length).fill(null);if(y[0]=a[0],typeof t.w=="string")p.addInput(t.w),y[s]=r[t.w].size[0];else if(t.w){const c=new e.TensorProto;c.setName(t.name+"_w"),c.setDataType(e.TensorProto.DataType.FLOAT);const _=U.fromArray(t.w);c.setDimsList(_.sizes),c.setFloatDataList(_.value),n.addInitializer(c),p.addInput(t.name+"_w"),y[s]=_.sizes[0]}else throw new Error("Require attribute 'w'");return n.addNode(p),{size:y}}},Dt={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("Cos"),n.addInput(r),n.addOutput(t.name),u.getGraph().addNode(n)}},xt={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("Cosh"),n.addInput(r),n.addOutput(t.name),u.getGraph().addNode(n)}},vt={export(u,t,r){const n=Array.isArray(t.input)?t.input[0]:t.input,d=new e.NodeProto;d.setOpType("Relu"),d.addInput(n),d.addOutput(t.name+"_relu");const a=new e.NodeProto;a.setOpType("Neg"),a.addInput(n),a.addOutput(t.name+"_neg");const p=new e.NodeProto;p.setOpType("Relu"),p.addInput(t.name+"_neg"),p.addOutput(t.name+"_neg_relu");const s=new e.NodeProto;s.setOpType("Concat"),s.addInput(t.name+"_relu"),s.addInput(t.name+"_neg_relu"),s.addOutput(t.name);const o=new e.AttributeProto;o.setName("axis"),o.setType(e.AttributeProto.AttributeType.INT),o.setI(-1),s.addAttribute(o);const i=u.getGraph();i.addNode(d),i.addNode(a),i.addNode(p),i.addNode(s);const m=r[n].size.concat();return m.at(-1)!=null&&(m[m.length-1]=m.at(-1)*2),{size:m}}},Lt={export(u,t){if(!Array.isArray(t.input))throw new Error(`Invalid attribute 'input' value ${t.input}.`);const r=u.getGraph(),n=new e.NodeProto;if(t.input.length===1)n.setOpType("Identity"),n.addInput(t.input[0]);else if(t.input.length===2)n.setOpType("Div"),n.addInput(t.input[0]),n.addInput(t.input[1]);else{let d=t.input[1];for(let a=2;a<t.input.length;a++){const p=new e.NodeProto;p.setOpType("Mul"),p.addInput(d),p.addInput(t.input[a]),p.addOutput(d=t.name+`_mul_${a-2}`),r.addNode(p)}n.setOpType("Div"),n.addInput(t.input[0]),n.addInput(d)}n.addOutput(t.name),r.addNode(n)}},Ft={export(u,t){const r=O(u,0),n=new e.TensorProto;n.setName(t.name+"_k"),n.setDataType(e.TensorProto.DataType.FLOAT),n.setDimsList([1]),n.setFloatDataList([t.k??1]);const d=new e.TensorProto;d.setName(t.name+"_beta"),d.setDataType(e.TensorProto.DataType.FLOAT),d.setDimsList([1]),d.setFloatDataList([t.beta??1]);const a=Array.isArray(t.input)?t.input[0]:t.input,p=new e.NodeProto;p.setOpType("Relu"),p.addInput(a),p.addOutput(t.name+"_relu");const s=new e.NodeProto;s.setOpType("Mul"),s.addInput(t.name+"_relu"),s.addInput(t.name+"_k"),s.addOutput(t.name+"_p");const o=new e.NodeProto;o.setOpType("Min"),o.addInput(a),o.addInput(r),o.addOutput(t.name+"_min");const i=new e.NodeProto;i.setOpType("Mul"),i.addInput(t.name+"_min"),i.addInput(t.name+"_beta"),i.addOutput(t.name+"_mul");const m=new e.NodeProto;m.setOpType("Elu"),m.addInput(t.name+"_mul"),m.addOutput(t.name+"_elu");const T=new e.AttributeProto;T.setName("alpha"),T.setType(e.AttributeProto.AttributeType.FLOAT),T.setF(t.alpha??1),m.addAttribute(T);const y=new e.NodeProto;y.setOpType("Add"),y.addInput(t.name+"_p"),y.addInput(t.name+"_elu"),y.addOutput(t.name);const c=u.getGraph();c.addInitializer(n),c.addInitializer(d),c.addNode(p),c.addNode(s),c.addNode(o),c.addNode(i),c.addNode(m),c.addNode(y)}},zt={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("Elu"),n.addInput(r),n.addOutput(t.name+"_elu");const d=new e.NodeProto;d.setOpType("Sigmoid"),d.addInput(r),d.addOutput(t.name+"_sigm");const a=new e.NodeProto;a.setOpType("Mul"),a.addInput(t.name+"_elu"),a.addInput(t.name+"_sigm"),a.addOutput(t.name);const p=u.getGraph();p.addNode(n),p.addNode(d),p.addNode(a)}},Gt={export(u,t){const r=O(u,1),n=O(u,2),d=Array.isArray(t.input)?t.input[0]:t.input,a=new e.NodeProto;a.setOpType("Softsign"),a.addInput(d),a.addOutput(t.name+"_softsign");const p=new e.NodeProto;p.setOpType("Add"),p.addInput(t.name+"_softsign"),p.addInput(r),p.addOutput(t.name+"_div");const s=new e.NodeProto;s.setOpType("Div"),s.addInput(t.name+"_div"),s.addInput(n),s.addOutput(t.name);const o=u.getGraph();o.addNode(a),o.addNode(p),o.addNode(s)}},St={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("Elu"),n.addInput(r),n.addOutput(t.name);const d=new e.AttributeProto;d.setName("alpha"),d.setType(e.AttributeProto.AttributeType.FLOAT),d.setF(t.a??1),n.addAttribute(d),u.getGraph().addNode(n)}},$t={export(u,t){if(!Array.isArray(t.input))throw new Error(`Invalid attribute 'input' value ${t.input}.`);const r=u.getGraph(),n=new e.NodeProto;if(t.input.length===1){const d=new e.NodeProto;d.setOpType("Shape"),d.addInput(t.input[0]),d.addOutput(t.name+"_shape"),r.addNode(d),n.setOpType("ConstantOfShape"),n.addInput(t.name+"_shape");const a=new e.TensorProto;a.setDataType(e.TensorProto.DataType.BOOL),a.setDimsList([1]),a.setInt32DataList([1]);const p=new e.AttributeProto;p.setName("value"),p.setType(e.AttributeProto.AttributeType.TENSOR),p.setT(a),n.addAttribute(p)}else if(t.input.length===2)n.setOpType("Equal"),n.addInput(t.input[0]),n.addInput(t.input[1]);else{for(let a=0;a<t.input.length-1;a++){const p=new e.NodeProto;p.setOpType("Equal"),p.addInput(t.input[a]),p.addInput(t.input[a+1]),p.addOutput(`${t.name}_eq_${a}`),r.addNode(p)}let d=t.name+"_eq_0";for(let a=1;a<t.input.length-2;a++){const p=new e.NodeProto;p.setOpType("And"),p.addInput(d),p.addInput(`${t.name}_eq_${a}`),p.addOutput(d=t.name+`_and_${a-1}`),r.addNode(p)}n.setOpType("And"),n.addInput(d),n.addInput(`${t.name}_eq_${t.input.length-2}`)}return n.addOutput(t.name),r.addNode(n),{type:e.TensorProto.DataType.BOOL}}},Et={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("Relu"),n.addInput(r),n.addOutput(t.name),u.getGraph().addNode(n)}},Mt={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("Erf"),n.addInput(r),n.addOutput(t.name),u.getGraph().addNode(n)}},kt={export(u,t){const r=new e.TensorProto;r.setName(t.name+"_beta"),r.setDataType(e.TensorProto.DataType.FLOAT),r.setDimsList([1]),r.setFloatDataList([t.beta??1]);const n=Array.isArray(t.input)?t.input[0]:t.input,d=new e.NodeProto;d.setOpType("Sigmoid"),d.addInput(n),d.addOutput(t.name+"_sigm");const a=new e.NodeProto;a.setOpType("Mul"),a.addInput(n),a.addInput(t.name+"_sigm"),a.addOutput(t.name+"_mul");const p=new e.NodeProto;p.setOpType("Mul"),p.addInput(t.name+"_beta"),p.addInput(t.name+"_mul"),p.addOutput(t.name);const s=u.getGraph();s.addInitializer(r),s.addNode(d),s.addNode(a),s.addNode(p)}},Rt={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("Exp"),n.addInput(r),n.addOutput(t.name),u.getGraph().addNode(n)}},Bt={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("LeakyRelu"),n.addInput(r),n.addOutput(t.name+"_lrelu");const d=new e.AttributeProto;d.setName("alpha"),d.setType(e.AttributeProto.AttributeType.FLOAT),d.setF(Math.LOG2E),n.addAttribute(d);const a=new e.NodeProto;a.setOpType("Elu"),a.addInput(t.name+"_lrelu"),a.addOutput(t.name);const p=new e.AttributeProto;p.setName("alpha"),p.setType(e.AttributeProto.AttributeType.FLOAT),p.setF(t.alpha??1),a.addAttribute(p);const s=u.getGraph();s.addNode(n),s.addNode(a)}},qt={export(u,t,r){const n=Array.isArray(t.input)?t.input[0]:t.input,d=new e.NodeProto;d.setOpType("Flatten"),d.addInput(n),d.addOutput(t.name),u.getGraph().addNode(d);const p=r[n].size;return{size:[p[0],p.slice(1).reduce((s,o)=>o==null||s==null?null:s*o,1)]}}},Ut={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("Floor"),n.addInput(r),n.addOutput(t.name),u.getGraph().addNode(n)}},Ct={export(u,t){const r=new e.TensorProto;r.setName(t.name+"_b"),r.setDataType(e.TensorProto.DataType.FLOAT),r.setDimsList([1]),r.setFloatDataList([t.b??0]);const n=Array.isArray(t.input)?t.input[0]:t.input,d=new e.NodeProto;d.setOpType("Relu"),d.addInput(n),d.addOutput(t.name+"_relu");const a=new e.NodeProto;a.setOpType("Add"),a.addInput(t.name+"_relu"),a.addInput(t.name+"_b"),a.addOutput(t.name);const p=u.getGraph();p.addInitializer(r),p.addNode(d),p.addNode(a)}},Vt={export(u,t,r){const n=Array.isArray(t.input)?t.input[0]:t.input,d=u.getGraph(),a=new e.NodeProto;if(a.setOpType("Gemm"),a.addInput(n),typeof t.w=="string")a.addInput(t.w);else if(t.w){const i=t.name+"_w";a.addInput(i);const m=new e.TensorProto;m.setName(i),m.setDataType(e.TensorProto.DataType.FLOAT);const T=C.fromArray(t.w);m.setDimsList(T.sizes),m.setFloatDataList(T.value),d.addInitializer(m)}else throw new Error("Require attribute 'w'");if(typeof t.b=="string")a.addInput(t.b);else{const i=t.name+"_b";a.addInput(i);const m=new e.TensorProto;if(m.setName(i),m.setDataType(e.TensorProto.DataType.FLOAT),t.b){const T=C.fromArray(t.b);m.setDimsList(T.sizes),m.setFloatDataList(T.value)}else m.setDimsList([1,t.out_size]),m.setFloatDataList(Array(t.out_size).fill(0));d.addInitializer(m)}if(d.addNode(a),t.activation){const i=t.name+"_a";a.addOutput(i);const m=typeof t.activation=="string"?{type:t.activation,input:i,name:t.name}:{...t.activation,input:i,name:t.name};K.getLayerExporter(m.type).export(u,m)}else a.addOutput(t.name);const p=Array.isArray(t.input)?t.input[0]:t.input,s=typeof t.out_size=="string"?r[t.out_size].size.at(-1):t.out_size,o=r[p].size.concat();return o[o.length-1]=s,{size:o}}},Kt={export(u,t){const r=O(u,2),n=Array.isArray(t.input)?t.input[0]:t.input,d=new e.NodeProto;d.setOpType("Pow"),d.addInput(n),d.addInput(r),d.addOutput(t.name+"_pow");const a=new e.NodeProto;a.setOpType("Neg"),a.addInput(t.name+"_pow"),a.addOutput(t.name+"_neg");const p=new e.NodeProto;p.setOpType("Div"),p.addInput(t.name+"_neg"),p.addInput(r),p.addOutput(t.name+"_div");const s=new e.NodeProto;s.setOpType("Exp"),s.addInput(t.name+"_div"),s.addOutput(t.name);const o=u.getGraph();o.addNode(d),o.addNode(a),o.addNode(p),o.addNode(s)}},Wt={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=u.getOpsetImportList()[0];if(n.getDomain()===""&&n.getVersion()>=20){const d=new e.NodeProto;d.setOpType("Gelu"),d.addInput(r),d.addOutput(t.name),u.getGraph().addNode(d)}else{const d=O(u,1),a=O(u,2),p=O(u,.3275911),s=O(u,.254829592),o=O(u,-.284496736),i=O(u,1.421413741),m=O(u,-1.453152027),T=O(u,1.061405429),y=new e.NodeProto;y.setOpType("Sqrt"),y.addInput(a),y.addOutput(t.name+"_sqrt2");const c=new e.NodeProto;c.setOpType("Div"),c.addInput(r),c.addInput(t.name+"_sqrt2"),c.addOutput(t.name+"_v");const _=new e.NodeProto;_.setOpType("Abs"),_.addInput(t.name+"_v"),_.addOutput(t.name+"_abs");const l=new e.NodeProto;l.setOpType("Mul"),l.addInput(t.name+"_abs"),l.addInput(p),l.addOutput(t.name+"_mul_p");const N=new e.NodeProto;N.setOpType("Add"),N.addInput(t.name+"_mul_p"),N.addInput(d),N.addOutput(t.name+"_add1");const I=new e.NodeProto;I.setOpType("Reciprocal"),I.addInput(t.name+"_add1"),I.addOutput(t.name+"_t");const A=new e.NodeProto;A.setOpType("Mul"),A.addInput(t.name+"_t"),A.addInput(T),A.addOutput(t.name+"_mul_a5");const w=new e.NodeProto;w.setOpType("Add"),w.addInput(t.name+"_mul_a5"),w.addInput(m),w.addOutput(t.name+"_add_a4");const h=new e.NodeProto;h.setOpType("Mul"),h.addInput(t.name+"_add_a4"),h.addInput(t.name+"_t"),h.addOutput(t.name+"_mul_a4");const g=new e.NodeProto;g.setOpType("Add"),g.addInput(t.name+"_mul_a4"),g.addInput(i),g.addOutput(t.name+"_add_a3");const f=new e.NodeProto;f.setOpType("Mul"),f.addInput(t.name+"_add_a3"),f.addInput(t.name+"_t"),f.addOutput(t.name+"_mul_a3");const D=new e.NodeProto;D.setOpType("Add"),D.addInput(t.name+"_mul_a3"),D.addInput(o),D.addOutput(t.name+"_add_a2");const x=new e.NodeProto;x.setOpType("Mul"),x.addInput(t.name+"_add_a2"),x.addInput(t.name+"_t"),x.addOutput(t.name+"_mul_a2");const v=new e.NodeProto;v.setOpType("Add"),v.addInput(t.name+"_mul_a2"),v.addInput(s),v.addOutput(t.name+"_add_a1");const L=new e.NodeProto;L.setOpType("Mul"),L.addInput(t.name+"_add_a1"),L.addInput(t.name+"_t"),L.addOutput(t.name+"_mul_a1");const F=new e.NodeProto;F.setOpType("Pow"),F.addInput(t.name+"_v"),F.addInput(a),F.addOutput(t.name+"_pow");const k=new e.NodeProto;k.setOpType("Neg"),k.addInput(t.name+"_pow"),k.addOutput(t.name+"_neg");const R=new e.NodeProto;R.setOpType("Exp"),R.addInput(t.name+"_neg"),R.addOutput(t.name+"_exp");const z=new e.NodeProto;z.setOpType("Mul"),z.addInput(t.name+"_mul_a1"),z.addInput(t.name+"_exp"),z.addOutput(t.name+"_mul");const G=new e.NodeProto;G.setOpType("Sub"),G.addInput(d),G.addInput(t.name+"_mul"),G.addOutput(t.name+"_erf");const B=new e.NodeProto;B.setOpType("Sign"),B.addInput(t.name+"_v"),B.addOutput(t.name+"_sign");const S=new e.NodeProto;S.setOpType("Mul"),S.addInput(t.name+"_erf"),S.addInput(t.name+"_sign"),S.addOutput(t.name+"_sign_erf");const $=new e.NodeProto;$.setOpType("Add"),$.addInput(d),$.addInput(t.name+"_sign_erf"),$.addOutput(t.name+"_erf_add1");const E=new e.NodeProto;E.setOpType("Mul"),E.addInput(r),E.addInput(t.name+"_erf_add1"),E.addOutput(t.name+"_mul_v");const M=new e.NodeProto;M.setOpType("Div"),M.addInput(t.name+"_mul_v"),M.addInput(a),M.addOutput(t.name);const P=u.getGraph();P.addNode(y),P.addNode(c),P.addNode(_),P.addNode(l),P.addNode(N),P.addNode(I),P.addNode(A),P.addNode(w),P.addNode(h),P.addNode(g),P.addNode(f),P.addNode(D),P.addNode(x),P.addNode(v),P.addNode(L),P.addNode(F),P.addNode(k),P.addNode(R),P.addNode(z),P.addNode(G),P.addNode(B),P.addNode(S),P.addNode($),P.addNode(E),P.addNode(M)}}},Ht={export(u,t,r){const n=u.getGraph(),d=Array.isArray(t.input)?t.input[0]:t.input,a=r[d].size.concat(),p=new e.NodeProto;p.setOpType("GlobalAveragePool");const s=Array(a.length).fill(1);if(s[0]=a[0],t.channel_dim===1)p.addInput(d),p.addOutput(t.name),s[1]=a[1];else if(t.channel_dim==null||t.channel_dim===-1){const o=new e.NodeProto;o.setOpType("Transpose"),o.addInput(d),o.addOutput(t.name+"_t1");const i=new e.AttributeProto;i.setName("perm"),i.setType(e.AttributeProto.AttributeType.INTS);const m=Array.from(a,(_,l)=>l-1);m[0]=0,m[1]=a.length-1,i.setIntsList(m),o.addAttribute(i),n.addNode(o),p.addInput(t.name+"_t1"),p.addOutput(t.name+"_gap");const T=new e.NodeProto;T.setOpType("Transpose"),T.addInput(t.name+"_gap"),T.addOutput(t.name);const y=new e.AttributeProto;y.setName("perm"),y.setType(e.AttributeProto.AttributeType.INTS);const c=Array.from(a,(_,l)=>l+1);c[0]=0,c[c.length-1]=1,y.setIntsList(c),T.addAttribute(y),n.addNode(T),s[a.length-1]=a[a.length-1]}else throw new Error(`Not implemented value of attribute 'channel_dim' ${t.channel_dim}.`);return n.addNode(p),{size:s}}},Xt={export(u,t,r){const n=u.getGraph(),d=Array.isArray(t.input)?t.input[0]:t.input,a=r[d].size.concat(),p=new e.NodeProto;p.setOpType("GlobalLpPool");const s=new e.AttributeProto;s.setName("p"),s.setType(e.AttributeProto.AttributeType.INT),s.setI(t.p??2),p.addAttribute(s);const o=Array(a.length).fill(1);if(o[0]=a[0],t.channel_dim===1)p.addInput(d),p.addOutput(t.name),o[1]=a[1];else if(t.channel_dim==null||t.channel_dim===-1){const i=new e.NodeProto;i.setOpType("Transpose"),i.addInput(d),i.addOutput(t.name+"_t1");const m=new e.AttributeProto;m.setName("perm"),m.setType(e.AttributeProto.AttributeType.INTS);const T=Array.from(a,(l,N)=>N-1);T[0]=0,T[1]=a.length-1,m.setIntsList(T),i.addAttribute(m),n.addNode(i),p.addInput(t.name+"_t1"),p.addOutput(t.name+"_gap");const y=new e.NodeProto;y.setOpType("Transpose"),y.addInput(t.name+"_gap"),y.addOutput(t.name);const c=new e.AttributeProto;c.setName("perm"),c.setType(e.AttributeProto.AttributeType.INTS);const _=Array.from(a,(l,N)=>N+1);_[0]=0,_[_.length-1]=1,c.setIntsList(_),y.addAttribute(c),n.addNode(y),o[a.length-1]=a[a.length-1]}else throw new Error(`Not implemented value of attribute 'channel_dim' ${t.channel_dim}.`);return n.addNode(p),{size:o}}},Jt={export(u,t,r){const n=u.getGraph(),d=Array.isArray(t.input)?t.input[0]:t.input,a=r[d].size.concat(),p=new e.NodeProto;p.setOpType("GlobalMaxPool");const s=Array(a.length).fill(1);if(s[0]=a[0],t.channel_dim===1)p.addInput(d),p.addOutput(t.name),s[1]=a[1];else if(t.channel_dim==null||t.channel_dim===-1){const o=new e.NodeProto;o.setOpType("Transpose"),o.addInput(d),o.addOutput(t.name+"_t1");const i=new e.AttributeProto;i.setName("perm"),i.setType(e.AttributeProto.AttributeType.INTS);const m=Array.from(a,(_,l)=>l-1);m[0]=0,m[1]=a.length-1,i.setIntsList(m),o.addAttribute(i),n.addNode(o),p.addInput(t.name+"_t1"),p.addOutput(t.name+"_gmp");const T=new e.NodeProto;T.setOpType("Transpose"),T.addInput(t.name+"_gmp"),T.addOutput(t.name);const y=new e.AttributeProto;y.setName("perm"),y.setType(e.AttributeProto.AttributeType.INTS);const c=Array.from(a,(_,l)=>l+1);c[0]=0,c[c.length-1]=1,y.setIntsList(c),T.addAttribute(y),n.addNode(T),s[a.length-1]=a[a.length-1]}else throw new Error(`Not implemented value of attribute 'channel_dim' ${t.channel_dim}.`);return n.addNode(p),{size:s}}},Qt={export(u,t){if(!Array.isArray(t.input))throw new Error(`Invalid attribute 'input' value ${t.input}.`);const r=u.getGraph(),n=new e.NodeProto;if(t.input.length===1){const d=new e.NodeProto;d.setOpType("Shape"),d.addInput(t.input[0]),d.addOutput(t.name+"_shape"),r.addNode(d),n.setOpType("ConstantOfShape"),n.addInput(t.name+"_shape");const a=new e.TensorProto;a.setDataType(e.TensorProto.DataType.BOOL),a.setDimsList([1]),a.setInt32DataList([1]);const p=new e.AttributeProto;p.setName("value"),p.setType(e.AttributeProto.AttributeType.TENSOR),p.setT(a),n.addAttribute(p)}else if(t.input.length===2)n.setOpType("Greater"),n.addInput(t.input[0]),n.addInput(t.input[1]);else{for(let a=0;a<t.input.length-1;a++){const p=new e.NodeProto;p.setOpType("Greater"),p.addInput(t.input[a]),p.addInput(t.input[a+1]),p.addOutput(`${t.name}_gt_${a}`),r.addNode(p)}let d=t.name+"_gt_0";for(let a=1;a<t.input.length-2;a++){const p=new e.NodeProto;p.setOpType("And"),p.addInput(d),p.addInput(`${t.name}_gt_${a}`),p.addOutput(d=t.name+`_and_${a-1}`),r.addNode(p)}n.setOpType("And"),n.addInput(d),n.addInput(`${t.name}_gt_${t.input.length-2}`)}return n.addOutput(t.name),r.addNode(n),{type:e.TensorProto.DataType.BOOL}}},Yt={export(u,t){if(!Array.isArray(t.input))throw new Error(`Invalid attribute 'input' value ${t.input}.`);const r=u.getGraph(),n=new e.NodeProto;if(t.input.length===1){const d=new e.NodeProto;d.setOpType("Shape"),d.addInput(t.input[0]),d.addOutput(t.name+"_shape"),r.addNode(d),n.setOpType("ConstantOfShape"),n.addInput(t.name+"_shape");const a=new e.TensorProto;a.setDataType(e.TensorProto.DataType.BOOL),a.setDimsList([1]),a.setInt32DataList([1]);const p=new e.AttributeProto;p.setName("value"),p.setType(e.AttributeProto.AttributeType.TENSOR),p.setT(a),n.addAttribute(p)}else if(t.input.length===2)n.setOpType("GreaterOrEqual"),n.addInput(t.input[0]),n.addInput(t.input[1]);else{for(let a=0;a<t.input.length-1;a++){const p=new e.NodeProto;p.setOpType("GreaterOrEqual"),p.addInput(t.input[a]),p.addInput(t.input[a+1]),p.addOutput(`${t.name}_ge_${a}`),r.addNode(p)}let d=t.name+"_ge_0";for(let a=1;a<t.input.length-2;a++){const p=new e.NodeProto;p.setOpType("And"),p.addInput(d),p.addInput(`${t.name}_ge_${a}`),p.addOutput(d=t.name+`_and_${a-1}`),r.addNode(p)}n.setOpType("And"),n.addInput(d),n.addInput(`${t.name}_ge_${t.input.length-2}`)}return n.addOutput(t.name),r.addNode(n),{type:e.TensorProto.DataType.BOOL}}},Zt={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("Elu"),n.addInput(r),n.addOutput(t.name+"_elu");const d=new e.NodeProto;d.setOpType("HardSigmoid"),d.addInput(r),d.addOutput(t.name+"_hardsigmoid");const a=new e.AttributeProto;a.setName("alpha"),a.setType(e.AttributeProto.AttributeType.FLOAT),a.setF(.5),d.addAttribute(a);const p=new e.AttributeProto;p.setName("beta"),p.setType(e.AttributeProto.AttributeType.FLOAT),p.setF(.5),d.addAttribute(p);const s=new e.NodeProto;s.setOpType("Mul"),s.addInput(t.name+"_elu"),s.addInput(t.name+"_hardsigmoid"),s.addOutput(t.name);const o=u.getGraph();o.addNode(n),o.addNode(d),o.addNode(s)}},bt={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("Shrink"),n.addInput(r),n.addOutput(t.name);const d=new e.AttributeProto;d.setName("lambd"),d.setType(e.AttributeProto.AttributeType.FLOAT),d.setF(t.l??.5),n.addAttribute(d),u.getGraph().addNode(n)}},jt={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("HardSigmoid"),n.addInput(r),n.addOutput(t.name);const d=new e.AttributeProto;d.setName("alpha"),d.setType(e.AttributeProto.AttributeType.FLOAT),d.setF(t.alpha??.2),n.addAttribute(d);const a=new e.AttributeProto;a.setName("beta"),a.setType(e.AttributeProto.AttributeType.FLOAT),a.setF(t.beta??.5),n.addAttribute(a),u.getGraph().addNode(n)}},te={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("HardSwish"),n.addInput(r),n.addOutput(t.name),u.getGraph().addNode(n)}},ee={export(u,t){const r=new e.TensorProto;r.setName(t.name+"_v"),r.setDataType(e.TensorProto.DataType.FLOAT),r.setDimsList([1]),r.setFloatDataList([t.v??1]);const n=new e.NodeProto;n.setOpType("Neg"),n.addInput(t.name+"_v"),n.addOutput(t.name+"_v_neg");const d=Array.isArray(t.input)?t.input[0]:t.input,a=new e.NodeProto;a.setOpType("Clip"),a.addInput(d),a.addInput(t.name+"_v_neg"),a.addInput(t.name+"_v"),a.addOutput(t.name);const p=u.getGraph();p.addInitializer(r),p.addNode(n),p.addNode(a)}},ne={export(u,t){const r=O(u,0),n=new e.TensorProto;n.setName(t.name+"_a"),n.setDataType(e.TensorProto.DataType.FLOAT),n.setDimsList([1]),n.setFloatDataList([t.a??1]);const d=new e.TensorProto;d.setName(t.name+"_b"),d.setDataType(e.TensorProto.DataType.FLOAT),d.setDimsList([1]),d.setFloatDataList([t.b??1]);const a=new e.TensorProto;a.setName(t.name+"_c"),a.setDataType(e.TensorProto.DataType.FLOAT),a.setDimsList([1]),a.setFloatDataList([t.c??1]);const p=new e.TensorProto;p.setName(t.name+"_d"),p.setDataType(e.TensorProto.DataType.FLOAT),p.setDimsList([1]),p.setFloatDataList([t.d??1]);const s=new e.NodeProto;s.setOpType("Neg"),s.addInput(t.name+"_a"),s.addOutput(t.name+"_-a");const o=new e.NodeProto;o.setOpType("Neg"),o.addInput(t.name+"_b"),o.addOutput(t.name+"_-b");const i=Array.isArray(t.input)?t.input[0]:t.input,m=new e.NodeProto;m.setOpType("GreaterOrEqual"),m.addInput(i),m.addInput(r),m.addOutput(t.name+"_posneg");const T=new e.NodeProto;T.setOpType("Where"),T.addInput(t.name+"_posneg"),T.addInput(t.name+"_-b"),T.addInput(t.name+"_d"),T.addOutput(t.name+"_where1");const y=new e.NodeProto;y.setOpType("Div"),y.addInput(i),y.addInput(t.name+"_where1"),y.addOutput(t.name+"_div");const c=new e.NodeProto;c.setOpType("Elu"),c.addInput(t.name+"_div"),c.addOutput(t.name+"_elu");const _=new e.NodeProto;_.setOpType("Where"),_.addInput(t.name+"_posneg"),_.addInput(t.name+"_-a"),_.addInput(t.name+"_c"),_.addOutput(t.name+"_where2");const l=new e.NodeProto;l.setOpType("Mul"),l.addInput(t.name+"_elu"),l.addInput(t.name+"_where2"),l.addOutput(t.name);const N=u.getGraph();N.addInitializer(n),N.addInitializer(d),N.addInitializer(a),N.addInitializer(p),N.addNode(s),N.addNode(o),N.addNode(m),N.addNode(T),N.addNode(y),N.addNode(c),N.addNode(_),N.addNode(l)}},ae={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("Identity"),n.addInput(r),n.addOutput(t.name),u.getGraph().addNode(n)}},de={export(u,t){const r=t.size;if(!r)throw new Error("Input layer must specify the size");const n=new e.ValueInfoProto,d=new e.TypeProto,a=new e.TypeProto.Tensor;a.setElemType(e.TensorProto.DataType.FLOAT);const p=new e.TensorShapeProto;return p.setDimList(r.map(o=>{const i=new e.TensorShapeProto.Dimension;return i.setDimValue(o??-1),i})),a.setShape(p),d.setTensorType(a),n.setType(d),n.setName(t.name),u.getGraph().addInput(n),{type:e.TensorProto.DataType.FLOAT,size:r}}},pe={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;return n.setOpType("IsInf"),n.addInput(r),n.addOutput(t.name),u.getGraph().addNode(n),{type:e.TensorProto.DataType.BOOL}}},re={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;return n.setOpType("IsNaN"),n.addInput(r),n.addOutput(t.name),u.getGraph().addNode(n),{type:e.TensorProto.DataType.BOOL}}},se={export(u,t){const r=O(u,t.a??1),n=O(u,t.alpha??1),d=t.a??1,a=1/(1+Math.exp(-d)),p=1/(1+Math.exp(d)),s=O(u,(a+p)/(2*(t.alpha??1))),o=Array.isArray(t.input)?t.input[0]:t.input,i=new e.NodeProto;i.setOpType("Shrink"),i.addInput(o),i.addOutput(t.name+"_shrink");const m=new e.AttributeProto;m.setName("bias"),m.setType(e.AttributeProto.AttributeType.FLOAT),m.setF(d+(p-a)/(2*(t.alpha??1))),i.addAttribute(m);const T=new e.AttributeProto;T.setName("lambd"),T.setType(e.AttributeProto.AttributeType.FLOAT),T.setF(t.a??1),i.addAttribute(T);const y=new e.NodeProto;y.setOpType("Add"),y.addInput(t.name+"_shrink"),y.addInput(s),y.addOutput(t.name+"_add");const c=new e.NodeProto;c.setOpType("Mul"),c.addInput(t.name+"_add"),c.addInput(n),c.addOutput(t.name+"_mul");const _=new e.NodeProto;_.setOpType("Abs"),_.addInput(o),_.addOutput(t.name+"_abs");const l=new e.NodeProto;l.setOpType("Greater"),l.addInput(t.name+"_abs"),l.addInput(r),l.addOutput(t.name+"_ot_a");const N=new e.NodeProto;N.setOpType("Sigmoid"),N.addInput(o),N.addOutput(t.name+"_sigmoid");const I=new e.NodeProto;I.setOpType("Where"),I.addInput(t.name+"_ot_a"),I.addInput(t.name+"_mul"),I.addInput(t.name+"_sigmoid"),I.addOutput(t.name);const A=u.getGraph();A.addNode(i),A.addNode(y),A.addNode(c),A.addNode(_),A.addNode(l),A.addNode(N),A.addNode(I)}},oe={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("LeakyRelu"),n.addInput(r),n.addOutput(t.name);const d=new e.AttributeProto;d.setName("alpha"),d.setType(e.AttributeProto.AttributeType.FLOAT),d.setF(t.a??.1),n.addAttribute(d),u.getGraph().addNode(n)}};const ue=[e.TensorProto.DataType.UINT8,e.TensorProto.DataType.UINT16,e.TensorProto.DataType.UINT32,e.TensorProto.DataType.UINT64];var ie={export(u,t,r){if(!Array.isArray(t.input))throw new Error(`Invalid attribute 'input' value ${t.input}.`);const n=u.getGraph(),d=new e.AttributeProto;d.setName("direction"),d.setType(e.AttributeProto.AttributeType.STRING),d.setS(new TextEncoder().encode("LEFT"));const a=new e.NodeProto;if(t.input.length===1){a.setOpType("Identity"),a.addInput(t.input[0]),a.addOutput(t.name),n.addNode(a);return}const p=[];for(const o of t.input)if(ue.includes(r[o].type))p.push(o);else{const i=new e.NodeProto;i.setOpType("Cast"),i.addInput(o),i.addOutput(`${t.name}_${o}_cast`);const m=new e.AttributeProto;m.setName("to"),m.setType(e.AttributeProto.AttributeType.INT),m.setI(e.TensorProto.DataType.UINT32),i.addAttribute(m),n.addNode(i),p.push(`${t.name}_${o}_cast`)}let s=p[0];for(let o=1;o<p.length-1;o++){const i=new e.NodeProto;i.setOpType("BitShift"),i.addInput(s),i.addInput(p[o]),i.addOutput(s=t.name+`_bitshift_${o-1}`),i.addAttribute(d),n.addNode(i)}return a.setOpType("BitShift"),a.addInput(s),a.addInput(p.at(-1)),a.addAttribute(d),a.addOutput(t.name),n.addNode(a),{type:e.TensorProto.DataType.UINT32}}},me={export(u,t){if(!Array.isArray(t.input))throw new Error(`Invalid attribute 'input' value ${t.input}.`);const r=u.getGraph(),n=new e.NodeProto;if(t.input.length===1){const d=new e.NodeProto;d.setOpType("Shape"),d.addInput(t.input[0]),d.addOutput(t.name+"_shape"),r.addNode(d),n.setOpType("ConstantOfShape"),n.addInput(t.name+"_shape");const a=new e.TensorProto;a.setDataType(e.TensorProto.DataType.BOOL),a.setDimsList([1]),a.setInt32DataList([1]);const p=new e.AttributeProto;p.setName("value"),p.setType(e.AttributeProto.AttributeType.TENSOR),p.setT(a),n.addAttribute(p)}else if(t.input.length===2)n.setOpType("Less"),n.addInput(t.input[0]),n.addInput(t.input[1]);else{for(let a=0;a<t.input.length-1;a++){const p=new e.NodeProto;p.setOpType("Less"),p.addInput(t.input[a]),p.addInput(t.input[a+1]),p.addOutput(`${t.name}_lt_${a}`),r.addNode(p)}let d=t.name+"_lt_0";for(let a=1;a<t.input.length-2;a++){const p=new e.NodeProto;p.setOpType("And"),p.addInput(d),p.addInput(`${t.name}_lt_${a}`),p.addOutput(d=t.name+`_and_${a-1}`),r.addNode(p)}n.setOpType("And"),n.addInput(d),n.addInput(`${t.name}_lt_${t.input.length-2}`)}return n.addOutput(t.name),r.addNode(n),{type:e.TensorProto.DataType.BOOL}}},Te={export(u,t){if(!Array.isArray(t.input))throw new Error(`Invalid attribute 'input' value ${t.input}.`);const r=u.getGraph(),n=new e.NodeProto;if(t.input.length===1){const d=new e.NodeProto;d.setOpType("Shape"),d.addInput(t.input[0]),d.addOutput(t.name+"_shape"),r.addNode(d),n.setOpType("ConstantOfShape"),n.addInput(t.name+"_shape");const a=new e.TensorProto;a.setDataType(e.TensorProto.DataType.BOOL),a.setDimsList([1]),a.setInt32DataList([1]);const p=new e.AttributeProto;p.setName("value"),p.setType(e.AttributeProto.AttributeType.TENSOR),p.setT(a),n.addAttribute(p)}else if(t.input.length===2)n.setOpType("LessOrEqual"),n.addInput(t.input[0]),n.addInput(t.input[1]);else{for(let a=0;a<t.input.length-1;a++){const p=new e.NodeProto;p.setOpType("LessOrEqual"),p.addInput(t.input[a]),p.addInput(t.input[a+1]),p.addOutput(`${t.name}_le_${a}`),r.addNode(p)}let d=t.name+"_le_0";for(let a=1;a<t.input.length-2;a++){const p=new e.NodeProto;p.setOpType("And"),p.addInput(d),p.addInput(`${t.name}_le_${a}`),p.addOutput(d=t.name+`_and_${a-1}`),r.addNode(p)}n.setOpType("And"),n.addInput(d),n.addInput(`${t.name}_le_${t.input.length-2}`)}return n.addOutput(t.name),r.addNode(n),{type:e.TensorProto.DataType.BOOL}}},ye={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("Tanh"),n.addInput(r),n.addOutput(t.name+"_tanh");const d=new e.NodeProto;d.setOpType("Mul"),d.addInput(t.name+"_tanh"),d.addInput(r),d.addOutput(t.name);const a=u.getGraph();a.addNode(n),a.addNode(d)}},_e={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("Log"),n.addInput(r),n.addOutput(t.name),u.getGraph().addNode(n)}},ce={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("LogSoftmax"),n.addInput(r),n.addOutput(t.name);const d=new e.AttributeProto;d.setName("axis"),d.setType(e.AttributeProto.AttributeType.INT),d.setI(t.axis??-1),n.addAttribute(d),u.getGraph().addNode(n)}},le={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("Neg"),n.addInput(r),n.addOutput(t.name+"_neg1");const d=new e.NodeProto;d.setOpType("Exp"),d.addInput(t.name+"_neg1"),d.addOutput(t.name+"_exp");const a=new e.NodeProto;a.setOpType("Neg"),a.addInput(t.name+"_exp"),a.addOutput(t.name+"_neg");const p=new e.NodeProto;p.setOpType("Exp"),p.addInput(t.name+"_neg"),p.addOutput(t.name);const s=u.getGraph();s.addNode(n),s.addNode(d),s.addNode(a),s.addNode(p)}},Ne={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("Sigmoid"),n.addInput(r),n.addOutput(t.name+"_sigmoid");const d=new e.NodeProto;d.setOpType("Log"),d.addInput(t.name+"_sigmoid"),d.addOutput(t.name);const a=u.getGraph();a.addNode(n),a.addNode(d)}},Ie={export(u,t,r){const n=u.getGraph(),d=Array.isArray(t.input)?t.input[0]:t.input,a=r[d].size.concat(),p=new e.NodeProto;p.setOpType("LpPool");const s=new e.AttributeProto;s.setName("p"),s.setType(e.AttributeProto.AttributeType.INT),s.setI(t.p??2),p.addAttribute(s);const o=Array(a.length).fill(null);if(o[0]=a[0],t.channel_dim===1)p.addInput(d),p.addOutput(t.name),o[1]=a[1];else if(t.channel_dim==null||t.channel_dim===-1){const _=new e.NodeProto;_.setOpType("Transpose"),_.addInput(d),_.addOutput(t.name+"_t1");const l=new e.AttributeProto;l.setName("perm"),l.setType(e.AttributeProto.AttributeType.INTS);const N=Array.from(a,(h,g)=>g-1);N[0]=0,N[1]=a.length-1,l.setIntsList(N),_.addAttribute(l),n.addNode(_),p.addInput(t.name+"_t1"),p.addOutput(t.name+"_ap");const I=new e.NodeProto;I.setOpType("Transpose"),I.addInput(t.name+"_ap"),I.addOutput(t.name);const A=new e.AttributeProto;A.setName("perm"),A.setType(e.AttributeProto.AttributeType.INTS);const w=Array.from(a,(h,g)=>g+1);w[0]=0,w[w.length-1]=1,A.setIntsList(w),I.addAttribute(A),n.addNode(I),o[a.length-1]=a[a.length-1]}else throw new Error(`Not implemented value of attribute 'channel_dim' ${t.channel_dim}.`);const i=Array.isArray(t.kernel)?t.kernel:Array(a.length-2).fill(t.kernel),m=new e.AttributeProto;m.setName("kernel_shape"),m.setType(e.AttributeProto.AttributeType.INTS),m.setIntsList(i),p.addAttribute(m);const T=t.stride??t.kernel,y=Array.isArray(T)?T:Array(i.length).fill(T??1),c=new e.AttributeProto;if(c.setName("strides"),c.setType(e.AttributeProto.AttributeType.INTS),c.setIntsList(y),p.addAttribute(c),t.padding!=null){const _=new e.AttributeProto;_.setName("pads"),_.setType(e.AttributeProto.AttributeType.INTS),_.setIntsList(Array.isArray(t.padding)?Array.isArray(t.padding[0])?[...t.padding.map(l=>l[0]),...t.padding.map(l=>l[1])]:[].concat(t.padding,t.padding):Array(i.length*2).fill(t.padding)),p.addAttribute(_)}else{const _=t.channel_dim===1?a.slice(2):a.slice(1,-1);if(_.some(l=>l==null)){const l=new e.AttributeProto;l.setName("auto_pad"),l.setType(e.AttributeProto.AttributeType.STRING),l.setS(new TextEncoder().encode("VALID")),p.addAttribute(l)}else{const l=_.map((I,A)=>(I-i[A])%y[A]),N=new e.AttributeProto;N.setName("pads"),N.setType(e.AttributeProto.AttributeType.INTS),N.setIntsList([...Array(i.length).fill(0),...l]),p.addAttribute(N)}}return n.addNode(p),{size:o}}},Ae={export(u,t,r){const n=u.getGraph(),d=Array.isArray(t.input)?t.input[0]:t.input,a=r[d].size.concat(),p=new e.NodeProto;if(p.setOpType("LRN"),t.channel_dim===1)p.addInput(d),p.addOutput(t.name);else if(t.channel_dim==null||t.channel_dim===-1){const T=new e.NodeProto;T.setOpType("Transpose"),T.addInput(d),T.addOutput(t.name+"_t1");const y=new e.AttributeProto;y.setName("perm"),y.setType(e.AttributeProto.AttributeType.INTS);const c=Array.from(a,(I,A)=>A-1);c[0]=0,c[1]=a.length-1,y.setIntsList(c),T.addAttribute(y),n.addNode(T),p.addInput(t.name+"_t1"),p.addOutput(t.name+"_gap");const _=new e.NodeProto;_.setOpType("Transpose"),_.addInput(t.name+"_gap"),_.addOutput(t.name);const l=new e.AttributeProto;l.setName("perm"),l.setType(e.AttributeProto.AttributeType.INTS);const N=Array.from(a,(I,A)=>A+1);N[0]=0,N[N.length-1]=1,l.setIntsList(N),_.addAttribute(l),n.addNode(_)}else throw new Error(`Not implemented value of attribute 'channel_dim' ${t.channel_dim}.`);if(t.n==null)throw new Error("Require attribute 'n'");const s=new e.AttributeProto;s.setName("size"),s.setType(e.AttributeProto.AttributeType.INT),s.setI(t.n),p.addAttribute(s);const o=new e.AttributeProto;o.setName("alpha"),o.setType(e.AttributeProto.AttributeType.FLOAT),o.setF(t.alpha??1e-4),p.addAttribute(o);const i=new e.AttributeProto;i.setName("beta"),i.setType(e.AttributeProto.AttributeType.FLOAT),i.setF(t.beta??.75),p.addAttribute(i);const m=new e.AttributeProto;m.setName("bias"),m.setType(e.AttributeProto.AttributeType.FLOAT),m.setF(t.k??2),p.addAttribute(m),n.addNode(p)}},Oe={export(u,t,r){if(!Array.isArray(t.input))throw new Error(`Invalid attribute 'input' value ${t.input}.`);const n=u.getGraph(),d=new e.NodeProto;if(t.input.length===1)d.setOpType("Identity"),d.addInput(t.input[0]);else{let p=t.input[0];for(let s=1;s<t.input.length-1;s++){const o=new e.NodeProto;o.setOpType("MatMul"),o.addInput(p),o.addInput(t.input[s]),o.addOutput(p=t.name+`_matmul_${s-1}`),n.addNode(o)}d.setOpType("MatMul"),d.addInput(p),d.addInput(t.input.at(-1))}d.addOutput(t.name),n.addNode(d);const a=r[t.input[0]].size.concat();return a[a.length-1]=r[t.input.at(-1)].size.at(-1),{size:a}}},Pe={export(u,t){if(!Array.isArray(t.input))throw new Error(`Invalid attribute 'input' value ${t.input}.`);const r=new e.NodeProto;r.setOpType("Max");for(const d of t.input)r.addInput(d);r.addOutput(t.name),u.getGraph().addNode(r)}},he={export(u,t,r){const n=u.getGraph(),d=Array.isArray(t.input)?t.input[0]:t.input,a=r[d].size.concat(),p=new e.NodeProto;p.setOpType("MaxPool");const s=Array(a.length).fill(null);if(s[0]=a[0],t.channel_dim===1)p.addInput(d),p.addOutput(t.name),s[1]=a[1];else if(t.channel_dim==null||t.channel_dim===-1){const c=new e.NodeProto;c.setOpType("Transpose"),c.addInput(d),c.addOutput(t.name+"_t1");const _=new e.AttributeProto;_.setName("perm"),_.setType(e.AttributeProto.AttributeType.INTS);const l=Array.from(a,(w,h)=>h-1);l[0]=0,l[1]=a.length-1,_.setIntsList(l),c.addAttribute(_),n.addNode(c),p.addInput(t.name+"_t1"),p.addOutput(t.name+"_ap");const N=new e.NodeProto;N.setOpType("Transpose"),N.addInput(t.name+"_ap"),N.addOutput(t.name);const I=new e.AttributeProto;I.setName("perm"),I.setType(e.AttributeProto.AttributeType.INTS);const A=Array.from(a,(w,h)=>h+1);A[0]=0,A[A.length-1]=1,I.setIntsList(A),N.addAttribute(I),n.addNode(N),s[a.length-1]=a[a.length-1]}else throw new Error(`Not implemented value of attribute 'channel_dim' ${t.channel_dim}.`);const o=Array.isArray(t.kernel)?t.kernel:Array(a.length-2).fill(t.kernel),i=new e.AttributeProto;i.setName("kernel_shape"),i.setType(e.AttributeProto.AttributeType.INTS),i.setIntsList(o),p.addAttribute(i);const m=t.stride??t.kernel,T=Array.isArray(m)?m:Array(o.length).fill(m??1),y=new e.AttributeProto;if(y.setName("strides"),y.setType(e.AttributeProto.AttributeType.INTS),y.setIntsList(T),p.addAttribute(y),t.padding!=null){const c=new e.AttributeProto;c.setName("pads"),c.setType(e.AttributeProto.AttributeType.INTS),c.setIntsList(Array.isArray(t.padding)?Array.isArray(t.padding[0])?[...t.padding.map(_=>_[0]),...t.padding.map(_=>_[1])]:[].concat(t.padding,t.padding):Array(o.length*2).fill(t.padding)),p.addAttribute(c)}else{const c=t.channel_dim===1?a.slice(2):a.slice(1,-1);if(c.some(_=>_==null)){const _=new e.AttributeProto;_.setName("auto_pad"),_.setType(e.AttributeProto.AttributeType.STRING),_.setS(new TextEncoder().encode("VALID")),p.addAttribute(_)}else{const _=c.map((N,I)=>(N-o[I])%T[I]),l=new e.AttributeProto;l.setName("pads"),l.setType(e.AttributeProto.AttributeType.INTS),l.setIntsList([...Array(o.length).fill(0),..._]),p.addAttribute(l)}}return n.addNode(p),{size:s}}},we={export(u,t,r){const n=u.getGraph(),d=Array.isArray(t.input)?t.input[0]:t.input,a=new e.NodeProto;a.setOpType("ReduceMean"),a.addInput(d),a.addOutput(t.name);const p=t.keepdims??!0?1:0,s=new e.AttributeProto;s.setName("keepdims"),s.setType(e.AttributeProto.AttributeType.INT),s.setI(p),a.addAttribute(s),n.addNode(a);const o=r[d].size.concat();if(typeof t.axis=="string")throw new Error("Unsupported axis type string");if(t.axis==null||typeof t.axis=="number"&&t.axis<0)return{size:p?Array(o.length).fill(1):[]};const i=Array.isArray(t.axis)?t.axis:[t.axis],m=new e.TensorProto;if(m.setName(t.name+"_axis"),m.setDataType(e.TensorProto.DataType.INT64),m.setDimsList([i.length]),m.setInt64DataList(i),n.addInitializer(m),a.addInput(t.name+"_axis"),i.sort((T,y)=>y-T),p)for(const T of i)o[T]=1;else for(const T of i)o.splice(T,1);return{size:o}}},ge={export(u,t){if(!Array.isArray(t.input))throw new Error(`Invalid attribute 'input' value ${t.input}.`);const r=new e.NodeProto;r.setOpType("Min");for(const d of t.input)r.addInput(d);r.addOutput(t.name),u.getGraph().addNode(r)}},fe={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("Softplus"),n.addInput(r),n.addOutput(t.name+"_sp");const d=new e.NodeProto;d.setOpType("Tanh"),d.addInput(t.name+"_sp"),d.addOutput(t.name+"_tanh");const a=new e.NodeProto;a.setOpType("Mul"),a.addInput(t.name+"_tanh"),a.addInput(r),a.addOutput(t.name);const p=u.getGraph();p.addNode(n),p.addNode(d),p.addNode(a)}};const De=[e.TensorProto.DataType.INT8,e.TensorProto.DataType.INT16,e.TensorProto.DataType.INT32,e.TensorProto.DataType.INT64,e.TensorProto.DataType.UINT8,e.TensorProto.DataType.UINT16,e.TensorProto.DataType.UINT32,e.TensorProto.DataType.UINT64];var xe={export(u,t,r){if(!Array.isArray(t.input))throw new Error(`Invalid attribute 'input' value ${t.input}.`);const n=u.getGraph(),d=new e.NodeProto;if(t.input.length===1){d.setOpType("Identity"),d.addInput(t.input[0]),d.addOutput(t.name),n.addNode(d);return}const a=[];for(const s of t.input)if(De.includes(r[s].type))a.push(s);else{const o=new e.NodeProto;o.setOpType("Cast"),o.addInput(s),o.addOutput(`${t.name}_${s}_cast`);const i=new e.AttributeProto;i.setName("to"),i.setType(e.AttributeProto.AttributeType.INT),i.setI(e.TensorProto.DataType.INT32),o.addAttribute(i),n.addNode(o),a.push(`${t.name}_${s}_cast`)}let p=a[0];for(let s=1;s<a.length-1;s++){const o=new e.NodeProto;o.setOpType("Mod"),o.addInput(p),o.addInput(a[s]),o.addOutput(p=t.name+`_mod_${s-1}`),n.addNode(o)}return d.setOpType("Mod"),d.addInput(p),d.addInput(a.at(-1)),d.addOutput(t.name),n.addNode(d),{type:e.TensorProto.DataType.INT32}}},ve={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("LeakyRelu"),n.addInput(r),n.addOutput(t.name+"_lrelu");const d=new e.AttributeProto;d.setName("alpha"),d.setType(e.AttributeProto.AttributeType.FLOAT),d.setF(t.beta??1),n.addAttribute(d);const a=new e.NodeProto;a.setOpType("Elu"),a.addInput(t.name+"_lrelu"),a.addOutput(t.name+"_elu");const p=new e.NodeProto;p.setOpType("LeakyRelu"),p.addInput(t.name+"_elu"),p.addOutput(t.name);const s=new e.AttributeProto;s.setName("alpha"),s.setType(e.AttributeProto.AttributeType.FLOAT),s.setF(t.alpha??1),p.addAttribute(d);const o=u.getGraph();o.addNode(n),o.addNode(a),o.addNode(p)}},Le={export(u,t){if(!Array.isArray(t.input))throw new Error(`Invalid attribute 'input' value ${t.input}.`);const r=u.getGraph(),n=new e.NodeProto;if(t.input.length===1)n.setOpType("Identity"),n.addInput(t.input[0]);else{let d=t.input[0];for(let a=1;a<t.input.length-1;a++){const p=new e.NodeProto;p.setOpType("Mul"),p.addInput(d),p.addInput(t.input[a]),p.addOutput(d=t.name+`_mul_${a-1}`),r.addNode(p)}n.setOpType("Mul"),n.addInput(d),n.addInput(t.input.at(-1))}n.addOutput(t.name),r.addNode(n)}},Fe={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("Neg"),n.addInput(r),n.addOutput(t.name),u.getGraph().addNode(n)}},ze={export(u,t){const r=O(u,1),n=new e.TensorProto;n.setName(t.name+"_beta"),n.setDataType(e.TensorProto.DataType.FLOAT),n.setDimsList([1]),n.setFloatDataList([t.beta??1]);const d=Array.isArray(t.input)?t.input[0]:t.input,a=new e.NodeProto;a.setOpType("Relu"),a.addInput(d),a.addOutput(t.name+"_relu");const p=new e.NodeProto;p.setOpType("Mul"),p.addInput(t.name+"_relu"),p.addInput(t.name+"_beta"),p.addOutput(t.name+"_mul");const s=new e.NodeProto;s.setOpType("Add"),s.addInput(t.name+"_mul"),s.addInput(r),s.addOutput(t.name+"_add");const o=new e.NodeProto;o.setOpType("Log"),o.addInput(t.name+"_add"),o.addOutput(t.name);const i=u.getGraph();i.addInitializer(n),i.addNode(a),i.addNode(p),i.addNode(s),i.addNode(o)}},Ge={export(u,t,r){const n=u.getGraph(),d=new e.NodeProto;d.setOpType("Not");const a=Array.isArray(t.input)?t.input[0]:t.input;if(e.TensorProto.DataType.BOOL===r[a].type)d.addInput(a);else{const p=new e.NodeProto;p.setOpType("Cast"),p.addInput(a),p.addOutput(`${t.name}_${a}_cast`);const s=new e.AttributeProto;s.setName("to"),s.setType(e.AttributeProto.AttributeType.INT),s.setI(e.TensorProto.DataType.BOOL),p.addAttribute(s),n.addNode(p),d.addInput(`${t.name}_${a}_cast`)}return d.addOutput(t.name),n.addNode(d),{type:e.TensorProto.DataType.BOOL}}},Se={export(u,t,r){if(!Array.isArray(t.input))throw new Error(`Invalid attribute 'input' value ${t.input}.`);const n=u.getGraph(),d=new e.NodeProto;if(t.input.length===1){d.setOpType("Identity"),d.addInput(t.input[0]),d.addOutput(t.name),n.addNode(d);return}const a=[];for(const s of t.input)if(r[s].type===e.TensorProto.DataType.BOOL)a.push(s);else{const o=new e.NodeProto;o.setOpType("Cast"),o.addInput(s),o.addOutput(`${t.name}_${s}_cast`);const i=new e.AttributeProto;i.setName("to"),i.setType(e.AttributeProto.AttributeType.INT),i.setI(e.TensorProto.DataType.BOOL),o.addAttribute(i),n.addNode(o),a.push(`${t.name}_${s}_cast`)}let p=a[0];for(let s=1;s<a.length-1;s++){const o=new e.NodeProto;o.setOpType("Or"),o.addInput(p),o.addInput(a[s]),o.addOutput(p=t.name+`_or_${s-1}`),n.addNode(o)}return d.setOpType("Or"),d.addInput(p),d.addInput(a.at(-1)),d.addOutput(t.name),n.addNode(d),{type:e.TensorProto.DataType.BOOL}}},$e={export(u,t,r){const n=new e.ValueInfoProto,d=new e.TypeProto,a=Array.isArray(t.input)?t.input[0]:t.input,p=new e.TypeProto.Tensor;p.setElemType(r[a].type);const s=new e.TensorShapeProto,o=r[a].size??[-1,-1];s.setDimList(o.map(m=>{const T=new e.TensorShapeProto.Dimension;return T.setDimValue(m),T})),p.setShape(s),d.setTensorType(p),n.setType(d),n.setName(t.input),u.getGraph().addOutput(n)}},Ee={export(u,t){const r=u.getGraph(),n=Array.isArray(t.input)?t.input[0]:t.input,d=Array.isArray(t.a)?t.a:Array((t.m??2)+1).fill(t.a??.1),a=Array.isArray(t.b)?t.b:Array(t.n??2).fill(t.b??0);let p=n;for(let _=2;_<Math.max(d.length,a.length+1);_++){const l=new e.NodeProto;l.setOpType("Mul"),l.addInput(n),l.addInput(p),l.addOutput(p=t.name+`_pow${_}`),r.addNode(l)}const s=new e.NodeProto;s.setOpType("Sum"),r.addNode(s);const o=new e.TensorProto;o.setName(t.name+"_a0"),o.setDataType(e.TensorProto.DataType.FLOAT),o.setDimsList([1]),o.setFloatDataList([d[0]]),r.addInitializer(o),s.addInput(t.name+"_a0");for(let _=1;_<d.length;_++){const l=new e.TensorProto;l.setName(t.name+`_a${_}`),l.setDataType(e.TensorProto.DataType.FLOAT),l.setDimsList([1]),l.setFloatDataList([d[_]]),r.addInitializer(l);const N=new e.NodeProto;N.setOpType("Mul"),N.addInput(_===1?n:t.name+`_pow${_}`),N.addInput(t.name+`_a${_}`),N.addOutput(t.name+`_mul_a${_}`),r.addNode(N),s.addInput(t.name+`_mul_a${_}`)}if(a.length===0){s.addOutput(t.name);return}s.addOutput(t.name+"_a");const i=new e.NodeProto;i.setOpType("Sum"),i.addOutput(t.name+"_b"),r.addNode(i);for(let _=0;_<a.length;_++){const l=new e.TensorProto;l.setName(t.name+`_b${_}`),l.setDataType(e.TensorProto.DataType.FLOAT),l.setDimsList([1]),l.setFloatDataList([a[_]]),r.addInitializer(l);const N=new e.NodeProto;N.setOpType("Mul"),N.addInput(_===0?n:t.name+`_pow${_+1}`),N.addInput(t.name+`_b${_}`),N.addOutput(t.name+`_mul_b${_}`),r.addNode(N),i.addInput(t.name+`_mul_b${_}`)}const m=new e.NodeProto;m.setOpType("Abs"),m.addInput(t.name+"_b"),m.addOutput(t.name+"_abs"),r.addNode(m);const T=O(u,1),y=new e.NodeProto;y.setOpType("Add"),y.addInput(T),y.addInput(t.name+"_abs"),y.addOutput(t.name+"_add"),r.addNode(y);const c=new e.NodeProto;c.setOpType("Div"),c.addInput(t.name+"_a"),c.addInput(t.name+"_add"),c.addOutput(t.name),r.addNode(c)}},Me={export(u,t){const r=O(u,0),n=O(u,1),d=new e.TensorProto;d.setName(t.name+"_alpha"),d.setDataType(e.TensorProto.DataType.FLOAT),d.setDimsList([1]),d.setFloatDataList([t.alpha??1]);const a=new e.TensorProto;a.setName(t.name+"_t"),a.setDataType(e.TensorProto.DataType.FLOAT),a.setDimsList([1]),a.setFloatDataList([t.t??.1]);const p=new e.NodeProto;p.setOpType("Sub"),p.addInput(n),p.addInput(t.name+"_t"),p.addOutput(t.name+"_1-t");const s=Array.isArray(t.input)?t.input[0]:t.input,o=new e.NodeProto;o.setOpType("Mul"),o.addInput(s),o.addInput(t.name+"_1-t"),o.addOutput(t.name+"_(1-t)*v");const i=new e.NodeProto;i.setOpType("Add"),i.addInput(t.name+"_(1-t)*v"),i.addInput(n),i.addOutput(t.name+"_1+(1-t)*v");const m=new e.NodeProto;m.setOpType("Reciprocal"),m.addInput(t.name+"_1-t"),m.addOutput(t.name+"_1/(1-t)");const T=new e.NodeProto;T.setOpType("Pow"),T.addInput(t.name+"_1+(1-t)*v"),T.addInput(t.name+"_1/(1-t)"),T.addOutput(t.name+"_pow");const y=new e.NodeProto;y.setOpType("Sub"),y.addInput(t.name+"_pow"),y.addInput(n),y.addOutput(t.name+"_sub");const c=new e.NodeProto;c.setOpType("Mul"),c.addInput(t.name+"_sub"),c.addInput(t.name+"_alpha"),c.addOutput(t.name+"_mul_alpha");const _=new e.NodeProto;_.setOpType("Greater"),_.addInput(s),_.addInput(r),_.addOutput(t.name+"_posneg");const l=new e.NodeProto;l.setOpType("Where"),l.addInput(t.name+"_posneg"),l.addInput(s),l.addInput(t.name+"_mul_alpha"),l.addOutput(t.name);const N=u.getGraph();N.addInitializer(d),N.addInitializer(a),N.addNode(p),N.addNode(o),N.addNode(i),N.addNode(m),N.addNode(T),N.addNode(y),N.addNode(c),N.addNode(_),N.addNode(l)}},ke={export(u,t){const r=new e.TensorProto;r.setName(t.name+"_a"),r.setDataType(e.TensorProto.DataType.FLOAT),r.setDimsList([1]),r.setFloatDataList([t.a??1]);const n=new e.TensorProto;n.setName(t.name+"_b"),n.setDataType(e.TensorProto.DataType.FLOAT),n.setDimsList([1]),n.setFloatDataList([t.b??1]);const d=Array.isArray(t.input)?t.input[0]:t.input,a=new e.NodeProto;a.setOpType("Div"),a.addInput(d),a.addInput(t.name+"_b"),a.addOutput(t.name+"_div");const p=new e.NodeProto;p.setOpType("Elu"),p.addInput(t.name+"_div"),p.addOutput(t.name+"_elu");const s=new e.NodeProto;s.setOpType("Mul"),s.addInput(t.name+"_elu"),s.addInput(t.name+"_a"),s.addOutput(t.name);const o=u.getGraph();o.addInitializer(r),o.addInitializer(n),o.addNode(a),o.addNode(p),o.addNode(s)}},Re={export(u,t){const r=new e.TensorProto;r.setName(t.name+"_alpha"),r.setDataType(e.TensorProto.DataType.FLOAT),r.setDimsList([1]),r.setFloatDataList([t.alpha??.1]);const n=new e.TensorProto;n.setName(t.name+"_c"),n.setDataType(e.TensorProto.DataType.FLOAT),n.setDimsList([1]),n.setFloatDataList([t.c??1]);const d=Array.isArray(t.input)?t.input[0]:t.input,a=new e.NodeProto;a.setOpType("Add"),a.addInput(d),a.addInput(t.name+"_c"),a.addOutput(t.name+"_lb_add");const p=new e.NodeProto;p.setOpType("Mul"),p.addInput(t.name+"_lb_add"),p.addInput(t.name+"_alpha"),p.addOutput(t.name+"_lb_mul");const s=new e.NodeProto;s.setOpType("Sub"),s.addInput(t.name+"_lb_mul"),s.addInput(t.name+"_c"),s.addOutput(t.name+"_lb");const o=new e.NodeProto;o.setOpType("Sub"),o.addInput(d),o.addInput(t.name+"_c"),o.addOutput(t.name+"_ub_sub");const i=new e.NodeProto;i.setOpType("Mul"),i.addInput(t.name+"_ub_sub"),i.addInput(t.name+"_alpha"),i.addOutput(t.name+"_ub_mul");const m=new e.NodeProto;m.setOpType("Add"),m.addInput(t.name+"_ub_mul"),m.addInput(t.name+"_c"),m.addOutput(t.name+"_ub");const T=new e.NodeProto;T.setOpType("Min"),T.addInput(d),T.addInput(t.name+"_ub"),T.addOutput(t.name+"_min");const y=new e.NodeProto;y.setOpType("Max"),y.addInput(t.name+"_min"),y.addInput(t.name+"_lb"),y.addOutput(t.name);const c=u.getGraph();c.addInitializer(r),c.addInitializer(n),c.addNode(a),c.addNode(p),c.addNode(s),c.addNode(o),c.addNode(i),c.addNode(m),c.addNode(T),c.addNode(y)}},Be={export(u,t){if(!Array.isArray(t.input))throw new Error(`Invalid attribute 'input' value ${t.input}.`);const r=u.getGraph(),n=new e.NodeProto;if(t.input.length===1)n.setOpType("Identity"),n.addInput(t.input[0]);else{let d=t.input[0];for(let a=1;a<t.input.length-1;a++){const p=new e.NodeProto;p.setOpType("Pow"),p.addInput(d),p.addInput(t.input[a]),p.addOutput(d=t.name+`_mul_${a-1}`),r.addNode(p)}n.setOpType("Pow"),n.addInput(d),n.addInput(t.input.at(-1))}n.addOutput(t.name),r.addNode(n)}},qe={export(u,t){const r=u.getGraph(),n=Array.isArray(t.input)?t.input[0]:t.input,d=new e.NodeProto;if(d.setOpType("PRelu"),d.addInput(n),d.addOutput(t.name),typeof t.a=="string")d.addInput(t.a);else{const a=Array.isArray(t.a)?t.a:[t.a??.25],p=new e.TensorProto;p.setName(t.name+"_a"),p.setDataType(e.TensorProto.DataType.FLOAT),p.setDimsList([a.length]),p.setFloatDataList(a),d.addInput(t.name+"_a"),r.addInitializer(p)}r.addNode(d)}},Ue={export(u,t){const r=O(u,0),n=new e.TensorProto;n.setName(t.name+"_alpha"),n.setDataType(e.TensorProto.DataType.FLOAT),n.setDimsList([1]),n.setFloatDataList([t.alpha??1]);const d=new e.TensorProto;d.setName(t.name+"_beta"),d.setDataType(e.TensorProto.DataType.FLOAT),d.setDimsList([1]),d.setFloatDataList([t.beta??1]);const a=Array.isArray(t.input)?t.input[0]:t.input,p=new e.NodeProto;p.setOpType("Min"),p.addInput(a),p.addInput(r),p.addOutput(t.name+"_min");const s=new e.NodeProto;s.setOpType("Mul"),s.addInput(t.name+"_min"),s.addInput(t.name+"_beta"),s.addOutput(t.name+"_mul_b");const o=new e.NodeProto;o.setOpType("Exp"),o.addInput(t.name+"_mul_b"),o.addOutput(t.name+"_exp");const i=new e.NodeProto;i.setOpType("Mul"),i.addInput(a),i.addInput(t.name+"_alpha"),i.addOutput(t.name+"_mul_a");const m=new e.NodeProto;m.setOpType("Mul"),m.addInput(t.name+"_mul_a"),m.addInput(t.name+"_exp"),m.addOutput(t.name);const T=u.getGraph();T.addInitializer(n),T.addInitializer(d),T.addNode(p),T.addNode(s),T.addNode(o),T.addNode(i),T.addNode(m)}},Ce={export(u,t,r){const n=u.getGraph(),d=Array.isArray(t.input)?t.input[0]:t.input,a=new e.NodeProto;a.setOpType("ReduceProd"),a.addInput(d),a.addOutput(t.name);const p=t.keepdims??!0?1:0,s=new e.AttributeProto;s.setName("keepdims"),s.setType(e.AttributeProto.AttributeType.INT),s.setI(p),a.addAttribute(s),n.addNode(a);const o=r[d].size.concat();if(typeof t.axis=="string")throw new Error("Unsupported axis type string");if(t.axis==null||typeof t.axis=="number"&&t.axis<0)return{size:p?Array(o.length).fill(1):[]};const i=Array.isArray(t.axis)?t.axis:[t.axis],m=new e.TensorProto;if(m.setName(t.name+"_axis"),m.setDataType(e.TensorProto.DataType.INT64),m.setDimsList([i.length]),m.setInt64DataList(i),n.addInitializer(m),a.addInput(t.name+"_axis"),i.sort((T,y)=>y-T),p)for(const T of i)o[T]=1;else for(const T of i)o.splice(T,1);return{size:o}}},Ve={export(u,t){const r=new e.TensorProto;r.setName(t.name+"_m"),r.setDataType(e.TensorProto.DataType.FLOAT),r.setDimsList([1]),r.setFloatDataList([t.m??2]);const n=Array.isArray(t.input)?t.input[0]:t.input,d=new e.NodeProto;d.setOpType("Sigmoid"),d.addInput(n),d.addOutput(t.name+"_sigmoid");const a=new e.NodeProto;a.setOpType("Pow"),a.addInput(t.name+"_sigmoid"),a.addInput(t.name+"_m"),a.addOutput(t.name);const p=u.getGraph();p.addInitializer(r),p.addNode(d),p.addNode(a)}},Ke={export(u,t){const r=O(u,0),n=O(u,1),d=new e.TensorProto;d.setName(t.name+"_a"),d.setDataType(e.TensorProto.DataType.FLOAT),d.setDimsList([1]),d.setFloatDataList([t.a??.25]);const a=Array.isArray(t.input)?t.input[0]:t.input,p=new e.NodeProto;p.setOpType("Tanh"),p.addInput(a),p.addOutput(t.name+"_tanh");const s=new e.NodeProto;s.setOpType("Less"),s.addInput(a),s.addInput(r),s.addOutput(t.name+"_less");const o=new e.NodeProto;o.setOpType("Where"),o.addInput(t.name+"_less"),o.addInput(t.name+"_a"),o.addInput(n),o.addOutput(t.name+"_where");const i=new e.NodeProto;i.setOpType("Mul"),i.addInput(t.name+"_tanh"),i.addInput(t.name+"_where"),i.addOutput(t.name);const m=u.getGraph();m.addInitializer(d),m.addNode(p),m.addNode(s),m.addNode(o),m.addNode(i)}},We={export(u,t){const r=O(u,0),n=new e.TensorProto;n.setName(t.name+"_alpha"),n.setDataType(e.TensorProto.DataType.FLOAT),n.setDimsList([1]),n.setFloatDataList([t.alpha??1]);const d=new e.TensorProto;d.setName(t.name+"_beta"),d.setDataType(e.TensorProto.DataType.FLOAT),d.setDimsList([1]),d.setFloatDataList([t.beta??1]);const a=Array.isArray(t.input)?t.input[0]:t.input,p=new e.NodeProto;p.setOpType("Mul"),p.addInput(a),p.addInput(t.name+"_beta"),p.addOutput(t.name+"_mul_b");const s=new e.NodeProto;s.setOpType("Tanh"),s.addInput(t.name+"_mul_b"),s.addOutput(t.name+"_tanh");const o=new e.NodeProto;o.setOpType("Mul"),o.addInput(t.name+"_tanh"),o.addInput(t.name+"_alpha"),o.addOutput(t.name+"_mul_a");const i=new e.NodeProto;i.setOpType("Greater"),i.addInput(a),i.addInput(r),i.addOutput(t.name+"_greater");const m=new e.NodeProto;m.setOpType("Where"),m.addInput(t.name+"_greater"),m.addInput(a),m.addInput(t.name+"_mul_a"),m.addOutput(t.name);const T=u.getGraph();T.addInitializer(n),T.addInitializer(d),T.addNode(p),T.addNode(s),T.addNode(o),T.addNode(i),T.addNode(m)}},He={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("Reciprocal"),n.addInput(r),n.addOutput(t.name),u.getGraph().addNode(n)}},Xe={export(u,t,r){const n=u.getGraph(),d=Array.isArray(t.input)?t.input[0]:t.input,a=new e.NodeProto;a.setOpType("ReduceMax"),a.addInput(d),a.addOutput(t.name);const p=t.keepdims??!0?1:0,s=new e.AttributeProto;s.setName("keepdims"),s.setType(e.AttributeProto.AttributeType.INT),s.setI(p),a.addAttribute(s),n.addNode(a);const o=r[d].size.concat();if(typeof t.axis=="string")throw new Error("Unsupported axis type string");if(t.axis==null||typeof t.axis=="number"&&t.axis<0)return{size:p?Array(o.length).fill(1):[]};const i=Array.isArray(t.axis)?t.axis:[t.axis],m=new e.TensorProto;if(m.setName(t.name+"_axis"),m.setDataType(e.TensorProto.DataType.INT64),m.setDimsList([i.length]),m.setInt64DataList(i),n.addInitializer(m),a.addInput(t.name+"_axis"),i.sort((T,y)=>y-T),p)for(const T of i)o[T]=1;else for(const T of i)o.splice(T,1);return{size:o}}},Je={export(u,t,r){const n=u.getGraph(),d=Array.isArray(t.input)?t.input[0]:t.input,a=new e.NodeProto;a.setOpType("ReduceMin"),a.addInput(d),a.addOutput(t.name);const p=t.keepdims??!0?1:0,s=new e.AttributeProto;s.setName("keepdims"),s.setType(e.AttributeProto.AttributeType.INT),s.setI(p),a.addAttribute(s),n.addNode(a);const o=r[d].size.concat();if(typeof t.axis=="string")throw new Error("Unsupported axis type string");if(t.axis==null||typeof t.axis=="number"&&t.axis<0)return{size:p?Array(o.length).fill(1):[]};const i=Array.isArray(t.axis)?t.axis:[t.axis],m=new e.TensorProto;if(m.setName(t.name+"_axis"),m.setDataType(e.TensorProto.DataType.INT64),m.setDimsList([i.length]),m.setInt64DataList(i),n.addInitializer(m),a.addInput(t.name+"_axis"),i.sort((T,y)=>y-T),p)for(const T of i)o[T]=1;else for(const T of i)o.splice(T,1);return{size:o}}},Qe={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("Relu"),n.addInput(r),n.addOutput(t.name),u.getGraph().addNode(n)}},Ye={export(u,t){const r=new e.TensorProto;r.setName(t.name+"_s"),r.setDataType(e.TensorProto.DataType.FLOAT),r.setDimsList([1]),r.setFloatDataList([t.s??2]);const n=Array.isArray(t.input)?t.input[0]:t.input,d=new e.NodeProto;d.setOpType("Relu"),d.addInput(n),d.addOutput(t.name+"_relu");const a=new e.NodeProto;a.setOpType("Pow"),a.addInput(t.name+"_relu"),a.addInput(t.name+"_s"),a.addOutput(t.name);const p=u.getGraph();p.addInitializer(r),p.addNode(d),p.addNode(a)}},Ze={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("Cosh"),n.addInput(r),n.addOutput(t.name+"_cosh");const d=new e.NodeProto;d.setOpType("Div"),d.addInput(r),d.addInput(t.name+"_cosh"),d.addOutput(t.name);const a=u.getGraph();a.addNode(n),a.addNode(d)}},be={export(u,t,r){const n=Array.isArray(t.input)?t.input[0]:t.input,d=r[n].size,a=typeof t.size=="string"?r[t.size].size:t.size;(a.length===1||d.slice(1).reduce((i,m)=>i*m,1)===a.reduce((i,m)=>i*m,1))&&a.unshift(d[0]);const p=new e.TensorProto;p.setName(t.name+"_shape"),p.setDataType(e.TensorProto.DataType.INT64),p.setDimsList([a.length]),p.setInt64DataList(a.map(i=>i??-1));const s=new e.NodeProto;s.setOpType("Reshape"),s.addInput(n),s.addInput(t.name+"_shape"),s.addOutput(t.name);const o=u.getGraph();return o.addInitializer(p),o.addNode(s),{size:a}}},je={export(u,t){const r=O(u,1),n=Array.isArray(t.input)?t.input[0]:t.input,d=new e.NodeProto;d.setOpType("Exp"),d.addInput(n),d.addOutput(t.name+"_exp");const a=new e.NodeProto;a.setOpType("Min"),a.addInput(r),a.addInput(t.name+"_exp"),a.addOutput(t.name+"_min");const p=new e.NodeProto;p.setOpType("Mul"),p.addInput(n),p.addInput(t.name+"_min"),p.addOutput(t.name);const s=u.getGraph();s.addNode(d),s.addNode(a),s.addNode(p)}};const tn=[e.TensorProto.DataType.UINT8,e.TensorProto.DataType.UINT16,e.TensorProto.DataType.UINT32,e.TensorProto.DataType.UINT64];var en={export(u,t,r){if(!Array.isArray(t.input))throw new Error(`Invalid attribute 'input' value ${t.input}.`);const n=u.getGraph(),d=new e.AttributeProto;d.setName("direction"),d.setType(e.AttributeProto.AttributeType.STRING),d.setS(new TextEncoder().encode("RIGHT"));const a=new e.NodeProto;if(t.input.length===1){a.setOpType("Identity"),a.addInput(t.input[0]),a.addOutput(t.name),n.addNode(a);return}const p=[];for(const o of t.input)if(tn.includes(r[o].type))p.push(o);else{const i=new e.NodeProto;i.setOpType("Cast"),i.addInput(o),i.addOutput(`${t.name}_${o}_cast`);const m=new e.AttributeProto;m.setName("to"),m.setType(e.AttributeProto.AttributeType.INT),m.setI(e.TensorProto.DataType.UINT32),i.addAttribute(m),n.addNode(i),p.push(`${t.name}_${o}_cast`)}let s=p[0];for(let o=1;o<p.length-1;o++){const i=new e.NodeProto;i.setOpType("BitShift"),i.addInput(s),i.addInput(p[o]),i.addOutput(s=t.name+`_bitshift_${o-1}`),i.addAttribute(d),n.addNode(i)}return a.setOpType("BitShift"),a.addInput(s),a.addInput(p.at(-1)),a.addAttribute(d),a.addOutput(t.name),n.addNode(a),{type:e.TensorProto.DataType.UINT32}}},nn={export(u,t){const r=O(u,1),n=O(u,2),d=Array.isArray(t.input)?t.input[0]:t.input,a=new e.NodeProto;a.setOpType("Pow"),a.addInput(d),a.addInput(n),a.addOutput(t.name+"_pow");const p=new e.NodeProto;p.setOpType("Add"),p.addInput(r),p.addInput(t.name+"_pow"),p.addOutput(t.name+"_add1");const s=new e.NodeProto;s.setOpType("Sqrt"),s.addInput(t.name+"_add1"),s.addOutput(t.name+"_sqrt");const o=new e.NodeProto;o.setOpType("Add"),o.addInput(r),o.addInput(t.name+"_sqrt"),o.addOutput(t.name+"_add2");const i=new e.NodeProto;i.setOpType("Div"),i.addInput(d),i.addInput(t.name+"_add2"),i.addOutput(t.name);const m=u.getGraph();m.addNode(a),m.addNode(p),m.addNode(s),m.addNode(o),m.addNode(i)}},an={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("Round"),n.addInput(r),n.addOutput(t.name),u.getGraph().addNode(n)}},dn={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("LeakyRelu"),n.addInput(r),n.addOutput(t.name);const d=new e.AttributeProto;d.setName("alpha"),d.setType(e.AttributeProto.AttributeType.FLOAT),d.setF(((t.l??1/8)+(t.u??1/3))/2),n.addAttribute(d),u.getGraph().addNode(n)}},pn={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("Relu"),n.addInput(r),n.addOutput(t.name),u.getGraph().addNode(n)}},rn={export(u,t){const r=new e.TensorProto;r.setName(t.name+"_g"),r.setDataType(e.TensorProto.DataType.FLOAT),r.setDimsList([1]),r.setFloatDataList([t.g??1.0507010221481323]);const n=Array.isArray(t.input)?t.input[0]:t.input,d=new e.NodeProto;d.setOpType("Elu"),d.addInput(n),d.addOutput(t.name+"_elu");const a=new e.AttributeProto;a.setName("alpha"),a.setType(e.AttributeProto.AttributeType.FLOAT),a.setF(t.a??1.6732631921768188),d.addAttribute(a);const p=new e.NodeProto;p.setOpType("Mul"),p.addInput(t.name+"_elu"),p.addInput(t.name+"_g"),p.addOutput(t.name);const s=u.getGraph();s.addInitializer(r),s.addNode(d),s.addNode(p)}},sn={export(u,t){const r=new e.TensorProto;r.setName(t.name+"_a"),r.setDataType(e.TensorProto.DataType.FLOAT),r.setDimsList([1]),r.setFloatDataList([t.a??1]);const n=Array.isArray(t.input)?t.input[0]:t.input,d=new e.NodeProto;d.setOpType("Mul"),d.addInput(n),d.addInput(t.name+"_a"),d.addOutput(t.name+"_mul");const a=new e.NodeProto;a.setOpType("Sigmoid"),a.addInput(t.name+"_mul"),a.addOutput(t.name);const p=u.getGraph();p.addInitializer(r),p.addNode(d),p.addNode(a)}},on={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("Sign"),n.addInput(r),n.addOutput(t.name),u.getGraph().addNode(n)}},un={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("Sigmoid"),n.addInput(r),n.addOutput(t.name+"_sigmoid");const d=new e.NodeProto;d.setOpType("Mul"),d.addInput(r),d.addInput(t.name+"_sigmoid"),d.addOutput(t.name);const a=u.getGraph();a.addNode(n),a.addNode(d)}},mn={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("Sin"),n.addInput(r),n.addOutput(t.name),u.getGraph().addNode(n)}},Tn={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("Sinh"),n.addInput(r),n.addOutput(t.name),u.getGraph().addNode(n)}},yn={export(u,t){const r=t.n??3,n=Array.isArray(t.a)?t.a:Array(r).fill(t.a??1),d=Array.isArray(t.input)?t.input[0]:t.input,a=u.getGraph(),p=new e.TensorProto;p.setName(t.name+"_a0"),p.setDataType(e.TensorProto.DataType.FLOAT),p.setDimsList([1]),p.setFloatDataList([n[0]]),a.addInitializer(p);const s=new e.NodeProto;s.setOpType("Sum"),s.addInput(t.name+"_a0"),s.addOutput(t.name);let o=d;for(let i=1;i<r;i++){const m=new e.TensorProto;m.setName(t.name+`_a${i}`),m.setDataType(e.TensorProto.DataType.FLOAT),m.setDimsList([1]),m.setFloatDataList([n[i]]),a.addInitializer(m);const T=new e.NodeProto;if(T.setOpType("Mul"),i===1)T.addInput(d);else{const y=new e.NodeProto;y.setOpType("Mul"),y.addInput(d),y.addInput(o),y.addOutput(t.name+`_pow${i}`),o=t.name+`_pow${i}`,T.addInput(t.name+`_pow${i}`),a.addNode(y)}T.addInput(t.name+`_a${i}`),T.addOutput(t.name+`_${i}`),a.addNode(T),s.addInput(t.name+`_${i}`)}a.addNode(s)}},_n={export(u,t){const r=O(u,0),n=new e.TensorProto;n.setName(t.name+"_alpha"),n.setDataType(e.TensorProto.DataType.FLOAT),n.setDimsList([1]),n.setFloatDataList([t.alpha??1]);const d=new e.TensorProto;d.setName(t.name+"_beta"),d.setDataType(e.TensorProto.DataType.FLOAT),d.setDimsList([1]),d.setFloatDataList([t.beta??1]);const a=new e.TensorProto;a.setName(t.name+"_gamma"),a.setDataType(e.TensorProto.DataType.FLOAT),a.setDimsList([1]),a.setFloatDataList([t.gamma??0]);const p=Array.isArray(t.input)?t.input[0]:t.input,s=new e.NodeProto;s.setOpType("Softplus"),s.addInput(p),s.addOutput(t.name+"_softplus");const o=new e.NodeProto;o.setOpType("Mul"),o.addInput(t.name+"_softplus"),o.addInput(t.name+"_beta"),o.addOutput(t.name+"_mul_beta");const i=new e.NodeProto;i.setOpType("Sub"),i.addInput(t.name+"_mul_beta"),i.addInput(t.name+"_gamma"),i.addOutput(t.name+"_sub");const m=new e.NodeProto;m.setOpType("Mul"),m.addInput(p),m.addInput(t.name+"_alpha"),m.addOutput(t.name+"_mul_alpha");const T=new e.NodeProto;T.setOpType("Greater"),T.addInput(p),T.addInput(r),T.addOutput(t.name+"_greater");const y=new e.NodeProto;y.setOpType("Where"),y.addInput(t.name+"_greater"),y.addInput(t.name+"_mul_alpha"),y.addInput(t.name+"_sub"),y.addOutput(t.name);const c=u.getGraph();c.addInitializer(n),c.addInitializer(d),c.addInitializer(a),c.addNode(s),c.addNode(o),c.addNode(i),c.addNode(m),c.addNode(T),c.addNode(y)}},cn={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("Shrink"),n.addInput(r),n.addOutput(t.name);const d=new e.AttributeProto;d.setName("bias"),d.setType(e.AttributeProto.AttributeType.FLOAT),d.setF(t.l??.5),n.addAttribute(d);const a=new e.AttributeProto;a.setName("lambd"),a.setType(e.AttributeProto.AttributeType.FLOAT),a.setF(t.l??.5),n.addAttribute(a),u.getGraph().addNode(n)}},ln={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("Softmax"),n.addInput(r),n.addOutput(t.name);const d=new e.AttributeProto;d.setName("axis"),d.setType(e.AttributeProto.AttributeType.INT),d.setI(t.axis??-1),n.addAttribute(d),u.getGraph().addNode(n)}},Nn={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("Neg"),n.addInput(r),n.addOutput(t.name+"_neg");const d=new e.NodeProto;d.setOpType("Softmax"),d.addInput(t.name+"_neg"),d.addOutput(t.name);const a=new e.AttributeProto;a.setName("axis"),a.setType(e.AttributeProto.AttributeType.INT),a.setI(t.axis??-1),d.addAttribute(a);const p=u.getGraph();p.addNode(n),p.addNode(d)}},In={export(u,t){const r=new e.TensorProto;r.setName(t.name+"_beta"),r.setDataType(e.TensorProto.DataType.FLOAT),r.setDimsList([1]),r.setFloatDataList([t.beta??1]);const n=Array.isArray(t.input)?t.input[0]:t.input,d=new e.NodeProto;d.setOpType("Mul"),d.addInput(n),d.addInput(t.name+"_beta"),d.addOutput(t.name+"_mul");const a=new e.NodeProto;a.setOpType("Softplus"),a.addInput(t.name+"_mul"),a.addOutput(t.name+"_softplus");const p=new e.NodeProto;p.setOpType("Div"),p.addInput(t.name+"_softplus"),p.addInput(t.name+"_beta"),p.addOutput(t.name);const s=u.getGraph();s.addInitializer(r),s.addNode(d),s.addNode(a),s.addNode(p)}},An={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("Softsign"),n.addInput(r),n.addOutput(t.name),u.getGraph().addNode(n)}},On={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("Sqrt"),n.addInput(r),n.addOutput(t.name),u.getGraph().addNode(n)}},Pn={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("Mul"),n.addInput(r),n.addInput(r),n.addOutput(t.name),u.getGraph().addNode(n)}},hn={export(u,t){const r=new e.TensorProto;r.setName(t.name+"_d"),r.setDataType(e.TensorProto.DataType.FLOAT),r.setDimsList([1]),r.setFloatDataList([t.d??0]);const n=Array.isArray(t.input)?t.input[0]:t.input,d=new e.NodeProto;d.setOpType("Max"),d.addInput(n),d.addInput(t.name+"_d"),d.addOutput(t.name);const a=u.getGraph();a.addInitializer(r),a.addNode(d)}},wn={export(u,t){const r=new e.TensorProto;r.setName(t.name+"_alpha"),r.setDataType(e.TensorProto.DataType.FLOAT),r.setDimsList([1]),r.setFloatDataList([t.alpha??3]);const n=new e.TensorProto;n.setName(t.name+"_beta"),n.setDataType(e.TensorProto.DataType.FLOAT),n.setDimsList([1]),n.setFloatDataList([t.beta??2]);const d=Array.isArray(t.input)?t.input[0]:t.input,a=new e.NodeProto;a.setOpType("Neg"),a.addInput(d),a.addOutput(t.name+"_neg");const p=new e.NodeProto;p.setOpType("Div"),p.addInput(t.name+"_neg"),p.addInput(t.name+"_beta"),p.addOutput(t.name+"_div_beta");const s=new e.NodeProto;s.setOpType("Exp"),s.addInput(t.name+"_div_beta"),s.addOutput(t.name+"_exp");const o=new e.NodeProto;o.setOpType("Div"),o.addInput(d),o.addInput(t.name+"_alpha"),o.addOutput(t.name+"_div_alpha");const i=new e.NodeProto;i.setOpType("Add"),i.addInput(t.name+"_div_alpha"),i.addInput(t.name+"_exp"),i.addOutput(t.name+"_add");const m=new e.NodeProto;m.setOpType("Div"),m.addInput(d),m.addInput(t.name+"_add"),m.addOutput(t.name);const T=u.getGraph();T.addInitializer(r),T.addInitializer(n),T.addNode(a),T.addNode(p),T.addNode(s),T.addNode(o),T.addNode(i),T.addNode(m)}},gn={export(u,t){const r=O(u,2),n=O(u,4),d=Array.isArray(t.input)?t.input[0]:t.input,a=new e.NodeProto;a.setOpType("Sigmoid"),a.addInput(d),a.addOutput(t.name+"_sigmoid");const p=new e.NodeProto;p.setOpType("Mul"),p.addInput(t.name+"_sigmoid"),p.addInput(n),p.addOutput(t.name+"_mul");const s=new e.NodeProto;s.setOpType("Sub"),s.addInput(t.name+"_mul"),s.addInput(r),s.addOutput(t.name);const o=u.getGraph();o.addNode(a),o.addNode(p),o.addNode(s)}},fn={export(u,t){const r=new e.TensorProto;r.setName(t.name+"_a"),r.setDataType(e.TensorProto.DataType.FLOAT),r.setDimsList([1]),r.setFloatDataList([t.a??1]);const n=new e.TensorProto;n.setName(t.name+"_b"),n.setDataType(e.TensorProto.DataType.FLOAT),n.setDimsList([1]),n.setFloatDataList([t.b??1]);const d=Array.isArray(t.input)?t.input[0]:t.input,a=new e.NodeProto;a.setOpType("Mul"),a.addInput(d),a.addInput(t.name+"_b"),a.addOutput(t.name+"_mul");const p=new e.NodeProto;p.setOpType("Tanh"),p.addInput(t.name+"_mul"),p.addOutput(t.name+"_tanh");const s=new e.NodeProto;s.setOpType("Mul"),s.addInput(t.name+"_tanh"),s.addInput(t.name+"_a"),s.addOutput(t.name);const o=u.getGraph();o.addInitializer(r),o.addInitializer(n),o.addNode(a),o.addNode(p),o.addNode(s)}},Dn={export(u,t,r){const n=u.getGraph(),d=Array.isArray(t.input)?t.input[0]:t.input,a=new e.NodeProto;a.setOpType("ReduceMean"),a.addInput(d),a.addOutput(t.name+"_mean");const p=new e.AttributeProto;p.setName("keepdims"),p.setType(e.AttributeProto.AttributeType.INT),p.setI(1),a.addAttribute(p);const s=new e.NodeProto;s.setOpType("Sub"),s.addInput(d),s.addInput(t.name+"_mean"),s.addOutput(t.name+"_sub");const o=new e.NodeProto;o.setOpType("Mul"),o.addInput(t.name+"_sub"),o.addInput(t.name+"_sub"),o.addOutput(t.name+"_mul");const i=new e.NodeProto;i.setOpType("ReduceMean"),i.addInput(t.name+"_mul"),i.addOutput(t.name+"_var");const m=t.keepdims??!0?1:0,T=new e.AttributeProto;T.setName("keepdims"),T.setType(e.AttributeProto.AttributeType.INT),T.setI(m),i.addAttribute(T);const y=new e.NodeProto;y.setOpType("Sqrt"),y.addInput(t.name+"_var"),y.addOutput(t.name),n.addNode(a),n.addNode(s),n.addNode(o),n.addNode(i),n.addNode(y);const c=r[d].size.concat();if(typeof t.axis=="string")throw new Error("Unsupported axis type string");if(t.axis==null||typeof t.axis=="number"&&t.axis<0)return{size:m?Array(c.length).fill(1):[]};const _=Array.isArray(t.axis)?t.axis:[t.axis],l=new e.TensorProto;if(l.setName(t.name+"_axis"),l.setDataType(e.TensorProto.DataType.INT64),l.setDimsList([_.length]),l.setInt64DataList(_),n.addInitializer(l),a.addInput(t.name+"_axis"),i.addInput(t.name+"_axis"),_.sort((N,I)=>I-N),m)for(const N of _)c[N]=1;else for(const N of _)c.splice(N,1);return{size:c}}},xn={export(u,t){if(!Array.isArray(t.input))throw new Error(`Invalid attribute 'input' value ${t.input}.`);const r=u.getGraph(),n=new e.NodeProto;if(t.input.length===1)n.setOpType("Identity"),n.addInput(t.input[0]);else if(n.setOpType("Sub"),n.addInput(t.input[0]),t.input.length===2)n.addInput(t.input[1]);else{const d=new e.NodeProto;d.setOpType("Sum");for(let a=1;a<t.input.length;a++)d.addInput(t.input[a]);d.addOutput(t.name+"_sum"),r.addNode(d),n.addInput(t.name+"_sum")}n.addOutput(t.name),r.addNode(n)}},vn={export(u,t,r){const n=u.getGraph(),d=Array.isArray(t.input)?t.input[0]:t.input,a=new e.NodeProto;a.setOpType("ReduceSum"),a.addInput(d),a.addOutput(t.name);const p=t.keepdims??!0?1:0,s=new e.AttributeProto;s.setName("keepdims"),s.setType(e.AttributeProto.AttributeType.INT),s.setI(p),a.addAttribute(s),n.addNode(a);const o=r[d].size.concat();if(typeof t.axis=="string")throw new Error("Unsupported axis type string");if(t.axis==null||typeof t.axis=="number"&&t.axis<0)return{size:p?Array(o.length).fill(1):[]};const i=Array.isArray(t.axis)?t.axis:[t.axis],m=new e.TensorProto;if(m.setName(t.name+"_axis"),m.setDataType(e.TensorProto.DataType.INT64),m.setDimsList([i.length]),m.setInt64DataList(i),n.addInitializer(m),a.addInput(t.name+"_axis"),i.sort((T,y)=>y-T),p)for(const T of i)o[T]=1;else for(const T of i)o.splice(T,1);return{size:o}}},Ln={export(u,t){const r=new e.TensorProto;r.setName(t.name+"_beta"),r.setDataType(e.TensorProto.DataType.FLOAT),r.setDimsList([1]),r.setFloatDataList([t.beta??1]);const n=Array.isArray(t.input)?t.input[0]:t.input,d=new e.NodeProto;d.setOpType("Mul"),d.addInput(n),d.addInput(t.name+"_beta"),d.addOutput(t.name+"_mul");const a=new e.NodeProto;a.setOpType("Sigmoid"),a.addInput(t.name+"_mul"),a.addOutput(t.name+"_sigmoid");const p=new e.NodeProto;p.setOpType("Mul"),p.addInput(n),p.addInput(t.name+"_sigmoid"),p.addOutput(t.name);const s=u.getGraph();s.addInitializer(r),s.addNode(d),s.addNode(a),s.addNode(p)}},Fn={export(u,t){const r=new e.TensorProto;r.setName(t.name+"_a"),r.setDataType(e.TensorProto.DataType.FLOAT),r.setDimsList([1]),r.setFloatDataList([t.a??0]);const n=new e.TensorProto;n.setName(t.name+"_b"),n.setDataType(e.TensorProto.DataType.FLOAT),n.setDimsList([1]),n.setFloatDataList([t.b??0]);const d=new e.NodeProto;d.setOpType("Mul"),d.addInput(t.name+"_b"),d.addInput(t.name+"_b"),d.addOutput(t.name+"_bb");const a=Array.isArray(t.input)?t.input[0]:t.input,p=new e.NodeProto;p.setOpType("Sub"),p.addInput(a),p.addInput(t.name+"_a"),p.addOutput(t.name+"_sub");const s=new e.NodeProto;s.setOpType("Mul"),s.addInput(t.name+"_sub"),s.addInput(t.name+"_sub"),s.addOutput(t.name+"_mul");const o=new e.NodeProto;o.setOpType("Add"),o.addInput(t.name+"_mul"),o.addInput(t.name+"_bb"),o.addOutput(t.name+"_add");const i=new e.NodeProto;i.setOpType("Sqrt"),i.addInput(t.name+"_add"),i.addOutput(t.name);const m=u.getGraph();m.addInitializer(r),m.addInitializer(n),m.addNode(d),m.addNode(p),m.addNode(s),m.addNode(o),m.addNode(i)}},zn={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("Tan"),n.addInput(r),n.addOutput(t.name),u.getGraph().addNode(n)}},Gn={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("Tanh"),n.addInput(r),n.addOutput(t.name),u.getGraph().addNode(n)}},Sn={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("Exp"),n.addInput(r),n.addOutput(t.name+"_exp");const d=new e.NodeProto;d.setOpType("Tanh"),d.addInput(t.name+"_exp"),d.addOutput(t.name+"_tanh");const a=new e.NodeProto;a.setOpType("Mul"),a.addInput(t.name+"_tanh"),a.addInput(r),a.addOutput(t.name);const p=u.getGraph();p.addNode(n),p.addNode(d),p.addNode(a)}},$n={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("Tanh"),n.addInput(r),n.addOutput(t.name+"_tanh");const d=new e.NodeProto;d.setOpType("Sub"),d.addInput(r),d.addInput(t.name+"_tanh"),d.addOutput(t.name);const a=u.getGraph();a.addNode(n),a.addNode(d)}},En={export(u,t){const r=Array.isArray(t.input)?t.input[0]:t.input,n=new e.NodeProto;n.setOpType("ThresholdedRelu"),n.addInput(r),n.addOutput(t.name);const d=new e.AttributeProto;d.setName("alpha"),d.setType(e.AttributeProto.AttributeType.FLOAT),d.setF(t.a??1),n.addAttribute(d),u.getGraph().addNode(n)}},Mn={export(u,t,r){const n=Array.isArray(t.input)?t.input[0]:t.input,d=new e.NodeProto;d.setOpType("Transpose"),d.addInput(n),d.addOutput(t.name);const a=new e.AttributeProto;a.setName("perm"),a.setType(e.AttributeProto.AttributeType.INTS),a.setIntsList(t.axis),d.addAttribute(a),u.getGraph().addNode(d);const s=r[n].size.concat();return{size:t.axis.map(o=>s[o])}}},kn={export(u,t,r){const n=u.getGraph(),d=Array.isArray(t.input)?t.input[0]:t.input,a=new e.NodeProto;a.setOpType("ReduceMean"),a.addInput(d),a.addOutput(t.name+"_mean");const p=new e.AttributeProto;p.setName("keepdims"),p.setType(e.AttributeProto.AttributeType.INT),p.setI(1),a.addAttribute(p);const s=new e.NodeProto;s.setOpType("Sub"),s.addInput(d),s.addInput(t.name+"_mean"),s.addOutput(t.name+"_sub");const o=new e.NodeProto;o.setOpType("Mul"),o.addInput(t.name+"_sub"),o.addInput(t.name+"_sub"),o.addOutput(t.name+"_mul");const i=new e.NodeProto;i.setOpType("ReduceMean"),i.addInput(t.name+"_mul"),i.addOutput(t.name);const m=t.keepdims??!0?1:0,T=new e.AttributeProto;T.setName("keepdims"),T.setType(e.AttributeProto.AttributeType.INT),T.setI(m),i.addAttribute(T),n.addNode(a),n.addNode(s),n.addNode(o),n.addNode(i);const y=r[d].size.concat();if(typeof t.axis=="string")throw new Error("Unsupported axis type string");if(t.axis==null||typeof t.axis=="number"&&t.axis<0)return{size:m?Array(y.length).fill(1):[]};const c=Array.isArray(t.axis)?t.axis:[t.axis],_=new e.TensorProto;if(_.setName(t.name+"_axis"),_.setDataType(e.TensorProto.DataType.INT64),_.setDimsList([c.length]),_.setInt64DataList(c),n.addInitializer(_),a.addInput(t.name+"_axis"),i.addInput(t.name+"_axis"),c.sort((l,N)=>N-l),m)for(const l of c)y[l]=1;else for(const l of c)y.splice(l,1);return{size:y}}},Rn={export(u,t,r){if(!Array.isArray(t.input))throw new Error(`Invalid attribute 'input' value ${t.input}.`);const n=u.getGraph(),d=new e.NodeProto;if(t.input.length===1){d.setOpType("Identity"),d.addInput(t.input[0]),d.addOutput(t.name),n.addNode(d);return}const a=[];for(const s of t.input)if(r[s].type===e.TensorProto.DataType.BOOL)a.push(s);else{const o=new e.NodeProto;o.setOpType("Cast"),o.addInput(s),o.addOutput(`${t.name}_${s}_cast`);const i=new e.AttributeProto;i.setName("to"),i.setType(e.AttributeProto.AttributeType.INT),i.setI(e.TensorProto.DataType.BOOL),o.addAttribute(i),n.addNode(o),a.push(`${t.name}_${s}_cast`)}let p=a[0];for(let s=1;s<a.length-1;s++){const o=new e.NodeProto;o.setOpType("Xor"),o.addInput(p),o.addInput(a[s]),o.addOutput(p=t.name+`_xor_${s-1}`),n.addNode(o)}return d.setOpType("Xor"),d.addInput(p),d.addInput(a.at(-1)),d.addOutput(t.name),n.addNode(d),{type:e.TensorProto.DataType.BOOL}}};export{W as abs,H as acos,X as acosh,J as add,Q as and,Y as apl,Z as aranda,b as argmax,j as argmin,tt as asin,et as asinh,nt as atan,at as atanh,dt as average_pool,pt as batch_normalization,rt as bdaa,st as bent_identity,ut as bitwise_and,it as bitwise_not,Tt as bitwise_or,_t as bitwise_xor,ct as blu,lt as brelu,Nt as ceil,It as celu,At as clip,Ot as cloglog,Pt as cloglogm,ht as concat,wt as cond,gt as const,ft as conv,Dt as cos,xt as cosh,vt as crelu,Lt as div,Ft as eelu,zt as elish,Gt as elliott,St as elu,$t as equal,Et as erelu,Mt as erf,kt as eswish,Rt as exp,Bt as felu,qt as flatten,Ut as floor,Ct as frelu,Vt as full,Kt as gaussian,Wt as gelu,Ht as global_average_pool,Xt as global_lp_pool,Jt as global_max_pool,Qt as greater,Yt as greater_or_equal,Zt as hard_elish,bt as hard_shrink,jt as hard_sigmoid,te as hard_swish,ee as hard_tanh,ne as hexpo,ae as identity,de as input,pe as is_inf,re as is_nan,se as isigmoid,oe as leaky_relu,ie as left_bitshift,me as less,Te as less_or_equal,ye as lisht,_e as log,ce as log_softmax,le as loglog,Ne as logsigmoid,Ie as lp_pool,Ae as lrn,Oe as matmul,Pe as max,he as max_pool,we as mean,ge as min,fe as mish,xe as mod,ve as mpelu,Le as mult,Fe as negative,ze as nlrelu,Ge as not,Se as or,$e as output,Ee as pau,Me as pdelu,ke as pelu,Re as plu,Be as power,qe as prelu,Ue as preu,Ce as prod,Ve as psf,Ke as ptanh,We as ptelu,He as reciprocal,Xe as reduce_max,Je as reduce_min,Qe as relu,Ye as repu,Ze as resech,be as reshape,je as reu,en as right_bitshift,nn as rootsig,an as round,dn as rrelu,pn as rtrelu,rn as selu,sn as sigmoid,on as sign,un as silu,mn as sin,Tn as sinh,yn as slaf,_n as slu,cn as soft_shrink,ln as softmax,Nn as softmin,In as softplus,An as softsign,On as sqrt,Pn as square,hn as srelu,wn as srs,gn as ssigmoid,fn as stanh,Dn as std,xn as sub,vn as sum,Ln as swish,Fn as taf,zn as tan,Gn as tanh,Sn as tanhexp,$n as tanhshrink,En as thresholded_relu,Mn as transpose,kn as variance,Rn as xor};
