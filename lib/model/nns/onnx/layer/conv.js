import{onnx as n}from"../onnx_exporter.js";import g from"../../../../util/tensor.js";export default{export(P,t,w){const u=P.getGraph(),y=Array.isArray(t.input)?t.input[0]:t.input,a=w[y].size.concat(),s=new n.NodeProto;s.setOpType("Conv");const h=t.channel_dim===1?1:a.length-1;if(t.channel_dim===1)s.addInput(y),s.addOutput(t.name);else if(t.channel_dim==null||t.channel_dim===-1){const r=new n.NodeProto;r.setOpType("Transpose"),r.addInput(y),r.addOutput(t.name+"_t1");const e=new n.AttributeProto;e.setName("perm"),e.setType(n.AttributeProto.AttributeType.INTS);const i=Array.from(a,(I,T)=>T-1);i[0]=0,i[1]=a.length-1,e.setIntsList(i),r.addAttribute(e),u.addNode(r),s.addInput(t.name+"_t1"),s.addOutput(t.name+"_ap");const d=new n.NodeProto;d.setOpType("Transpose"),d.addInput(t.name+"_ap"),d.addOutput(t.name);const p=new n.AttributeProto;p.setName("perm"),p.setType(n.AttributeProto.AttributeType.INTS);const c=Array.from(a,(I,T)=>T+1);c[0]=0,c[c.length-1]=1,p.setIntsList(c),d.addAttribute(p),u.addNode(d)}else throw new Error(`Not implemented value of attribute 'channel_dim' ${t.channel_dim}.`);const o=Array.isArray(t.kernel)?t.kernel:Array(a.length-2).fill(t.kernel),l=new n.AttributeProto;l.setName("kernel_shape"),l.setType(n.AttributeProto.AttributeType.INTS),l.setIntsList(o),s.addAttribute(l);const N=Array.isArray(t.stride)?t.stride:Array(o.length).fill(t.stride??1),A=new n.AttributeProto;if(A.setName("strides"),A.setType(n.AttributeProto.AttributeType.INTS),A.setIntsList(N),s.addAttribute(A),t.padding!=null){const r=new n.AttributeProto;r.setName("pads"),r.setType(n.AttributeProto.AttributeType.INTS),r.setIntsList(Array.isArray(t.padding)?Array.isArray(t.padding[0])?[...t.padding.map(e=>e[0]),...t.padding.map(e=>e[1])]:[].concat(t.padding,t.padding):Array(o.length*2).fill(t.padding)),s.addAttribute(r)}else{const r=t.channel_dim===1?a.slice(2):a.slice(1,-1);if(r.some(e=>e==null)){const e=new n.AttributeProto;e.setName("auto_pad"),e.setType(n.AttributeProto.AttributeType.STRING),e.setS(new TextEncoder().encode("VALID")),s.addAttribute(e)}else{const e=r.map((d,p)=>(d-o[p])%N[p]),i=new n.AttributeProto;i.setName("pads"),i.setType(n.AttributeProto.AttributeType.INTS),i.setIntsList([...Array(o.length).fill(0),...e]),s.addAttribute(i)}}const m=Array(a.length).fill(null);if(m[0]=a[0],typeof t.w=="string")s.addInput(t.w),m[h]=w[t.w].size[0];else if(t.w){const r=new n.TensorProto;r.setName(t.name+"_w"),r.setDataType(n.TensorProto.DataType.FLOAT);const e=g.fromArray(t.w);r.setDimsList(e.sizes),r.setFloatDataList(e.value),u.addInitializer(r),s.addInput(t.name+"_w"),m[h]=e.sizes[0]}else throw new Error("Require attribute 'w'");return u.addNode(s),{size:m}}};
