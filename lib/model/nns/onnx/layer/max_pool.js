import{onnx as r}from"../onnx_exporter.js";export default{export(g,t,h){const c=g.getGraph(),y=Array.isArray(t.input)?t.input[0]:t.input,a=h[y].size.concat(),s=new r.NodeProto;s.setOpType("MaxPool");const u=Array(a.length).fill(null);if(u[0]=a[0],t.channel_dim===1)s.addInput(y),s.addOutput(t.name),u[1]=a[1];else if(t.channel_dim==null||t.channel_dim===-1){const n=new r.NodeProto;n.setOpType("Transpose"),n.addInput(y),n.addOutput(`${t.name}_t1`);const e=new r.AttributeProto;e.setName("perm"),e.setType(r.AttributeProto.AttributeType.INTS);const d=Array.from(a,(I,N)=>N-1);d[0]=0,d[1]=a.length-1,e.setIntsList(d),n.addAttribute(e),c.addNode(n),s.addInput(`${t.name}_t1`),s.addOutput(`${t.name}_ap`);const i=new r.NodeProto;i.setOpType("Transpose"),i.addInput(`${t.name}_ap`),i.addOutput(t.name);const p=new r.AttributeProto;p.setName("perm"),p.setType(r.AttributeProto.AttributeType.INTS);const m=Array.from(a,(I,N)=>N+1);m[0]=0,m[m.length-1]=1,p.setIntsList(m),i.addAttribute(p),c.addNode(i),u[a.length-1]=a[a.length-1]}else throw new Error(`Not implemented value of attribute 'channel_dim' ${t.channel_dim}.`);const o=Array.isArray(t.kernel)?t.kernel:Array(a.length-2).fill(t.kernel),l=new r.AttributeProto;l.setName("kernel_shape"),l.setType(r.AttributeProto.AttributeType.INTS),l.setIntsList(o),s.addAttribute(l);const T=t.stride??t.kernel,P=Array.isArray(T)?T:Array(o.length).fill(T??1),A=new r.AttributeProto;if(A.setName("strides"),A.setType(r.AttributeProto.AttributeType.INTS),A.setIntsList(P),s.addAttribute(A),t.padding!=null){const n=new r.AttributeProto;n.setName("pads"),n.setType(r.AttributeProto.AttributeType.INTS),n.setIntsList(Array.isArray(t.padding)?Array.isArray(t.padding[0])?[...t.padding.map(e=>e[0]),...t.padding.map(e=>e[1])]:[].concat(t.padding,t.padding):Array(o.length*2).fill(t.padding)),s.addAttribute(n)}else{const n=t.channel_dim===1?a.slice(2):a.slice(1,-1);if(n.some(e=>e==null)){const e=new r.AttributeProto;e.setName("auto_pad"),e.setType(r.AttributeProto.AttributeType.STRING),e.setS(new TextEncoder().encode("VALID")),s.addAttribute(e)}else{const e=n.map((i,p)=>(i-o[p])%P[p]),d=new r.AttributeProto;d.setName("pads"),d.setType(r.AttributeProto.AttributeType.INTS),d.setIntsList([...Array(o.length).fill(0),...e]),s.addAttribute(d)}}return c.addNode(s),{size:u}}};
