import{onnx as e}from"../onnx_exporter.js";export default{export(h,t,I){const y=h.getGraph(),T=Array.isArray(t.input)?t.input[0]:t.input,s=I[T].size.concat(),a=new e.NodeProto;a.setOpType("LpPool");const u=new e.AttributeProto;u.setName("p"),u.setType(e.AttributeProto.AttributeType.INT),u.setI(t.p??2),a.addAttribute(u);const l=Array(s.length).fill(null);if(l[0]=s[0],t.channel_dim===1)a.addInput(T),a.addOutput(t.name),l[1]=s[1];else if(t.channel_dim==null||t.channel_dim===-1){const n=new e.NodeProto;n.setOpType("Transpose"),n.addInput(T),n.addOutput(t.name+"_t1");const r=new e.AttributeProto;r.setName("perm"),r.setType(e.AttributeProto.AttributeType.INTS);const d=Array.from(s,(_,P)=>P-1);d[0]=0,d[1]=s.length-1,r.setIntsList(d),n.addAttribute(r),y.addNode(n),a.addInput(t.name+"_t1"),a.addOutput(t.name+"_ap");const i=new e.NodeProto;i.setOpType("Transpose"),i.addInput(t.name+"_ap"),i.addOutput(t.name);const p=new e.AttributeProto;p.setName("perm"),p.setType(e.AttributeProto.AttributeType.INTS);const c=Array.from(s,(_,P)=>P+1);c[0]=0,c[c.length-1]=1,p.setIntsList(c),i.addAttribute(p),y.addNode(i),l[s.length-1]=s[s.length-1]}else throw new Error(`Not implemented value of attribute 'channel_dim' ${t.channel_dim}.`);const o=Array.isArray(t.kernel)?t.kernel:Array(s.length-2).fill(t.kernel),A=new e.AttributeProto;A.setName("kernel_shape"),A.setType(e.AttributeProto.AttributeType.INTS),A.setIntsList(o),a.addAttribute(A);const N=t.stride??t.kernel,g=Array.isArray(N)?N:Array(o.length).fill(N??1),m=new e.AttributeProto;if(m.setName("strides"),m.setType(e.AttributeProto.AttributeType.INTS),m.setIntsList(g),a.addAttribute(m),t.padding!=null){const n=new e.AttributeProto;n.setName("pads"),n.setType(e.AttributeProto.AttributeType.INTS),n.setIntsList(Array.isArray(t.padding)?Array.isArray(t.padding[0])?[...t.padding.map(r=>r[0]),...t.padding.map(r=>r[1])]:[].concat(t.padding,t.padding):Array(o.length*2).fill(t.padding)),a.addAttribute(n)}else{const n=t.channel_dim===1?s.slice(2):s.slice(1,-1);if(n.some(r=>r==null)){const r=new e.AttributeProto;r.setName("auto_pad"),r.setType(e.AttributeProto.AttributeType.STRING),r.setS(new TextEncoder().encode("VALID")),a.addAttribute(r)}else{const r=n.map((i,p)=>(i-o[p])%g[p]),d=new e.AttributeProto;d.setName("pads"),d.setType(e.AttributeProto.AttributeType.INTS),d.setIntsList([...Array(o.length).fill(0),...r]),a.addAttribute(d)}}return y.addNode(a),{size:l}}};
