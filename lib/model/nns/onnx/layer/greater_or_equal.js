import{onnx as p}from"../onnx_exporter.js";export default{export(r,t){if(!Array.isArray(t.input))throw new Error(`Invalid attribute 'input' value ${t.input}.`);const u=r.getGraph(),a=new p.NodeProto;if(t.input.length===1){const d=new p.NodeProto;d.setOpType("Shape"),d.addInput(t.input[0]),d.addOutput(t.name+"_shape"),u.addNode(d),a.setOpType("ConstantOfShape"),a.addInput(t.name+"_shape");const n=new p.TensorProto;n.setDataType(p.TensorProto.DataType.BOOL),n.setDimsList([1]),n.setInt32DataList([1]);const e=new p.AttributeProto;e.setName("value"),e.setType(p.AttributeProto.AttributeType.TENSOR),e.setT(n),a.addAttribute(e)}else if(t.input.length===2)a.setOpType("GreaterOrEqual"),a.addInput(t.input[0]),a.addInput(t.input[1]);else{for(let n=0;n<t.input.length-1;n++){const e=new p.NodeProto;e.setOpType("GreaterOrEqual"),e.addInput(t.input[n]),e.addInput(t.input[n+1]),e.addOutput(`${t.name}_ge_${n}`),u.addNode(e)}let d=t.name+"_ge_0";for(let n=1;n<t.input.length-2;n++){const e=new p.NodeProto;e.setOpType("And"),e.addInput(d),e.addInput(`${t.name}_ge_${n}`),e.addOutput(d=t.name+`_and_${n-1}`),u.addNode(e)}a.setOpType("And"),a.addInput(d),a.addInput(`${t.name}_ge_${t.input.length-2}`)}return a.addOutput(t.name),u.addNode(a),{type:p.TensorProto.DataType.BOOL}}};
