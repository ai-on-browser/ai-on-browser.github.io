var d=Object.defineProperty;var c=(s,t)=>d(s,"name",{value:t,configurable:!0});import l from"./onnx_pb.js";export{default as onnx}from"./onnx_pb.js";import y from"./operators/input.js";import g from"./operators/output.js";import*as f from"./operators/index.js";import{loadTensor as h}from"./utils.js";export default class w{static{c(this,"ONNXImporter")}static async load(t){t.arrayBuffer&&typeof t.arrayBuffer=="function"&&(t=new Uint8Array(await t.arrayBuffer())),t instanceof ArrayBuffer&&(t=new Uint8Array(t));const i=l.ModelProto.deserializeBinary(t),a=i.getGraph(),r=[];for(const o of a.getInputList())r.push(...y.import(i,o));for(const o of a.getNodeList()){const e=o.getOpType();if(!f[e.toLowerCase()]){console.error(`Unimplemented operator ${e}.`);continue}const n=f[e.toLowerCase()];r.push(...n.import(i,o))}for(const o of a.getOutputList())r.push(...g.import(i,o));const p=new Set(r.map(o=>o.name)),u=new Map(a.getInitializerList().map(o=>[o.getName(),o]));for(const o of r.filter(e=>e.input)){const e=Array.isArray(o.input)?o.input:[o.input];for(const n of e){if(p.has(n))continue;const m=u.get(n);m&&(r.push({type:"const",name:n,value:h(m)}),p.add(n))}}return r}}
