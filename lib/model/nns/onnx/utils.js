import{onnx}from"./onnx_importer.js";export const loadTensor=e=>{const t=e.getDimsList();let r=[];if(e.getFloatDataList().length>0)r=e.getFloatDataList();else if(e.getInt32DataList().length>0)r=e.getInt32DataList();else if(e.getInt64DataList().length>0)r=e.getInt64DataList();else if(e.getUint64DataList().length>0)r=e.getUint64DataList();else if(e.getDoubleDataList().length>0)r=e.getDoubleDataList();else if(e.getStringDataList_asB64().length>0)r=e.getStringDataList_asB64().map((e=>Buffer.from(e,"base64").toString()));else{let t=e.getRawData_asB64();if("string"==typeof t){const e=Buffer.from(t,"base64");t=new Uint8Array(e.buffer,e.byteOffset,e.byteLength/Uint8Array.BYTES_PER_ELEMENT)}if(1===e.getDataType())r=Array.from(new Float32Array(t.buffer,t.byteOffset));else if(2===e.getDataType())r=Array.from(t);else if(3===e.getDataType())r=Array.from(new Int8Array(t.buffer,t.byteOffset));else if(4===e.getDataType())r=Array.from(new Uint16Array(t.buffer,t.byteOffset));else if(5===e.getDataType())r=Array.from(new Int16Array(t.buffer,t.byteOffset));else if(6===e.getDataType())r=Array.from(new Int32Array(t.buffer,t.byteOffset));else if(7===e.getDataType())r=Array.from(new BigInt64Array(t.buffer,t.byteOffset),(e=>Number(e)));else if(9===e.getDataType())r=Array.from(t,(e=>!!e));else if(10===e.getDataType())for(let e=0;e<t.length;e+=2){const a=128&t[e+1]?-1:1,s=(124&t[e+1])>>>2,f=0===s?-14:s-15,n=.25*(3&t[e+1])+t[e]*2**-10;31===s?r.push(0===n?1/0*a:NaN):r.push(a*(n+(0===s?0:1))*2**f)}else if(11===e.getDataType())r=Array.from(new Float64Array(t.buffer,t.byteOffset));else if(12===e.getDataType())r=Array.from(new Uint32Array(t.buffer,t.byteOffset));else{if(13!==e.getDataType())throw new Error(`Not implemented data type ${e.getDataType()}`);r=Array.from(new BigUint64Array(t.buffer,t.byteOffset),(e=>Number(e)))}}if(0===t.length)return r[0];const a=[];let s=[a],f=0;for(let e=0;e<t.length;e++){const a=[];for(const n of s)if(e===t.length-1)n.push(...r.slice(f,f+t[e])),f+=t[e];else for(let r=0;r<t[e];r++)a.push(n[r]=[]);s=a}return a};export const loadAttribute=e=>{switch(e.getType()){case 1:return e.getF();case 2:return e.getI();case 3:return Buffer.from(e.getS_asB64(),"base64").toString("utf8");case 4:return loadTensor(e.getT());case 6:return e.getFloatsList();case 7:return e.getIntsList();case 8:return e.getStringsList_asB64().map((e=>Buffer.from(e,"base64").toString("utf8")));case 9:return e.getTensorsList().map((e=>loadTensor(e)))}throw new Error("Not implemented attribute type.")};export const requireTensor=(e,t)=>{const r=[];for(const a of e.getGraph().getInitializerList())t.includes(a.getName())&&r.push({type:"const",value:loadTensor(a),name:a.getName()});return r};