import{onnx}from"./onnx_importer.js";export const loadTensor=t=>{const e=t.dimsList,s=e.reduce(((t,e)=>t*e),1);let n=[];if(t.floatDataList.length>0)n=t.floatDataList;else if(t.int32DataList.length>0)n=t.int32DataList;else if(t.int64DataList.length>0)n=t.int64DataList;else if(t.uint64DataList.length>0)n=t.uint64DataList;else if(t.doubleDataList.length>0)n=t.doubleDataList;else if(t.stringDataList.length>0)n=t.stringDataList;else{let e=t.rawData;if("string"==typeof e){const t=Buffer.from(e,"base64");e=new Uint8Array(t.buffer,t.byteOffset,t.byteLength/Uint8Array.BYTES_PER_ELEMENT)}const r=e.length/s;for(let t=0;t<e.length;t+=r){const s=128&e[t+3]?-1:1,r=2*(127&e[t+3])+((128&e[t+2])>>>7),a=0===r?0:r-127,i=(127&e[t+2])*2**-7+e[t+1]*2**-15+e[t+0]*2**-23;n.push(s*(i+1)*2**a)}}if(0===e.length)return n[0];const r=[];let a=[r],i=0;for(let t=0;t<e.length;t++){const s=[];for(const r of a)if(t===e.length-1)r.push(...n.slice(i,i+e[t])),i+=e[t];else for(let n=0;n<e[t];n++)s.push(r[n]=[]);a=s}return r};export const loadAttribute=t=>{switch(t.type){case 1:return t.f;case 2:return t.i;case 3:return Buffer.from(t.s,"base64").toString("utf8");case 4:return loadTensor(t.t);case 6:return t.floatsList;case 7:return t.intsList;case 8:return t.stringsList.map((t=>Buffer.from(t,"base64").toString("utf8")));case 9:return t.tensorsList.map((t=>loadTensor(t)))}throw new Error("Not implemented attribute type.")};export const requireTensor=(t,e)=>{const s=[];for(const n of t.graph.initializerList)e.indexOf(n.name)>=0&&s.push({type:"const",value:loadTensor(n),name:n.name});return s};