var u=Object.defineProperty;var g=(e,r)=>u(e,"name",{value:r,configurable:!0});import"./onnx_importer.js";export const loadTensor=g(e=>{const r=e.getDimsList();let a=[];if(e.getFloatDataList().length>0)a=e.getFloatDataList();else if(e.getInt32DataList().length>0)a=e.getInt32DataList();else if(e.getInt64DataList().length>0)a=e.getInt64DataList();else if(e.getUint64DataList().length>0)a=e.getUint64DataList();else if(e.getDoubleDataList().length>0)a=e.getDoubleDataList();else if(e.getStringDataList_asB64().length>0)a=e.getStringDataList_asB64().map(t=>Buffer.from(t,"base64").toString());else{let t=e.getRawData_asB64();if(typeof t=="string"){const f=Buffer.from(t,"base64");t=new Uint8Array(f.buffer,f.byteOffset,f.byteLength/Uint8Array.BYTES_PER_ELEMENT)}if(e.getDataType()===1)a=Array.from(new Float32Array(t.buffer,t.byteOffset));else if(e.getDataType()===2)a=Array.from(t);else if(e.getDataType()===3)a=Array.from(new Int8Array(t.buffer,t.byteOffset));else if(e.getDataType()===4)a=Array.from(new Uint16Array(t.buffer,t.byteOffset));else if(e.getDataType()===5)a=Array.from(new Int16Array(t.buffer,t.byteOffset));else if(e.getDataType()===6)a=Array.from(new Int32Array(t.buffer,t.byteOffset));else if(e.getDataType()===7)a=Array.from(new BigInt64Array(t.buffer,t.byteOffset),f=>Number(f));else if(e.getDataType()===9)a=Array.from(t,f=>!!f);else if(e.getDataType()===10)for(let f=0;f<t.length;f+=2){const n=t[f+1]&128?-1:1,s=(t[f+1]&124)>>>2,p=s===0?-14:s-15,o=(t[f+1]&3)*2**-2+t[f]*2**-10;s===31?a.push(o===0?1/0*n:NaN):a.push(n*(o+(s===0?0:1))*2**p)}else if(e.getDataType()===11)a=Array.from(new Float64Array(t.buffer,t.byteOffset));else if(e.getDataType()===12)a=Array.from(new Uint32Array(t.buffer,t.byteOffset));else if(e.getDataType()===13)a=Array.from(new BigUint64Array(t.buffer,t.byteOffset),f=>Number(f));else throw new Error(`Not implemented data type ${e.getDataType()}`)}if(r.length===0)return a[0];const i=[];let y=[i],l=0;for(let t=0;t<r.length;t++){const f=[];for(const n of y)if(t===r.length-1)n.push(...a.slice(l,l+r[t])),l+=r[t];else for(let s=0;s<r[t];s++)f.push(n[s]=[]);y=f}return i},"loadTensor"),loadAttribute=g(e=>{switch(e.getType()){case 1:return e.getF();case 2:return e.getI();case 3:return Buffer.from(e.getS_asB64(),"base64").toString("utf8");case 4:return loadTensor(e.getT());case 6:return e.getFloatsList();case 7:return e.getIntsList();case 8:return e.getStringsList_asB64().map(r=>Buffer.from(r,"base64").toString("utf8"));case 9:return e.getTensorsList().map(r=>loadTensor(r))}throw new Error("Not implemented attribute type.")},"loadAttribute"),requireTensor=g((e,r)=>{const a=[];for(const i of e.getGraph().getInitializerList())r.includes(i.getName())&&a.push({type:"const",value:loadTensor(i),name:i.getName()});return a},"requireTensor");
