var c=Object.defineProperty;var l=(e,f)=>c(e,"name",{value:f,configurable:!0});import{onnx as y}from"./onnx_importer.js";export const loadTensor=l(e=>{const f=e.getDimsList();let a=[];if(e.getFloatDataList().length>0)a=e.getFloatDataList();else if(e.getInt32DataList().length>0)a=e.getInt32DataList();else if(e.getInt64DataList().length>0)a=e.getInt64DataList();else if(e.getUint64DataList().length>0)a=e.getUint64DataList();else if(e.getDoubleDataList().length>0)a=e.getDoubleDataList();else if(e.getStringDataList_asB64().length>0)a=e.getStringDataList_asB64().map(t=>Buffer.from(t,"base64").toString());else{let t=e.getRawData_asB64();if(typeof t=="string"){const r=Buffer.from(t,"base64");t=new Uint8Array(r.buffer,r.byteOffset,r.byteLength/Uint8Array.BYTES_PER_ELEMENT)}if(e.getDataType()===1)a=Array.from(new Float32Array(t.buffer,t.byteOffset));else if(e.getDataType()===2)a=Array.from(t);else if(e.getDataType()===3)a=Array.from(new Int8Array(t.buffer,t.byteOffset));else if(e.getDataType()===4)a=Array.from(new Uint16Array(t.buffer,t.byteOffset));else if(e.getDataType()===5)a=Array.from(new Int16Array(t.buffer,t.byteOffset));else if(e.getDataType()===6)a=Array.from(new Int32Array(t.buffer,t.byteOffset));else if(e.getDataType()===7)a=Array.from(new BigInt64Array(t.buffer,t.byteOffset),r=>Number(r));else if(e.getDataType()===9)a=Array.from(t,r=>!!r);else if(e.getDataType()===10)for(let r=0;r<t.length;r+=2){const g=t[r+1]&128?-1:1,i=(t[r+1]&124)>>>2,u=i===0?-14:i-15,p=(t[r+1]&3)*2**-2+t[r]*2**-10;i===31?a.push(p===0?1/0*g:NaN):a.push(g*(p+(i===0?0:1))*2**u)}else if(e.getDataType()===11)a=Array.from(new Float64Array(t.buffer,t.byteOffset));else if(e.getDataType()===12)a=Array.from(new Uint32Array(t.buffer,t.byteOffset));else if(e.getDataType()===13)a=Array.from(new BigUint64Array(t.buffer,t.byteOffset),r=>Number(r));else throw new Error(`Not implemented data type ${e.getDataType()}`)}if(f.length===0)return a[0];const s=[];let o=[s],n=0;for(let t=0;t<f.length;t++){const r=[];for(const g of o)if(t===f.length-1)g.push(...a.slice(n,n+f[t])),n+=f[t];else for(let i=0;i<f[t];i++)r.push(g[i]=[]);o=r}return s},"loadTensor"),loadAttribute=l(e=>{switch(e.getType()){case 1:return e.getF();case 2:return e.getI();case 3:return Buffer.from(e.getS_asB64(),"base64").toString("utf8");case 4:return loadTensor(e.getT());case 6:return e.getFloatsList();case 7:return e.getIntsList();case 8:return e.getStringsList_asB64().map(f=>Buffer.from(f,"base64").toString("utf8"));case 9:return e.getTensorsList().map(f=>loadTensor(f))}throw new Error("Not implemented attribute type.")},"loadAttribute"),requireTensor=l((e,f)=>{const a=[];for(const s of e.getGraph().getInitializerList())f.includes(s.getName())&&a.push({type:"const",value:loadTensor(s),name:s.getName()});return a},"requireTensor"),getConstNodeName=l((e,f)=>{const a="__const_"+f;for(const t of e.getGraph().getNodeList()){const r=t.getOutputList();if(r.length>0&&r[0]===a)return a}const s=new y.NodeProto;s.setOpType("Constant");const o=new y.TensorProto;o.setDataType(y.TensorProto.DataType.FLOAT),o.setDimsList([1]),o.setFloatDataList([f]);const n=new y.AttributeProto;return n.setName("value"),n.setType(y.AttributeProto.AttributeType.TENSOR),n.setT(o),s.addAttribute(n),s.addOutput(a),e.getGraph().addNode(s),a},"getConstNodeName");
