import{onnx}from"./onnx_importer.js";export const loadTensor=e=>{const t=e.dimsList;let r=[];if(e.floatDataList.length>0)r=e.floatDataList;else if(e.int32DataList.length>0)r=e.int32DataList;else if(e.int64DataList.length>0)r=e.int64DataList;else if(e.uint64DataList.length>0)r=e.uint64DataList;else if(e.doubleDataList.length>0)r=e.doubleDataList;else if(e.stringDataList.length>0)r=e.stringDataList;else{let t=e.rawData;if("string"==typeof t){const e=Buffer.from(t,"base64");t=new Uint8Array(e.buffer,e.byteOffset,e.byteLength/Uint8Array.BYTES_PER_ELEMENT)}if(1===e.dataType)r=Array.from(new Float32Array(t.buffer,t.byteOffset));else if(2===e.dataType)r=Array.from(t);else if(3===e.dataType)r=Array.from(new Int8Array(t.buffer,t.byteOffset));else if(4===e.dataType)r=Array.from(new Uint16Array(t.buffer,t.byteOffset));else if(5===e.dataType)r=Array.from(new Int16Array(t.buffer,t.byteOffset));else if(6===e.dataType)r=Array.from(new Int32Array(t.buffer,t.byteOffset));else if(7===e.dataType)r=Array.from(new BigInt64Array(t.buffer,t.byteOffset),(e=>Number(e)));else if(9===e.dataType)r=Array.from(t,(e=>!!e));else if(10===e.dataType)for(let e=0;e<t.length;e+=2){const a=128&t[e+1]?-1:1,f=(124&t[e+1])>>>2,s=0===f?-14:f-15,n=.25*(3&t[e+1])+t[e]*2**-10;31===f?r.push(0===n?1/0*a:NaN):r.push(a*(n+(0===f?0:1))*2**s)}else if(11===e.dataType)r=Array.from(new Float64Array(t.buffer,t.byteOffset));else if(12===e.dataType)r=Array.from(new Uint32Array(t.buffer,t.byteOffset));else{if(13!==e.dataType)throw new Error(`Not implemented data type ${e.dataType}`);r=Array.from(new BigUint64Array(t.buffer,t.byteOffset),(e=>Number(e)))}}if(0===t.length)return r[0];const a=[];let f=[a],s=0;for(let e=0;e<t.length;e++){const a=[];for(const n of f)if(e===t.length-1)n.push(...r.slice(s,s+t[e])),s+=t[e];else for(let r=0;r<t[e];r++)a.push(n[r]=[]);f=a}return a};export const loadAttribute=e=>{switch(e.type){case 1:return e.f;case 2:return e.i;case 3:return Buffer.from(e.s,"base64").toString("utf8");case 4:return loadTensor(e.t);case 6:return e.floatsList;case 7:return e.intsList;case 8:return e.stringsList.map((e=>Buffer.from(e,"base64").toString("utf8")));case 9:return e.tensorsList.map((e=>loadTensor(e)))}throw new Error("Not implemented attribute type.")};export const requireTensor=(e,t)=>{const r=[];for(const a of e.graph.initializerList)t.indexOf(a.name)>=0&&r.push({type:"const",value:loadTensor(a),name:a.name});return r};