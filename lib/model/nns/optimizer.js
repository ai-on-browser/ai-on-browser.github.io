import Matrix from"../../util/matrix.js";export class SGDOptimizer{constructor(t){this._learningrate=t}set learningRate(t){this._learningrate=t}manager(){const t=this;return{get lr(){return t._learningrate},delta(t,a){if("number"==typeof a)return a*this.lr;const r=a.copy();return r.map((t=>t*this.lr)),r}}}}export class MomentumOptimizer{constructor(t,a=.9){this._learningrate=t,this._beta=a}set learningRate(t){this._learningrate=t}manager(){const t=this;return{get lr(){return t._learningrate},params:{},delta(a,r){if("number"==typeof r)return this.params[a]=(this.params[a]??r)*t._beta+r*(1-t._beta),this.params[a]*this.lr;this.params[a]||(this.params[a]=r.copy()),this.params[a].broadcastOperate(r,((a,r)=>a*t._beta+r*(1-t._beta)));const e=this.params[a].copy();return e.map((t=>t*this.lr)),e}}}}export class RMSPropOptimizer{constructor(t,a=.999){this._learningrate=t,this._beta=a}set learningRate(t){this._learningrate=t}manager(){const t=this;return{get lr(){return t._learningrate},params:{},delta(a,r){if("number"==typeof r)return this.params[a]=(this.params[a]??r**2)*t._beta+(1-t._beta)*r**2,this.lr*r/Math.sqrt(this.params[a]+1e-12);this.params[a]||(this.params[a]=r.copy(),this.params[a].map((t=>t**2))),this.params[a].broadcastOperate(r,((a,r)=>a*t._beta+(1-t._beta)*r*r));const e=r.copy();return e.broadcastOperate(this.params[a],((t,a)=>t*(this.lr/Math.sqrt(a+1e-12)))),e}}}}export class AdamOptimizer{constructor(t=.001,a=.9,r=.999){this._learningrate=t,this._beta1=a,this._beta2=r}set learningRate(t){this._learningrate=t}manager(){const t=this;return{get lr(){return t._learningrate},params:{},delta(a,r){const e="number"==typeof r;if(e&&(r=new Matrix(1,1,r)),!this.params[a]){const t=r.copy();t.map((t=>t**2)),this.params[a]={v:r.copy(),s:t}}this.params[a].v.broadcastOperate(r,((a,r)=>a*t._beta1+r*(1-t._beta1))),this.params[a].s.broadcastOperate(r,((a,r)=>a*t._beta2+(1-t._beta2)*r*r));const s=this.params[a].v.copy();return s.broadcastOperate(this.params[a].s,((t,a)=>t*(this.lr/Math.sqrt(a+1e-12)))),e?s.toScaler():s}}}}