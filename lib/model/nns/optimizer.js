import Matrix from"../../util/matrix.js";export class SGDOptimizer{constructor(t){this._learningrate=t}set learningRate(t){this._learningrate=t}manager(){const t=this;return{get lr(){return t._learningrate},delta(t,r){if("number"==typeof r)return r*this.lr;const a=r.copy();return a.map((t=>t*this.lr)),a}}}}export class MomentumOptimizer{constructor(t,r=.9){this._learningrate=t,this._beta=r}set learningRate(t){this._learningrate=t}manager(){const t=this;return{get lr(){return t._learningrate},params:{},delta(r,a){const e="number"==typeof a;e&&(a=new Matrix(1,1,a)),this.params[r]||(this.params[r]=a.copy()),this.params[r].broadcastOperate(a,((r,a)=>r*t._beta+a*(1-t._beta)));const s=this.params[r].copy();return s.map((t=>t*this.lr)),e?s.toScaler():s}}}}export class RMSPropOptimizer{constructor(t,r=.999){this._learningrate=t,this._beta=r}set learningRate(t){this._learningrate=t}manager(){const t=this;return{get lr(){return t._learningrate},params:{},delta(r,a){const e="number"==typeof a;e&&(a=new Matrix(1,1,a)),this.params[r]||(this.params[r]=a.copy(),this.params[r].broadcastOperate(a,((t,r)=>t*r))),this.params[r].broadcastOperate(a,((r,a)=>r*t._beta+(1-t._beta)*a*a));const s=a.copy();return s.broadcastOperate(this.params[r],((t,r)=>t*(this.lr/Math.sqrt(r+1e-12)))),e?s.toScaler():s}}}}export class AdamOptimizer{constructor(t=.001,r=.9,a=.999){this._learningrate=t,this._beta1=r,this._beta2=a}set learningRate(t){this._learningrate=t}manager(){const t=this;return{get lr(){return t._learningrate},params:{},delta(r,a){const e="number"==typeof a;if(e&&(a=new Matrix(1,1,a)),!this.params[r]){const t=a.copy();t.broadcastOperate(a,((t,r)=>t*r)),this.params[r]={v:a.copy(),s:t}}this.params[r].v.broadcastOperate(a,((r,a)=>r*t._beta1+a*(1-t._beta1))),this.params[r].s.broadcastOperate(a,((r,a)=>r*t._beta2+(1-t._beta2)*a*a));const s=this.params[r].v.copy();return s.broadcastOperate(this.params[r].s,((t,r)=>t*(this.lr/Math.sqrt(r+1e-12)))),e?s.toScaler():s}}}}