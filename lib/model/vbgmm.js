import Matrix from"../util/matrix.js";class BigFract{constructor(t=0n,i=1n){this._n=BigInt(t),this._d=BigInt(i)}_euclidean(t,i){if(0n===t||0n===i)return 0n!==t?t:0n!==i?i:1n;if((t=t<0?-t:t)===(i=i<0?-i:i))return t;for(t>i&&([t,i]=[i,t]);;){const r=i-i/t*t;if(0n===r)return t;[t,i]=[r,t]}}toFloat(){return Number(this._n)/Number(this._d)}add(t){const i=this._n*t._d+t._n*this._d,r=this._d*t._d,s=this._euclidean(i,r);return new BigFract(i/s,r/s)}mult(t){const i=this._n*t._n,r=this._d*t._d,s=this._euclidean(i,r);return new BigFract(i/s,r/s)}}const BigFract0=new BigFract(0),B=[new BigFract(1),new BigFract(-1,2),new BigFract(1,6)],bernoulli=t=>{if(t<0)throw"Invalid bernoulli parameter";if(B[t])return B[t];if(t%2==1&&t>1)return B[t]=BigFract0;let i=new BigFract(1).mult(B[0]);for(let r=1;r<t;r++){let s=1n,a=1n;for(let i=0n;i<r;i++)s*=BigInt(t+1)-i,a*=i+1n;i=i.add(new BigFract(s,a).mult(bernoulli(r)))}return B[t]=i.mult(new BigFract(-1,t+1))};export default class VBGMM{constructor(t,i,r){this._a0=t,this._b0=i,this._k=r}get means(){return this._m}get covs(){return this._nu.value.map(((t,i)=>Matrix.mult(this._w[i],t).inv()))}get effectivity(){return this._r.sum(0).value.map((t=>t>=1))}init(t){this._x=Matrix.fromArray(t);const i=this._x.rows,r=this._x.cols,s=this._x.variance(0).mean();this._m0=Matrix.zeros(1,r),this._w0=Matrix.eye(r,r,1/s),this._nu0=1;const a=this._x.sample(this._k)[0],e=[];for(let t=0;t<this._k;t++)e.push(Matrix.eye(r,r,s));this._r=new Matrix(i,this._k);for(let t=0;t<this._k;t++){const i=Matrix.sub(this._x,a.row(t)),s=Matrix.mult(i.dot(e[t].inv()),i).sum(1),n=Math.sqrt(e[t].det()*(2*Math.PI)**r);s.map((t=>Math.exp(-t/2)/n)),this._r.set(0,t,s)}this._r.div(this._r.sum(1)),this._r.map((t=>t<1e-10?1e-10:t))}_digamma(t){if(isNaN(t))return t;const i=.5772156649;if(t>0&&Number.isInteger(t)){let r=-i;for(let i=1;i<t;i++)r+=1/i;return r}if(t>0&&Number.isInteger(t-.5)){let r=-i-2*Math.log(2);for(let i=0;i<t-1;i++)r+=2/(2*i+1);return r}let r=0;for(t<0&&(r-=Math.PI/Math.tan(Math.PI*t),t=1-t);t<10;)r-=1/t,t+=1;r+=Math.log(t)-1/(2*t);let s=1;for(;;){const i=2*s,a=this._bernoulli(i)/(i*t**i);if(r-=a,Math.abs(a/r)<1e-12)break;s+=1}return r}_bernoulli(t){return bernoulli(t).toFloat()}fit(){const t=this._r.sum(0),i=this._r.tDot(this._x);i.div(t.t);const r=this._r.cols,s=this._x.cols,a=this._x.rows,e=[];for(let s=0;s<r;s++){const r=this._r.col(s),a=Matrix.sub(this._x,i.row(s)),n=Matrix.mult(a,r).tDot(a);n.div(t.value[s]),e.push(n)}const n=this._p=Matrix.add(t,this._a0);this._p.div(this._p.sum());const h=Matrix.add(t,this._b0),o=Matrix.mult(this._m0,this._b0),u=this._m=Matrix.add(Matrix.mult(i,t.t),o);u.div(h.t);const l=this._w=[];for(let s=0;s<r;s++){const r=this._w0.inv(),a=t.value[s];r.add(Matrix.mult(e[s],a));const n=this._b0*a/(this._b0+a),h=Matrix.sub(i.row(s),this._m0);r.add(Matrix.mult(h.tDot(h),n)),l.push(r.inv())}const _=this._nu=Matrix.add(t,this._nu0),m=Matrix.map(n,(t=>this._digamma(t)));m.sub(this._digamma(n.sum()));const c=Matrix.zeros(a,r);for(let t=0;t<r;t++){const i=_.value[t];let r=s*Math.log(2)+Math.log(l[t].det());for(let t=0;t<s;t++)r+=this._digamma((i-t)/2);const a=Matrix.sub(this._x,u.row(t)),e=Matrix.mult(a.dot(l[t]),a).sum(1);e.mult(i),e.add(s/h.value[t]),e.map((t=>(r-s*Math.log(2*Math.PI)-t)/2)),c.set(0,t,e)}const d=Matrix.add(c,m),M=Matrix.zeros(a,r);for(let t=0;t<a;t++){const i=d.row(t),r=Math.log(i.value.reduce(((t,i)=>t+Math.exp(i)),0));i.sub(r),M.set(t,0,i)}M.map(Math.exp),M.div(M.sum(1)),M.map((t=>t<1e-10?1e-10:t)),this._r=M}probability(t){const i=Matrix.fromArray(t),r=this.covs,s=new Matrix(i.rows,r.length);for(let t=0;t<r.length;t++){const a=Matrix.sub(i,this._m.row(t));let e=a.dot(r[t].inv());e.mult(a),e=e.sum(1);const n=Math.sqrt(r[t].det()*(2*Math.PI)**i.cols);e.map((t=>Math.exp(-t/2)/n)),s.set(0,t,e)}return s.mult(this._p),s}predict(t){return this.probability(t).argmax(1).value}}