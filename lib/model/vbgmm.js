var P=Object.defineProperty;var b=(u,t)=>P(u,"name",{value:t,configurable:!0});import n from"../util/matrix.js";class a{static{b(this,"BigFract")}constructor(t=0n,s=1n){this._n=BigInt(t),this._d=BigInt(s)}_euclidean(t,s){if(t===0n||s===0n)return t!==0n?t:s!==0n?s:1n;if(t=t<0?-t:t,s=s<0?-s:s,t===s)return t;for(t>s&&([t,s]=[s,t]);;){const e=s/t,o=s-e*t;if(o===0n)return t;[t,s]=[o,t]}}toFloat(){return Number(this._n)/Number(this._d)}add(t){const s=this._n*t._d+t._n*this._d,e=this._d*t._d,o=this._euclidean(s,e);return new a(s/o,e/o)}mult(t){const s=this._n*t._n,e=this._d*t._d,o=this._euclidean(s,e);return new a(s/o,e/o)}}const q=new a(0),p=[new a(1),new a(-1,2),new a(1,6)],N=b(u=>{if(u<0)throw"Invalid bernoulli parameter";if(p[u])return p[u];if(u%2===1&&u>1)return p[u]=q,p[u];let t=new a(1).mult(p[0]);for(let s=1;s<u;s++){let e=1n,o=1n;for(let r=0n;r<s;r++)e*=BigInt(u+1)-r,o*=r+1n;t=t.add(new a(e,o).mult(N(s)))}return p[u]=t.mult(new a(-1,u+1)),p[u]},"bernoulli");export default class D{static{b(this,"VBGMM")}constructor(t,s,e){this._a0=t,this._b0=s,this._k=e}get means(){return this._m}get covs(){return this._nu.value.map((t,s)=>n.mult(this._w[s],t).inv())}get effectivity(){return this._r.sum(0).value.map(t=>t>=1)}init(t){this._x=n.fromArray(t);const s=this._x.rows,e=this._x.cols,o=this._x.variance(0).mean();this._m0=n.zeros(1,e),this._w0=n.eye(e,e,1/o),this._nu0=1;const r=this._x.sample(this._k)[0],l=[];for(let h=0;h<this._k;h++)l.push(n.eye(e,e,o));this._r=new n(s,this._k);for(let h=0;h<this._k;h++){const f=n.sub(this._x,r.row(h)),w=n.mult(f.dot(l[h].inv()),f).sum(1),g=Math.sqrt(l[h].det()*(2*Math.PI)**e);w.map(x=>Math.exp(-x/2)/g),this._r.set(0,h,w)}this._r.div(this._r.sum(1)),this._r.map(h=>h<1e-10?1e-10:h)}_digamma(t){if(Number.isNaN(t))return t;const s=.5772156649;if(t>0&&Number.isInteger(t)){let r=-s;for(let l=1;l<t;l++)r+=1/l;return r}else if(t>0&&Number.isInteger(t-.5)){let r=-s-2*Math.log(2);for(let l=0;l<t-1;l++)r+=2/(2*l+1);return r}let e=0;for(t<0&&(e-=Math.PI/Math.tan(Math.PI*t),t=1-t);t<10;)e-=1/t,t+=1;e+=Math.log(t)-1/(2*t);let o=1;for(;;){const r=o*2,l=this._bernoulli(r)/(r*t**r);if(e-=l,Math.abs(l/e)<1e-12)break;o+=1}return e}_bernoulli(t){return N(t).toFloat()}fit(){const t=this._r.sum(0),s=this._r.tDot(this._x);s.div(t.t);const e=this._r.cols,o=this._x.cols,r=this._x.rows,l=[];for(let i=0;i<e;i++){const c=this._r.col(i),_=n.sub(this._x,s.row(i)),m=n.mult(_,c).tDot(_);m.div(t.value[i]),l.push(m)}const h=n.add(t,this._a0);this._p=h,this._p.div(this._p.sum());const f=n.add(t,this._b0),w=n.mult(this._m0,this._b0),g=n.add(n.mult(s,t.t),w);g.div(f.t),this._m=g;const x=[];this._w=x;for(let i=0;i<e;i++){const c=this._w0.inv(),_=t.value[i];c.add(n.mult(l[i],_));const m=this._b0*_/(this._b0+_),d=n.sub(s.row(i),this._m0);c.add(n.mult(d.tDot(d),m)),x.push(c.inv())}const k=n.add(t,this._nu0);this._nu=k;const I=n.map(h,i=>this._digamma(i));I.sub(this._digamma(h.sum()));const y=n.zeros(r,e);for(let i=0;i<e;i++){const c=k.value[i];let _=o*Math.log(2)+Math.log(x[i].det());for(let M=0;M<o;M++)_+=this._digamma((c-M)/2);const m=n.sub(this._x,g.row(i)),d=n.mult(m.dot(x[i]),m).sum(1);d.mult(c),d.add(o/f.value[i]),d.map(M=>(_-o*Math.log(2*Math.PI)-M)/2),y.set(0,i,d)}const B=n.add(y,I),v=n.zeros(r,e);for(let i=0;i<r;i++){const c=B.row(i),_=Math.log(c.value.reduce((m,d)=>m+Math.exp(d),0));c.sub(_),v.set(i,0,c)}v.map(Math.exp),v.div(v.sum(1)),v.map(i=>i<1e-10?1e-10:i),this._r=v}probability(t){const s=n.fromArray(t),e=this.covs,o=new n(s.rows,e.length);for(let r=0;r<e.length;r++){const l=n.sub(s,this._m.row(r));let h=l.dot(e[r].inv());h.mult(l),h=h.sum(1);const f=Math.sqrt(e[r].det()*(2*Math.PI)**s.cols);h.map(w=>Math.exp(-w/2)/f),o.set(0,r,h)}return o.mult(this._p),o}predict(t){return this.probability(t).argmax(1).value}}
