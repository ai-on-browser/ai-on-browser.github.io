var P=Object.defineProperty;var b=(u,t)=>P(u,"name",{value:t,configurable:!0});import i from"../util/matrix.js";class a{static{b(this,"BigFract")}constructor(t=0n,s=1n){this._n=BigInt(t),this._d=BigInt(s)}_euclidean(t,s){if(t===0n||s===0n)return t!==0n?t:s!==0n?s:1n;if(t=t<0?-t:t,s=s<0?-s:s,t===s)return t;for(t>s&&([t,s]=[s,t]);;){const e=s/t,o=s-e*t;if(o===0n)return t;[t,s]=[o,t]}}toFloat(){return Number(this._n)/Number(this._d)}add(t){const s=this._n*t._d+t._n*this._d,e=this._d*t._d,o=this._euclidean(s,e);return new a(s/o,e/o)}mult(t){const s=this._n*t._n,e=this._d*t._d,o=this._euclidean(s,e);return new a(s/o,e/o)}}const q=new a(0),g=[new a(1),new a(-1,2),new a(1,6)],y=b(u=>{if(u<0)throw"Invalid bernoulli parameter";if(g[u])return g[u];if(u%2===1&&u>1)return g[u]=q;let t=new a(1).mult(g[0]);for(let s=1;s<u;s++){let e=1n,o=1n;for(let r=0n;r<s;r++)e*=BigInt(u+1)-r,o*=r+1n;t=t.add(new a(e,o).mult(y(s)))}return g[u]=t.mult(new a(-1,u+1))},"bernoulli");export default class D{static{b(this,"VBGMM")}constructor(t,s,e){this._a0=t,this._b0=s,this._k=e}get means(){return this._m}get covs(){return this._nu.value.map((t,s)=>i.mult(this._w[s],t).inv())}get effectivity(){return this._r.sum(0).value.map(t=>t>=1)}init(t){this._x=i.fromArray(t);const s=this._x.rows,e=this._x.cols,o=this._x.variance(0).mean();this._m0=i.zeros(1,e),this._w0=i.eye(e,e,1/o),this._nu0=1;const r=this._x.sample(this._k)[0],l=[];for(let h=0;h<this._k;h++)l.push(i.eye(e,e,o));this._r=new i(s,this._k);for(let h=0;h<this._k;h++){const f=i.sub(this._x,r.row(h)),p=i.mult(f.dot(l[h].inv()),f).sum(1),M=Math.sqrt(l[h].det()*(2*Math.PI)**e);p.map(x=>Math.exp(-x/2)/M),this._r.set(0,h,p)}this._r.div(this._r.sum(1)),this._r.map(h=>h<1e-10?1e-10:h)}_digamma(t){if(Number.isNaN(t))return t;const s=.5772156649;if(t>0&&Number.isInteger(t)){let r=-s;for(let l=1;l<t;l++)r+=1/l;return r}else if(t>0&&Number.isInteger(t-.5)){let r=-s-2*Math.log(2);for(let l=0;l<t-1;l++)r+=2/(2*l+1);return r}let e=0;for(t<0&&(e-=Math.PI/Math.tan(Math.PI*t),t=1-t);t<10;)e-=1/t,t+=1;e+=Math.log(t)-1/(2*t);let o=1;for(;;){const r=o*2,l=this._bernoulli(r)/(r*t**r);if(e-=l,Math.abs(l/e)<1e-12)break;o+=1}return e}_bernoulli(t){return y(t).toFloat()}fit(){const t=this._r.sum(0),s=this._r.tDot(this._x);s.div(t.t);const e=this._r.cols,o=this._x.cols,r=this._x.rows,l=[];for(let n=0;n<e;n++){const c=this._r.col(n),_=i.sub(this._x,s.row(n)),m=i.mult(_,c).tDot(_);m.div(t.value[n]),l.push(m)}const h=this._p=i.add(t,this._a0);this._p.div(this._p.sum());const f=i.add(t,this._b0),p=i.mult(this._m0,this._b0),M=this._m=i.add(i.mult(s,t.t),p);M.div(f.t);const x=this._w=[];for(let n=0;n<e;n++){const c=this._w0.inv(),_=t.value[n];c.add(i.mult(l[n],_));const m=this._b0*_/(this._b0+_),d=i.sub(s.row(n),this._m0);c.add(i.mult(d.tDot(d),m)),x.push(c.inv())}const N=this._nu=i.add(t,this._nu0),k=i.map(h,n=>this._digamma(n));k.sub(this._digamma(h.sum()));const I=i.zeros(r,e);for(let n=0;n<e;n++){const c=N.value[n];let _=o*Math.log(2)+Math.log(x[n].det());for(let v=0;v<o;v++)_+=this._digamma((c-v)/2);const m=i.sub(this._x,M.row(n)),d=i.mult(m.dot(x[n]),m).sum(1);d.mult(c),d.add(o/f.value[n]),d.map(v=>(_-o*Math.log(2*Math.PI)-v)/2),I.set(0,n,d)}const B=i.add(I,k),w=i.zeros(r,e);for(let n=0;n<r;n++){const c=B.row(n),_=Math.log(c.value.reduce((m,d)=>m+Math.exp(d),0));c.sub(_),w.set(n,0,c)}w.map(Math.exp),w.div(w.sum(1)),w.map(n=>n<1e-10?1e-10:n),this._r=w}probability(t){const s=i.fromArray(t),e=this.covs,o=new i(s.rows,e.length);for(let r=0;r<e.length;r++){const l=i.sub(s,this._m.row(r));let h=l.dot(e[r].inv());h.mult(l),h=h.sum(1);const f=Math.sqrt(e[r].det()*(2*Math.PI)**s.cols);h.map(p=>Math.exp(-p/2)/f),o.set(0,r,h)}return o.mult(this._p),o}predict(t){return this.probability(t).argmax(1).value}}
