import Matrix from"../util/matrix.js";export default class VBGMM{constructor(t,s,i){this._a0=t,this._b0=s,this._k=i}get means(){return this._m}get covs(){return this._nu.value.map(((t,s)=>Matrix.mult(this._w[s],t).inv()))}get effectivity(){return this._r.sum(0).value.map((t=>t>=1))}init(t){this._x=Matrix.fromArray(t);const s=this._x.rows,i=this._x.cols,a=this._x.variance(0).mean();this._m0=Matrix.zeros(1,i),this._w0=Matrix.eye(i,i,1/a),this._nu0=1;const r=this._x.sample(this._k)[0],h=[];for(let t=0;t<this._k;t++)h.push(Matrix.eye(i,i,a));this._r=new Matrix(s,this._k);for(let t=0;t<this._k;t++){const s=Matrix.sub(this._x,r.row(t)),a=Matrix.mult(s.dot(h[t].inv()),s).sum(1),o=Math.sqrt(h[t].det()*(2*Math.PI)**i);a.map((t=>Math.exp(-t/2)/o)),this._r.set(0,t,a)}this._r.div(this._r.sum(1)),this._r.map((t=>t<1e-10?1e-10:t))}_digamma(t){if(t<=0)throw"Invalid digamma value";let s=-.5772156649,i=0;for(;;){const a=(t-1)/((i+1)*(t+i));if(Math.abs(a)<1e-12)break;s+=a,i++}return s}fit(){const t=this._r.sum(0),s=this._r.tDot(this._x);s.div(t.t);const i=this._r.cols,a=this._x.cols,r=this._x.rows,h=[];for(let a=0;a<i;a++){const i=this._r.col(a),r=Matrix.sub(this._x,s.row(a)),o=Matrix.mult(r,i).tDot(r);o.div(t.value[a]),h.push(o)}const o=this._p=Matrix.add(t,this._a0);this._p.div(this._p.sum());const e=Matrix.add(t,this._b0),_=Matrix.mult(this._m0,this._b0),m=this._m=Matrix.add(Matrix.mult(s,t.t),_);m.div(e.t);const u=this._w=[];for(let a=0;a<i;a++){const i=this._w0.inv(),r=t.value[a];i.add(Matrix.mult(h[a],r));const o=this._b0*r/(this._b0+r),e=Matrix.sub(s.row(a),this._m0);i.add(Matrix.mult(e.tDot(e),o)),u.push(i.inv())}const l=this._nu=Matrix.add(t,this._nu0),x=Matrix.map(o,(t=>this._digamma(t)));x.sub(this._digamma(o.sum()));const n=Matrix.zeros(r,i);for(let t=0;t<i;t++){const s=l.value[t];let i=a*Math.log(2)+Math.log(u[t].det());for(let t=0;t<a;t++)i+=this._digamma((s-t)/2);const r=Matrix.sub(this._x,m.row(t)),h=Matrix.mult(r.dot(u[t]),r).sum(1);h.mult(s),h.add(a/e.value[t]),h.map((t=>(i-a*Math.log(2*Math.PI)-t)/2)),n.set(0,t,h)}const M=Matrix.add(n,x),d=Matrix.zeros(r,i);for(let t=0;t<r;t++){const s=M.row(t),i=Math.log(s.value.reduce(((t,s)=>t+Math.exp(s)),0));s.sub(i),d.set(t,0,s)}d.map(Math.exp),d.div(d.sum(1)),d.map((t=>t<1e-10?1e-10:t)),this._r=d}probability(t){const s=Matrix.fromArray(t),i=this.covs,a=new Matrix(s.rows,i.length);for(let t=0;t<i.length;t++){const r=Matrix.sub(s,this._m.row(t));let h=r.dot(i[t].inv());h.mult(r),h=h.sum(1);const o=Math.sqrt(i[t].det()*(2*Math.PI)**s.cols);h.map((t=>Math.exp(-t/2)/o)),a.set(0,t,h)}return a.mult(this._p),a}predict(t){return this.probability(t).argmax(1).value}}