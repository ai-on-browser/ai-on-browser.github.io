import{Matrix}from"../util/math.js";export default class VBGMM{constructor(t,s,i){this._a0=t,this._b0=s,this._k=i}get means(){return this._m}get covs(){return this._nu.value.map(((t,s)=>this._w[s].copyMult(t).inv()))}get effectivity(){return this._r.sum(0).value.map((t=>t>=1))}init(t){this._x=Matrix.fromArray(t);const s=this._x.rows,i=this._x.cols,o=this._x.variance(0).mean();this._m0=Matrix.zeros(1,i),this._w0=Matrix.eye(i,i,1/o),this._nu0=1;const h=this._x.sampleRow(this._k),r=[];for(let t=0;t<this._k;t++)r.push(Matrix.eye(i,i,o));this._r=new Matrix(s,this._k);for(let t=0;t<this._k;t++){const s=this._x.copySub(h.row(t)),o=s.dot(r[t].inv()).copyMult(s).sum(1),a=Math.sqrt(r[t].det()*(2*Math.PI)**i);o.map((t=>Math.exp(-t/2)/a)),this._r.set(0,t,o)}this._r.div(this._r.sum(1)),this._r.map((t=>t<1e-10?1e-10:t))}_digamma(t){if(t<=0)throw"Invalid digamma value";let s=-.5772156649,i=0;for(;;){const o=(t-1)/((i+1)*(t+i));if(Math.abs(o)<1e-12)break;s+=o,i++}return s}fit(){const t=this._r.sum(0),s=this._r.tDot(this._x);s.div(t.t);const i=this._r.cols,o=this._x.cols,h=this._x.rows,r=[];for(let o=0;o<i;o++){const i=this._r.col(o),h=this._x.copySub(s.row(o)),a=h.copyMult(i).tDot(h);a.div(t.value[o]),r.push(a)}const a=this._p=t.copyAdd(this._a0);this._p.div(this._p.sum());const e=t.copyAdd(this._b0),_=this._m0.copyMult(this._b0),c=this._m=s.copyMult(t.t).copyAdd(_);c.div(e.t);const u=this._w=[];for(let o=0;o<i;o++){const i=this._w0.inv(),h=t.value[o];i.add(r[o].copyMult(h));const a=this._b0*h/(this._b0+h),e=s.row(o).copySub(this._m0);i.add(e.tDot(e).copyMult(a)),u.push(i.inv())}const l=this._nu=t.copyAdd(this._nu0),n=a.copyMap((t=>this._digamma(t)));n.sub(this._digamma(a.sum()));const m=Matrix.zeros(h,i);for(let t=0;t<i;t++){const s=l.value[t];let i=o*Math.log(2)+Math.log(u[t].det());for(let t=0;t<o;t++)i+=this._digamma((s-t)/2);const h=this._x.copySub(c.row(t)),r=h.dot(u[t]).copyMult(h).sum(1);r.mult(s),r.add(o/e.value[t]),r.map((t=>(i-o*Math.log(2*Math.PI)-t)/2)),m.set(0,t,r)}const p=m.copyAdd(n),d=Matrix.zeros(h,i);for(let t=0;t<h;t++){const s=p.row(t),i=Math.log(s.value.reduce(((t,s)=>t+Math.exp(s)),0));s.sub(i),d.set(t,0,s)}d.map(Math.exp),d.div(d.sum(1)),d.map((t=>t<1e-10?1e-10:t)),this._r=d}probability(t){const s=Matrix.fromArray(t),i=this.covs,o=new Matrix(s.rows,i.length);for(let t=0;t<i.length;t++){const h=s.copySub(this._m.row(t));let r=h.dot(i[t].inv());r.mult(h),r=r.sum(1);const a=Math.sqrt(i[t].det()*(2*Math.PI)**s.cols);r.map((t=>Math.exp(-t/2)/a)),o.set(0,t,r)}return o.mult(this._p),o}predict(t){return this.probability(t).argmax(1).value}}