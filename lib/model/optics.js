var b=Object.defineProperty;var d=(p,s)=>b(p,"name",{value:s,configurable:!0});class v{static{d(this,"PriorityQueue")}constructor(s){this._value=s||[]}get length(){return this._value.length}_sort(){this._value.sort((s,e)=>s[1]-e[1])}push(s,e){this._value.push([s,e]),this._sort()}move(s,e){for(let n=0;n<this.length;n++)if(this._value[n][0]===s){this._value[n][1]=e,this._sort();return}this.push(s,e)}shift(){const[s]=this._value.shift();return s}}export default class y{static{d(this,"OPTICS")}constructor(s,e=1/0,n=5,u="euclid"){if(this._threshold=s,this._eps=e,this._minPts=n,this._metric=u,typeof this._metric=="function")this._d=this._metric;else switch(this._metric){case"euclid":this._d=(c,_)=>Math.sqrt(c.reduce((o,l,m)=>o+(l-_[m])**2,0));break;case"manhattan":this._d=(c,_)=>c.reduce((o,l,m)=>o+Math.abs(l-_[m]),0);break;case"chebyshev":this._d=(c,_)=>Math.max(...c.map((o,l)=>Math.abs(o-_[l])));break}}fit(s){const e=s.length,n=Array(e);for(let t=0;t<e;n[t++]=Array(e));for(let t=0;t<e;t++)for(let i=0;i<t;i++){const r=this._d(s[t],s[i]);n[t][i]=n[i][t]=r}const u=d(t=>{const i=[];for(let r=0;r<e;r++)n[t][r]<this._eps&&i.push(r);return i},"getNeighbors"),c=d(t=>{const i=u(t).map(r=>n[t][r]);return i.length<=this._minPts?null:(i.sort((r,a)=>r-a),i[this._minPts])},"coreDist"),_=d((t,i)=>{const r=c(i);return r===null?r:Math.max(r,n[i][t])},"reachabilityDist"),o=Array(e).fill(!1),l=Array(e).fill(null),m=d((t,i,r)=>{const a=c(i);if(a!==null)for(const h of t){if(o[h])continue;const f=Math.max(a,n[i][h]);l[h]===null?(l[h]=f,r.push(h,f)):f<l[h]&&(l[h]=f,r.move(h,f))}},"update");this._core_distance=[];for(let t=0;t<e;t++){if(o[t])continue;const i=u(t);o[t]=!0;const r=c(t);if(this._core_distance.push([t,r]),r!==null){const a=new v;for(m(i,t,a);a.length>0;){const h=a.shift(),f=u(h);o[h]=!0;const g=c(h);this._core_distance.push([h,g]),g!==null&&m(f,h,a)}}}}predict(){let s=0;const e=this._core_distance.length,n=Array(e);for(let u=0;u<e;u++){const[c,_]=this._core_distance[u];n[c]=_>this._threshold?++s:s}return n}}
