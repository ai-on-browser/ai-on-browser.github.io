var g=Object.defineProperty;var u=(c,t)=>g(c,"name",{value:t,configurable:!0});class v{static{u(this,"PriorityQueue")}constructor(t){this._value=t||[]}get length(){return this._value.length}_sort(){this._value.sort((t,s)=>t[1]-s[1])}push(t,s){this._value.push([t,s]),this._sort()}move(t,s){for(let i=0;i<this.length;i++)if(this._value[i][0]===t){this._value[i][1]=s,this._sort();return}this.push(t,s)}shift(){const[t]=this._value.shift();return t}}const y={euclid:u((c,t)=>Math.sqrt(c.reduce((s,i,o)=>s+(i-t[o])**2,0)),"euclid"),manhattan:u((c,t)=>c.reduce((s,i,o)=>s+Math.abs(i-t[o]),0),"manhattan"),chebyshev:u((c,t)=>Math.max(...c.map((s,i)=>Math.abs(s-t[i]))),"chebyshev")};export default class b{static{u(this,"OPTICS")}constructor(t,s=1/0,i=5,o="euclid"){this._threshold=t,this._eps=s,this._minPts=i,this._metric=o,typeof this._metric=="function"?this._d=this._metric:this._d=y[this._metric]}fit(t){const s=t.length,i=Array(s);for(let e=0;e<s;i[e++]=Array(s));for(let e=0;e<s;e++)for(let n=0;n<e;n++){const r=this._d(t[e],t[n]);i[e][n]=i[n][e]=r}const o=u(e=>{const n=[];for(let r=0;r<s;r++)i[e][r]<this._eps&&n.push(r);return n},"getNeighbors"),f=u(e=>{const n=o(e).map(r=>i[e][r]);return n.length<=this._minPts?null:(n.sort((r,l)=>r-l),n[this._minPts])},"coreDist"),a=Array(s).fill(!1),d=Array(s).fill(null),m=u((e,n,r)=>{const l=f(n);if(l!==null)for(const h of e){if(a[h])continue;const _=Math.max(l,i[n][h]);d[h]===null?(d[h]=_,r.push(h,_)):_<d[h]&&(d[h]=_,r.move(h,_))}},"update");this._core_distance=[];for(let e=0;e<s;e++){if(a[e])continue;const n=o(e);a[e]=!0;const r=f(e);if(this._core_distance.push([e,r]),r!==null){const l=new v;for(m(n,e,l);l.length>0;){const h=l.shift(),_=o(h);a[h]=!0;const p=f(h);this._core_distance.push([h,p]),p!==null&&m(_,h,l)}}}}predict(){let t=0;const s=this._core_distance.length,i=Array(s);for(let o=0;o<s;o++){const[f,a]=this._core_distance[o];i[f]=a>this._threshold?++t:t}return i}}
