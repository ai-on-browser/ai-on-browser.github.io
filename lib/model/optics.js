class PriorityQueue{constructor(t){this._value=t||[]}get length(){return this._value.length}_sort(){this._value.sort(((t,s)=>t[1]-s[1]))}push(t,s){this._value.push([t,s]),this._sort()}move(t,s){for(let e=0;e<this.length;e++)if(this._value[e][0]===t)return this._value[e][1]=s,void this._sort();this.push(t,s)}shift(){const[t,s]=this._value.shift();return t}}export default class OPTICS{constructor(t=1/0,s=5,e="euclid"){switch(this._eps=t,this._minPts=s,this._metric=e,this._metric){case"euclid":this._d=(t,s)=>Math.sqrt(t.reduce(((t,e,i)=>t+(e-s[i])**2),0));break;case"manhattan":this._d=(t,s)=>t.reduce(((t,e,i)=>t+Math.abs(e-s[i])),0);break;case"chebyshev":this._d=(t,s)=>Math.max(...t.map(((t,e)=>Math.abs(t-s[e]))))}}fit(t){const s=t.length,e=Array(s);for(let t=0;t<s;e[t++]=Array(s));for(let i=0;i<s;i++)for(let s=0;s<i;s++){const r=this._d(t[i],t[s]);e[i][s]=e[s][i]=r}const i=t=>{const i=[];for(let r=0;r<s;r++)e[t][r]<this._eps&&i.push(r);return i},r=t=>{const s=i(t).map((s=>e[t][s]));return s.length<=this._minPts?null:(s.sort(((t,s)=>t-s)),s[this._minPts])},h=Array(s).fill(!1),n=Array(s).fill(null),o=(t,s,i)=>{const o=r(s);if(null!==o)for(const r of t){if(h[r])continue;const t=Math.max(o,e[s][r]);null===n[r]?(n[r]=t,i.push(r,t)):t<n[r]&&(n[r]=t,i.move(r,t))}};this._core_distance=[];for(let t=0;t<s;t++){if(h[t])continue;const s=i(t);h[t]=!0;const e=r(t);if(this._core_distance.push([t,e]),null!==e){const e=new PriorityQueue;for(o(s,t,e);e.length>0;){const t=e.shift(),s=i(t);h[t]=!0;const n=r(t);this._core_distance.push([t,n]),null!==n&&o(s,t,e)}}}}predict(t=.1){let s=0;const e=this._core_distance.length,i=Array(e);for(let r=0;r<e;r++){const[e,h]=this._core_distance[r];i[e]=h>t?++s:s}return i}}