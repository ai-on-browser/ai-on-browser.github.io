var d=Object.defineProperty;var l=(o,s)=>d(o,"name",{value:s,configurable:!0});import f from"../util/matrix.js";export default class g{static{l(this,"ISODATA")}constructor(s,r,t,i,e,n){this._init_k=s,this._min_k=r,this._max_k=t,this._min_n=i,this._split_sd=e,this._merge_distance=n,this._centroids=[]}get centroids(){return this._centroids}get size(){return this._centroids.length}_distance(s,r){return Math.sqrt(s.reduce((t,i,e)=>t+(i-r[e])**2,0))}init(s){const r=s.length,t=[];for(let i=0;i<this._init_k;i++)t.push(Math.floor(Math.random()*(r-i)));for(let i=this._init_k-1;i>=0;i--)for(let e=this._init_k-1;e>i;e--)t[i]<=t[e]&&t[e]++;this._centroids=[];for(let i=0;i<this._init_k;i++)this._centroids[i]=s[t[i]]}_fit_centers(s){for(;;){const r=this.predict(s),t=[];for(let e=0;e<this._centroids.length;e++){const n=s.filter((c,h)=>r[h]===e),_=Array(s[0].length).fill(0);for(let c=0;c<n.length;c++)for(let h=0;h<n[c].length;h++)_[h]+=n[c][h];t[e]=_.map(c=>c/n.length)}let i=0;for(let e=0;e<this._centroids.length;e++)i+=this._centroids[e].reduce((n,_,c)=>n+(_-t[e][c])**2,0);if(Number.isNaN(i)||i<1e-8)break;this._centroids=t}}fit(s){this._fit_centers(s),this._centroids.length<this._max_k&&this._split_centroids(s),this._centroids.length>this._min_k&&this._delete_centroids(s),this._centroids.length>this._min_k&&this._merge_centroids(s)}_merge_centroids(s){for(let r=0;r<this._centroids.length;r++)for(let t=0;t<r;t++)if(this._distance(this._centroids[r],this._centroids[t])<this._merge_distance){this._centroids[t]=this._centroids[t].map((e,n)=>(e+this._centroids[r][n])/2),this._centroids.splice(r,1),this._fit_centers(s);return}}_split_centroids(s){const r=this.predict(s);for(let t=0;t<this._centroids.length;t++){const e=f.fromArray(s.filter((n,_)=>r[_]===t)).std(0).value;for(let n=0;n<e.length;n++)if(n>this._split_sd){const _=this._centroids[t].concat();_[n]+=e[n]/100,this._centroids.splice(t,0,_),this._fit_centers(s);return}}}_delete_centroids(s){const r=this.predict(s);for(let t=this._centroids.length-1;t>=0;t--)r.every(i=>i!==t)&&this._centroids.splice(t,1);for(let t=this._centroids.length-1;t>=0;t--)if(r.reduce((i,e)=>i+(e===t?1:0),0)<this._min_n){this._centroids.splice(t,1),this._fit_centers(s);return}}predict(s){if(this._centroids.length===0)throw new Error("Call fit before predict.");return s.map(r=>{let t=1/0,i=-1;for(let e=0;e<this._centroids.length;e++){const n=this._distance(r,this._centroids[e]);n<t&&(t=n,i=e)}return i})}}
