var d=Object.defineProperty;var l=(o,s)=>d(o,"name",{value:s,configurable:!0});import f from"../util/matrix.js";export default class g{static{l(this,"ISODATA")}constructor(s,n,t,i,e,r){this._init_k=s,this._min_k=n,this._max_k=t,this._min_n=i,this._split_sd=e,this._merge_distance=r,this._centroids=[]}get centroids(){return this._centroids}get size(){return this._centroids.length}_distance(s,n){return Math.sqrt(s.reduce((t,i,e)=>t+(i-n[e])**2,0))}init(s){const n=s.length,t=[];for(let i=0;i<this._init_k;i++)t.push(Math.floor(Math.random()*(n-i)));for(let i=this._init_k-1;i>=0;i--)for(let e=this._init_k-1;e>i;e--)t[i]<=t[e]&&t[e]++;this._centroids=[];for(let i=0;i<this._init_k;i++)this._centroids[i]=s[t[i]]}_fit_centers(s){for(;;){const n=this.predict(s),t=[];for(let e=0;e<this._centroids.length;e++){const r=s.filter((c,h)=>n[h]===e),_=Array(s[0].length).fill(0);for(let c=0;c<r.length;c++)for(let h=0;h<r[c].length;h++)_[h]+=r[c][h];t[e]=_.map(c=>c/r.length)}let i=0;for(let e=0;e<this._centroids.length;e++)i+=this._centroids[e].reduce((r,_,c)=>r+(_-t[e][c])**2,0);if(isNaN(i)||i<1e-8)break;this._centroids=t}}fit(s){this._fit_centers(s),this._centroids.length<this._max_k&&this._split_centroids(s),this._centroids.length>this._min_k&&this._delete_centroids(s),this._centroids.length>this._min_k&&this._merge_centroids(s)}_merge_centroids(s){for(let n=0;n<this._centroids.length;n++)for(let t=0;t<n;t++)if(this._distance(this._centroids[n],this._centroids[t])<this._merge_distance){this._centroids[t]=this._centroids[t].map((e,r)=>(e+this._centroids[n][r])/2),this._centroids.splice(n,1),this._fit_centers(s);return}}_split_centroids(s){const n=this.predict(s);for(let t=0;t<this._centroids.length;t++){const e=f.fromArray(s.filter((r,_)=>n[_]===t)).std(0).value;for(let r=0;r<e.length;r++)if(r>this._split_sd){const _=this._centroids[t].concat();_[r]+=e[r]/100,this._centroids.splice(t,0,_),this._fit_centers(s);return}}}_delete_centroids(s){const n=this.predict(s);for(let t=this._centroids.length-1;t>=0;t--)n.every(i=>i!==t)&&this._centroids.splice(t,1);for(let t=this._centroids.length-1;t>=0;t--)if(n.reduce((i,e)=>i+(e===t?1:0),0)<this._min_n){this._centroids.splice(t,1),this._fit_centers(s);return}}predict(s){if(this._centroids.length===0)throw new Error("Call fit before predict.");return s.map(n=>{let t=1/0,i=-1;for(let e=0;e<this._centroids.length;e++){const r=this._distance(n,this._centroids[e]);r<t&&(t=r,i=e)}return i})}}
