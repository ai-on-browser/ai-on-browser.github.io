import Matrix from"../util/matrix.js";export default class ISODATA{constructor(t,i,e,s,r,n){this._init_k=t,this._min_k=i,this._max_k=e,this._min_n=s,this._split_sd=r,this._merge_distance=n,this._centroids=[]}get centroids(){return this._centroids}get size(){return this._centroids.length}_distance(t,i){return Math.sqrt(t.reduce(((t,e,s)=>t+(e-i[s])**2),0))}init(t){const i=t.length,e=[];for(let t=0;t<this._init_k;t++)e.push(Math.floor(Math.random()*(i-t)));for(let t=this._init_k-1;t>=0;t--)for(let i=this._init_k-1;i>t;i--)e[t]<=e[i]&&e[i]++;this._centroids=[];for(let i=0;i<this._init_k;i++)this._centroids[i]=t[e[i]]}_fit_centers(t){for(;;){const i=this.predict(t),e=[];for(let s=0;s<this._centroids.length;s++){const r=t.filter(((t,e)=>i[e]===s)),n=Array(t[0].length).fill(0);for(let t=0;t<r.length;t++)for(let i=0;i<r[t].length;i++)n[i]+=r[t][i];e[s]=n.map((t=>t/r.length))}let s=0;for(let t=0;t<this._centroids.length;t++)s+=this._centroids[t].reduce(((i,s,r)=>i+(s-e[t][r])**2),0);if(isNaN(s)||s<1e-8)break;this._centroids=e}}fit(t){this._fit_centers(t),this._centroids.length<this._max_k&&this._split_centroids(t),this._centroids.length>this._min_k&&this._delete_centroids(t),this._centroids.length>this._min_k&&this._merge_centroids(t)}_merge_centroids(t){for(let i=0;i<this._centroids.length;i++)for(let e=0;e<i;e++){if(this._distance(this._centroids[i],this._centroids[e])<this._merge_distance)return this._centroids[e]=this._centroids[e].map(((t,e)=>(t+this._centroids[i][e])/2)),this._centroids.splice(i,1),void this._fit_centers(t)}}_split_centroids(t){const i=this.predict(t);for(let e=0;e<this._centroids.length;e++){const s=Matrix.fromArray(t.filter(((t,s)=>i[s]===e))).std(0).value;for(let i=0;i<s.length;i++)if(i>this._split_sd){const r=this._centroids[e].concat();return r[i]+=s[i]/100,this._centroids.splice(e,0,r),void this._fit_centers(t)}}}_delete_centroids(t){const i=this.predict(t);for(let t=this._centroids.length-1;t>=0;t--)i.every((i=>i!==t))&&this._centroids.splice(t,1);for(let e=this._centroids.length-1;e>=0;e--)if(i.reduce(((t,i)=>t+(i===e?1:0)),0)<this._min_n)return this._centroids.splice(e,1),void this._fit_centers(t)}predict(t){if(0!==this._centroids.length)return t.map((t=>{let i=1/0,e=-1;for(let s=0;s<this._centroids.length;s++){const r=this._distance(t,this._centroids[s]);r<i&&(i=r,e=s)}return e}))}}