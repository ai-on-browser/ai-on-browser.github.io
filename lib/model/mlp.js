var d=Object.defineProperty;var r=(e,t)=>d(e,"name",{value:t,configurable:!0});import c from"../util/matrix.js";import{AdamOptimizer as f}from"./nns/optimizer.js";const g={identity:{calc:r(e=>e,"calc"),grad:r(()=>1,"grad")},elu:{calc:r(e=>e>0?e:Math.exp(e)-1,"calc"),grad:r(e=>e>0?1:Math.exp(e),"grad")},gaussian:{calc:r(e=>Math.exp(-(e**2)/2),"calc"),grad:r((e,t)=>-t*e,"grad")},leaky_relu:{calc:r(e=>e>0?e:.01*e,"calc"),grad:r(e=>e>0?1:.01,"grad")},relu:{calc:r(e=>Math.max(0,e),"calc"),grad:r(e=>e>0?1:0,"grad")},sigmoid:{calc:r(e=>1/(1+Math.exp(-e)),"calc"),grad:r((e,t)=>t*(1-t),"grad")},softplus:{calc:r(e=>Math.log(1+Math.exp(e)),"calc"),grad:r(e=>1/(1+Math.exp(-e)),"grad")},softsign:{calc:r(e=>e/(1+Math.abs(e)),"calc"),grad:r(e=>1/(1+Math.abs(e))**2,"grad")},tanh:{calc:Math.tanh,grad:r((e,t)=>1-t**2,"grad")}};class u{static{r(this,"MLP")}constructor(t,s){this._layer_sizes=t,this._activations=s,this._a=[],this._w=[],this._b=[];for(let i=0;i<t.length-1;i++)this._a[i]=g[s[i]],this._w[i]=c.randn(t[i],t[i+1],0,.1),this._b[i]=c.zeros(1,t[i+1]);this._optimizer=new f,this._optimizer_mng=this._optimizer.manager()}calc(t){this._i=[t],this._o=[t];for(let s=0;s<this._w.length;s++)this._i[s+1]=t=t.dot(this._w[s]),t.add(this._b[s]),this._o[s+1]=t=t.copy(),this._a[s]&&t.map(this._a[s].calc);return t}update(t,s){this._optimizer.learningRate=s;for(let i=this._w.length-1;i>=0;i--){if(this._a[i])for(let n=0;n<t.length;n++)t.value[n]*=this._a[i].grad(this._i[i+1].value[n],this._o[i+1].value[n]);const l=this._o[i].tDot(t);l.div(this._i[i].rows);const o=t.mean(0);t=t.dot(this._w[i].t),this._w[i].sub(this._optimizer_mng.delta(`w${i}`,l)),this._b[i].sub(this._optimizer_mng.delta(`b${i}`,o))}}toObject(){const t=[{type:"input"}];for(let s=0;s<this._layer_sizes.length-1;s++)t.push({type:"full",out_size:this._layer_sizes[s+1],activation:this._activations[s],w:this._w[s]?.toArray(),b:this._b[s]?.toArray()});return t}}export class MLPClassifier{static{r(this,"MLPClassifier")}constructor(t,s="tanh"){this._hidden_sizes=t,this._activations=Array(this._hidden_sizes.length).fill(s),this._model=null,this._classes=null,this._epoch=0}get categories(){return this._classes}get epoch(){return this._epoch}toObject(){return[...this._model.toObject(),{type:"softmax"},{type:"output"}]}fit(t,s,i,l=.001,o=0){if(!this._model){this._classes=[...new Set(s)];const h=[t[0].length,...this._hidden_sizes,this._classes.length];this._model=new u(h,this._activations)}const n=s.map(h=>{const m=Array(this._classes.length).fill(0);return m[this._classes.indexOf(h)]=1,m}),_=[],p=[];if(o>0)for(let h=0;h<t.length;h+=o)_.push(c.fromArray(t.slice(h,h+o))),p.push(c.fromArray(n.slice(h,h+o)));else _.push(c.fromArray(t)),p.push(c.fromArray(n));let a;for(let h=0;h<i;h++)for(let m=0;m<_.length;m++)a=this._fitonce(_[m],p[m],l);return this._epoch+=i,a.map(h=>h**2),a.mean()}_fitonce(t,s,i){const l=this._model.calc(t);l.sub(l.max(1)),l.map(Math.exp),l.div(l.sum(1));const o=c.sub(l,s);return this._model.update(o,i),o}probability(t){const s=this._model.calc(c.fromArray(t));return s.sub(s.max(1)),s.map(Math.exp),s.div(s.sum(1)),s.toArray()}predict(t){return this._model.calc(c.fromArray(t)).argmax(1).value.map(s=>this._classes[s])}}export class MLPRegressor{static{r(this,"MLPRegressor")}constructor(t,s="tanh"){this._hidden_sizes=t,this._activations=Array(t.length).fill(s),this._model=null,this._epoch=0}get epoch(){return this._epoch}toObject(){return[...this._model.toObject(),{type:"output"}]}fit(t,s,i,l=.001,o=0){if(!this._model){const a=[t[0].length,...this._hidden_sizes,s[0].length];this._model=new u(a,this._activations)}const n=[],_=[];if(o>0)for(let a=0;a<t.length;a+=o)n.push(c.fromArray(t.slice(a,a+o))),_.push(c.fromArray(s.slice(a,a+o)));else n.push(c.fromArray(t)),_.push(c.fromArray(s));let p;for(let a=0;a<i;a++)for(let h=0;h<n.length;h++)p=this._fitonce(n[h],_[h],l);return this._epoch+=i,p.map(a=>a**2),p.mean()}_fitonce(t,s,i){const l=this._model.calc(t),o=c.sub(l,s);return o.div(2),this._model.update(o,i),o}predict(t){return t=c.fromArray(t),this._model.calc(t).toArray()}}
