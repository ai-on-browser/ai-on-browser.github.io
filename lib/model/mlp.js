var d=Object.defineProperty;var m=(e,t)=>d(e,"name",{value:t,configurable:!0});import l from"../util/matrix.js";import{AdamOptimizer as f}from"./nns/optimizer.js";const g={identity:{calc:e=>e,grad:()=>1},elu:{calc:e=>e>0?e:Math.exp(e)-1,grad:e=>e>0?1:Math.exp(e)},gaussian:{calc:e=>Math.exp(-(e**2)/2),grad:(e,t)=>-t*e},leaky_relu:{calc:e=>e>0?e:.01*e,grad:e=>e>0?1:.01},relu:{calc:e=>Math.max(0,e),grad:e=>e>0?1:0},sigmoid:{calc:e=>1/(1+Math.exp(-e)),grad:(e,t)=>t*(1-t)},softplus:{calc:e=>Math.log(1+Math.exp(e)),grad:e=>1/(1+Math.exp(-e))},softsign:{calc:e=>e/(1+Math.abs(e)),grad:e=>1/(1+Math.abs(e))**2},tanh:{calc:Math.tanh,grad:(e,t)=>1-t**2}};class u{static{m(this,"MLP")}constructor(t,s){this._layer_sizes=t,this._activations=s,this._a=[],this._w=[],this._b=[];for(let i=0;i<t.length-1;i++)this._a[i]=g[s[i]],this._w[i]=l.randn(t[i],t[i+1],0,.1),this._b[i]=l.zeros(1,t[i+1]);this._optimizer=new f,this._optimizer_mng=this._optimizer.manager()}calc(t){this._i=[t],this._o=[t];for(let s=0;s<this._w.length;s++)this._i[s+1]=t=t.dot(this._w[s]),t.add(this._b[s]),this._o[s+1]=t=t.copy(),this._a[s]&&t.map(this._a[s].calc);return t}update(t,s){this._optimizer.learningRate=s;for(let i=this._w.length-1;i>=0;i--){if(this._a[i])for(let c=0;c<t.length;c++)t.value[c]*=this._a[i].grad(this._i[i+1].value[c],this._o[i+1].value[c]);const a=this._o[i].tDot(t);a.div(this._i[i].rows);const h=t.mean(0);t=t.dot(this._w[i].t),this._w[i].sub(this._optimizer_mng.delta(`w${i}`,a)),this._b[i].sub(this._optimizer_mng.delta(`b${i}`,h))}}toObject(){const t=[{type:"input"}];for(let s=0;s<this._layer_sizes.length-1;s++)t.push({type:"full",out_size:this._layer_sizes[s+1],activation:this._activations[s],w:this._w[s]?.toArray(),b:this._b[s]?.toArray()});return t}}export class MLPClassifier{static{m(this,"MLPClassifier")}constructor(t,s="tanh"){this._hidden_sizes=t,this._activations=Array(this._hidden_sizes.length).fill(s),this._model=null,this._classes=null,this._epoch=0}get categories(){return this._classes}get epoch(){return this._epoch}toObject(){return[...this._model.toObject(),{type:"softmax"},{type:"output"}]}fit(t,s,i,a=.001,h=0){if(!this._model){this._classes=[...new Set(s)];const r=[t[0].length,...this._hidden_sizes,this._classes.length];this._model=new u(r,this._activations)}const c=s.map(r=>{const p=Array(this._classes.length).fill(0);return p[this._classes.indexOf(r)]=1,p}),n=[],_=[];if(h>0)for(let r=0;r<t.length;r+=h)n.push(l.fromArray(t.slice(r,r+h))),_.push(l.fromArray(c.slice(r,r+h)));else n.push(l.fromArray(t)),_.push(l.fromArray(c));let o;for(let r=0;r<i;r++)for(let p=0;p<n.length;p++)o=this._fitonce(n[p],_[p],a);return this._epoch+=i,o.map(r=>r**2),o.mean()}_fitonce(t,s,i){const a=this._model.calc(t);a.sub(a.max(1)),a.map(Math.exp),a.div(a.sum(1));const h=l.sub(a,s);return this._model.update(h,i),h}probability(t){const s=this._model.calc(l.fromArray(t));return s.sub(s.max(1)),s.map(Math.exp),s.div(s.sum(1)),s.toArray()}predict(t){return this._model.calc(l.fromArray(t)).argmax(1).value.map(s=>this._classes[s])}}export class MLPRegressor{static{m(this,"MLPRegressor")}constructor(t,s="tanh"){this._hidden_sizes=t,this._activations=Array(t.length).fill(s),this._model=null,this._epoch=0}get epoch(){return this._epoch}toObject(){return[...this._model.toObject(),{type:"output"}]}fit(t,s,i,a=.001,h=0){if(!this._model){const o=[t[0].length,...this._hidden_sizes,s[0].length];this._model=new u(o,this._activations)}const c=[],n=[];if(h>0)for(let o=0;o<t.length;o+=h)c.push(l.fromArray(t.slice(o,o+h))),n.push(l.fromArray(s.slice(o,o+h)));else c.push(l.fromArray(t)),n.push(l.fromArray(s));let _;for(let o=0;o<i;o++)for(let r=0;r<c.length;r++)_=this._fitonce(c[r],n[r],a);return this._epoch+=i,_.map(o=>o**2),_.mean()}_fitonce(t,s,i){const a=this._model.calc(t),h=l.sub(a,s);return h.div(2),this._model.update(h,i),h}predict(t){return t=l.fromArray(t),this._model.calc(t).toArray()}}
