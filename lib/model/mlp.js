var a=Object.defineProperty;var r=(l,t)=>a(l,"name",{value:t,configurable:!0});import _ from"./neuralnetwork.js";export class MLPClassifier{static{r(this,"MLPClassifier")}constructor(t,s,i){this._layers=[{type:"input"}];for(let e=0;e<t.length;e++)this._layers.push({type:"full",out_size:t[e],activation:s});this._model=null,this._classes=null,this._optimizer=i,this._epoch=0}get epoch(){return this._epoch}fit(t,s,i,e,h){this._model||(this._classes=[...new Set(s)],this._layers.push({type:"full",out_size:this._classes.length}),this._model=_.fromObject(this._layers,"mse",this._optimizer));const o=s.map(u=>{const c=Array(this._classes.length).fill(0);return c[this._classes.indexOf(u)]=1,c}),p=this._model.fit(t,o,i,e,h);return this._epoch+=i,p[0]}predict(t){return this._model.calc(t).argmax(1).value.map(s=>this._classes[s])}}export class MLPRegressor{static{r(this,"MLPRegressor")}constructor(t,s,i){this._layers=[{type:"input"}];for(let e=0;e<t.length;e++)this._layers.push({type:"full",out_size:t[e],activation:s});this._model=null,this._optimizer=i,this._epoch=0}get epoch(){return this._epoch}fit(t,s,i,e,h){this._model||(this._layers.push({type:"full",out_size:s[0].length}),this._model=_.fromObject(this._layers,"mse",this._optimizer));const o=this._model.fit(t,s,i,e,h);return this._epoch+=i,o[0]}predict(t){return this._model.calc(t).toArray()}}
