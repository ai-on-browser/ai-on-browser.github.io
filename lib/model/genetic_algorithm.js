import{QTableBase}from"./q_learning.js";class GeneticPTable extends QTableBase{constructor(t,e=20){super(t,e),this._s=this._action_sizes.reduce(((t,e)=>t*e),1);for(let t=0;t<this._table.length;t+=this._s){const e=Math.floor(Math.random()*this._s);this._table[t+e]=1}}copy(t){const e=t||new GeneticPTable(this._env,this.resolution);for(let t=0;t<this._tensor.length;t++)e._table[t]=this._table[t];return e}mutation(t){for(let e=0;e<this._table.length;e+=this._s)if(Math.random()<t){for(let t=0;t<this._s;t++)this._table[e+t]=0;const t=Math.floor(Math.random()*this._s);this._table[e+t]=1}}mix(t,e){for(let s=0;s<this._table.length;s+=this._s)if(Math.random()<e)for(let e=0;e<this._s;e++)this._table[s+e]=t._table[s+e]}mixCopy(t,e,s){const i=this.copy(s);return i.mix(t,e),i}}class GeneticQTable extends QTableBase{constructor(t,e=20){super(t,e);for(let t=0;t<this._tensor.length;t++)this._tensor.value[t]=2*Math.random()-1}copy(t){const e=t||new GeneticQTable(this._env,this.resolution);for(let t=0;t<this._tensor.length;t++)e._table[t]=this._table[t];return e}mutation(t){for(let e=0;e<this._table.length;e++)Math.random()<t&&(this._table[e]=2*Math.random()-1)}mix(t,e){for(let s=0;s<this._table.length;s++)Math.random()<e&&(this._table[s]=t._table[s])}mixCopy(t,e,s){const i=this.copy(s);return i.mix(t,e),i}}class GeneticAlgorithmAgent{constructor(t,e=20,s=null){this._env=t,this._resolution=e,this._table=s||new GeneticPTable(t,e),this._total_reward=0,this._max_epoch=1e3}get total_reward(){return this._total_reward}reset(){this._total_reward=0}get_score(){return this._table.toArray()}get_action(t){return this._table.best_action(t)}run(t){let e=t.reset(this),s=0;for(;s++<this._max_epoch;){const s=this.get_action(e),[i,a,r]=t.step(s,this);if(e=i,this._total_reward+=a,r)break}}mutation(){this._table.mutation(.005)}mix(t){this._table.mix(t._table,.5)}mixCopy(t,e){return new GeneticAlgorithmAgent(this._env,this._resolution,this._table.mixCopy(t._table,.5,e._table))}}export default class GeneticAlgorithmGeneration{constructor(t,e=100,s=20){this._env=t,this._size=e,this._resolution=s,this._agents=[];for(let i=0;i<e;i++)this._agents.push(new GeneticAlgorithmAgent(t,s))}reset(){this._agents.forEach((t=>t.reset()))}get_score(){return this._agents[0].get_score()}top_agent(){return this._agents[0]}run(){this.reset(),this._agents.forEach(((t,e)=>{t.run(this._env)})),this._agents.sort(((t,e)=>e._total_reward-t._total_reward))}next(t=.001){const e=[];for(let t=0;t<this._size;t++)if(Math.random()<(this._size-2*t)/this._size)e.push(this._agents[t]);else{const s=Math.floor(Math.random()*t);let i=Math.floor(Math.random()*(t-1));i>=s&&i++,e[t]=this._agents[s].mixCopy(this._agents[i],this._agents[t])}for(let s=0;s<e.length;s++)Math.random()<t&&e[s].mutation();this._agents=e}}