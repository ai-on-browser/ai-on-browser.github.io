var n=Object.defineProperty;var r=(a,s)=>n(a,"name",{value:s,configurable:!0});export default class d{static{r(this,"NearestCentroid")}constructor(s="euclid"){switch(this._c=[],this._metric=s,this._metric){case"euclid":this._d=(c,t)=>Math.sqrt(c.reduce((i,e,h)=>i+(e-t[h])**2,0));break;case"manhattan":this._d=(c,t)=>c.reduce((i,e,h)=>i+Math.abs(e-t[h]),0);break;case"chebyshev":this._d=(c,t)=>Math.max(...c.map((i,e)=>Math.abs(i-t[e])));break;case"minkowski":this._dp=2,this._d=(c,t)=>Math.pow(c.reduce((i,e,h)=>i+(e-t[h])**this._dp,0),1/this._dp);break}}add(s,c){for(let t=0;t<this._c.length;t++)if(this._c[t].category===c){const i=++this._c[t].n;for(let e=0;e<this._c[t].point.length;e++)this._c[t].point[e]+=s[e],this._c[t].center[e]=this._c[t].point[e]/i;return}this._c.push({n:1,category:c,point:s.concat(),center:s.concat()})}fit(s,c){s.forEach((t,i)=>this.add(t,c[i]))}predict(s){return s.map(c=>{let t=1/0,i=null;return this._c.forEach(e=>{const h=this._d(e.center,c);h<t&&(t=h,i=e.category)}),i})}}
