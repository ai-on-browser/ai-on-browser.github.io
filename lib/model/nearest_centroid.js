export default class NearestCentroid{constructor(t="euclid"){switch(this._c=[],this._metric=t,this._metric){case"euclid":this._d=(t,e)=>Math.sqrt(t.reduce(((t,c,s)=>t+(c-e[s])**2),0));break;case"manhattan":this._d=(t,e)=>t.reduce(((t,c,s)=>t+Math.abs(c-e[s])),0);break;case"chebyshev":this._d=(t,e)=>Math.max(...t.map(((t,c)=>Math.abs(t-e[c]))));break;case"minkowski":this._dp=2,this._d=(t,e)=>Math.pow(t.reduce(((t,c,s)=>t+(c-e[s])**this._dp),0),1/this._dp)}}add(t,e){for(let c=0;c<this._c.length;c++)if(this._c[c].category===e){const e=++this._c[c].n;for(let s=0;s<this._c[c].point.length;s++)this._c[c].point[s]+=t[s],this._c[c].center[s]=this._c[c].point[s]/e;return}this._c.push({n:1,category:e,point:t.concat(),center:t.concat()})}fit(t,e){t.forEach(((t,c)=>this.add(t,e[c])))}predict(t){return t.map((t=>{let e=1/0,c=null;return this._c.forEach((s=>{const i=this._d(s.center,t);i<e&&(e=i,c=s.category)})),c}))}}