var n=Object.defineProperty;var r=(a,s)=>n(a,"name",{value:s,configurable:!0});export default class _{static{r(this,"NearestCentroid")}constructor(s="euclid"){if(this._c=[],this._metric=s,typeof this._metric=="function")this._d=this._metric;else switch(this._metric){case"euclid":this._d=(i,t)=>Math.sqrt(i.reduce((c,e,h)=>c+(e-t[h])**2,0));break;case"manhattan":this._d=(i,t)=>i.reduce((c,e,h)=>c+Math.abs(e-t[h]),0);break;case"chebyshev":this._d=(i,t)=>Math.max(...i.map((c,e)=>Math.abs(c-t[e])));break;case"minkowski":this._dp=2,this._d=(i,t)=>Math.pow(i.reduce((c,e,h)=>c+(e-t[h])**this._dp,0),1/this._dp);break}}add(s,i){for(let t=0;t<this._c.length;t++)if(this._c[t].category===i){const c=++this._c[t].n;for(let e=0;e<this._c[t].point.length;e++)this._c[t].point[e]+=s[e],this._c[t].center[e]=this._c[t].point[e]/c;return}this._c.push({n:1,category:i,point:s.concat(),center:s.concat()})}fit(s,i){s.forEach((t,c)=>this.add(t,i[c]))}predict(s){return s.map(i=>{let t=1/0,c=null;return this._c.forEach(e=>{const h=this._d(e.center,i);h<t&&(t=h,c=e.category)}),c})}}
