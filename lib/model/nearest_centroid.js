var a=Object.defineProperty;var n=(s,e)=>a(s,"name",{value:e,configurable:!0});const o={euclid:n(()=>(s,e)=>Math.sqrt(s.reduce((i,t,c)=>i+(t-e[c])**2,0)),"euclid"),manhattan:n(()=>(s,e)=>s.reduce((i,t,c)=>i+Math.abs(t-e[c]),0),"manhattan"),chebyshev:n(()=>(s,e)=>Math.max(...s.map((i,t)=>Math.abs(i-e[t]))),"chebyshev"),minkowski:n(({p:s=2}={})=>(e,i)=>Math.pow(e.reduce((t,c,h)=>t+(c-i[h])**s,0),1/s),"minkowski")};export default class _{static{n(this,"NearestCentroid")}constructor(e="euclid"){this._c=[],this._metric=e,typeof this._metric=="function"?this._d=this._metric:this._d=o[this._metric]()}add(e,i){for(let t=0;t<this._c.length;t++)if(this._c[t].category===i){const c=++this._c[t].n;for(let h=0;h<this._c[t].point.length;h++)this._c[t].point[h]+=e[h],this._c[t].center[h]=this._c[t].point[h]/c;return}this._c.push({n:1,category:i,point:e.concat(),center:e.concat()})}fit(e,i){e.forEach((t,c)=>this.add(t,i[c]))}predict(e){return e.map(i=>{let t=1/0,c=null;return this._c.forEach(h=>{const r=this._d(h.center,i);r<t&&(t=r,c=h.category)}),c})}}
