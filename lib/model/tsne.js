import Matrix from"../util/matrix.js";const normal_random=function(t=0,r=1){const e=Math.sqrt(r),l=Math.random(),o=Math.random();return[Math.sqrt(-2*Math.log(l))*Math.cos(2*Math.PI*o)*e+t,Math.sqrt(-2*Math.log(l))*Math.sin(2*Math.PI*o)*e+t]};export class SNE{constructor(t,r=1,e=30){this._x=t,this._epoch=0,this._rd=r,this._learning_rate=.1,this._perplexity=e,this._y=[];for(let e=0;e<t.length;e++){this._y[e]=[];for(let t=0;t<r;t++)this._y[e][t]=normal_random(0,1e-4)[0]}}_pj_i(t){const r=t.length,e=[],l=[];let o=1;for(let e=0;e<r;e++){l[e]=[],l[e][e]=0;for(let r=0;r<e;r++)l[e][r]=l[r][e]=t[e].reduce(((e,l,o)=>e+(l-t[r][o])**2),0),l[e][r]>o&&(o=l[e][r])}for(let t=0;t<r;t++){let i=o,s=0,n=null;const h=1e-8;let a=Array(r).fill(0);for(;;){let e=0;const o=2*i**2;a[t]=0;for(let i=0;i<r;i++)t!==i&&(e+=a[i]=Math.exp(-l[t][i]/o));let f=0;for(let t=0;t<r;t++)a[t]/=e,a[t]>h&&(f-=a[t]*Math.log2(a[t]));if(!isFinite(i))break;const _=2**f;if(Math.abs(_-this._perplexity)<h)break;_<this._perplexity?(s=i,i=null===n?2*i:(i+n)/2):(n=i,i=(i+s)/2)}e.push(a)}return e}fit(){const t=this._x,r=this._y,e=t.length,l=this._pj_i(t),o=[];for(let t=0;t<e;t++){let l=0;o[t]=Array(e).fill(0);for(let i=0;i<e;i++){if(t===i)continue;const e=Math.exp(-r[t].reduce(((t,e,l)=>t+(e-r[i][l])**2),0));o[t][i]=e,l+=e}l>0&&(o[t]=o[t].map((t=>t/l)))}const i=this._rd,s=[];for(let t=0;t<e;t++){s[t]=Array(i).fill(0);for(let n=0;n<e;n++){if(n===t)continue;const e=l[t][n]-o[t][n]+l[n][t]-o[n][t];for(let l=0;l<i;l++)s[t][l]+=e*(r[t][l]-r[n][l])}}for(let t=0;t<e;t++)for(let e=0;e<i;e++)r[t][e]-=2*s[t][e]*this._learning_rate;return this._epoch+=1,new Matrix(e,i,this._y).toArray()}predict(){return Matrix.fromArray(this._y).toArray()}}export class tSNE{constructor(t,r=1,e=30){this._x=t,this._epoch=0,this._rd=r,this._learning_rate=200,this._perplexity=e,this._y=[];for(let e=0;e<t.length;e++){this._y[e]=[];for(let t=0;t<r;t++)this._y[e][t]=normal_random(0,1e-4)[0]}}_pj_i(t){const r=t.length,e=[],l=[];let o=1;for(let e=0;e<r;e++){l[e]=[],l[e][e]=0;for(let r=0;r<e;r++)l[e][r]=l[r][e]=t[e].reduce(((e,l,o)=>e+(l-t[r][o])**2),0),l[e][r]>o&&(o=l[e][r])}for(let t=0;t<r;t++){let i=o,s=0,n=null;const h=1e-8;let a=Array(r).fill(0);for(;;){let e=0;const o=2*i**2;a[t]=0;for(let i=0;i<r;i++)t!==i&&(e+=a[i]=Math.exp(-l[t][i]/o));let f=0;for(let t=0;t<r;t++)a[t]/=e,a[t]>h&&(f-=a[t]*Math.log2(a[t]));if(!isFinite(i))break;const _=2**f;if(Math.abs(_-this._perplexity)<h)break;_<this._perplexity?(s=i,i=null===n?2*i:(i+n)/2):(n=i,i=(i+s)/2)}e.push(a)}return e}fit(){const t=this._x,r=this._y,e=t.length,l=this._pj_i(t),o=[];for(let t=0;t<e;t++){o[t]=[];for(let r=0;r<=t;r++)o[t][r]=o[r][t]=(l[t][r]+l[r][t])/(2*e)}const i=[];let s=0;for(let t=0;t<e;t++){i[t]=[];for(let e=0;e<=t;e++){const l=1/(1+r[t].reduce(((t,l,o)=>t+(l-r[e][o])**2),0));i[t][e]=i[e][t]=l,t!==e&&(s+=2*l)}}const n=i.map((t=>t.map((t=>t/s)))),h=this._rd,a=[];for(let t=0;t<e;t++){a[t]=Array(h).fill(0);for(let l=0;l<e;l++){if(l===t)continue;const e=(o[t][l]-n[t][l])*i[t][l];for(let o=0;o<h;o++)a[t][o]+=e*(r[t][o]-r[l][o])}}for(let t=0;t<e;t++)for(let e=0;e<h;e++)r[t][e]-=4*a[t][e]*this._learning_rate;return this._epoch+=1,new Matrix(e,h,this._y).toArray()}predict(){return Matrix.fromArray(this._y).toArray()}}