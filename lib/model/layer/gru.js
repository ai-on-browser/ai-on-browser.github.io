import Layer from"./base.js";import{Matrix,Tensor}from"../../util/math.js";export default class GRULayer extends Layer{constructor({size:t,return_sequences:s=!1,...i}){super(i),this._size=t,this._w_z=null,this._w_r=null,this._w_h=null,this._u_z=Matrix.randn(this._size,this._size),this._u_r=Matrix.randn(this._size,this._size),this._u_h=Matrix.randn(this._size,this._size),this._b_z=Matrix.zeros(1,this._size),this._b_r=Matrix.zeros(1,this._size),this._b_h=Matrix.zeros(1,this._size),this._s0=Matrix.zeros(1,this._size),this._return_sequences=s}_sigmoid(t){return t.copyMap((t=>1/(1+Math.exp(-t))))}_grad_sigmoid(t){return t.copyMap((t=>t*(1-t)))}_tanh(t){return t.copyMap(Math.tanh)}_grad_tanh(t){return t.copyMap((t=>1-t**2))}calc(t){t=t.transpose(1,0,2),this._x=[];for(let s=0;s<t.sizes[0];s++)this._x[s]=t.at(s).toMatrix();this._w_z||(this._w_z=Matrix.randn(this._x[0].cols,this._size),this._w_r=Matrix.randn(this._x[0].cols,this._size),this._w_h=Matrix.randn(this._x[0].cols,this._size)),this._h=[],this._s=[],this._z=[],this._r=[];for(let t=0;t<this._x.length;t++){const s=0===t?this._s0:this._s[t-1],i=this._x[t].dot(this._w_z);i.add(s.dot(this._u_z)),i.add(this._b_h);const _=this._sigmoid(i);this._z[t]=_;const h=this._x[t].dot(this._w_r);h.add(s.dot(this._u_r)),h.add(this._b_r);const r=this._sigmoid(h);this._r[t]=r;const d=this._x[t].dot(this._w_h);d.add(r.copyMult(s).dot(this._u_h)),d.add(this._b_h);const o=this._tanh(d);this._h[t]=o,this._s[t]=_.copyIsub(1),this._s[t].mult(o),this._s[t].add(_.copyMult(s))}if(this._return_sequences){return Tensor.fromArray(this._s.map((t=>t.toArray()))).transpose(1,0,2)}return this._s[this._s.length-1]}grad(t){return this._grad_bptt(t)}_grad_bptt(t){const s=this._s.length;if(this._bo=Array(s),this._return_sequences){t=t.transpose(1,0,2);for(let i=0;i<s;i++)this._bo[i]=t.at(i).toMatrix()}else this._bo[s-1]=t;this._dy=[],this._dr=[],this._dz=[],this._dh=[];const i=[];for(let t=s-1;t>=0;t--){const _=0===t?this._s0:this._s[t-1];this._dy[t]=this._bo[t]||Matrix.zeros(1,1),t<s-1&&(this._dy[t].add(this._dz[t+1].dot(this._u_z.t)),this._dy[t].add(this._dr[t+1].dot(this._u_r.t)),this._dy[t].add(this._dh[t+1].dot(this._u_h.t).copyMult(this._r[t+1])),this._dy[t].add(this._z[t+1].copyMult(this._dy[t+1]))),this._dz[t]=_.copyMult(this._dy[t]),this._dz[t].sub(this._h[t].copyMult(this._dy[t])),this._dz[t].mult(this._grad_sigmoid(this._z[t])),this._dh[t]=this._z[t].copyIsub(1),this._dh[t].mult(this._dy[t]),this._dh[t].mult(this._grad_tanh(this._h[t])),this._dr[t]=this._dh[t].dot(this._u_h.t),this._dr[t].mult(_),this._dr[t].mult(this._grad_sigmoid(this._r[t])),i[t]=this._dh[t].dot(this._w_h.t),i[t].add(this._dz[t].dot(this._w_z.t)),i[t].add(this._dr[t].dot(this._w_r.t))}return Tensor.fromArray(i.map((t=>t.toArray()))).transpose(1,0,2)}update(){this._update_bptt()}_update_bptt(){const t=this._s.length,s=this._x[0].rows,i=Matrix.zeros(...this._w_r.sizes),_=Matrix.zeros(...this._w_z.sizes),h=Matrix.zeros(...this._w_h.sizes),r=Matrix.zeros(1,this._size),d=Matrix.zeros(1,this._size),o=Matrix.zeros(1,this._size);for(let e=0;e<t;e++){const t=this._x[e].tDot(this._dr[e]);t.div(s),i.add(t);const a=this._x[e].tDot(this._dz[e]);a.div(s),_.add(a);const z=this._x[e].tDot(this._dh[e]);z.div(s),h.add(z),r.add(this._dr[e].mean(0)),d.add(this._dz[e].mean(0)),o.add(this._dh[e].mean(0))}this._w_r.sub(this._opt.delta("w_r",i)),this._w_z.sub(this._opt.delta("w_z",_)),this._w_h.sub(this._opt.delta("w_h",h)),this._b_r.sub(this._opt.delta("b_r",r)),this._b_z.sub(this._opt.delta("b_z",d)),this._b_h.sub(this._opt.delta("b_h",o));const e=Matrix.zeros(this._size,this._size),a=Matrix.zeros(this._size,this._size),z=Matrix.zeros(this._size,this._size);for(let i=0;i<t-1;i++){const t=this._s[i].tDot(this._dr[i+1]);t.div(s),e.add(t);const _=this._s[i].tDot(this._dz[i+1]);_.div(s),a.add(_);const h=this._s[i].tDot(this._dh[i+1]);h.div(s),z.add(h)}this._u_r.sub(this._opt.delta("u_r",e)),this._u_z.sub(this._opt.delta("u_z",a)),this._u_h.sub(this._opt.delta("u_h",z))}}