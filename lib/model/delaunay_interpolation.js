class Point{constructor(n,t){this._p=n,this.value=t}get x(){return this._p[0]}get y(){return this._p[1]}}class Triangle{constructor(n,t,i){this.p=[n,t,i],this.adjoin=[null,null,null]}get p(){return this._p}set p(n){const[t,i,e]=this._p=n,s=2*((i.x-t.x)*(e.y-t.y)-(i.y-t.y)*(e.x-t.x)),o=i.x**2-t.x**2+i.y**2-t.y**2,l=e.x**2-t.x**2+e.y**2-t.y**2,a=((e.y-t.y)*o+(t.y-i.y)*l)/s,h=((t.x-e.x)*o+(i.x-t.x)*l)/s;this._c=[a,h],this._r2=(a-t.x)**2+(h-t.y)**2,this._h=[(i.y-t.y)*(e.value-t.value)-(i.value-t.value)*(e.y-t.y),(i.value-t.value)*(e.x-t.x)-(i.x-t.x)*(e.value-t.value),(i.x-t.x)*(e.y-t.y)-(i.y-t.y)*(e.x-t.x)],this._h[3]=-(this._h[0]*t.x+this._h[1]*t.y+this._h[2]*t.value)}contains(n){const t=(n,t,i)=>(n.x-i.x)*(t.y-i.y)-(t.x-i.x)*(n.y-i.y),i=(t(n,this.p[0],this.p[1]),t(n,this.p[1],this.p[2]),t(n,this.p[2],this.p[0]),[]);for(let e=0;e<3;e++){const s=t(n,this.p[e],this.p[(e+1)%3]);if(0!==s){if(i.length>0&&i[i.length-1]!==s<0)return!1;i.push(s<0)}}return!0}contains_circle(n){return(n.x-this._c[0])**2+(n.y-this._c[1])**2<this._r2}value(n){return-(this._h[0]*n.x+this._h[1]*n.y+this._h[3])/this._h[2]}}export default class DelaunayInterpolation{fit(n,t){const i=n.length,e=[1/0,1/0],s=[-1/0,-1/0];for(let t=0;t<i;t++)for(let i=0;i<2;i++)e[i]=Math.min(e[i],n[t][i]),s[i]=Math.max(s[i],n[t][i]);for(let n=0;n<2;n++)e[n]-=1,s[n]+=1;const o=[new Point([e[0]-(s[1]-e[1]),e[1]],null),new Point([s[0]+(s[1]-e[1]),e[1]],null),new Point([(e[0]+s[0])/2,s[1]+(s[0]-e[0])/2],null)],l=[new Triangle(...o)];for(let e=0;e<i;e++){const i=new Point(n[e],t[e]);let s=0;for(;s<l.length&&!l[s].contains(i);s++);const o=l.splice(s,1)[0],a=new Triangle(i,o.p[1],o.p[2]),h=new Triangle(i,o.p[2],o.p[0]),r=new Triangle(i,o.p[0],o.p[1]);a.adjoin=[o.adjoin[0],h,r],h.adjoin=[o.adjoin[1],r,a],r.adjoin=[o.adjoin[2],a,h];const p=[a,h,r];for(let n=0;n<o.adjoin.length;n++){if(!o.adjoin[n])continue;const t=o.adjoin[n].adjoin.indexOf(o);o.adjoin[n].adjoin[t]=p[n]}l.push(...p);const c=p.map((n=>[n,0]));for(;c.length>0;){const[n,t]=c.pop(),i=n.adjoin[t];if(!i)continue;const e=i.adjoin.indexOf(n);if(!n.contains_circle(i.p[e]))continue;const s=(t+1)%3,o=(t+2)%3;let l=(e+1)%3,a=(e+2)%3;i.p[l].x===n.p[s].x&&i.p[l].y===n.p[s].y||([l,a]=[a,l]);const h=n.p,r=n.adjoin,p=i.adjoin;n.p=[n.p[t],n.p[s],i.p[e]],n.adjoin=[p[a],i,r[o]],p[a]&&(p[a].adjoin[p[a].adjoin.indexOf(i)]=n),i.p=[h[t],h[o],i.p[e]],i.adjoin=[p[l],n,r[s]],r[s]&&(r[s].adjoin[r[s].adjoin.indexOf(n)]=i),c.push([n,0]),c.push([i,0])}}for(let n=l.length-1;n>=0;n--)l[n].p.some((n=>o.some((t=>n.x===t.x&&n.y===t.y))))&&l.splice(n,1);this._triangles=l}predict(n){const t=Array(n.length).fill(null);for(let i=0;i<n.length;i++){const e=new Point(n[i],null);for(let n=0;n<this._triangles.length;n++)if(this._triangles[n].contains(e)){t[i]=this._triangles[n].value(e);break}}return t}}