class Point{constructor(t,n=null){this._p=t,this.value=n}get x(){return this._p[0]}get y(){return this._p[1]}}class Circle{constructor(t,n){this._c=t,this._r=n}contains(t){return(t.x-this._c.x)**2+(t.y-this._c.y)**2<this._r**2}}class Triangle{constructor(t,n,i){this.p=[t,n,i],this.adjoin=[null,null,null],this._circumcircle=null}get p(){return this._p}set p(t){const[n,i,e]=this._p=t;this._circumcircle=null,this._h=[(i.y-n.y)*(e.value-n.value)-(i.value-n.value)*(e.y-n.y),(i.value-n.value)*(e.x-n.x)-(i.x-n.x)*(e.value-n.value),(i.x-n.x)*(e.y-n.y)-(i.y-n.y)*(e.x-n.x)],this._h[3]=-(this._h[0]*n.x+this._h[1]*n.y+this._h[2]*n.value)}get circumcircle(){if(this._circumcircle)return this._circumcircle;const[t,n,i]=this.p,e=2*((n.x-t.x)*(i.y-t.y)-(n.y-t.y)*(i.x-t.x))+1e-12,s=n.x**2-t.x**2+n.y**2-t.y**2,c=i.x**2-t.x**2+i.y**2-t.y**2,o=((i.y-t.y)*s+(t.y-n.y)*c)/e,l=((t.x-i.x)*s+(n.x-t.x)*c)/e;return this._circumcircle=new Circle(new Point([o,l]),Math.sqrt((o-t.x)**2+(l-t.y)**2)),this._circumcircle}contains(t){const n=[];for(let c=0;c<3;c++){const o=(i=t,e=this.p[c],s=this.p[(c+1)%3],(i.x-s.x)*(e.y-s.y)-(e.x-s.x)*(i.y-s.y));if(0!==o){if(n.length>0&&n[n.length-1]!==o<0)return!1;n.push(o<0)}}var i,e,s;return!0}contains_circle(t){return this.circumcircle.contains(t)}value(t){return-(this._h[0]*t.x+this._h[1]*t.y+this._h[3])/this._h[2]}}export default class DelaunayInterpolation{fit(t,n){const i=t.length,e=[1/0,1/0],s=[-1/0,-1/0];for(let n=0;n<i;n++)for(let i=0;i<2;i++)e[i]=Math.min(e[i],t[n][i]),s[i]=Math.max(s[i],t[n][i]);for(let t=0;t<2;t++)e[t]-=1,s[t]+=1;const c=[new Point([e[0]-(s[1]-e[1]),e[1]]),new Point([s[0]+(s[1]-e[1]),e[1]]),new Point([(e[0]+s[0])/2,s[1]+(s[0]-e[0])/2])],o=[new Triangle(...c)];for(let e=0;e<i;e++){const i=new Point(t[e],n[e]);let s=0;for(;s<o.length&&!o[s].contains(i);s++);const c=o.splice(s,1)[0],l=new Triangle(i,c.p[1],c.p[2]),r=new Triangle(i,c.p[2],c.p[0]),a=new Triangle(i,c.p[0],c.p[1]);l.adjoin=[c.adjoin[0],r,a],r.adjoin=[c.adjoin[1],a,l],a.adjoin=[c.adjoin[2],l,r];const h=[l,r,a];for(let t=0;t<c.adjoin.length;t++){if(!c.adjoin[t])continue;const n=c.adjoin[t].adjoin.indexOf(c);c.adjoin[t].adjoin[n]=h[t]}o.push(...h);const u=h.map((t=>[t,0]));for(;u.length>0;){const[t,n]=u.pop(),i=t.adjoin[n];if(!i)continue;const e=i.adjoin.indexOf(t);if(!t.contains_circle(i.p[e]))continue;const s=(n+1)%3,c=(n+2)%3;let o=(e+1)%3,l=(e+2)%3;i.p[o].x===t.p[s].x&&i.p[o].y===t.p[s].y||([o,l]=[l,o]);const r=t.p,a=t.adjoin,h=i.adjoin;t.p=[t.p[n],t.p[s],i.p[e]],t.adjoin=[h[l],i,a[c]],h[l]&&(h[l].adjoin[h[l].adjoin.indexOf(i)]=t),i.p=[r[n],r[c],i.p[e]],i.adjoin=[h[o],t,a[s]],a[s]&&(a[s].adjoin[a[s].adjoin.indexOf(t)]=i),u.push([t,0]),u.push([i,0])}}for(let t=o.length-1;t>=0;t--)o[t].p.some((t=>c.some((n=>t.x===n.x&&t.y===n.y))))&&o.splice(t,1);this._triangles=o}predict(t){const n=Array(t.length).fill(null);for(let i=0;i<t.length;i++){const e=new Point(t[i]);for(let t=0;t<this._triangles.length;t++)if(this._triangles[t].contains(e)){n[i]=this._triangles[t].value(e);break}}return n}}