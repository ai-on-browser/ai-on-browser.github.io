var C=Object.defineProperty;var _=(j,t)=>C(j,"name",{value:t,configurable:!0});class d{static{_(this,"Point")}constructor(t,n=null){this._p=t,this.value=n}get x(){return this._p[0]}get y(){return this._p[1]}}class D{static{_(this,"Circle")}constructor(t,n){this._c=t,this._r=n}contains(t){return(t.x-this._c.x)**2+(t.y-this._c.y)**2<this._r**2}}class b{static{_(this,"Triangle")}constructor(t,n,c){this.p=[t,n,c],this.adjoin=[null,null,null],this._circumcircle=null}get p(){return this._p}set p(t){this._p=t;const[n,c,i]=t;this._circumcircle=null,this._h=[(c.y-n.y)*(i.value-n.value)-(c.value-n.value)*(i.y-n.y),(c.value-n.value)*(i.x-n.x)-(c.x-n.x)*(i.value-n.value),(c.x-n.x)*(i.y-n.y)-(c.y-n.y)*(i.x-n.x)],this._h[3]=-(this._h[0]*n.x+this._h[1]*n.y+this._h[2]*n.value)}get circumcircle(){if(this._circumcircle)return this._circumcircle;const[t,n,c]=this.p,i=2*((n.x-t.x)*(c.y-t.y)-(n.y-t.y)*(c.x-t.x))+1e-12,e=n.x**2-t.x**2+n.y**2-t.y**2,u=c.x**2-t.x**2+c.y**2-t.y**2,h=((c.y-t.y)*e+(t.y-n.y)*u)/i,o=((t.x-c.x)*e+(n.x-t.x)*u)/i;return this._circumcircle=new D(new d([h,o]),Math.sqrt((h-t.x)**2+(o-t.y)**2)),this._circumcircle}contains(t){const n=_((i,e,u)=>(i.x-u.x)*(e.y-u.y)-(e.x-u.x)*(i.y-u.y),"outer"),c=[];for(let i=0;i<3;i++){const e=n(t,this.p[i],this.p[(i+1)%3]);if(e!==0){if(c.length>0&&c[c.length-1]!==e<0)return!1;c.push(e<0)}}return!0}contains_circle(t){return this.circumcircle.contains(t)}value(t){return-(this._h[0]*t.x+this._h[1]*t.y+this._h[3])/this._h[2]}}export default class F{static{_(this,"DelaunayInterpolation")}fit(t,n){const c=t.length,i=[1/0,1/0],e=[-1/0,-1/0];for(let o=0;o<c;o++)for(let l=0;l<2;l++)i[l]=Math.min(i[l],t[o][l]),e[l]=Math.max(e[l],t[o][l]);for(let o=0;o<2;o++)i[o]-=1,e[o]+=1;const u=[new d([i[0]-(e[1]-i[1]),i[1]]),new d([e[0]+(e[1]-i[1]),i[1]]),new d([(i[0]+e[0])/2,e[1]+(e[0]-i[0])/2])],h=[new b(...u)];for(let o=0;o<c;o++){const l=new d(t[o],n[o]);let p=0;for(;p<h.length&&!h[p].contains(l);p++);const r=h.splice(p,1)[0],k=new b(l,r.p[1],r.p[2]),I=new b(l,r.p[2],r.p[0]),O=new b(l,r.p[0],r.p[1]);k.adjoin=[r.adjoin[0],I,O],I.adjoin=[r.adjoin[1],O,k],O.adjoin=[r.adjoin[2],k,I];const P=[k,I,O];for(let s=0;s<r.adjoin.length;s++){if(!r.adjoin[s])continue;const y=r.adjoin[s].adjoin.indexOf(r);r.adjoin[s].adjoin[y]=P[s]}h.push(...P);const M=P.map(s=>[s,0]);for(;M.length>0;){const[s,y]=M.pop(),a=s.adjoin[y];if(!a)continue;const g=a.adjoin.indexOf(s);if(!s.contains_circle(a.p[g]))continue;const x=(y+1)%3,q=(y+2)%3;let m=(g+1)%3,f=(g+2)%3;(a.p[m].x!==s.p[x].x||a.p[m].y!==s.p[x].y)&&([m,f]=[f,m]);const A=s.p,v=s.adjoin,w=a.adjoin;s.p=[s.p[y],s.p[x],a.p[g]],s.adjoin=[w[f],a,v[q]],w[f]&&(w[f].adjoin[w[f].adjoin.indexOf(a)]=s),a.p=[A[y],A[q],a.p[g]],a.adjoin=[w[m],s,v[x]],v[x]&&(v[x].adjoin[v[x].adjoin.indexOf(s)]=a),M.push([s,0]),M.push([a,0])}}for(let o=h.length-1;o>=0;o--)h[o].p.some(l=>u.some(p=>l.x===p.x&&l.y===p.y))&&h.splice(o,1);this._triangles=h}predict(t){const n=Array(t.length).fill(null);for(let c=0;c<t.length;c++){const i=new d(t[c]);for(let e=0;e<this._triangles.length;e++)if(this._triangles[e].contains(i)){n[c]=this._triangles[e].value(i);break}}return n}}
