import Matrix from"../util/matrix.js";export default class CURE{constructor(t){this._c=t,this._a=.2,this._root=null}_distance(t,e){return Math.sqrt(t.reduce(((t,n,r)=>t+(n-e[r])**2),0))}_leafs(t){let e=[t];for(;e.some((t=>t.children));){const t=[];for(let n=0;n<e.length;n++)e[n].children?t.push(...e[n].children):t.push(e[n]);e=t}return e}fit(t){const e=[],n=[];for(t.forEach(((r,s)=>{e.push({point:r,index:s,repr:[r],distance:0}),n[s]=t.map((t=>this._distance(r,t)))}));e.length>1;){let t=0,r=1,s=1/0;const l=e.length;for(let e=0;e<l;e++)for(let i=e+1;i<l;i++)n[e][i]<s&&(t=e,r=i,s=n[e][i]);const i=[...this._leafs(e[t]).map((t=>t.point)),...this._leafs(e[r]).map((t=>t.point))],o=[];let c=Math.floor(Math.random()*i.length);for(let t=0;t<Math.min(i.length,this._c);t++){let t=0,e=-1;for(let n=0;n<i.length;n++){if(o.indexOf(n)>=0)continue;const r=this._distance(i[n],i[c]);r>t&&(t=r,e=n)}o.push(e),c=e}const h=[],a=Matrix.fromArray(i).mean(0).value;for(let t=0;t<o.length;t++){h[t]=i[o[t]].concat();for(let e=0;e<a.length;e++)h[t][e]=this._a*a[e]+(1-this._a)*h[t][e]}for(let s=0;s<l;s++){if(s===t||s===r){n[t][s]=0;continue}let l=1/0;const i=e[s];for(let t=0;t<i.repr.length;t++)for(let e=0;e<h.length;e++){const n=this._distance(i.repr[t],h[e]);n<l&&(l=n)}n[s][t]=n[t][s]=l,n[s].splice(r,1)}n[t].splice(r,1),n.splice(r,1),e[t]={repr:h,distance:s,children:[e[t],e[r]]},e.splice(r,1)}this._root=e[0]}getClusters(t){const e=[this._root];for(;e.length<t;){let t=0,n=-1;for(let r=0;r<e.length;r++){const s=e[r];s.children&&s.distance>t&&(n=r,t=s.distance)}if(-1===n)break;const r=e[n];e.splice(n,1,r.children[0],r.children[1])}return e}predict(t){const e=[],n=this.getClusters(t);for(let t=0;t<n.length;t++){const r=this._leafs(n[t]);for(let n=0;n<r.length;n++)e[r[n].index]=t}return e}}