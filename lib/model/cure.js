import{Tree,Matrix}from"../util/math.js";export default class CURE{constructor(t){this._c=t,this._a=.2,this._root=null}_distance(t,e){return Math.sqrt(t.reduce(((t,n,l)=>t+(n-e[l])**2),0))}fit(t){const e=[],n=[];for(t.forEach(((l,r)=>{e.push(new Tree({point:l,index:r,repr:[l],distance:0})),n[r]=t.map((t=>this._distance(l,t)))}));e.length>1;){let t=0,l=1,r=1/0;const s=e.length;for(let e=0;e<s;e++)for(let o=e+1;o<s;o++)n[e][o]<r&&(t=e,l=o,r=n[e][o]);const o=[...e[t].leafValues().map((t=>t.point)),...e[l].leafValues().map((t=>t.point))],i=[];let a=Math.floor(Math.random()*o.length);for(let t=0;t<Math.min(o.length,this._c);t++){let t=0,e=-1;for(let n=0;n<o.length;n++){if(i.indexOf(n)>=0)continue;const l=this._distance(o[n],o[a]);l>t&&(t=l,e=n)}i.push(e),a=e}const c=[],h=Matrix.fromArray(o).mean(0).value;for(let t=0;t<i.length;t++){c[t]=o[i[t]].concat();for(let e=0;e<h.length;e++)c[t][e]=this._a*h[e]+(1-this._a)*c[t][e]}for(let r=0;r<s;r++){if(r===t||r===l){n[t][r]=0;continue}let s=1/0;const o=e[r].value;for(let t=0;t<o.repr.length;t++)for(let e=0;e<c.length;e++){const n=this._distance(o.repr[t],c[e]);n<s&&(s=n)}n[r][t]=n[t][r]=s,n[r].splice(l,1)}n[t].splice(l,1),n.splice(l,1),e[t]=new Tree({repr:c,distance:r},[e[t],e[l]]),e.splice(l,1)}this._root=e[0]}getClusters(t){const e=[this._root];for(;e.length<t;){let t=0,n=-1;for(let l=0;l<e.length;l++){const r=e[l];!r.isLeaf()&&r.value.distance>t&&(n=l,t=r.value.distance)}if(-1===n)break;const l=e[n];e.splice(n,1,l.at(0),l.at(1))}return e}predict(t){const e=[],n=this.getClusters(t);for(let t=0;t<n.length;t++){const l=n[t].leafValues();for(let n=0;n<l.length;n++)e[l[n].index]=t}return e}}