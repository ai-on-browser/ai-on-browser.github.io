import Tree from"../util/tree.js";import Matrix from"../util/matrix.js";export default class CURE{constructor(t){this._c=t,this._a=.2,this._root=null}_distance(t,e){return Math.sqrt(t.reduce(((t,r,l)=>t+(r-e[l])**2),0))}fit(t){const e=[],r=[];for(t.forEach(((l,n)=>{e.push(new Tree({point:l,index:n,repr:[l],distance:0})),r[n]=t.map((t=>this._distance(l,t)))}));e.length>1;){let t=0,l=1,n=1/0;const s=e.length;for(let e=0;e<s;e++)for(let o=e+1;o<s;o++)r[e][o]<n&&(t=e,l=o,n=r[e][o]);const o=[...e[t].leafValues().map((t=>t.point)),...e[l].leafValues().map((t=>t.point))],i=[];let a=Math.floor(Math.random()*o.length);for(let t=0;t<Math.min(o.length,this._c);t++){let t=0,e=-1;for(let r=0;r<o.length;r++){if(i.indexOf(r)>=0)continue;const l=this._distance(o[r],o[a]);l>t&&(t=l,e=r)}i.push(e),a=e}const c=[],h=Matrix.fromArray(o).mean(0).value;for(let t=0;t<i.length;t++){c[t]=o[i[t]].concat();for(let e=0;e<h.length;e++)c[t][e]=this._a*h[e]+(1-this._a)*c[t][e]}for(let n=0;n<s;n++){if(n===t||n===l){r[t][n]=0;continue}let s=1/0;const o=e[n].value;for(let t=0;t<o.repr.length;t++)for(let e=0;e<c.length;e++){const r=this._distance(o.repr[t],c[e]);r<s&&(s=r)}r[n][t]=r[t][n]=s,r[n].splice(l,1)}r[t].splice(l,1),r.splice(l,1),e[t]=new Tree({repr:c,distance:n},[e[t],e[l]]),e.splice(l,1)}this._root=e[0]}getClusters(t){const e=[this._root];for(;e.length<t;){let t=0,r=-1;for(let l=0;l<e.length;l++){const n=e[l];!n.isLeaf()&&n.value.distance>t&&(r=l,t=n.value.distance)}if(-1===r)break;const l=e[r];e.splice(r,1,l.at(0),l.at(1))}return e}predict(t){const e=[],r=this.getClusters(t);for(let t=0;t<r.length;t++){const l=r[t].leafValues();for(let r=0;r<l.length;r++)e[l[r].index]=t}return e}}