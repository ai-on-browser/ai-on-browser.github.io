var w=Object.defineProperty;var M=(m,c)=>w(m,"name",{value:c,configurable:!0});import y from"../util/matrix.js";export default class C{static{M(this,"CURE")}constructor(c){this._c=c,this._a=.2,this._root=null}_distance(c,n){return Math.sqrt(c.reduce((l,e,s)=>l+(e-n[s])**2,0))}fit(c){const n=[],l=[];for(c.forEach((e,s)=>{n.push({point:e,index:s,repr:[e],distance:0,get leafs(){return[this]}}),l[s]=c.map(r=>this._distance(e,r))});n.length>1;){let e=0,s=1,r=1/0;const a=n.length;for(let t=0;t<a;t++)for(let i=t+1;i<a;i++)l[t][i]<r&&(e=t,s=i,r=l[t][i]);const j=n[e].leafs.map(t=>t.point),k=n[s].leafs.map(t=>t.point),h=[...j,...k],p=[];let u=Math.floor(Math.random()*h.length);for(let t=0;t<Math.min(h.length,this._c);t++){let i=0,f=-1;for(let o=0;o<h.length;o++){if(p.includes(o))continue;const _=this._distance(h[o],h[u]);_>i&&(i=_,f=o)}p.push(f),u=f}const d=[],g=y.fromArray(h).mean(0).value;for(let t=0;t<p.length;t++){d[t]=h[p[t]].concat();for(let i=0;i<g.length;i++)d[t][i]=this._a*g[i]+(1-this._a)*d[t][i]}for(let t=0;t<a;t++){if(t===e||t===s){l[e][t]=0;continue}let i=1/0;const f=n[t];for(let o=0;o<f.repr.length;o++)for(let _=0;_<d.length;_++){const x=this._distance(f.repr[o],d[_]);x<i&&(i=x)}l[t][e]=l[e][t]=i,l[t].splice(s,1)}l[e].splice(s,1),l.splice(s,1),n[e]={repr:d,distance:r,children:[n[e],n[s]],get leafs(){return[...this.children[0].leafs,...this.children[1].leafs]}},n.splice(s,1)}this._root=n[0]}getClusters(c){const n=[this._root];for(;n.length<c;){let l=0,e=-1;for(let r=0;r<n.length;r++){const a=n[r];a.children&&a.distance>l&&(e=r,l=a.distance)}if(e===-1)break;const s=n[e];n.splice(e,1,s.children[0],s.children[1])}return n}predict(c){const n=[],l=this.getClusters(c);for(let e=0;e<l.length;e++){const s=l[e].leafs;for(let r=0;r<s.length;r++)n[s[r].index]=e}return n}}
