var o=Object.defineProperty;var a=(i,s)=>o(i,"name",{value:s,configurable:!0});const g={gaussian:a(i=>Math.exp(-i*i/2),"gaussian"),rectangular:a(i=>Math.abs(i)<=1?.5:0,"rectangular"),triangular:a(i=>Math.abs(i)<=1?1-Math.abs(i):0,"triangular"),epanechnikov:a(i=>Math.abs(i)<=1?3*(1-i**2)/4:0,"epanechnikov"),biweight:a(i=>Math.abs(i)<=1?.9375*(1-i**2)**2:0,"biweight"),triweight:a(i=>Math.abs(i)<=1?1.09375*(1-i**2)**3:0,"triweight")};export default class f{static{a(this,"BlurringMeanShift")}constructor(s,e,t="gaussian"){this._x=null,this._c=[],this._h=s,this._threshold=e,typeof t=="function"?this._kernel=t:(typeof t=="string"&&(t={name:t}),this._kernel=g[t.name])}get categories(){const s=this.predict();return[...new Set(s)]}get size(){const s=this.predict();return new Set(s).size}_distance(s,e){return Math.sqrt(s.reduce((t,h,c)=>t+(h-e[c])**2,0))}init(s){this._x=s,this._c=this._x.map(e=>[].concat(e))}predict(){const s=[];for(let e=0;e<this._c.length;e++){let t=e;for(let h=0;h<e;h++)if(this._distance(this._c[e],this._c[h])<this._threshold){t=s[h];break}s[e]=t}return s}fit(){const s=[];for(let t=0;t<this._c.length;t++){s[t]=[],s[t][t]=this._kernel(this._distance(this._c[t],this._c[t])/this._h);for(let h=0;h<t;h++)s[t][h]=s[h][t]=this._kernel(this._distance(this._c[t],this._c[h])/this._h)}let e=!1;return this._c=this._c.map((t,h)=>{let c=0;const _=Array(t.length).fill(0);for(let n=0;n<this._c.length;n++){c+=s[h][n];for(let r=0;r<_.length;r++)_[r]+=this._c[n][r]*s[h][n]}const l=_.map(n=>n/c);return e||=t.some((n,r)=>n!==l[r]),l}),e}}
