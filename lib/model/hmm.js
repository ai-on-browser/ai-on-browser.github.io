import Matrix from"../util/matrix.js";class HMMBase{constructor(t){this._n=t,this._a=Matrix.random(this._n,this._n),this._a.div(this._a.sum(1)),this._p=new Matrix(1,this._n,1/this._n)}_bt(t,s){throw"Not implemented"}_forward(t,s=!1){let r=this._p.copy();const i=s&&new Matrix(t.rows,t.cols);r.repeat(t.rows,0),r.mult(this._bt(t,0)),i&&(i.set(0,0,r.sum(1)),r.div(i.col(0)));const o=[r.copy()];for(let s=1;s<t.cols;s++)r=r.dot(this._a),r.mult(this._bt(t,s)),i&&(i.set(0,s,r.sum(1)),r.div(i.col(s))),o.push(r.copy());return i?[o,i]:o}_backward(t,s=null,r=!1){let i=Matrix.ones(t.rows,this._n);const o=[i.copy()];for(let r=t.cols-1;r>0;r--)i.mult(this._bt(t,r)),i=i.dot(this._a.t),s&&i.div(s.col(r)),o.unshift(i.copy());return r&&(i.mult(this._bt(t,0)),i.mult(this._p)),o}_gamma(t,s){const r=[],i=t[t.length-1].sum(1);for(let o=0;o<t.length;o++){const e=t[o].copyMult(s[o]);e.div(i),r.push(e)}return r}_xi(t,s,r,i){const o=[],e=s[s.length-1].sum(1);for(let a=0;a<s.length-1;a++){o[a]=[];const h=this._bt(t,a+1);for(let n=0;n<t.rows;n++){const t=s[a].row(n).t,_=r[a+1].row(n);_.mult(h.row(n));const l=this._a.copy();l.mult(t),l.mult(_),i?l.div(i.at(n,a+1)):l.div(e.value[n]),o[a].push(l)}}return o}_update(t,s){const r=t[0].rows,i=Matrix.zeros(this._n,this._n),o=Matrix.zeros(r,this._n);for(let s=0;s<t.length-1;s++)o.add(t[s]);o.add(1e-12);for(let t=0;t<r;t++){const r=Matrix.zeros(this._n,this._n);for(let i=0;i<s.length;i++)r.add(s[i][t]);r.div(o.row(t).t),i.add(r)}i.div(r);const e=t[0].mean(0);this._a=i,this._p=e}probability(t){const s=this._forward(t);return s[s.length-1].sum(1)}bestPath(t){const s=new Matrix(t.rows,t.cols),r=this._p.copy();r.repeat(t.rows,0),r.mult(this._bt(t,0)),s.set(0,0,r.argmax(1));for(let i=1;i<t.cols;i++){for(let o=0;o<t.rows;o++){const t=s.at(o,i-1),e=this._a.row(t);e.mult(r.at(o,t)),r.set(o,0,e)}r.mult(this._bt(t,i)),s.set(0,i,r.argmax(1))}return s}}export class HMM extends HMMBase{constructor(t){super(t),this._b=null,this._x_cand=[],this._type="mealy"}_bt(t,s){const r=new Matrix(t.rows,this._n);for(let i=0;i<t.rows;i++){const o=this._x_cand.indexOf(t.at(i,s));r.set(i,0,this._b.col(o).t)}return r}fit(t,s=!1){const r=Matrix.fromArray(t);null===this._b&&(this._x_cand=[...new Set(r.value)],this._b=new Matrix(this._n,this._x_cand.length,1/this._x_cand.length));const i=r.rows;let o,e;s?[o,e]=this._forward(r,!0):o=this._forward(r);const a=this._backward(r,e),h=this._gamma(o,a),n=this._xi(r,o,a,e);this._update(h,n);const _=Matrix.zeros(i,this._n);for(let t=0;t<h.length;t++)_.add(h[t]);const l=Matrix.zeros(this._n,this._b.cols);for(let t=0;t<i;t++){const s=Matrix.zeros(this._n,this._b.cols);for(let i=0;i<r.cols;i++)for(let o=0;o<this._n;o++)s.addAt(o,this._x_cand.indexOf(r.at(t,i)),h[i].at(t,o));s.div(_.row(t).t),l.add(s)}l.div(i),this._b=l}probability(t){const s=Matrix.fromArray(t);return super.probability(s).value}bestPath(t){const s=Matrix.fromArray(t);return super.bestPath(s).toArray()}}export class ContinuousHMM extends HMMBase{constructor(t,s){super(t),this._k=3,this._d=s,this._c=new Matrix(this._n,this._k,1/this._k),this._m=[],this._s=[];for(let t=0;t<this._n;t++){this._m[t]=Matrix.zeros(this._k,this._d),this._s[t]=[];for(let s=0;s<this._k;s++)this._s[t][s]=Matrix.eye(this._d,this._d)}}_btk(t,s,r){t=Matrix.fromArray(t.col(s).value);const i=new Matrix(t.rows,this._n);for(let s=0;s<this._n;s++){const o=this._m[s],e=this._s[s],a=Matrix.zeros(t.rows,1),h=t.copySub(o.row(r)),n=h.dot(e[r].inv());n.mult(h);const _=n.sum(1),l=Math.sqrt((2*Math.PI)**this._d*e[r].det());_.map((t=>Math.exp(-t/2)/l*this._c.at(s,r))),a.add(_),i.set(0,s,a)}return i}_bt(t,s){const r=new Matrix(t.rows,this._n);for(let i=0;i<this._k;i++)r.add(this._btk(t,s,i));return r}fit(t,s=!1){let r,i;t=Matrix.fromArray(t),s?[r,i]=this._forward(t,!0):r=this._forward(t);const o=this._backward(t,i),e=this._gamma(r,o),a=this._xi(t,r,o,i);this._update(e,a);const h=[],n=Matrix.zeros(t.rows,this._n),_=[],l=[];for(let s=0;s<e.length;s++)l[s]=this._bt(t,s);for(let s=0;s<this._k;s++){h[s]=[],_[s]=Matrix.zeros(t.rows,this._n);for(let r=0;r<e.length;r++){const i=this._btk(t,r,s);i.div(l[r]),i.mult(e[r]),h[s][r]=i,n.add(i),_[s].add(i)}}const c=new Matrix(this._n,this._k);for(let t=0;t<this._k;t++)c.set(0,t,_[t].copyDiv(n).mean(0).t);const d=[];for(let s=0;s<t.cols;s++)d[s]=Matrix.fromArray(t.col(s).value);const u=[],m=[];for(let s=0;s<this._n;s++){const r=new Matrix(this._k,this._d),i=[];for(let o=0;o<this._k;o++){const e=Matrix.zeros(t.rows,this._d);for(let r=0;r<t.cols;r++)e.add(d[r].copyMult(h[o][r].col(s)));e.div(_[o].col(s)),r.set(o,0,e.mean(0));const a=Matrix.zeros(this._d,this._d);for(let r=0;r<t.rows;r++){const i=Matrix.zeros(this._d,this._d);for(let e=0;e<t.cols;e++){const t=d[e].row(r).copySub(this._m[s].row(o)),a=t.tDot(t);a.mult(h[o][e].at(r,s)),i.add(a)}i.div(_[o].at(r,s)),a.add(i)}a.div(t.rows),i[o]=a}u[s]=r,m[s]=i}this._c=c,this._m=u,this._s=m}probability(t){const s=Matrix.fromArray(t);return super.probability(s).value}bestPath(t){const s=Matrix.fromArray(t);return super.bestPath(s).toArray()}generate(t=1,s=5){const r=(t,s)=>{let r=Math.random(),i=0;for(;i<t.cols-1&&!((r-=t.at(s,i))<=0);i++);return i},i=[];for(let o=0;o<t;o++){i[o]=[];let t=r(this._p,0),e=r(this._c,t);i[o][0]=Matrix.randn(1,this._d,this._m[t].row(e),this._s[t][e]).value;for(let a=1;a<s;a++)t=r(this._a,t),e=r(this._c,t),i[o][a]=Matrix.randn(1,this._d,this._m[t].row(e),this._s[t][e]).value}return i}}export class HMMClassifier{constructor(t,s,r=ContinuousHMM){this._classes=[...t],this._models=[];for(let t=0;t<this._classes.length;t++){const t=new r(s,1);this._models.push(t)}}fit(t,s,r=!1){for(let i=0;i<this._models.length;i++){const o=t.filter(((t,r)=>this._classes[i]===s[r]));this._models[i].fit(o,r)}}predict(t){const s=[];for(const r of this._models)s.push(r.probability(t));const r=Matrix.fromArray(s),i=r.argmax(0),o=r.max(0);return i.map(((t,s)=>o.at(s)>0?this._classes[t]:null)),i.value}}