import{Matrix}from"../util/math.js";class HMMBase{constructor(t){this._n=t,this._a=Matrix.random(this._n,this._n),this._a.div(this._a.sum(1)),this._p=new Matrix(1,this._n,1/this._n)}_bt(t,s){throw"Not implemented"}_forward(t,s=!1){let r=this._p.copy();const o=s&&new Matrix(t.rows,t.cols);r.repeat(t.rows,0),r.mult(this._bt(t,0)),o&&(o.set(0,0,r.sum(1)),r.div(o.col(0)));const i=[r.copy()];for(let s=1;s<t.cols;s++)r=r.dot(this._a),r.mult(this._bt(t,s)),o&&(o.set(0,s,r.sum(1)),r.div(o.col(s))),i.push(r.copy());return o?[i,o]:i}_backward(t,s=null,r=!1){let o=Matrix.ones(t.rows,this._n);const i=[o.copy()];for(let r=t.cols-1;r>0;r--)o.mult(this._bt(t,r)),o=o.dot(this._a.t),s&&o.div(s.col(r)),i.unshift(o.copy());return r&&(o.mult(this._bx(t,0)),o.mult(this._p)),i}_gamma(t,s){const r=[],o=t[t.length-1].sum(1);for(let i=0;i<t.length;i++){const a=t[i].copyMult(s[i]);a.div(o),r.push(a)}return r}_xi(t,s,r,o){const i=[],a=s[s.length-1].sum(1);for(let e=0;e<s.length-1;e++){i[e]=[];const h=this._bt(t,e+1);for(let n=0;n<t.rows;n++){const t=s[e].row(n).t,l=r[e+1].row(n);l.mult(h.row(n));const _=this._a.copy();_.mult(t),_.mult(l),o?_.div(o.at(n,e+1)):_.div(a.value[n]),i[e].push(_)}}return i}_update(t,s){const r=t[0].rows,o=Matrix.zeros(this._n,this._n),i=Matrix.zeros(r,this._n);for(let s=0;s<t.length-1;s++)i.add(t[s]);for(let t=0;t<r;t++){const r=Matrix.zeros(this._n,this._n);for(let o=0;o<s.length;o++)r.add(s[o][t]);r.div(i.row(t).t),o.add(r)}o.div(r);const a=t[0].mean(0);this._a=o,this._p=a}probability(t){const s=this._forward(t);return s[s.length-1].sum(1)}bestPath(t){const s=new Matrix(t.rows,t.cols),r=this._p.copy();r.repeat(t.rows,0),r.mult(this._bt(t,0)),s.set(0,0,r.argmax(1));for(let o=1;o<t.cols;o++){for(let i=0;i<t.rows;i++){const t=s.at(i,o-1),a=this._a.row(t);a.mult(r.at(i,t)),r.set(i,0,a)}r.mult(this._bt(t,o)),s.set(0,o,r.argmax(1))}return s}}export class HMM extends HMMBase{constructor(t,s=10){super(t),this._l=s,this._b=new Matrix(this._n,this._l,1/this._l),this._lmap=null,this._type="mealy"}_bt(t,s){const r=new Matrix(t.rows,this._n);for(let o=0;o<t.rows;o++)r.set(o,0,this._b.col(t.at(o,s)).t);return r}_forward(t,s=!1){const r=t.copyMap((t=>this._lmap(t)));return super._forward(r,s)}_backward(t,s=null,r=!1){const o=t.copyMap((t=>this._lmap(t)));return super._backward(o,s,r)}setLabelFromData(t){const s=Matrix.fromArray(t);if(Array.isArray(s.at(0,0))){const t=Matrix.fromArray(s.value),r=t.max(0).value,o=t.min(0).value,i=Math.floor(Math.sqrt(this._l));this._lmap=t=>{const s=t.map(((t,s)=>Math.floor((t-o[s])/(r[s]-o[s])*i))).reduce(((t,s)=>t*i+Math.min(i,s)),0);return Math.max(0,Math.min(this._l-1,s))}}else{const t=s.max(),r=s.min();this._lmap=s=>{const o=Math.floor((s-r)/(t-r)*this._l);return Math.max(0,Math.min(this._l-1,o))}}}fit(t,s=!1){this._lmap||this.setLabelFromData(t);const r=Matrix.fromArray(t),o=r.rows,i=r.copyMap((t=>this._lmap(t)));let a,e;s?[a,e]=this._forward(r,!0):a=this._forward(r);const h=this._backward(r,e),n=this._gamma(a,h),l=this._xi(i,a,h,e);this._update(n,l);const _=Matrix.zeros(o,this._n);for(let t=0;t<n.length;t++)_.add(n[t]);const c=Matrix.zeros(this._n,this._l);for(let t=0;t<o;t++){const s=Matrix.zeros(this._n,this._l);for(let o=0;o<r.cols;o++)for(let r=0;r<this._n;r++)s.addAt(r,i.at(t,o),n[o].at(t,r));s.div(_.row(t).t),c.add(s)}c.div(o),this._b=c}probability(t){const s=Matrix.fromArray(t);return super.probability(s).value}bestPath(t){const s=Matrix.fromArray(t).copyMap((t=>this._lmap(t)));return super.bestPath(s).toArray()}}export class ContinuousHMM extends HMMBase{constructor(t,s){super(t),this._k=3,this._d=s,this._c=new Matrix(this._n,this._k,1/this._k),this._m=[],this._s=[];for(let t=0;t<this._n;t++){this._m[t]=Matrix.zeros(this._k,this._d),this._s[t]=[];for(let s=0;s<this._k;s++)this._s[t][s]=Matrix.eye(this._d,this._d)}}_btk(t,s,r){t=Matrix.fromArray(t.col(s).value);const o=new Matrix(t.rows,this._n);for(let s=0;s<this._n;s++){const i=this._m[s],a=this._s[s],e=Matrix.zeros(t.rows,1),h=t.copySub(i.row(r)),n=h.dot(a[r].inv());n.mult(h);const l=n.sum(1),_=Math.sqrt((2*Math.PI)**this._d*a[r].det());l.map((t=>Math.exp(-t/2)/_*this._c.at(s,r))),e.add(l),o.set(0,s,e)}return o}_bt(t,s){t=Matrix.fromArray(t.col(s).value);const r=new Matrix(t.rows,this._n);for(let s=0;s<this._n;s++){const o=this._m[s],i=this._s[s],a=Matrix.zeros(t.rows,1);for(let r=0;r<this._k;r++){const e=t.copySub(o.row(r)),h=e.dot(i[r].inv());h.mult(e);const n=h.sum(1),l=Math.sqrt((2*Math.PI)**this._d*i[r].det());n.map((t=>Math.exp(-t/2)/l*this._c.at(s,r))),a.add(n)}r.set(0,s,a)}return r}fit(t,s=!1){let r,o;t=Matrix.fromArray(t),s?[r,o]=this._forward(t,!0):r=this._forward(t);const i=this._backward(t,o),a=this._gamma(r,i),e=this._xi(t,r,i,o);this._update(a,e);const h=[],n=Matrix.zeros(t.rows,this._n),l=[],_=[];for(let s=0;s<a.length;s++)_[s]=this._bt(t,s);for(let s=0;s<this._k;s++){h[s]=[],l[s]=Matrix.zeros(t.rows,this._n);for(let r=0;r<a.length;r++){const o=this._btk(t,r,s);o.div(_[r]),o.mult(a[r]),h[s][r]=o,n.add(o),l[s].add(o)}}const c=new Matrix(this._n,this._k);for(let t=0;t<this._k;t++)c.set(0,t,l[t].copyDiv(n).mean(0).t);const m=[];for(let s=0;s<t.cols;s++)m[s]=Matrix.fromArray(t.col(s).value);const d=[],u=[];for(let s=0;s<this._n;s++){const r=new Matrix(this._k,this._d),o=[];for(let i=0;i<this._k;i++){const a=Matrix.zeros(t.rows,this._d);for(let r=0;r<t.cols;r++)a.add(m[r].copyMult(h[i][r].col(s)));a.div(l[i].col(s)),r.set(i,0,a.mean(0));const e=Matrix.zeros(this._d,this._d);for(let r=0;r<t.rows;r++){const o=Matrix.zeros(this._d,this._d);for(let a=0;a<t.cols;a++){const t=m[a].row(r).copySub(this._m[s].row(i)),e=t.tDot(t);e.mult(h[i][a].at(r,s)),o.add(e)}o.div(l[i].at(r,s)),e.add(o)}e.div(t.rows),o[i]=e}d[s]=r,u[s]=o}this._c=c,this._m=d,this._s=u}probability(t){const s=Matrix.fromArray(t);return super.probability(s).value}bestPath(t){const s=Matrix.fromArray(t);return super.bestPath(s).toArray()}generate(t=1,s=5){const r=(t,s)=>{let r=Math.random(),o=0;for(;o<t.cols-1&&!((r-=t.at(s,o))<=0);o++);return o},o=[];for(let i=0;i<t;i++){o[i]=[];let t=r(this._p,0),a=r(this._c,t);o[i][0]=Matrix.randn(1,this._d,this._m[t].row(a),this._s[t][a]).value;for(let e=1;e<s;e++)t=r(this._a,t),a=r(this._c,t),o[i][e]=Matrix.randn(1,this._d,this._m[t].row(a),this._s[t][a]).value}return o}}export class HMMClassifier{constructor(t,s,r=ContinuousHMM){this._classes=[...t],this._models=[];for(let t=0;t<this._classes.length;t++){const t=new r(s,1);this._models.push(t)}}fit(t,s){for(let r=0;r<this._models.length;r++){const o=t.filter(((t,o)=>this._classes[r]===s[o][0]));this._models[r].fit(o)}}predict(t){const s=[];for(const r of this._models)s.push(r.probability(t));const r=Matrix.fromArray(s),o=r.argmax(0),i=r.max(0).value;return o.map(((t,s)=>i[s]>0?this._classes[t]:-1)),o.value}}