var j=Object.defineProperty;var y=(g,t)=>j(g,"name",{value:t,configurable:!0});import e from"../util/matrix.js";class O{static{y(this,"HMMBase")}constructor(t){this._n=t,this._a=e.random(this._n,this._n),this._a.div(this._a.sum(1)),this._p=new e(1,this._n,1/this._n)}_bt(t,i){throw"Not implemented"}_forward(t,i=!1){let s=this._p.copy();const o=i&&new e(t.rows,t.cols);s.repeat(t.rows,0),s.mult(this._bt(t,0)),o&&(o.set(0,0,s.sum(1)),s.div(o.col(0)));const r=[s.copy()];for(let n=1;n<t.cols;n++)s=s.dot(this._a),s.mult(this._bt(t,n)),o&&(o.set(0,n,s.sum(1)),s.div(o.col(n))),r.push(s.copy());return o?[r,o]:r}_backward(t,i=null,s=!1){let o=e.ones(t.rows,this._n);const r=[o.copy()];for(let n=t.cols-1;n>0;n--)o.mult(this._bt(t,n)),o=o.dot(this._a.t),i&&o.div(i.col(n)),r.unshift(o.copy());return s&&(o.mult(this._bt(t,0)),o.mult(this._p)),r}_gamma(t,i){const s=[],o=t[t.length-1].sum(1);for(let r=0;r<t.length;r++){const n=e.mult(t[r],i[r]);n.div(o),s.push(n)}return s}_xi(t,i,s,o){const r=[],n=i[i.length-1].sum(1);for(let _=0;_<i.length-1;_++){r[_]=[];const a=this._bt(t,_+1);for(let l=0;l<t.rows;l++){const d=i[_].row(l).t,f=s[_+1].row(l);f.mult(a.row(l));const c=this._a.copy();c.mult(d),c.mult(f),o?c.div(o.at(l,_+1)):c.div(n.value[l]),r[_].push(c)}}return r}_update(t,i){const s=t[0].rows,o=e.zeros(this._n,this._n),r=e.zeros(s,this._n);for(let _=0;_<t.length-1;_++)r.add(t[_]);r.add(1e-12);for(let _=0;_<s;_++){const a=e.zeros(this._n,this._n);for(let l=0;l<i.length;l++)a.add(i[l][_]);a.div(r.row(_).t),o.add(a)}o.div(s);const n=t[0].mean(0);this._a=o,this._p=n}probability(t){const i=this._forward(t);return i[i.length-1].sum(1)}bestPath(t){const i=new e(t.rows,t.cols),s=this._p.copy();s.repeat(t.rows,0),s.mult(this._bt(t,0)),i.set(0,0,s.argmax(1));for(let o=1;o<t.cols;o++){for(let r=0;r<t.rows;r++){const n=i.at(r,o-1),_=this._a.row(n);_.mult(s.at(r,n)),s.set(r,0,_)}s.mult(this._bt(t,o)),i.set(0,o,s.argmax(1))}return i}}export class HMM extends O{static{y(this,"HMM")}constructor(t){super(t),this._b=null,this._x_cand=[],this._type="mealy"}_bt(t,i){const s=new e(t.rows,this._n);for(let o=0;o<t.rows;o++){const r=this._x_cand.indexOf(t.at(o,i));s.set(o,0,this._b.col(r).t)}return s}fit(t,i=!1){const s=e.fromArray(t);this._b===null&&(this._x_cand=[...new Set(s.value)],this._b=new e(this._n,this._x_cand.length,1/this._x_cand.length));const o=s.rows;let r,n;i?[r,n]=this._forward(s,!0):r=this._forward(s);const _=this._backward(s,n),a=this._gamma(r,_),l=this._xi(s,r,_,n);this._update(a,l);const d=e.zeros(o,this._n);for(let c=0;c<a.length;c++)d.add(a[c]);const f=e.zeros(this._n,this._b.cols);for(let c=0;c<o;c++){const b=e.zeros(this._n,this._b.cols);for(let k=0;k<s.cols;k++)for(let v=0;v<this._n;v++)b.addAt(v,this._x_cand.indexOf(s.at(c,k)),a[k].at(c,v));b.div(d.row(c).t),f.add(b)}f.div(o),this._b=f}probability(t){const i=e.fromArray(t);return super.probability(i).value}bestPath(t){const i=e.fromArray(t);return super.bestPath(i).toArray()}}export class ContinuousHMM extends O{static{y(this,"ContinuousHMM")}constructor(t){super(t),this._k=3,this._d=null,this._c=new e(this._n,this._k,1/this._k),this._m=[],this._s=[]}_btk(t,i,s){t=e.fromArray(t.col(i).value);const o=new e(t.rows,this._n);for(let r=0;r<this._n;r++){const n=this._m[r],_=this._s[r],a=e.zeros(t.rows,1),l=e.sub(t,n.row(s)),d=l.dot(_[s].inv());d.mult(l);const f=d.sum(1),c=Math.sqrt((2*Math.PI)**this._d*_[s].det());f.map(b=>Math.exp(-b/2)/c*this._c.at(r,s)),a.add(f),o.set(0,r,a)}return o}_bt(t,i){const s=new e(t.rows,this._n);for(let o=0;o<this._k;o++)s.add(this._btk(t,i,o));return s}fit(t,i=!1){if(!this._d){this._d=Array.isArray(t[0][0])?t[0][0].length:1;for(let h=0;h<this._n;h++){this._m[h]=e.zeros(this._k,this._d),this._s[h]=[];for(let u=0;u<this._k;u++)this._s[h][u]=e.eye(this._d,this._d)}}t=e.fromArray(t);let s,o;i?[s,o]=this._forward(t,!0):s=this._forward(t);const r=this._backward(t,o),n=this._gamma(s,r),_=this._xi(t,s,r,o);this._update(n,_);const a=[],l=e.zeros(t.rows,this._n),d=[],f=[];for(let h=0;h<n.length;h++)f[h]=this._bt(t,h);for(let h=0;h<this._k;h++){a[h]=[],d[h]=e.zeros(t.rows,this._n);for(let u=0;u<n.length;u++){const p=this._btk(t,u,h);p.div(f[u]),p.mult(n[u]),a[h][u]=p,l.add(p),d[h].add(p)}}const c=new e(this._n,this._k);for(let h=0;h<this._k;h++)c.set(0,h,e.div(d[h],l).mean(0).t);const b=[];for(let h=0;h<t.cols;h++)b[h]=e.fromArray(t.col(h).value);const k=[],v=[];for(let h=0;h<this._n;h++){const u=new e(this._k,this._d),p=[];for(let w=0;w<this._k;w++){const A=e.zeros(t.rows,this._d);for(let m=0;m<t.cols;m++)A.add(e.mult(b[m],a[w][m].col(h)));A.div(d[w].col(h)),u.set(w,0,A.mean(0));const M=e.zeros(this._d,this._d);for(let m=0;m<t.rows;m++){const P=e.zeros(this._d,this._d);for(let z=0;z<t.cols;z++){const H=e.sub(b[z].row(m),this._m[h].row(w)),I=H.tDot(H);I.mult(a[w][z].at(m,h)),P.add(I)}P.div(d[w].at(m,h)),M.add(P)}M.div(t.rows),p[w]=M}k[h]=u,v[h]=p}this._c=c,this._m=k,this._s=v}probability(t){const i=e.fromArray(t);return super.probability(i).value}bestPath(t){const i=e.fromArray(t);return super.bestPath(i).toArray()}generate(t=1,i=5){const s=y((r,n)=>{let _=Math.random(),a=0;for(;a<r.cols-1&&!((_-=r.at(n,a))<=0);a++);return a},"randIdx"),o=[];for(let r=0;r<t;r++){o[r]=[];let n=s(this._p,0),_=s(this._c,n);o[r][0]=e.randn(1,this._d,this._m[n].row(_),this._s[n][_]).value;for(let a=1;a<i;a++)n=s(this._a,n),_=s(this._c,n),o[r][a]=e.randn(1,this._d,this._m[n].row(_),this._s[n][_]).value}return o}}
