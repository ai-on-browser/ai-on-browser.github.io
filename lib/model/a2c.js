var g=Object.defineProperty;var u=(d,s)=>g(d,"name",{value:s,configurable:!0});import{RLRealRange as y}from"../rl/base.js";import v from"./neuralnetwork.js";class A{static{u(this,"ActorCriticNet")}constructor(s,a=20,t=[],n="sgd"){this._resolution=a,this._states=s.states,this._actions=s.actions,this._action_sizes=s.actions.map(e=>Array.isArray(e)?e.length:a),this._layers=[{type:"input",name:"state"},...t,{type:"identity",name:"d"},{type:"full",out_size:1,name:"value"},{type:"full",out_size:this._action_sizes.reduce((e,o)=>e*o,1),input:["d"],name:"actor"},{type:"softmax",name:"prob"},{type:"log",name:"log_prob"},{type:"input",name:"action"},{type:"mult",input:["log_prob","action"]},{type:"sum",axis:1,name:"action_log_prob"},{type:"mult",input:["log_prob","prob"]},{type:"sum",axis:1},{type:"mean"},{type:"negative",name:"entropy"},{type:"input",name:"reward"},{type:"sub",input:["reward","value"],name:"advantages"},{type:"power",input:["advantages",2]},{type:"mean",name:"value_loss"},{type:"detach",input:["advantages"],name:"detach_adv"},{type:"mult",input:["action_log_prob","detach_adv"]},{type:"mean",name:"action_gain"},{type:"mult",input:[.5,"value_loss"],name:"value_c"},{type:"mult",input:[.01,"entropy"],name:"entropy_c"},{type:"sub",input:["value_c","action_gain","entropy_c"]},{type:"mean"}],this._net=v.fromObject(this._layers,null,n)}get_action(s){s=this._state_to_input(s);const t=this._net.calc([s],null,["prob"]).prob.toArray()[0];let n=Math.random();for(let e=0;e<t.length;e++)if(n-=t[e],n<0)return this._pos_action(e);return this._pos_action(0)}_state_to_input(s){const a=[];for(let t=0;t<s.length;t++)if(Array.isArray(this._states[t]))for(let n=0;n<this._states[t].length;n++)a.push(this._states[t][n]===s[t]?1:0);else a.push(s[t]);return a}get_score(s){if(s)return this._net.calc(s.map(e=>this._state_to_input(e)),null,["value"]).value.toArray();if(!this._states_data){const e=this._states.map(h=>h.toArray(this._resolution).length);this._states_data=[];const o=u(h=>{for(let l=0;l<h.length;l++){if(h[l]++,h[l]<e[l])return!0;h[l]=0}return!1},"next_idx"),_=Array(this._states.length).fill(0);do this._states_data.push([].concat(_));while(o(_))}const a=this._net.calc(this._states_data,null,["prob"]).prob.toArray(),t=[],n=this._states.length;for(let e=0;e<this._states_data.length;e++){let o=t;for(let _=0;_<n-1;_++)o[this._states_data[e][_]]||(o[this._states_data[e][_]]=[]),o=o[this._states_data[e][_]];o[this._states_data[e][n-1]]=a[e]}return t}_action_pos(s){let a=0;for(let t=0;t<s.length;t++)if(a=a*this._action_sizes[t],Array.isArray(this._actions[t]))a+=this._actions[t].indexOf(s[t]);else if(this._actions[t]instanceof y)a+=this._actions[t].indexOf(s[t],this._resolution);else throw"Not implemented";return a}_pos_action(s){const a=[];for(let t=this._action_sizes.length-1;t>=0;t--){const n=s%this._action_sizes[t];if(s=Math.floor(s/this._action_sizes[t]),Array.isArray(this._actions[t]))a.unshift(this._actions[t][n]);else if(this._actions[t]instanceof y)a.unshift(this._actions[t].toArray(this._resolution)[n]);else throw"Not implemented"}return a}update(s,a,t,n,e){return s=s.map(_=>this._state_to_input(_)),a=a.map(_=>{const h=this._action_pos(_),l=Array(this._action_sizes.reduce((c,m)=>c*m,1)).fill(0);return l[h]=1,l}),this._net.fit({state:s,action:a,reward:t},null,1,n,e)[0]}}export default class b{static{u(this,"A2CAgent")}constructor(s,a,t,n,e){this._net=new A(s,a,n,e),this._procs=t,this._env=s,this._advanced_step=5,this._gamma=.99,this._states=[],this._envs=[];for(let o=0;o<this._procs;o++)this._envs[o]=this._env.clone(),this._states[o]=this._envs[o].reset()}terminate(){}get_score(){return this._net.get_score()}get_action(s){return this._net.get_action(s)}update(s,a,t){const n=[],e=[],o=[],_=[],h=[];for(let i=0;i<this._advanced_step;i++)for(let r=0;r<this._procs;r++){const f=this._net.get_action(this._states[r]),p=this._envs[i].step(f);(n[r]||=[]).push(f),(e[r]||=[]).push(this._states[r]),(o[r]||=[]).push(p.state),(_[r]||=[]).push(p.reward),(h[r]||=[]).push(p.done),p.done?this._states[r]=this._envs[i].reset():this._states[r]=p.state}const l=this._net.get_score(o.map(i=>i[i.length-1])),c=[];for(let i=0;i<this._procs;i++)c[i]=[],c[i][this._advanced_step-1]=l[i][0];for(let i=this._advanced_step-2;i>=0;i--)for(let r=0;r<this._procs;r++)c[r][i]=_[r][i],h[r][i]||(c[r][i]+=c[r][i+1]*this._gamma);return this._net.update(e.flat(1),n.flat(1),c.flat(1).map(i=>[i]),a,t)}}
