var g=Object.defineProperty;var u=(d,s)=>g(d,"name",{value:s,configurable:!0});import{RLRealRange as y}from"../rl/base.js";import v from"./neuralnetwork.js";class A{static{u(this,"ActorCriticNet")}constructor(s,a=20,t=[],i="sgd"){this._resolution=a,this._states=s.states,this._actions=s.actions,this._action_sizes=s.actions.map(e=>Array.isArray(e)?e.length:a),this._layers=[{type:"input",name:"state"},...t,{type:"identity",name:"d"},{type:"full",out_size:1,name:"value"},{type:"full",out_size:this._action_sizes.reduce((e,r)=>e*r,1),input:["d"],name:"actor"},{type:"softmax",name:"prob"},{type:"log",name:"log_prob"},{type:"input",name:"action"},{type:"mult",input:["log_prob","action"]},{type:"sum",axis:1,name:"action_log_prob"},{type:"mult",input:["log_prob","prob"]},{type:"sum",axis:1},{type:"mean"},{type:"negative",name:"entropy"},{type:"input",name:"reward"},{type:"sub",input:["reward","value"],name:"advantages"},{type:"power",input:["advantages",2]},{type:"mean",name:"value_loss"},{type:"detach",input:["advantages"],name:"detach_adv"},{type:"mult",input:["action_log_prob","detach_adv"]},{type:"mean",name:"action_gain"},{type:"mult",input:[.5,"value_loss"],name:"value_c"},{type:"mult",input:[.01,"entropy"],name:"entropy_c"},{type:"sub",input:["value_c","action_gain","entropy_c"]},{type:"mean"}],this._net=v.fromObject(this._layers,null,i)}get_action(s){s=this._state_to_input(s);const t=this._net.calc([s],null,["prob"]).prob.toArray()[0];let i=Math.random();for(let e=0;e<t.length;e++)if(i-=t[e],i<0)return this._pos_action(e);return this._pos_action(0)}_state_to_input(s){const a=[];for(let t=0;t<s.length;t++)if(Array.isArray(this._states[t]))for(let i=0;i<this._states[t].length;i++)a.push(this._states[t][i]===s[t]?1:0);else a.push(s[t]);return a}get_score(s){if(s)return this._net.calc(s.map(e=>this._state_to_input(e)),null,["value"]).value.toArray();if(!this._states_data){const e=this._states.map(h=>h.toArray(this._resolution).length);this._states_data=[];const r=u(h=>{for(let l=0;l<h.length;l++){if(h[l]++,h[l]<e[l])return!0;h[l]=0}return!1},"next_idx"),_=Array(this._states.length).fill(0);do this._states_data.push([].concat(_));while(r(_))}const a=this._net.calc(this._states_data,null,["prob"]).prob.toArray(),t=[],i=this._states.length;for(let e=0;e<this._states_data.length;e++){let r=t;for(let _=0;_<i-1;_++)r[this._states_data[e][_]]||(r[this._states_data[e][_]]=[]),r=r[this._states_data[e][_]];r[this._states_data[e][i-1]]=a[e]}return t}_action_pos(s){let a=0;for(let t=0;t<s.length;t++)if(a=a*this._action_sizes[t],Array.isArray(this._actions[t]))a+=this._actions[t].indexOf(s[t]);else if(this._actions[t]instanceof y)a+=this._actions[t].indexOf(s[t],this._resolution);else throw"Not implemented";return a}_pos_action(s){const a=[];for(let t=this._action_sizes.length-1;t>=0;t--){const i=s%this._action_sizes[t];if(s=Math.floor(s/this._action_sizes[t]),Array.isArray(this._actions[t]))a.unshift(this._actions[t][i]);else if(this._actions[t]instanceof y)a.unshift(this._actions[t].toArray(this._resolution)[i]);else throw"Not implemented"}return a}update(s,a,t,i,e){return s=s.map(_=>this._state_to_input(_)),a=a.map(_=>{const h=this._action_pos(_),l=Array(this._action_sizes.reduce((c,m)=>c*m,1)).fill(0);return l[h]=1,l}),this._net.fit({state:s,action:a,reward:t},null,1,i,e)[0]}}export default class b{static{u(this,"A2CAgent")}constructor(s,a,t,i,e){this._net=new A(s,a,i,e),this._procs=t,this._env=s,this._advanced_step=5,this._gamma=.99,this._states=[],this._envs=[];for(let r=0;r<this._procs;r++)this._envs[r]=this._env.clone(),this._states[r]=this._envs[r].reset()}terminate(){}get_score(){return this._net.get_score()}get_action(s){return this._net.get_action(s)}update(s,a,t){const i=[],e=[],r=[],_=[],h=[];for(let n=0;n<this._advanced_step;n++)for(let o=0;o<this._procs;o++){const f=this._net.get_action(this._states[o]),p=this._envs[o].step(f);(i[o]||=[]).push(f),(e[o]||=[]).push(this._states[o]),(r[o]||=[]).push(p.state),(_[o]||=[]).push(p.reward),(h[o]||=[]).push(p.done),p.done?this._states[o]=this._envs[o].reset():this._states[o]=p.state}const l=this._net.get_score(r.map(n=>n[n.length-1])),c=[];for(let n=0;n<this._procs;n++)c[n]=[],c[n][this._advanced_step-1]=l[n][0];for(let n=this._advanced_step-2;n>=0;n--)for(let o=0;o<this._procs;o++)c[o][n]=_[o][n],h[o][n]||(c[o][n]+=c[o][n+1]*this._gamma);return this._net.update(e.flat(1),i.flat(1),c.flat(1).map(n=>[n]),a,t)}}
