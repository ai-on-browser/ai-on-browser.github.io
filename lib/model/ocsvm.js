const Kernel={gaussian:(t=1)=>(h,i)=>{let s=h.reduce(((t,h,s)=>t+(h-i[s])**2),0);return Math.exp(-s/(2*t*t))},linear:()=>(t,h)=>t.reduce(((t,i,s)=>t+i*h[s]),0)};export default class OCSVM{constructor(t,h,i=[]){this._kernel=Kernel[h](...i),this._nu=t,this._eps=.001}init(t){this._x=t;const h=this._x.length;this._nl=h*this._nu,this._a=Array(h).fill(1/this._nl),this._b=0,this._alldata=!0,this._k=[];for(let t=0;t<h;this._k[t++]=[]);for(let t=0;t<h;t++)for(let i=t;i<h;i++)this._k[t][i]=this._k[i][t]=this._kernel(this._x[t],this._x[i])}fit(){const t=this._fitOnce(this._alldata);if(this._alldata){if(this._alldata=!1,0===t)return}else 0===t&&(this._alldata=!0)}_fitOnce(){let t=0;const h=this._x.length;for(let i=0;i<h;i++){const s=[];this._rho=-1/0;for(let t=0;t<h;t++){s[t]=0;for(let i=0;i<h;i++)s[t]+=this._a[t]*this._k[t][i];this._rho<s[t]&&(this._rho=s[t])}if(!this._alldata){if(!(t=>(s[i]-this._rho)*t>0||(this._rho-s[i])*(1/this._nl-t)>0)(this._a[i]))continue;if(this._a[i]>=1/this._nl-this._eps||this._a[i]<=this._eps)continue}let _=-1,e=-1/0;for(let t=0;t<h;t++)t!==i&&(this._a[t]>=1/this._nl-this._eps||this._a[t]<=this._eps||e<Math.abs(s[i]-s[t])&&(_=t,e=Math.abs(s[i]-s[t])));if(_<0||_===i){const t=Math.floor(Math.random()*(h+1));for(let s=0;s<h;s++){const e=(s+t)%h;if(e!==i){_=e;break}}}let a=1;for(let t=0;t<h;t++)t!==i&&t!==_&&(a-=this._a[t]);this._a[_]+=(s[i]-s[_])/(this._k[i][i]+this._k[_][_]-2*this._k[i][_]),this._a[_]=Math.max(0,Math.min(1/this._nl,this._a[_])),this._a[i]=Math.max(0,Math.min(1/this._nl,a-this._a[_])),t++}this._rho=-1/0;for(let t=0;t<h;t++){let i=0;for(let s=0;s<h;s++)i+=this._a[t]*this._k[t][s];this._rho<i&&(this._rho=i)}return t}predict(t){return t.map((t=>{let h=0;for(let i=0;i<this._x.length;i++)this._a[i]&&(h+=this._a[i]*this._kernel(t,this._x[i]));return h-this._rho}))}}