const Kernel={gaussian:(t=1)=>(s,h)=>{let i=s.reduce(((t,s,i)=>t+(s-h[i])**2),0);return Math.exp(-i/(2*t*t))},linear:()=>(t,s)=>t.reduce(((t,h,i)=>t+h*s[i]),0)};export default class OCSVM{constructor(t,s,h=[]){this._kernel=Kernel[s](...h),this._nu=t,this._eps=.001}init(t){this._x=t;const s=this._x.length;this._nl=s*this._nu,this._a=Array(s).fill(1/this._nl),this._b=0,this._alldata=!0,this._k=[];for(let t=0;t<s;this._k[t++]=[]);for(let t=0;t<s;t++)for(let h=t;h<s;h++)this._k[t][h]=this._k[h][t]=this._kernel(this._x[t],this._x[h])}fit(){const t=this._fitOnce(this._alldata);if(this._alldata){if(this._alldata=!1,0===t)return}else 0===t&&(this._alldata=!0)}_fitOnce(){let t=0;const s=this._x.length;for(let h=0;h<s;h++){const i=[];this._rho=-1/0;for(let t=0;t<s;t++){i[t]=0;for(let h=0;h<s;h++)i[t]+=this._a[t]*this._k[t][h];this._rho<i[t]&&(this._rho=i[t])}if(!this._alldata){if(!(t=>(i[h]-this._rho)*t>0||(this._rho-i[h])*(1/this._nl-t)>0)(this._a[h]))continue;if(this._a[h]>=1/this._nl-this._eps||this._a[h]<=this._eps)continue}let _=-1,a=-1/0;for(let t=0;t<s;t++)t!==h&&(this._a[t]>=1/this._nl-this._eps||this._a[t]<=this._eps||a<Math.abs(i[h]-i[t])&&(_=t,a=Math.abs(i[h]-i[t])));if(_<0||_===h){const t=Math.floor(Math.random()*(s+1));for(let i=0;i<s;i++){const a=(i+t)%s;if(a!==h){_=a;break}}}let e=1;for(let t=0;t<s;t++)t!==h&&t!==_&&(e-=this._a[t]);this._a[_]+=(i[h]-i[_])/(this._k[h][h]+this._k[_][_]-2*this._k[h][_]),this._a[_]=Math.max(0,Math.min(1/this._nl,this._a[_])),this._a[h]=Math.max(0,Math.min(1/this._nl,e-this._a[_])),t++}this._rho=-1/0;for(let t=0;t<s;t++){let h=0;for(let i=0;i<s;i++)h+=this._a[t]*this._k[t][i];this._rho<h&&(this._rho=h)}return t}predict(t){const s=t=>{let s=0;for(let h=0;h<this._x.length;h++)this._a[h]&&(s+=this._a[h]*this._kernel(t,this._x[h]));return s-this._rho};return Array.isArray(t[0])?t.map(s):s(t)}}