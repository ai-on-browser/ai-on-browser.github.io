import{Tree}from"../util/math.js";class HierarchyClustering{constructor(e="euclid"){switch(this._root=null,this._metric=e,this._metric){case"euclid":this._d=(e,t)=>Math.sqrt(e.reduce(((e,a,r)=>e+(a-t[r])**2),0));break;case"manhattan":this._d=(e,t)=>e.reduce(((e,a,r)=>e+Math.abs(a-t[r])),0);break;case"chebyshev":this._d=(e,t)=>e.reduce(((e,a,r)=>Math.max(e,Math.abs(a-t[r]))),-1/0)}}fit(e){const t=[];e.forEach(((a,r)=>{t.push(new Tree({point:a,index:r,distances:e.map((e=>this._d(a,e)))}))}));const a=[];for(let e=0;e<t.length;e++){a[e]||(a[e]=[]);for(let r=0;r<e;r++)a[e][r]||(a[e][r]=a[r][e]=this.distance(t[e],t[r]))}for(;t.length>1;){let e=t.length,r=0,s=1,l=a[0][1];for(let t=1;t<e;t++)a[t].forEach(((e,a)=>{e<l&&(r=t,s=a,l=e)}));let n=t[r].leafCount(),i=t[s].leafCount();a.forEach(((e,l)=>{l!=s&&l!=r&&(e[r]=this.update(n,i,t[l].leafCount(),e[r],e[s],a[s][r]),a[r][l]=e[r],e.splice(s,1))})),a[r].splice(s,1),a.splice(s,1),t[r]=new Tree({distance:l},[t[r],t[s]]),t.splice(s,1)}this._root=t[0]}getClusters(e){const t=[this._root];for(;t.length<e;){let e=0,a=-1;for(let r=0;r<t.length;r++){const s=t[r];!s.isLeaf()&&s.value.distance>e&&(a=r,e=s.value.distance)}if(-1===a)break;const r=t[a];t.splice(a,1,r.at(0),r.at(1))}return t}distance(e,t){throw new Error("Not Implemented")}_mean(e){const t=Array(e[0].length).fill(0);for(let a=0;a<e.length;a++)for(let r=0;r<e[a].length;r++)t[r]+=e[a][r];return t.map((t=>t/e.length))}_lanceWilliamsUpdater(e,t,a,r){return(s,l,n)=>e*s+t*l+a*n+r*Math.abs(s-l)}update(e,t,a,r,s,l){throw new Error("Not Implemented")}}export class CompleteLinkageHierarchyClustering extends HierarchyClustering{distance(e,t){let a=e.leafValues(),r=t.leafValues();return Math.max.apply(null,a.map((e=>Math.max.apply(null,r.map((t=>e.distances[t.index]))))))}update(e,t,a,r,s,l){return this._lanceWilliamsUpdater(.5,.5,0,.5)(r,s,l)}}export class SingleLinkageHierarchyClustering extends HierarchyClustering{distance(e,t){let a=e.leafValues(),r=t.leafValues();return Math.min.apply(null,a.map((e=>Math.min.apply(null,r.map((t=>e.distances[t.index]))))))}update(e,t,a,r,s,l){return this._lanceWilliamsUpdater(.5,.5,0,-.5)(r,s,l)}}export class GroupAverageHierarchyClustering extends HierarchyClustering{distance(e,t){let a=e.leafValues(),r=t.leafValues();return a.reduce(((e,t)=>e+r.reduce(((e,a)=>e+t.distances[a.index]),0)),0)/(a.length*r.length)}update(e,t,a,r,s,l){return this._lanceWilliamsUpdater(e/(e+t),t/(e+t),0,0)(r,s,l)}}export class WardsHierarchyClustering extends HierarchyClustering{distance(e,t){let a=e.leafValues().map((e=>e.point)),r=t.leafValues().map((e=>e.point)),s=a.concat(r),l=this._mean(a),n=this._mean(r),i=this._mean(s),u=a.reduce(((e,t)=>e+this._d(t,l)**2),0),c=r.reduce(((e,t)=>e+this._d(t,n)**2),0);return s.reduce(((e,t)=>e+this._d(t,i)**2),0)-u-c}update(e,t,a,r,s,l){return this._lanceWilliamsUpdater((a+e)/(a+e+t),(a+t)/(a+e+t),-a/(a+e+t),0)(r,s,l)}}export class CentroidHierarchyClustering extends HierarchyClustering{distance(e,t){let a=e.leafValues().map((e=>e.point)),r=t.leafValues().map((e=>e.point)),s=this._d(this._mean(a),this._mean(r));return s*s}update(e,t,a,r,s,l){return this._lanceWilliamsUpdater(e/(e+t),t/(e+t),-e*t/((e+t)*(e+t)),0)(r,s,l)}}export class WeightedAverageHierarchyClustering extends HierarchyClustering{distance(e,t){return function e(t,a){return 1===t.leafCount()&&1===a.leafCount()?t.value.distances[a.value.index]:1===a.leafCount()?(e(a,t.at(0))+e(a,t.at(1)))/2:(e(t,a.at(0))+e(t,a.at(1)))/2}(e,t)}update(e,t,a,r,s,l){return this._lanceWilliamsUpdater(.5,.5,0,0)(r,s,l)}}export class MedianHierarchyClustering extends HierarchyClustering{distance(e,t){let a=this._mean(e.leafValues().map((e=>e.point))),r=this._mean(t.leafValues().map((e=>e.point))),s=a.map(((e,t)=>(e+r[t])/2));return this._d(s,r)**2}update(e,t,a,r,s,l){return this._lanceWilliamsUpdater(.5,.5,-.25,0)(r,s,l)}}