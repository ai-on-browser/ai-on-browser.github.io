import{Tree}from"../util/math.js";class HierarchyClustering{constructor(e="euclid"){switch(this._root=null,this._metric=e,this._metric){case"euclid":this._d=(e,t)=>Math.sqrt(e.reduce(((e,a,r)=>e+(a-t[r])**2),0));break;case"manhattan":this._d=(e,t)=>e.reduce(((e,a,r)=>e+Math.abs(a-t[r])),0);break;case"chebyshev":this._d=(e,t)=>e.reduce(((e,a,r)=>Math.max(e,Math.abs(a-t[r]))),-1/0)}}fit(e){const t=[];e.forEach(((a,r)=>{t.push(new Tree({point:a,index:r,distances:e.map((e=>this._d(a,e)))}))}));const a=[];for(let e=0;e<t.length;e++){a[e]||(a[e]=[]);for(let r=0;r<e;r++)a[e][r]||(a[e][r]=a[r][e]=this.distance(t[e],t[r]))}for(;t.length>1;){let e=t.length,r=0,l=1,s=a[0][1];for(let t=1;t<e;t++)a[t].forEach(((e,a)=>{e<s&&(r=t,l=a,s=e)}));let n=t[r].leafCount(),i=t[l].leafCount();a.forEach(((e,s)=>{s!=l&&s!=r&&(e[r]=this.update(n,i,t[s].leafCount(),e[r],e[l],a[l][r]),a[r][s]=e[r],e.splice(l,1))})),a[r].splice(l,1),a.splice(l,1),t[r]=new Tree({distance:s},[t[r],t[l]]),t.splice(l,1)}this._root=t[0]}getClusters(e){const t=[this._root];for(;t.length<e;){let e=0,a=-1;for(let r=0;r<t.length;r++){const l=t[r];!l.isLeaf()&&l.value.distance>e&&(a=r,e=l.value.distance)}if(-1===a)break;const r=t[a];t.splice(a,1,r.at(0),r.at(1))}return t}predict(e){const t=[],a=this.getClusters(e);for(let e=0;e<a.length;e++){const r=a[e].leafValues();for(let a=0;a<r.length;a++)t[r[a].index]=e}return t}distance(e,t){throw new Error("Not Implemented")}_mean(e){const t=Array(e[0].length).fill(0);for(let a=0;a<e.length;a++)for(let r=0;r<e[a].length;r++)t[r]+=e[a][r];return t.map((t=>t/e.length))}_lanceWilliamsUpdater(e,t,a,r){return(l,s,n)=>e*l+t*s+a*n+r*Math.abs(l-s)}update(e,t,a,r,l,s){throw new Error("Not Implemented")}}export class CompleteLinkageHierarchyClustering extends HierarchyClustering{distance(e,t){let a=e.leafValues(),r=t.leafValues();return Math.max.apply(null,a.map((e=>Math.max.apply(null,r.map((t=>e.distances[t.index]))))))}update(e,t,a,r,l,s){return this._lanceWilliamsUpdater(.5,.5,0,.5)(r,l,s)}}export class SingleLinkageHierarchyClustering extends HierarchyClustering{distance(e,t){let a=e.leafValues(),r=t.leafValues();return Math.min.apply(null,a.map((e=>Math.min.apply(null,r.map((t=>e.distances[t.index]))))))}update(e,t,a,r,l,s){return this._lanceWilliamsUpdater(.5,.5,0,-.5)(r,l,s)}}export class GroupAverageHierarchyClustering extends HierarchyClustering{distance(e,t){let a=e.leafValues(),r=t.leafValues();return a.reduce(((e,t)=>e+r.reduce(((e,a)=>e+t.distances[a.index]),0)),0)/(a.length*r.length)}update(e,t,a,r,l,s){return this._lanceWilliamsUpdater(e/(e+t),t/(e+t),0,0)(r,l,s)}}export class WardsHierarchyClustering extends HierarchyClustering{distance(e,t){let a=e.leafValues().map((e=>e.point)),r=t.leafValues().map((e=>e.point)),l=a.concat(r),s=this._mean(a),n=this._mean(r),i=this._mean(l),u=a.reduce(((e,t)=>e+this._d(t,s)**2),0),c=r.reduce(((e,t)=>e+this._d(t,n)**2),0);return l.reduce(((e,t)=>e+this._d(t,i)**2),0)-u-c}update(e,t,a,r,l,s){return this._lanceWilliamsUpdater((a+e)/(a+e+t),(a+t)/(a+e+t),-a/(a+e+t),0)(r,l,s)}}export class CentroidHierarchyClustering extends HierarchyClustering{distance(e,t){let a=e.leafValues().map((e=>e.point)),r=t.leafValues().map((e=>e.point)),l=this._d(this._mean(a),this._mean(r));return l*l}update(e,t,a,r,l,s){return this._lanceWilliamsUpdater(e/(e+t),t/(e+t),-e*t/((e+t)*(e+t)),0)(r,l,s)}}export class WeightedAverageHierarchyClustering extends HierarchyClustering{distance(e,t){return function e(t,a){return 1===t.leafCount()&&1===a.leafCount()?t.value.distances[a.value.index]:1===a.leafCount()?(e(a,t.at(0))+e(a,t.at(1)))/2:(e(t,a.at(0))+e(t,a.at(1)))/2}(e,t)}update(e,t,a,r,l,s){return this._lanceWilliamsUpdater(.5,.5,0,0)(r,l,s)}}export class MedianHierarchyClustering extends HierarchyClustering{distance(e,t){let a=this._mean(e.leafValues().map((e=>e.point))),r=this._mean(t.leafValues().map((e=>e.point))),l=a.map(((e,t)=>(e+r[t])/2));return this._d(l,r)**2}update(e,t,a,r,l,s){return this._lanceWilliamsUpdater(.5,.5,-.25,0)(r,l,s)}}