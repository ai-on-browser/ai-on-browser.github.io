var E=Object.defineProperty;var v=(o,i)=>E(o,"name",{value:i,configurable:!0});const S={gaussian:(o=1)=>(i,n)=>{let _=i.reduce((t,l,k)=>t+(l-n[k])**2,0);return Math.exp(-_/(2*o*o))},linear:()=>(o,i)=>o.reduce((n,_,t)=>n+_*i[t],0)};export default class F{static{v(this,"SVM")}constructor(i){this._n=0,this._a=[],this._x=[],this._t=[],this._b=0,this._C=1e3,this._eps=.001,this._tolerance=.001,this._err=[],typeof i=="function"?this._kernel=i:(typeof i=="string"&&(i={name:i}),i.name==="gaussian"?this._kernel=S.gaussian(i.d):this._kernel=S.linear())}init(i,n){this._n=i.length,this._a=Array(this._n).fill(0),this._x=i.map(_=>_),this._t=n,this._err=Array(this._n).fill(0),this._alldata=!0}fit(){let i=this._fitOnce(this._alldata);if(this._alldata){if(this._alldata=!1,i===0)return}else i===0&&(this._alldata=!0)}_fitOnce(i=!1){let n=0;const _=v(t=>this._eps<t&&t<this._C-this._eps,"between_eps");for(let t=0;t<this._n;t++){let l=0;if(_(this._a[t]))l=this._err[t];else if(i)l=this._predict1(this._x[t])-this._t[t];else continue;const k=l*this._t[t];if((this._a[t]>=this._C-this._eps||k>=-this._tolerance)&&(this._a[t]<=this._eps||k<=this._tolerance))continue;let A=0,b=-1;const V=Math.floor(Math.random()*(this._n+1)),g=[],y=[];for(let f=0;f<this._n;f++){const s=(f+V)%this._n;if(s!==t)if(_(this._a[s])){const h=this._err[s];Math.abs(l-h)>A?(A=Math.abs(l-h),b>=0&&g.push(b),b=s):g.push(s)}else y.push(s)}const O=b>=0?[].concat(b,g,y):[].concat(g,y);for(let f=0;f<O.length;f++){const s=O[f],h=this._a[t],a=this._a[s];let p,u;if(this._t[t]!=this._t[s]?(p=Math.max(0,h-a),u=Math.min(this._C,this._C+h-a)):(p=Math.max(0,h+a-this._C),u=Math.min(this._C,h+a)),p===u)continue;const j=this._kernel(this._x[t],this._x[t]),m=this._kernel(this._x[s],this._x[s]),c=this._kernel(this._x[t],this._x[s]),K=j+m-2*c,w=_(this._a[s])?this._err[s]:this._predict1(this._x[s])-this._t[s];let C=!1,e=0,x=0;if(K<=0){const r=[p,u].map(z=>{const d=z,M=a+this._t[t]*this._t[s]*(h-d);this._a[t]=d,this._a[s]=M;const B=this._predict1(this._x[s])+this._b-this._t[s]*a*m-this._t[t]*h*c,D=this._predict1(this._x[t])+this._b-this._t[s]*a*c-this._t[t]*h*j;return M+d-m*M**2/2-j*d**2/2-this._t[s]*this._t[t]*c*M*d-this._t[s]*M*B-this._t[t]*d*D});this._a[t]=h,this._a[s]=a,e=r[0]>r[1]+this._eps?p:r[0]<r[1]-this._eps?u:h,C=!0}else e=h+this._t[t]*(w-l)/K,e>u?(C=!0,e=u):e<p&&(C=!0,e=p);if(Math.abs(e-h)<this._eps*(e+h+this._eps))continue;x=a+this._t[t]*this._t[s]*(h-e);const q=this._b;_(this._a[t])?this._b+=l+(e-h)*this._t[t]*j+(x-a)*this._t[s]*c:_(this._a[s])?this._b+=w+(e-h)*this._t[t]*c+(x-a)*this._t[s]*m:this._b+=(l+w+(e-h)*this._t[t]*(j+c)+(x-a)*this._t[s]*(c+m))/2;for(let r=0;r<this._n;r++)r===t||r===s||(this._err[r]+=this._t[s]*(x-a)*this._kernel(this._x[s],this._x[r])+this._t[t]*(e-h)*this._kernel(this._x[t],this._x[r])+q-this._b);this._a[t]=e,this._a[s]=x,C?_(e)&&(this._err[t]=this._predict1(this._x[t])-this._t[t]):this._err[t]=0,this._err[s]=this._predict1(this._x[s])-this._t[s],n++;break}}return n}_predict1(i){let n=0;for(let _=0;_<this._n;_++)this._a[_]&&(n+=this._a[_]*this._t[_]*this._kernel(i,this._x[_]));return n-this._b}predict(i){return i.map(n=>this._predict1(n))}}
