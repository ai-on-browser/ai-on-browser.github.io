const Kernel={gaussian:(t=1)=>(s,i)=>{let h=s.reduce(((t,s,h)=>t+(s-i[h])**2),0);return Math.exp(-h/(2*t*t))},linear:()=>(t,s)=>t.reduce(((t,i,h)=>t+i*s[h]),0)};export default class SVM{constructor(t,s=[]){this._n=0,this._a=[],this._x=[],this._t=[],this._b=0,this._C=1e3,this._eps=.001,this._tolerance=.001,this._err=[],this._kernel=Kernel[t](...s)}init(t,s){this._n=t.length,this._a=Array(this._n).fill(0),this._x=t.map((t=>t)),this._t=s,this._err=Array(this._n).fill(0),this._alldata=!0}fit(){let t=this._fitOnce(this._alldata);if(this._alldata){if(this._alldata=!1,0===t)return}else 0===t&&(this._alldata=!0)}_fitOnce(t=!1){let s=0;const i=t=>this._eps<t&&t<this._C-this._eps;for(let h=0;h<this._n;h++){let _=0;if(i(this._a[h]))_=this._err[h];else{if(!t)continue;_=this._predict1(this._x[h])-this._t[h]}const e=_*this._t[h];if((this._a[h]>=this._C-this._eps||e>=-this._tolerance)&&(this._a[h]<=this._eps||e<=this._tolerance))continue;let r=0,a=-1;const n=Math.floor(Math.random()*(this._n+1)),l=[],c=[];for(let t=0;t<this._n;t++){const s=(t+n)%this._n;if(s!==h)if(i(this._a[s])){const t=this._err[s];Math.abs(_-t)>r?(r=Math.abs(_-t),a>=0&&l.push(a),a=s):l.push(s)}else c.push(s)}const o=a>=0?[].concat(a,l,c):[].concat(l,c);for(let t=0;t<o.length;t++){const e=o[t],r=this._a[h],a=this._a[e];let n,l;if(this._t[h]!=this._t[e]?(n=Math.max(0,r-a),l=Math.min(this._C,this._C+r-a)):(n=Math.max(0,r+a-this._C),l=Math.min(this._C,r+a)),n===l)continue;const c=this._kernel(this._x[h],this._x[h]),p=this._kernel(this._x[e],this._x[e]),x=this._kernel(this._x[h],this._x[e]),f=c+p-2*x,d=i(this._a[e])?this._err[e]:this._predict1(this._x[e])-this._t[e];let u=!1,b=0,M=0;if(f<=0){const t=[n,l].map((t=>{const s=t,i=a+this._t[h]*this._t[e]*(r-s);this._a[h]=s,this._a[e]=i;const _=this._predict1(this._x[e])+this._b-this._t[e]*a*p-this._t[h]*r*x,n=this._predict1(this._x[h])+this._b-this._t[e]*a*x-this._t[h]*r*c;return i+s-p*i**2/2-c*s**2/2-this._t[e]*this._t[h]*x*i*s-this._t[e]*i*_-this._t[h]*s*n}));this._a[h]=r,this._a[e]=a,b=t[0]>t[1]+this._eps?n:t[0]<t[1]-this._eps?l:r,u=!0}else b=r+this._t[h]*(d-_)/f,b>l?(u=!0,b=l):b<n&&(u=!0,b=n);if(Math.abs(b-r)<this._eps*(b+r+this._eps))continue;M=a+this._t[h]*this._t[e]*(r-b);const k=this._b;i(this._a[h])?this._b+=_+(b-r)*this._t[h]*c+(M-a)*this._t[e]*x:i(this._a[e])?this._b+=d+(b-r)*this._t[h]*x+(M-a)*this._t[e]*p:this._b+=(_+d+(b-r)*this._t[h]*(c+x)+(M-a)*this._t[e]*(x+p))/2;for(let t=0;t<this._n;t++)t!==h&&t!==e&&(this._err[t]+=this._t[e]*(M-a)*this._kernel(this._x[e],this._x[t])+this._t[h]*(b-r)*this._kernel(this._x[h],this._x[t])+k-this._b);this._a[h]=b,this._a[e]=M,u?i(b)&&(this._err[h]=this._predict1(this._x[h])-this._t[h]):this._err[h]=0,this._err[e]=this._predict1(this._x[e])-this._t[e],s++;break}}return s}_predict1(t){let s=0;for(let i=0;i<this._n;i++)this._a[i]&&(s+=this._a[i]*this._t[i]*this._kernel(t,this._x[i]));return s-this._b}predict(t){return t.map((t=>this._predict1(t)))}}