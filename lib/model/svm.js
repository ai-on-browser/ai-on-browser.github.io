var D=Object.defineProperty;var v=(o,i)=>D(o,"name",{value:i,configurable:!0});const E={gaussian:(o=1)=>(i,e)=>{let _=i.reduce((t,l,M)=>t+(l-e[M])**2,0);return Math.exp(-_/(2*o*o))},linear:()=>(o,i)=>o.reduce((e,_,t)=>e+_*i[t],0)};export default class F{static{v(this,"SVM")}constructor(i,e=[]){this._n=0,this._a=[],this._x=[],this._t=[],this._b=0,this._C=1e3,this._eps=.001,this._tolerance=.001,this._err=[],typeof i=="function"?this._kernel=i:this._kernel=E[i](...e)}init(i,e){this._n=i.length,this._a=Array(this._n).fill(0),this._x=i.map(_=>_),this._t=e,this._err=Array(this._n).fill(0),this._alldata=!0}fit(){let i=this._fitOnce(this._alldata);if(this._alldata){if(this._alldata=!1,i===0)return}else i===0&&(this._alldata=!0)}_fitOnce(i=!1){let e=0;const _=v(t=>this._eps<t&&t<this._C-this._eps,"between_eps");for(let t=0;t<this._n;t++){let l=0;if(_(this._a[t]))l=this._err[t];else if(i)l=this._predict1(this._x[t])-this._t[t];else continue;const M=l*this._t[t];if((this._a[t]>=this._C-this._eps||M>=-this._tolerance)&&(this._a[t]<=this._eps||M<=this._tolerance))continue;let A=0,b=-1;const S=Math.floor(Math.random()*(this._n+1)),C=[],y=[];for(let f=0;f<this._n;f++){const s=(f+S)%this._n;if(s!==t)if(_(this._a[s])){const h=this._err[s];Math.abs(l-h)>A?(A=Math.abs(l-h),b>=0&&C.push(b),b=s):C.push(s)}else y.push(s)}const O=b>=0?[].concat(b,C,y):[].concat(C,y);for(let f=0;f<O.length;f++){const s=O[f],h=this._a[t],a=this._a[s];let p,u;if(this._t[t]!=this._t[s]?(p=Math.max(0,h-a),u=Math.min(this._C,this._C+h-a)):(p=Math.max(0,h+a-this._C),u=Math.min(this._C,h+a)),p===u)continue;const j=this._kernel(this._x[t],this._x[t]),k=this._kernel(this._x[s],this._x[s]),c=this._kernel(this._x[t],this._x[s]),K=j+k-2*c,w=_(this._a[s])?this._err[s]:this._predict1(this._x[s])-this._t[s];let g=!1,n=0,x=0;if(K<=0){const r=[p,u].map(q=>{const d=q,m=a+this._t[t]*this._t[s]*(h-d);this._a[t]=d,this._a[s]=m;const z=this._predict1(this._x[s])+this._b-this._t[s]*a*k-this._t[t]*h*c,B=this._predict1(this._x[t])+this._b-this._t[s]*a*c-this._t[t]*h*j;return m+d-k*m**2/2-j*d**2/2-this._t[s]*this._t[t]*c*m*d-this._t[s]*m*z-this._t[t]*d*B});this._a[t]=h,this._a[s]=a,n=r[0]>r[1]+this._eps?p:r[0]<r[1]-this._eps?u:h,g=!0}else n=h+this._t[t]*(w-l)/K,n>u?(g=!0,n=u):n<p&&(g=!0,n=p);if(Math.abs(n-h)<this._eps*(n+h+this._eps))continue;x=a+this._t[t]*this._t[s]*(h-n);const V=this._b;_(this._a[t])?this._b+=l+(n-h)*this._t[t]*j+(x-a)*this._t[s]*c:_(this._a[s])?this._b+=w+(n-h)*this._t[t]*c+(x-a)*this._t[s]*k:this._b+=(l+w+(n-h)*this._t[t]*(j+c)+(x-a)*this._t[s]*(c+k))/2;for(let r=0;r<this._n;r++)r===t||r===s||(this._err[r]+=this._t[s]*(x-a)*this._kernel(this._x[s],this._x[r])+this._t[t]*(n-h)*this._kernel(this._x[t],this._x[r])+V-this._b);this._a[t]=n,this._a[s]=x,g?_(n)&&(this._err[t]=this._predict1(this._x[t])-this._t[t]):this._err[t]=0,this._err[s]=this._predict1(this._x[s])-this._t[s],e++;break}}return e}_predict1(i){let e=0;for(let _=0;_<this._n;_++)this._a[_]&&(e+=this._a[_]*this._t[_]*this._kernel(i,this._x[_]));return e-this._b}predict(i){return i.map(e=>this._predict1(e))}}
