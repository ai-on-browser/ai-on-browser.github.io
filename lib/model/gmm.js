var k=Object.defineProperty;var f=(u,t)=>k(u,"name",{value:t,configurable:!0});import r from"../util/matrix.js";export class GMM{static{f(this,"GMM")}constructor(){this._k=0,this._d=null,this._p=[],this._m=[],this._s=[]}_init(t){if(!this._d){this._d=t[0].length;for(let h=0;h<this._k;h++)this.add(),this._k--}}add(){if(this._k++,this._d){this._p.push(Math.random()),this._m.push(r.random(this._d,1));const t=r.randn(this._d,this._d);this._s.push(t.tDot(t))}}clear(){this._k=0,this._p=[],this._m=[],this._s=[]}probability(t){return this._init(t),t.map(h=>{const n=new r(this._d,1,h),s=[];for(let _=0;_<this._k;_++){const i=this._gaussian(n,this._m[_],this._s[_])*this._p[_];s.push(i)}return s})}predict(t){return this._init(t),t.map(h=>{const n=new r(this._d,1,h);let s=0,_=-1;for(let i=0;i<this._k;i++){const e=this._gaussian(n,this._m[i],this._s[i]);e>s&&(s=e,_=i)}return _})}_gaussian(t,h,n){const s=r.sub(t,h);return Math.exp(-.5*s.tDot(n.inv()).dot(s).toScaler())/(Math.sqrt(2*Math.PI)**this._d*Math.sqrt(n.det()))}fit(t){this._init(t);const h=t.length,n=[],s=Array(this._k).fill(0),_=[];t.forEach(i=>{const e=[];let l=0;const d=new r(this._d,1,i);for(let c=0;c<this._k;c++){const p=this._gaussian(d,this._m[c],this._s[c])*this._p[c];e.push(p||0),l+=p||0}const o=e.map(c=>c/(l||1));n.push(o),_.push(d),o.forEach((c,p)=>{s[p]+=c})});for(let i=0;i<this._k;i++){const e=new r(this._d,1);for(let d=0;d<h;d++)e.add(r.mult(_[d],n[d][i]));e.div(s[i]),this._m[i]=e;const l=new r(this._d,this._d);for(let d=0;d<h;d++){let o=r.sub(_[d],e);o=o.dot(o.t),o.mult(n[d][i]),l.add(o)}l.div(s[i]),l.add(r.eye(this._d,this._d,1e-8)),this._s[i]=l,this._p[i]=s[i]/h}}}export class SemiSupervisedGMM extends GMM{static{f(this,"SemiSupervisedGMM")}constructor(){super()}get categories(){return this._classes}init(t,h){this.clear(),this._init(t),this._classes=[...new Set(h.filter(n=>n!=null))];for(let n=0;n<this._classes.length;n++)super.add()}add(){}fit(t,h){this._init(t);const n=t.length,s=[],_=Array(this._k).fill(0),i=[];t.forEach((e,l)=>{const d=[];let o=0;const c=new r(this._d,1,e);for(let a=0;a<this._k;a++){const m=this._classes.indexOf(h[l]);let x=0;m<0?x=this._gaussian(c,this._m[a],this._s[a])*this._p[a]:x=m===a?1:0,d.push(x||0),o+=x||0}const p=d.map(a=>a/(o||1));s.push(p),i.push(c),p.forEach((a,m)=>{_[m]+=a})});for(let e=0;e<this._k;e++){const l=new r(this._d,1);for(let o=0;o<n;o++)l.add(r.mult(i[o],s[o][e]));l.div(_[e]),this._m[e]=l;const d=new r(this._d,this._d);for(let o=0;o<n;o++){let c=r.sub(i[o],l);c=c.dot(c.t),c.mult(s[o][e]),d.add(c)}d.div(_[e]),d.add(r.eye(this._d,this._d,1e-8)),this._s[e]=d,this._p[e]=_[e]/n}}predict(t){return super.predict(t).map(h=>this._classes[h])}}export class GMR extends GMM{static{f(this,"GMR")}constructor(){super(),this._input_d=0,this._mx=[],this._my=[],this._sxx=[],this._sxy=[]}add(){if(super.add(),this._mx.length<this._m.length)for(let t=this._mx.length;t<this._m.length;t++)this._mx[t]=this._m[t].slice(0,this._input_d),this._my[t]=this._m[t].slice(this._input_d),this._sxx[t]=this._s[t].block(0,0,this._input_d,this._input_d),this._sxy[t]=this._s[t].block(this._input_d,0,null,this._input_d)}clear(){super.clear(),this._mx=[],this._my=[],this._sxx=[],this._sxy=[]}fit(t,h){this._input_d=t[0].length;const n=t.map((s,_)=>s.concat(h[_]));super.fit(n),this._mx=this._m.map(s=>s.slice(0,this._input_d)),this._my=this._m.map(s=>s.slice(this._input_d)),this._sxx=this._s.map(s=>s.block(0,0,this._input_d,this._input_d)),this._sxy=this._s.map(s=>s.block(0,this._input_d,this._input_d,null))}probability(t,h){const n=t.map((s,_)=>s.concat(h[_]));return super.probability(n)}predict(t){if(this._mx.length===0)return[];t=r.fromArray(t);const h=new r(t.rows,this._k);for(let s=0;s<t.rows;s++){const _=t.row(s).t;for(let i=0;i<this._k;i++){const e=this._gaussian(_,this._mx[i],this._sxx[i])*this._p[i];h.set(s,i,e)}}h.div(h.sum(1));const n=new r(t.rows,this._my[0].cols);for(let s=0;s<this._k;s++){const _=r.sub(t,this._mx[s].t).dot(this._sxx[s].inv()).dot(this._sxy[s]);_.add(this._my[s]),_.mult(h.col(s)),n.add(_)}return n.toArray()}}
