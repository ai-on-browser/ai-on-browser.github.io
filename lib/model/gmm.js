var k=Object.defineProperty;var f=(u,t)=>k(u,"name",{value:t,configurable:!0});import o from"../util/matrix.js";export class GMM{static{f(this,"GMM")}constructor(){this._k=0,this._d=null,this._p=[],this._m=[],this._s=[]}_init(t){if(!this._d){this._d=t[0].length;for(let h=0;h<this._k;h++)this.add(),this._k--}}add(){if(this._k++,this._d){this._p.push(Math.random()),this._m.push(o.random(this._d,1));const t=o.randn(this._d,this._d);this._s.push(t.tDot(t))}}clear(){this._k=0,this._p=[],this._m=[],this._s=[]}probability(t){return this._init(t),t.map(h=>{const n=new o(this._d,1,h),s=[];for(let _=0;_<this._k;_++){const i=this._gaussian(n,this._m[_],this._s[_])*this._p[_];s.push(i)}return s})}predict(t){return this._init(t),t.map(h=>{const n=new o(this._d,1,h);let s=0,_=-1;for(let i=0;i<this._k;i++){let e=this._gaussian(n,this._m[i],this._s[i]);e>s&&(s=e,_=i)}return _})}_gaussian(t,h,n){const s=o.sub(t,h);return Math.exp(-.5*s.tDot(n.inv()).dot(s).toScaler())/(Math.sqrt(2*Math.PI)**this._d*Math.sqrt(n.det()))}fit(t){this._init(t);const h=t.length,n=[],s=Array(this._k).fill(0),_=[];t.forEach(i=>{const e=[];let c=0;const d=new o(this._d,1,i);for(let l=0;l<this._k;l++){const p=this._gaussian(d,this._m[l],this._s[l])*this._p[l];e.push(p||0),c+=p||0}const r=e.map(l=>l/(c||1));n.push(r),_.push(d),r.forEach((l,p)=>s[p]+=l)});for(let i=0;i<this._k;i++){const e=new o(this._d,1);for(let d=0;d<h;d++)e.add(o.mult(_[d],n[d][i]));e.div(s[i]),this._m[i]=e;const c=new o(this._d,this._d);for(let d=0;d<h;d++){let r=o.sub(_[d],e);r=r.dot(r.t),r.mult(n[d][i]),c.add(r)}c.div(s[i]),c.add(o.eye(this._d,this._d,1e-8)),this._s[i]=c,this._p[i]=s[i]/h}}}export class SemiSupervisedGMM extends GMM{static{f(this,"SemiSupervisedGMM")}constructor(){super()}get categories(){return this._classes}init(t,h){this.clear(),this._init(t),this._classes=[...new Set(h.filter(n=>n!=null))];for(let n=0;n<this._classes.length;n++)super.add()}add(){}fit(t,h){this._init(t);const n=t.length,s=[],_=Array(this._k).fill(0),i=[];t.forEach((e,c)=>{const d=[];let r=0;const l=new o(this._d,1,e);for(let a=0;a<this._k;a++){const m=this._classes.indexOf(h[c]);let x=0;m<0?x=this._gaussian(l,this._m[a],this._s[a])*this._p[a]:x=m===a?1:0,d.push(x||0),r+=x||0}const p=d.map(a=>a/(r||1));s.push(p),i.push(l),p.forEach((a,m)=>_[m]+=a)});for(let e=0;e<this._k;e++){const c=new o(this._d,1);for(let r=0;r<n;r++)c.add(o.mult(i[r],s[r][e]));c.div(_[e]),this._m[e]=c;const d=new o(this._d,this._d);for(let r=0;r<n;r++){let l=o.sub(i[r],c);l=l.dot(l.t),l.mult(s[r][e]),d.add(l)}d.div(_[e]),d.add(o.eye(this._d,this._d,1e-8)),this._s[e]=d,this._p[e]=_[e]/n}}predict(t){return super.predict(t).map(h=>this._classes[h])}}export class GMR extends GMM{static{f(this,"GMR")}constructor(){super(),this._input_d=0,this._mx=[],this._my=[],this._sxx=[],this._sxy=[]}add(){if(super.add(),this._mx.length<this._m.length)for(let t=this._mx.length;t<this._m.length;t++)this._mx[t]=this._m[t].slice(0,this._input_d),this._my[t]=this._m[t].slice(this._input_d),this._sxx[t]=this._s[t].block(0,0,this._input_d,this._input_d),this._sxy[t]=this._s[t].block(this._input_d,0,null,this._input_d)}clear(){super.clear(),this._mx=[],this._my=[],this._sxx=[],this._sxy=[]}fit(t,h){this._input_d=t[0].length;const n=t.map((s,_)=>s.concat(h[_]));super.fit(n),this._mx=this._m.map(s=>s.slice(0,this._input_d)),this._my=this._m.map(s=>s.slice(this._input_d)),this._sxx=this._s.map(s=>s.block(0,0,this._input_d,this._input_d)),this._sxy=this._s.map(s=>s.block(0,this._input_d,this._input_d,null))}probability(t,h){const n=t.map((s,_)=>s.concat(h[_]));return super.probability(n)}predict(t){if(this._mx.length===0)return[];t=o.fromArray(t);const h=new o(t.rows,this._k);for(let s=0;s<t.rows;s++){const _=t.row(s).t;for(let i=0;i<this._k;i++){const e=this._gaussian(_,this._mx[i],this._sxx[i])*this._p[i];h.set(s,i,e)}}h.div(h.sum(1));const n=new o(t.rows,this._my[0].cols);for(let s=0;s<this._k;s++){const _=o.sub(t,this._mx[s].t).dot(this._sxx[s].inv()).dot(this._sxy[s]);_.add(this._my[s]),_.mult(h.col(s)),n.add(_)}return n.toArray()}}
