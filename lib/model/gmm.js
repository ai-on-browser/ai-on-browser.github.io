import Matrix from"../util/matrix.js";export class GMM{constructor(){this._k=0,this._d=null,this._p=[],this._m=[],this._s=[]}_init(t){if(!this._d){this._d=t[0].length;for(let t=0;t<this._k;t++)this.add(),this._k--}}add(){if(this._k++,this._d){this._p.push(Math.random()),this._m.push(Matrix.random(this._d,1));const t=Matrix.randn(this._d,this._d);this._s.push(t.tDot(t))}}clear(){this._k=0,this._p=[],this._m=[],this._s=[]}probability(t){return this._init(t),t.map((t=>{const s=new Matrix(this._d,1,t),i=[];for(let t=0;t<this._k;t++){const h=this._gaussian(s,this._m[t],this._s[t])*this._p[t];i.push(h)}return i}))}predict(t){return this._init(t),t.map((t=>{const s=new Matrix(this._d,1,t);let i=0,h=-1;for(let t=0;t<this._k;t++){let _=this._gaussian(s,this._m[t],this._s[t]);_>i&&(i=_,h=t)}return h}))}_gaussian(t,s,i){const h=t.copySub(s);return Math.exp(-.5*h.tDot(i.inv()).dot(h).toScaler())/(Math.sqrt(2*Math.PI)**this._d*Math.sqrt(i.det()))}fit(t){this._init(t);const s=t.length,i=[],h=Array(this._k).fill(0),_=[];t.forEach((t=>{const s=[];let r=0;const e=new Matrix(this._d,1,t);for(let t=0;t<this._k;t++){const i=this._gaussian(e,this._m[t],this._s[t])*this._p[t];s.push(i||0),r+=i||0}const n=s.map((t=>t/(r||1)));i.push(n),_.push(e),n.forEach(((t,s)=>h[s]+=t))}));for(let t=0;t<this._k;t++){const r=new Matrix(this._d,1);for(let h=0;h<s;h++)r.add(_[h].copyMult(i[h][t]));r.div(h[t]),this._m[t]=r;const e=new Matrix(this._d,this._d);for(let h=0;h<s;h++){let s=_[h].copySub(r);s=s.dot(s.t),s.mult(i[h][t]),e.add(s)}e.div(h[t]),e.add(Matrix.eye(this._d,this._d,1e-8)),this._s[t]=e,this._p[t]=h[t]/s}}}export class SemiSupervisedGMM extends GMM{constructor(){super()}get categories(){return this._classes}init(t,s){this.clear(),this._init(t),this._classes=[...new Set(s.filter((t=>null!=t)))];for(let t=0;t<this._classes.length;t++)super.add()}add(){}fit(t,s){this._init(t);const i=t.length,h=[],_=Array(this._k).fill(0),r=[];t.forEach(((t,i)=>{const e=[];let n=0;const o=new Matrix(this._d,1,t);for(let t=0;t<this._k;t++){const h=this._classes.indexOf(s[i]);let _=0;_=h<0?this._gaussian(o,this._m[t],this._s[t])*this._p[t]:h===t?1:0,e.push(_||0),n+=_||0}const a=e.map((t=>t/(n||1)));h.push(a),r.push(o),a.forEach(((t,s)=>_[s]+=t))}));for(let t=0;t<this._k;t++){const s=new Matrix(this._d,1);for(let _=0;_<i;_++)s.add(r[_].copyMult(h[_][t]));s.div(_[t]),this._m[t]=s;const e=new Matrix(this._d,this._d);for(let _=0;_<i;_++){let i=r[_].copySub(s);i=i.dot(i.t),i.mult(h[_][t]),e.add(i)}e.div(_[t]),e.add(Matrix.eye(this._d,this._d,1e-8)),this._s[t]=e,this._p[t]=_[t]/i}}predict(t){return super.predict(t).map((t=>this._classes[t]))}}export class GMR extends GMM{constructor(){super(),this._input_d=0,this._mx=[],this._my=[],this._sxx=[],this._sxy=[]}add(){if(super.add(),this._mx.length<this._m.length)for(let t=this._mx.length;t<this._m.length;t++)this._mx[t]=this._m[t].slice(0,this._input_d),this._my[t]=this._m[t].slice(this._input_d),this._sxx[t]=this._s[t].block(0,0,this._input_d,this._input_d),this._sxy[t]=this._s[t].block(this._input_d,0,null,this._input_d)}clear(){super.clear(),this._mx=[],this._my=[],this._sxx=[],this._sxy=[]}fit(t,s){this._input_d=t[0].length;const i=t.map(((t,i)=>t.concat(s[i])));super.fit(i),this._mx=this._m.map((t=>t.slice(0,this._input_d))),this._my=this._m.map((t=>t.slice(this._input_d))),this._sxx=this._s.map((t=>t.block(0,0,this._input_d,this._input_d))),this._sxy=this._s.map((t=>t.block(0,this._input_d,this._input_d,null)))}probability(t,s){const i=t.map(((t,i)=>t.concat(s[i])));return super.probability(i)}predict(t){if(0===this._mx.length)return[];t=Matrix.fromArray(t);const s=new Matrix(t.rows,this._k);for(let i=0;i<t.rows;i++){const h=t.row(i).t;for(let t=0;t<this._k;t++){const _=this._gaussian(h,this._mx[t],this._sxx[t])*this._p[t];s.set(i,t,_)}}s.div(s.sum(1));const i=new Matrix(t.rows,this._my[0].cols);for(let h=0;h<this._k;h++){const _=t.copySub(this._mx[h].t).dot(this._sxx[h].inv()).dot(this._sxy[h]);_.add(this._my[h]),_.mult(s.col(h)),i.add(_)}return i.toArray()}}