import NeuralNetwork from"./neuralnetwork.js";export default class LadderNetwork{constructor(e,t,a,n){this._hidden_sizes=e,this._lambdas=t,this._activation=a,this._optimizer=n,this._noise_std=Array(this._hidden_sizes.length+2).fill(.001),this._model=null,this._classes=null,this._optimizer=n,this._epoch=0}get epoch(){return this._epoch}_build(){const e=[...this._hidden_sizes,this._classes.length];this._layers=[{type:"input",name:"x"},{type:"linear",name:"z_0"},{type:"random",size:"x",variance:this._noise_std[0]**2,name:"noize"},{type:"add",input:["x","noize"],name:"zt_0"},{type:"mean",input:"x",name:"mean_0"},{type:"std",input:"x",name:"std_0"},{type:"concat",input:["z_0","zt_0"],axis:0}];for(let t=0;t<e.length;t++){const a=t+1;this._layers.push({type:"full",out_size:e[t]},{type:"split",size:2,axis:0,name:`zpre_${a}`},{type:"batch_normalization",input:`zpre_${a}[1]`,name:`ztbn_${a}`},{type:"random",size:`ztbn_${a}`,variance:this._noise_std[a]**2,name:`noize_${a}`},{type:"add",input:[`ztbn_${a}`,`noize_${a}`],name:`zt_${a}`},{type:"mean",input:`zpre_${a}[0]`,name:`mean_${a}`},{type:"std",input:`zpre_${a}[0]`,name:`std_${a}`},{type:"batch_normalization",input:`zpre_${a}[0]`,name:`z_${a}`},{type:"concat",input:[`z_${a}`,`zt_${a}`],axis:0,name:`zcon_${a}`},{type:"variable",size:[1,e[t]],name:`b_${a}`},{type:"add",input:[`zcon_${a}`,`b_${a}`],name:`hadd_${a}`},{type:"variable",size:[1,e[t]],name:`g_${a}`},{type:"mult",input:[`hadd_${a}`,`g_${a}`]},{type:this._activation})}this._layers.push({type:"split",size:2,axis:0,name:"reduced"},{type:"softmax",input:"reduced[0]",name:"predict"},{type:"linear",input:"reduced[1]"});for(let t=e.length;t>=0;t--){const a=0===t?"x":e[t-1];t===e.length?this._layers.push({type:"batch_normalization",name:`u_${t}`}):this._layers.push({type:"full",out_size:a,input:`zh_${t+1}`},{type:"batch_normalization",name:`u_${t}`}),this._layers.push({type:"variable",size:`mean_${t}`,name:`a1_${t}`},{type:"variable",size:`mean_${t}`,name:`a2_${t}`},{type:"variable",size:`mean_${t}`,name:`a3_${t}`},{type:"variable",size:`mean_${t}`,name:`a4_${t}`},{type:"variable",size:`mean_${t}`,name:`a5_${t}`},{type:"variable",size:`mean_${t}`,name:`a6_${t}`},{type:"variable",size:`mean_${t}`,name:`a7_${t}`},{type:"variable",size:`mean_${t}`,name:`a8_${t}`},{type:"variable",size:`mean_${t}`,name:`a9_${t}`},{type:"variable",size:`mean_${t}`,name:`a0_${t}`},{type:"mult",input:[`a2_${t}`,`u_${t}`],name:`m1_${t}`},{type:"add",input:[`a3_${t}`,`m1_${t}`]},{type:"sigmoid",name:`m2_${t}`},{type:"mult",input:[`a1_${t}`,`m2_${t}`],name:`m3_${t}`},{type:"mult",input:[`a4_${t}`,`u_${t}`],name:`m4_${t}`},{type:"add",input:[`a5_${t}`,`m3_${t}`,`m4_${t}`],name:`m_${t}`},{type:"mult",input:[`a7_${t}`,`u_${t}`],name:`v1_${t}`},{type:"add",input:[`a8_${t}`,`v1_${t}`]},{type:"sigmoid",name:`v2_${t}`},{type:"mult",input:[`a6_${t}`,`v2_${t}`],name:`v3_${t}`},{type:"mult",input:[`a9_${t}`,`u_${t}`],name:`v4_${t}`},{type:"add",input:[`a0_${t}`,`v3_${t}`,`v4_${t}`],name:`v_${t}`},{type:"sub",input:[`zt_${t}`,`m_${t}`],name:`zh1_${t}`},{type:"mult",input:[`zh1_${t}`,`v_${t}`],name:`zh2_${t}`},{type:"add",input:[`zh2_${t}`,`m_${t}`],name:`zh_${t}`},{type:"sub",input:[`zh_${t}`,`mean_${t}`],name:`zhbn1_${t}`},{type:"div",input:[`zhbn1_${t}`,`std_${t}`],name:`zhbn_${t}`})}this._layers.push({type:"output",name:"reconstruct"},{type:"supervisor",name:"t"},{type:"sub",input:["t","predict"]},{type:"square"},{type:"sum",axis:1},{type:"mean",name:"cc0"},{type:"input",name:"is_labeled"},{type:"mult",input:["cc0","is_labeled"],name:"cc"});const t=["cc"];for(let a=0;a<=e.length;a++)this._layers.push({type:"sub",input:[`z_${a}`,`zhbn_${a}`]},{type:"square"},{type:"sum",axis:1},{type:"mean",name:`cl_${a}`},{type:"mult",input:[this._lambdas[a],`cl_${a}`],name:`wcl_${a}`}),t.push(`wcl_${a}`);return this._layers.push({type:"add",input:t}),NeuralNetwork.fromObject(this._layers,null,"adam")}fit(e,t,a,n,i){if(!this._classes){const e=new Set;for(let a=0;a<t.length;a++)null!=t[a]&&e.add(t[a]);this._classes=[...e]}this._model||(this._model=this._build());let _=null,s=null;const p=e.filter(((e,a)=>null!=t[a]));if(p.length>0){const e=t.filter((e=>null!=e)).map((e=>{const t=Array(this._classes.length).fill(0);return t[this._classes.indexOf(e)]=1,t}));_=this._model.fit({x:p,is_labeled:[[1]]},e,a,n,i)}const l=e.filter(((e,a)=>null==t[a]));return l.length>0&&(s=this._model.fit({x:l,is_labeled:[[0]]},[[0]],a,n,i)),this._epoch+=a,{labeledLoss:_?.[0],unlabeledLoss:s?.[0]}}predict(e){return this._model.calc({x:e,is_labeled:null},null,["predict"]).predict.argmax(1).value.map((e=>this._classes[e]))}}