const levinsonDurbin=(t,s)=>{let h=[],i=[];for(let t=0;t<s+1;t++)h.push(0),i.push(0);h[0]=1,h[1]=-t[1]/t[0],i[1]=t[0]+t[1]*h[1];let r=-t[1]/t[0];for(let _=1;_<s;_++){r=0;for(let s=0;s<_+1;s++)r-=h[s]*t[_+1-s];r/=i[_];const s=[1];for(let t=1;t<_+1;t++)s.push(h[t]);s.push(0);const e=[0];for(let t=_;t>0;t--)e.push(h[t]);e.push(1),h=[];for(let t=0;t<s.length;t++)h.push(s[t]+r*e[t]);i[_+1]=i[_]*(1-r**2)}return[h,i[i.length-1]]};export class SDAR{constructor(t=1,s=.8){this._m=Math.random(),this._c=[];for(let s=0;s<t+1;s++)this._c.push(Math.random()/100);this._w=null,this._s=Math.random(),this._r=s,this._p=t,this._x=[]}_update(t){this._m=(1-this._r)*this._m+this._r*t;const s=this._c[this._c.length-1];this._c.unshift((1-this._r)*s+this._r*(t-this._m)**2),this._c.pop();const[h,i]=levinsonDurbin(this._c,this._p);let r=0;for(let t=0;t<h.length&&t<this._x.length;t++)r-=h[t]*(this._x[this._x.length-t-1]-this._m);const _=r+this._m;return this._x.push(t),this._s=(1-this._r)*this._s+this._r*(t-_)**2,[Math.exp(-.5*(t-_)**2/this._s)/Math.sqrt(2*Math.PI*this._s),_]}probability(t){return t.map((t=>{const[s,h]=this._update(t);return s}))}predict(t,s){for(let s=0;s<t.length-1;s++)this._update(t[s]);const h=[];let i=t[t.length-1];for(let t=0;t<s;t++){const[t,s]=this._update(i);h.push(s),i=s}return h}}