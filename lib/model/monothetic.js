export default class MonotheticClustering{constructor(){}get size(){return this._c.leafs.length}init(e){this._x=e,this._d=e[0].length;const t=e.map(((e,t)=>t));this._c={index:t,values:this._x,children:[],get leafs(){return 0===this.children.length?[this]:[...this.children[0].leafs,...this.children[1].leafs]}}}_distance2(e,t){return e.reduce(((e,i,l)=>e+(i-t[l])**2),0)}_inertia(e){const t=e[0].concat();for(let i=1;i<e.length;i++)for(let l=0;l<this._d;l++)t[l]+=e[i][l];for(let i=0;i<this._d;i++)t[i]/=e.length;let i=0;for(let l=0;l<e.length;l++)i+=this._distance2(e[l],t);return i}fit(){const e=this._c.leafs;let t=-1/0,i=-1,l=-1,s=null;for(let n=0;n<e.length;n++){const r=e[n].values,h=this._inertia(r);for(let c=0;c<this._d;c++){const a=r.map((e=>e[c]));a.sort(((e,t)=>e-t));for(let d=0;d<a.length-1;d++){const f=(a[d]+a[d+1])/2,o=r.filter((e=>e[c]<=f)),u=r.filter((e=>e[c]>f)),g=h-this._inertia(o)-this._inertia(u);t<g&&(t=g,i=c,l=f,s=e[n])}}}s.feature=i,s.threshold=l,s.children=[{index:s.index.filter(((e,t)=>s.values[t][i]<=l)),values:s.values.filter((e=>e[i]<=l)),children:[],get leafs(){return 0===this.children.length?[this]:[...this.children[0].leafs,...this.children[1].leafs]}},{index:s.index.filter(((e,t)=>s.values[t][i]>l)),values:s.values.filter((e=>e[i]>l)),children:[],get leafs(){return 0===this.children.length?[this]:[...this.children[0].leafs,...this.children[1].leafs]}}]}predict(){const e=this._c.leafs,t=[];for(let i=0;i<e.length;i++)for(let l=0;l<e[i].index.length;l++)t[e[i].index[l]]=i;return t}}