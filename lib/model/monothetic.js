var m=Object.defineProperty;var _=(o,e)=>m(o,"name",{value:e,configurable:!0});export default class b{static{_(this,"MonotheticClustering")}constructor(){}get size(){return this._c.leafs.length}init(e){this._x=e,this._d=e[0].length;const s=e.map((i,t)=>t);this._c={index:s,values:this._x,children:[],get leafs(){return this.children.length===0?[this]:[...this.children[0].leafs,...this.children[1].leafs]}}}_distance2(e,s){return e.reduce((i,t,l)=>i+(t-s[l])**2,0)}_inertia(e){const s=e[0].concat();for(let t=1;t<e.length;t++)for(let l=0;l<this._d;l++)s[l]+=e[t][l];for(let t=0;t<this._d;t++)s[t]/=e.length;let i=0;for(let t=0;t<e.length;t++)i+=this._distance2(e[t],s);return i}fit(){const e=this._c.leafs;let s=-1/0,i=-1,t=-1,l=null;for(let n=0;n<e.length;n++){const r=e[n].values,g=this._inertia(r);for(let c=0;c<this._d;c++){const d=r.map(h=>h[c]);d.sort((h,f)=>h-f);for(let h=0;h<d.length-1;h++){const f=(d[h]+d[h+1])/2,x=r.filter(a=>a[c]<=f),v=r.filter(a=>a[c]>f),k=this._inertia(x),p=this._inertia(v),u=g-k-p;s<u&&(s=u,i=c,t=f,l=e[n])}}}l.feature=i,l.threshold=t,l.children=[{index:l.index.filter((n,r)=>l.values[r][i]<=t),values:l.values.filter(n=>n[i]<=t),children:[],get leafs(){return this.children.length===0?[this]:[...this.children[0].leafs,...this.children[1].leafs]}},{index:l.index.filter((n,r)=>l.values[r][i]>t),values:l.values.filter(n=>n[i]>t),children:[],get leafs(){return this.children.length===0?[this]:[...this.children[0].leafs,...this.children[1].leafs]}}]}predict(){const e=this._c.leafs,s=[];for(let i=0;i<e.length;i++)for(let t=0;t<e[i].index.length;t++)s[e[i].index[t]]=i;return s}}
