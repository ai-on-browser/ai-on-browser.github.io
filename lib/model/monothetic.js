export default class MonotheticClustering{constructor(){}get size(){return this._leafs().length}init(t){this._x=t,this._d=t[0].length;const e=[];for(let l=0;l<t.length;e[l]=l++);this._c={index:e,values:this._x,children:[]}}_leafs(){let t=[this._c];for(;;){const e=[];for(let l=0;l<t.length;l++)t[l].children.length>0?e.push(...t[l].children):e.push(t[l]);if(t.length===e.length)return t;t=e}}_distance2(t,e){return t.reduce(((t,l,i)=>t+(l-e[i])**2),0)}_inertia(t){const e=t[0].concat();for(let l=1;l<t.length;l++)for(let i=0;i<this._d;i++)e[i]+=t[l][i];for(let l=0;l<this._d;l++)e[l]/=t.length;let l=0;for(let i=0;i<t.length;i++)l+=this._distance2(t[i],e);return l}fit(){const t=this._leafs();let e=-1/0,l=-1,i=-1,n=null;for(let r=0;r<t.length;r++){const s=t[r].values,h=this._inertia(s);for(let o=0;o<this._d;o++){const c=s.map((t=>t[o]));c.sort(((t,e)=>t-e));for(let f=0;f<c.length-1;f++){const a=(c[f]+c[f+1])/2,d=s.filter((t=>t[o]<=a)),u=s.filter((t=>t[o]>a)),_=h-this._inertia(d)-this._inertia(u);e<_&&(e=_,l=o,i=a,n=t[r])}}}n.feature=l,n.threshold=i,n.children=[{index:n.index.filter(((t,e)=>n.values[e][l]<=i)),values:n.values.filter((t=>t[l]<=i)),children:[]},{index:n.index.filter(((t,e)=>n.values[e][l]>i)),values:n.values.filter((t=>t[l]>i)),children:[]}]}predict(){const t=this._leafs(),e=[];for(let l=0;l<t.length;l++)for(let i=0;i<t[l].index.length;i++)e[t[l].index[i]]=l;return e}}