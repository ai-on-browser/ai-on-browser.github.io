export default class MonotheticClustering{constructor(){}get size(){return this._c.leafs.length}init(e){this._x=e,this._d=e[0].length;const t=[];for(let l=0;l<e.length;t[l]=l++);this._c={index:t,values:this._x,children:[],get leafs(){return 0===this.children.length?[this]:[...this.children[0].leafs,...this.children[1].leafs]}}}_distance2(e,t){return e.reduce(((e,l,i)=>e+(l-t[i])**2),0)}_inertia(e){const t=e[0].concat();for(let l=1;l<e.length;l++)for(let i=0;i<this._d;i++)t[i]+=e[l][i];for(let l=0;l<this._d;l++)t[l]/=e.length;let l=0;for(let i=0;i<e.length;i++)l+=this._distance2(e[i],t);return l}fit(){const e=this._c.leafs;let t=-1/0,l=-1,i=-1,s=null;for(let n=0;n<e.length;n++){const r=e[n].values,h=this._inertia(r);for(let c=0;c<this._d;c++){const a=r.map((e=>e[c]));a.sort(((e,t)=>e-t));for(let f=0;f<a.length-1;f++){const d=(a[f]+a[f+1])/2,o=r.filter((e=>e[c]<=d)),u=r.filter((e=>e[c]>d)),g=h-this._inertia(o)-this._inertia(u);t<g&&(t=g,l=c,i=d,s=e[n])}}}s.feature=l,s.threshold=i,s.children=[{index:s.index.filter(((e,t)=>s.values[t][l]<=i)),values:s.values.filter((e=>e[l]<=i)),children:[],get leafs(){return 0===this.children.length?[this]:[...this.children[0].leafs,...this.children[1].leafs]}},{index:s.index.filter(((e,t)=>s.values[t][l]>i)),values:s.values.filter((e=>e[l]>i)),children:[],get leafs(){return 0===this.children.length?[this]:[...this.children[0].leafs,...this.children[1].leafs]}}]}predict(){const e=this._c.leafs,t=[];for(let l=0;l<e.length;l++)for(let i=0;i<e[l].index.length;i++)t[e[l].index[i]]=l;return t}}