var u=Object.defineProperty;var o=(a,e)=>u(a,"name",{value:e,configurable:!0});class _{static{o(this,"RadiusNeighborBase")}constructor(e=1,t="euclid"){switch(this._p=[],this._c=[],this._r=e,this._metric=t,this._metric){case"euclid":this._d=(i,s)=>Math.sqrt(i.reduce((r,c,d)=>r+(c-s[d])**2,0));break;case"manhattan":this._d=(i,s)=>i.reduce((r,c,d)=>r+Math.abs(c-s[d]),0);break;case"chebyshev":this._d=(i,s)=>Math.max(...i.map((r,c)=>Math.abs(r-s[c])));break;case"minkowski":this._dp=2,this._d=(i,s)=>Math.pow(i.reduce((r,c,d)=>r+(c-s[d])**this._dp,0),1/this._dp);break}}_near_points(e){const t=[];return this._p.forEach((i,s)=>{const r=this._d(e,i);r<this._r&&t.push({d:r,category:this._c[s],idx:s})}),t}_add(e,t){this._p.push(e),this._c.push(t)}}export class RadiusNeighbor extends _{static{o(this,"RadiusNeighbor")}constructor(e=1,t="euclid"){super(e,t)}add(e,t){super._add(e,t)}fit(e,t){for(let i=0;i<e.length;i++)this.add(e[i],t[i])}predict(e){return e.map(t=>{const i=this._near_points(t),s={};i.forEach(n=>{let h=n.category;s[h]?(s[h].count+=1,s[h].min_d=Math.min(s[h].min_d,n.d)):s[h]={category:h,count:1,min_d:n.d}});let r=0,c=-1,d=null;for(let n of Object.keys(s))(r<s[n].count||r===s[n].count&&s[n].min_d<c)&&(r=s[n].count,c=s[n].min_d,d=s[n].category);return d})}}export class RadiusNeighborRegression extends _{static{o(this,"RadiusNeighborRegression")}constructor(e=1,t="euclid"){super(e,t)}add(e,t){super._add(e,t)}fit(e,t){for(let i=0;i<e.length;i++)this.add(e[i],t[i])}predict(e){return e.map(t=>{const i=this._near_points(t);return i.length===0?null:i.reduce((s,r)=>s+r.category,0)/i.length})}}export class SemiSupervisedRadiusNeighbor extends _{static{o(this,"SemiSupervisedRadiusNeighbor")}constructor(e=5,t="euclid"){super(e,t),this._k=1/0,this._orgk=e}add(e,t){super._add(e,t)}fit(e,t){for(let i=0;i<e.length;i++)this.add(e[i],t[i])}predict(){for(;;){const e=[];for(let t=0;t<this._p.length;t++)if(this._c[t]!=null){let i=0;const s=this._near_points(this._p[t]);for(const r of s)if(r.category==null&&(r.d<(e[r.idx]?.d??1/0)&&(e[r.idx]={d:r.d,category:this._c[t]}),++i>=this._orgk))break}if(e.length===0)break;for(let t=0;t<this._p.length;t++)e[t]&&(this._c[t]=e[t].category)}return this._c}}
