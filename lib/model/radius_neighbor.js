var u=Object.defineProperty;var a=(o,e)=>u(o,"name",{value:e,configurable:!0});class _{static{a(this,"RadiusNeighborBase")}constructor(e=1,t="euclid"){if(this._p=[],this._c=[],this._r=e,this._metric=t,typeof this._metric=="function")this._d=this._metric;else switch(this._metric){case"euclid":this._d=(i,s)=>Math.sqrt(i.reduce((r,c,h)=>r+(c-s[h])**2,0));break;case"manhattan":this._d=(i,s)=>i.reduce((r,c,h)=>r+Math.abs(c-s[h]),0);break;case"chebyshev":this._d=(i,s)=>Math.max(...i.map((r,c)=>Math.abs(r-s[c])));break;case"minkowski":this._dp=2,this._d=(i,s)=>Math.pow(i.reduce((r,c,h)=>r+(c-s[h])**this._dp,0),1/this._dp);break}}_near_points(e){const t=[];return this._p.forEach((i,s)=>{const r=this._d(e,i);r<this._r&&t.push({d:r,category:this._c[s],idx:s})}),t}_add(e,t){this._p.push(e),this._c.push(t)}}export class RadiusNeighbor extends _{static{a(this,"RadiusNeighbor")}constructor(e=1,t="euclid"){super(e,t)}add(e,t){super._add(e,t)}fit(e,t){for(let i=0;i<e.length;i++)this.add(e[i],t[i])}predict(e){return e.map(t=>{const i=this._near_points(t),s={};i.forEach(n=>{let d=n.category;s[d]?(s[d].count+=1,s[d].min_d=Math.min(s[d].min_d,n.d)):s[d]={category:d,count:1,min_d:n.d}});let r=0,c=-1,h=null;for(let n of Object.keys(s))(r<s[n].count||r===s[n].count&&s[n].min_d<c)&&(r=s[n].count,c=s[n].min_d,h=s[n].category);return h})}}export class RadiusNeighborRegression extends _{static{a(this,"RadiusNeighborRegression")}constructor(e=1,t="euclid"){super(e,t)}add(e,t){super._add(e,t)}fit(e,t){for(let i=0;i<e.length;i++)this.add(e[i],t[i])}predict(e){return e.map(t=>{const i=this._near_points(t);return i.length===0?null:i.reduce((s,r)=>s+r.category,0)/i.length})}}export class SemiSupervisedRadiusNeighbor extends _{static{a(this,"SemiSupervisedRadiusNeighbor")}constructor(e=5,t="euclid"){super(e,t),this._k=1/0,this._orgk=e}add(e,t){super._add(e,t)}fit(e,t){for(let i=0;i<e.length;i++)this.add(e[i],t[i])}predict(){for(;;){const e=[];for(let t=0;t<this._p.length;t++)if(this._c[t]!=null){let i=0;const s=this._near_points(this._p[t]);for(const r of s)if(r.category==null&&(r.d<(e[r.idx]?.d??1/0)&&(e[r.idx]={d:r.d,category:this._c[t]}),++i>=this._orgk))break}if(e.length===0)break;for(let t=0;t<this._p.length;t++)e[t]&&(this._c[t]=e[t].category)}return this._c}}
