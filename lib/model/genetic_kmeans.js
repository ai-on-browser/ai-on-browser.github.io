class GeneticKMeansModel{constructor(t){this._k=t}get centroids(){return this._c}_distance(t,e){return Math.sqrt(t.reduce(((t,s,i)=>t+(s-e[i])**2),0))}init(t){this._data=t;const e=t.length,s=[];for(let t=0;t<this._k;t++)s.push(Math.floor(Math.random()*(e-t)));for(let t=e-1;t>=0;t--)for(let i=e-1;i>t;i--)s[t]<=s[i]&&s[i]++;this._c=s.map((t=>this._data[t].concat()))}copy(){const t=new GeneticKMeansModel(this._k);t.init(this._data);for(let e=0;e<this._c.length;e++)t._c[e]=this._c[e].concat();return t}cost(){const t=this.predict(this._data);let e=0;for(let s=0;s<this._data.length;s++)for(let i=0;i<this._data[s].length;i++)e+=(this._data[s][i]-this._c[t[s]][i])**2;return e}fit(){const t=this.predict(this._data);for(let e=0;e<this._k;e++){const s=Array(this._data[0].length).fill(0);let i=0;for(let h=0;h<this._data.length;h++)if(t[h]===e){for(let t=0;t<s.length;t++)s[t]+=this._data[h][t];i++}this._c[e]=s.map((t=>t/i))}}predict(t){return t.map((t=>{let e=1/0,s=-1;for(let i=0;i<this._c.length;i++){const h=this._distance(t,this._c[i]);h<e&&(e=h,s=i)}return s}))}mutation(t,e){const s=this.predict(this._data);for(let i=0;i<this._data.length;i++){if(Math.random()>=t)continue;const h=this._c.map((t=>this._distance(t,this._data[i])));if(0===h[s[i]])continue;const a=Math.max(...h),o=h.map((t=>e*a-t));let n=Math.random()*o.reduce(((t,e)=>t+e),0);for(let t=0;t<o.length;t++)if(n-=o[t],n<=0){s[i]=t;break}}for(let t=0;t<this._k;t++){const e=Array(this._data[0].length).fill(0);let i=0;for(let h=0;h<this._data.length;h++)if(s[h]===t){for(let t=0;t<e.length;t++)e[t]+=this._data[h][t];i++}this._c[t]=e.map((t=>t/i))}}}export default class GeneticKMeans{constructor(t,e){this._k=t,this._size=e,this._c=1,this._pm=.1,this._cm=1,this._models=[];for(let t=0;t<this._size;t++)this._models[t]=new GeneticKMeansModel(this._k)}get centroids(){return this.bestModel.centroids}get bestModel(){return this._models[0]}init(t){this._models.forEach((e=>e.init(t)))}predict(t){return this.bestModel.predict(t)}fit(){const t=this._models.map((t=>-t.cost())),e=t.reduce(((t,e)=>t+e),0)/t.length,s=Math.sqrt(t.reduce(((t,s)=>t+(s-e)**2),0)/t.length),i=t.map((t=>Math.max(0,t-(e-this._c*s)))),h=i.reduce(((t,e)=>t+e),0),a=[];for(let t=0;t<this._size;t++){let e=Math.random()*h;for(let s=0;s<i.length;s++)e-=i[s],e<=0&&(a[t]=this._models[s].copy())}this._models=a;for(let t=0;t<this._size;t++)this._models[t].mutation(this._pm,this._cm),this._models[t].fit();const o=this._models.map(((t,e)=>[t.cost(),e]));o.sort(((t,e)=>t[0]-e[0])),this._models=o.map((t=>this._models[t[1]]))}}