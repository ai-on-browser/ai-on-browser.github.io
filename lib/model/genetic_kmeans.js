var m=Object.defineProperty;var l=(_,s)=>m(_,"name",{value:s,configurable:!0});class d{static{l(this,"GeneticKMeansModel")}constructor(s){this._k=s}get centroids(){return this._c}_distance(s,h){return Math.sqrt(s.reduce((e,t,o)=>e+(t-h[o])**2,0))}init(s){this._data=s;const h=s.length,e=[];for(let t=0;t<this._k;t++)e.push(Math.floor(Math.random()*(h-t)));for(let t=h-1;t>=0;t--)for(let o=h-1;o>t;o--)e[t]<=e[o]&&e[o]++;this._c=e.map(t=>this._data[t].concat())}copy(){const s=new d(this._k);s.init(this._data);for(let h=0;h<this._c.length;h++)s._c[h]=this._c[h].concat();return s}cost(){const s=this.predict(this._data);let h=0;for(let e=0;e<this._data.length;e++)for(let t=0;t<this._data[e].length;t++)h+=(this._data[e][t]-this._c[s[e]][t])**2;return h}fit(){const s=this.predict(this._data);for(let h=0;h<this._k;h++){const e=Array(this._data[0].length).fill(0);let t=0;for(let o=0;o<this._data.length;o++)if(s[o]===h){for(let c=0;c<e.length;c++)e[c]+=this._data[o][c];t++}this._c[h]=e.map(o=>o/t)}}predict(s){return s.map(h=>{let e=1/0,t=-1;for(let o=0;o<this._c.length;o++){const c=this._distance(h,this._c[o]);c<e&&(e=c,t=o)}return t})}mutation(s,h){const e=this.predict(this._data);for(let t=0;t<this._data.length;t++){if(Math.random()>=s)continue;const o=this._c.map(n=>this._distance(n,this._data[t]));if(o[e[t]]===0)continue;const c=Math.max(...o),r=o.map(n=>h*c-n);let i=Math.random()*r.reduce((n,a)=>n+a,0);for(let n=0;n<r.length;n++)if(i-=r[n],i<=0){e[t]=n;break}}for(let t=0;t<this._k;t++){const o=Array(this._data[0].length).fill(0);let c=0;for(let r=0;r<this._data.length;r++)if(e[r]===t){for(let i=0;i<o.length;i++)o[i]+=this._data[r][i];c++}this._c[t]=o.map(r=>r/c)}}}export default class f{static{l(this,"GeneticKMeans")}constructor(s,h){this._k=s,this._size=h,this._c=1,this._pm=.1,this._cm=1,this._models=[];for(let e=0;e<this._size;e++)this._models[e]=new d(this._k)}get centroids(){return this.bestModel.centroids}get bestModel(){return this._models[0]}init(s){this._models.forEach(h=>h.init(s))}predict(s){return this.bestModel.predict(s)}fit(){const s=this._models.map(i=>-i.cost()),h=s.reduce((i,n)=>i+n,0)/s.length,e=Math.sqrt(s.reduce((i,n)=>i+(n-h)**2,0)/s.length),t=s.map(i=>Math.max(0,i-(h-this._c*e))),o=t.reduce((i,n)=>i+n,0),c=[];for(let i=0;i<this._size;i++){let n=Math.random()*o;for(let a=0;a<t.length;a++)n-=t[a],n<=0&&(c[i]=this._models[a].copy())}this._models=c;for(let i=0;i<this._size;i++)this._models[i].mutation(this._pm,this._cm),this._models[i].fit();const r=this._models.map((i,n)=>[i.cost(),n]);r.sort((i,n)=>i[0]-n[0]),this._models=r.map(i=>this._models[i[1]])}}
