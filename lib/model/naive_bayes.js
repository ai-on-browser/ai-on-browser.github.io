var c=Object.defineProperty;var o=(h,a)=>c(h,"name",{value:a,configurable:!0});import l from"../util/matrix.js";class m{static{o(this,"Gaussian")}constructor(){this._means=null,this._vars=null}_estimate_prob(a){this._means=a.mean(0),this._vars=a.variance(0)}_data_prob(a){const r=l.sub(a,this._means);return r.mult(r),r.div(this._vars),r.map(s=>Math.exp(-s/2)),r.div(l.map(this._vars,s=>Math.sqrt(2*Math.PI*s))),r.prod(1)}}export default class u{static{o(this,"NaiveBayes")}constructor(a="gaussian"){this._labels=[],this._rate=[],a==="gaussian"&&(this._p_class=m),this._p=[]}fit(a,r){this._labels=[...new Set(r)],this._p=[],this._rate=[];for(let s=0;s<this._labels.length;s++){const t=l.fromArray(a.filter((i,e)=>r[e]===this._labels[s]));this._p[s]=new this._p_class,this._p[s]._estimate_prob(t),this._rate[s]=t.rows/a.length}}probability(a){const r=l.fromArray(a),s=[];for(let t=0;t<r.rows;t++)s[t]=[];for(let t=0;t<this._labels.length;t++){const i=this._p[t]._data_prob(r);i.mult(this._rate[t]);for(let e=0;e<r.rows;e++)s[e][t]=i.value[e]}return s}predict(a){const r=l.fromArray(a),s=[];for(let t=0;t<this._labels.length;t++){const i=this._p[t]._data_prob(r);i.mult(this._rate[t]),s.push(i)}return a.map((t,i)=>{let e=0,n=-1;for(let _=0;_<this._labels.length;_++){let p=s[_].value[i];p>e&&(e=p,n=_)}return this._labels[n]})}}
