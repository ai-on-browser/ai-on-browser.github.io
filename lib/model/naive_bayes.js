import{Matrix}from"../util/math.js";class NaiveBayes{constructor(){this._k=0,this._labels=[],this._rate=[]}fit(t,s){this._labels=[...new Set(s)],this._init(),this._rate=[];for(let a=0;a<this._labels.length;a++){const r=Matrix.fromArray(t.filter(((t,r)=>s[r]===this._labels[a])));this._estimate_prob(r,a),this._rate[a]=r.rows/t.length}}probability(t){const s=Matrix.fromArray(t),a=[];for(let t=0;t<s.rows;t++)a[t]=[];for(let t=0;t<this._labels.length;t++){const r=this._data_prob(s,t);r.mult(this._rate[t]);for(let e=0;e<s.rows;e++)a[e][t]=r.value[e]}return a}predict(t){const s=Matrix.fromArray(t),a=[];for(let t=0;t<this._labels.length;t++){const r=this._data_prob(s,t);r.mult(this._rate[t]),a.push(r)}return t.map(((t,s)=>{let r=0,e=-1;for(let t=0;t<this._labels.length;t++){let i=a[t].value[s];i>r&&(r=i,e=t)}return this._labels[e]}))}}export class GaussianNaiveBayes extends NaiveBayes{constructor(){super(),this._means=[],this._vars=[]}_init(){this._means=[],this._vars=[]}_estimate_prob(t,s){this._means[s]=t.mean(0),this._vars[s]=t.variance(0)}_data_prob(t,s){const a=this._means[s],r=this._vars[s],e=t.copySub(a);return e.mult(e),e.div(r),e.map((t=>Math.exp(-t/2))),e.div(r.copyMap((t=>Math.sqrt(2*Math.PI*t)))),e.prod(1)}}