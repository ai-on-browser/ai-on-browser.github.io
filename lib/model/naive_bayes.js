import{Matrix}from"../util/math.js";class NaiveBayes{constructor(){this._k=0,this._labels=[],this._rate=[]}fit(t,s){if(Array.isArray(s[0])&&(s=s.map((t=>t[0]))),this._labels=[],this._init(),0===t.length)return;const a=[];for(let e=0;e<s.length;e++){const r=this._labels.indexOf(s[e]);r>=0?a[r].push(t[e]):(this._labels.push(s[e]),a.push([t[e]]))}for(let t=0;t<this._labels.length;t++){const s=Matrix.fromArray(a[t]);this._estimate_prob(s,t)}this._rate=a.map((s=>s.length/t.length))}predict(t){const s=Matrix.fromArray(t),a=[];for(let t=0;t<this._labels.length;t++){const e=this._data_prob(s,t);e.mult(this._rate[t]),a.push(e)}return t.map(((t,s)=>{let e=0,r=-1;for(let t=0;t<this._labels.length;t++){let i=a[t].value[s];i>e&&(e=i,r=t)}return this._labels[r]}))}}export class GaussianNaiveBayes extends NaiveBayes{constructor(){super(),this._means=[],this._vars=[]}_init(){this._means=[],this._vars=[]}_estimate_prob(t,s){this._means[s]=t.mean(0),this._vars[s]=t.variance(0)}_data_prob(t,s){const a=this._means[s],e=this._vars[s],r=t.copySub(a);return r.mult(r),r.div(e),r.map((t=>Math.exp(-t/2))),r.div(e.copyMap((t=>Math.sqrt(2*Math.PI*t)))),r.prod(1)}}