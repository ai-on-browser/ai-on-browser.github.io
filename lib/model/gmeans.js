var m=Object.defineProperty;var f=(l,i)=>m(l,"name",{value:i,configurable:!0});import p from"../util/matrix.js";class x{static{f(this,"KMeans")}constructor(i,n){this._x=i,this._k=n;const e=this._x.length,r=[];for(let s=0;s<this._k;s++)r.push(Math.floor(Math.random()*(e-s)));for(let s=r.length-1;s>=0;s--)for(let t=r.length-1;t>s;t--)r[s]<=r[t]&&r[t]++;this._c=r.map(s=>this._x[s]),this._d=(s,t)=>Math.sqrt(s.reduce((c,h,_)=>c+(h-t[_])**2,0))}get centroids(){return this._c}fit(){const i=this.predict(),n=this._c.map(t=>Array.from(t,()=>0)),e=Array(this._k).fill(0),r=this._x.length;for(let t=0;t<r;t++){for(let c=0;c<this._x[t].length;c++)n[i[t]][c]+=this._x[t][c];e[i[t]]++}let s=0;for(let t=0;t<this._k;t++){const c=n[t].map(h=>h/e[t]);s+=this._c[t].reduce((h,_,u)=>h+(_-c[u])**2,0),this._c[t]=n[t].map(h=>h/e[t])}return s}predict(){const i=[],n=this._x.length;for(let e=0;e<n;e++){let r=1/0;i[e]=-1;for(let s=0;s<this._k;s++){const t=this._d(this._x[e],this._c[s]);t<r&&(r=t,i[e]=s)}}return i}}const M=[[.514,.578,.683,.779,.926],[.528,.591,.704,.815,.969],[.546,.616,.735,.861,1.021],[.559,.631,.754,.884,1.047],[.576,.656,.787,.918,1.092]],k=f((l,i)=>{l.sort((o,d)=>o-d);const n=l.length,e=l.reduce((o,d)=>o+d,0)/n,r=l.reduce((o,d)=>o+(d-e)**2,0)/(n-1),s=Math.sqrt(r),c=l.map(o=>(o-e)/s).map(o=>1/(1+Math.exp(-1.7*o)));let h=0;for(let o=0;o<n;o++)h+=(2*(o+1)-1)*(Math.log(c[o])+Math.log(1-c[n-o-1]));const u=(-n-h/n)*(1+4/n-25/n**2),a=M[n<=10?0:n<=20?1:n<=50?2:n<=100?3:4][i===15?0:i===10?1:i===5?2:i===2.5?3:i===1?4:-1];return u<=a},"AndersonDarling");export default class v{static{f(this,"GMeans")}constructor(){this._centroids=[],this._init_k=2}get centroids(){return this._centroids}get size(){return this._centroids.length}_distance(i,n){return Math.sqrt(i.reduce((e,r,s)=>e+(r-n[s])**2,0))}clear(){this._centroids=[]}fit(i,n=-1){let e=null;this._centroids.length===0?(e=this._split_cluster(i,this._init_k),n--):e=this._create_clusters(this,i);const r=[];for(;e.length>0&&(n<0||n-- >0);){const s=[];for(;e.length>0;){const t=e.shift();if(t.size<=3){r.push(t.centroid);continue}const c=p.fromArray(t.data),[h,_]=c.cov().eigenPowerIteration();_.mult(Math.sqrt(2*h/Math.PI));const u=p.mult(_,2),a=c.dot(u);if(a.div(u.norm()),k(a.value,5))r.push(t.centroid);else{const[d,g]=this._split_cluster(t.data);s.push(d,g)}}e=s}e.length>0&&r.push(...e.map(s=>s.centroid)),this._centroids=r}_split_cluster(i,n=2){const e=new x(i,n);for(;e.fit()>0;);return this._create_clusters(e,i)}_create_clusters(i,n){const e=i.centroids.length,r=i.predict(n),s=[];for(let c=0;c<e;s[c++]=[]);n.forEach((c,h)=>s[r[h]].push(c));const t=[];for(let c=0;c<e;c++)t[c]={size:s[c].length,data:s[c],centroid:i.centroids[c]};return t}predict(i){if(this._centroids.length===0)throw new Error("Call fit before predict.");return i.map(n=>{let e=1/0,r=-1;for(let s=0;s<this._centroids.length;s++){const t=this._distance(n,this._centroids[s]);t<e&&(e=t,r=s)}return r})}}
