var c=Object.defineProperty;var o=(l,s)=>c(l,"name",{value:s,configurable:!0});const g={gaussian:o(l=>{const s=l.length;return Math.exp(-l.reduce((i,t)=>i+t**2,0)/2)/(2*Math.PI)**(s/2)},"gaussian")};export default class u{static{o(this,"DENCLUE")}constructor(s,i=1,t="gaussian"){this._version=i,this._h=s,this._delta=.01,this._ignore_p=.2,this._xi=1e-12,typeof t=="function"?this._kernel=t:(t==="gaussian"||t.name==="gaussian")&&(this._kernel=g.gaussian)}get size(){return new Set(this.predict()).size}init(s){if(this._datas=s,this._x=s.map(i=>i.concat()),this._version===2){const i=this._x.length;if(this._ignore_p>0){this._k=[];for(let t=0;t<i;this._k[t++]=[]);for(let t=0;t<i;t++){this._k[t][t]={k:1/0,idx:t};for(let h=t+1;h<i;h++){const e=this._kernel(this._x[t].map((_,r)=>(_-this._x[h][r])/this._h));this._k[t][h]={k:e,idx:h},this._k[h][t]={k:e,idx:t}}this._k[t].sort((h,e)=>h.k-e.k),this._k[t].forEach((h,e)=>{e<this._ignore_p*i&&(h.low=!0)}),this._k[t].sort((h,e)=>h.idx-e.idx)}}this._radius=Array(this._x.length);for(let t=0;t<i;t++)this._radius[t]=[]}this._xi>0&&(this._probs=this._x.map(i=>this._p(i)))}_p(s){let i=0;for(let t=0;t<this._datas.length;t++)i+=this._kernel(this._datas[t].map((h,e)=>(s[e]-h)/this._h));return i/(this._datas.length*this._h**s.length)}_dp(s){let i=Array(s.length).fill(0);for(let t=0;t<this._datas.length;t++){const h=this._kernel(this._datas[t].map((e,_)=>(s[_]-e)/this._h));for(let e=0;e<i.length;e++)i[e]+=h*(this._datas[t][e]-s[e])}return i.map(t=>t/(this._datas.length*i.length**(s.length+2)))}fit(){if(this._version===1)for(let s=0;s<this._x.length;s++){const i=this._dp(this._x[s]),t=Math.sqrt(i.reduce((h,e)=>h+e**2,0));for(let h=0;h<this._x[s].length;h++)this._x[s][h]+=this._delta*i[h]/t}else for(let s=0;s<this._x.length;s++){const i=this._x[s];let t=0;const h=Array(i.length).fill(0);for(let _=0;_<this._datas.length;_++){let r;this._k&&this._k[s][_].low?r=this._k[s][_].k:r=this._kernel(this._datas[_].map((n,a)=>(i[a]-n)/this._h));for(let n=0;n<i.length;n++)h[n]+=r*this._datas[_][n];t+=r}for(let _=0;_<h.length;_++)h[_]/=t;const e=Math.sqrt(i.reduce((_,r,n)=>_+(r-h[n])**2,0));this._x[s]=h,e>1e-8&&this._radius[s].push(e)}}predict(){const s=[];let i=-1;for(let t=0;t<this._x.length;t++){if(this._probs&&this._probs[t]<this._xi){s[t]=-1;continue}const h=this._version===1?this._delta:this._radius[t].reduce((r,n)=>r+n,0);let e=-1,_=1/0;for(let r=0;r<t;r++){const n=Math.sqrt(this._x[r].reduce((a,d,f)=>a+(d-this._x[t][f])**2,0));n<2*h&&n<_&&(e=r,_=n)}e<0?s[t]=++i:s[t]=s[e]}return s}}
