export default class DENCLUE{constructor(t,s=1,i="gaussian"){this._version=s,this._h=t,this._delta=.01,this._ignore_p=.2,this._xi=1e-12,"gaussian"===i&&(this._kernel=t=>{const s=t.length;return Math.exp(-t.reduce(((t,s)=>t+s**2),0)/2)/(2*Math.PI)**(s/2)})}get size(){return new Set(this.predict()).size}init(t){if(this._datas=t,this._x=t.map((t=>t.concat())),2===this._version){const t=this._x.length;if(this._ignore_p>0){this._k=[];for(let s=0;s<t;this._k[s++]=[]);for(let s=0;s<t;s++){this._k[s][s]={k:1/0,idx:s};for(let i=s+1;i<t;i++){const t=this._kernel(this._x[s].map(((t,s)=>(t-this._x[i][s])/this._h)));this._k[s][i]={k:t,idx:i},this._k[i][s]={k:t,idx:s}}this._k[s].sort(((t,s)=>t.k-s.k)),this._k[s].forEach(((s,i)=>{i<this._ignore_p*t&&(s.low=!0)})),this._k[s].sort(((t,s)=>t.idx-s.idx))}}this._radius=Array(this._x.length);for(let s=0;s<t;s++)this._radius[s]=[]}this._xi>0&&(this._probs=this._x.map((t=>this._p(t))))}_p(t){let s=0;for(let i=0;i<this._datas.length;i++)s+=this._kernel(this._datas[i].map(((s,i)=>(t[i]-s)/this._h)));return s/(this._datas.length*this._h**t.length)}_dp(t){let s=Array(t.length).fill(0);for(let i=0;i<this._datas.length;i++){const h=this._kernel(this._datas[i].map(((s,i)=>(t[i]-s)/this._h)));for(let e=0;e<s.length;e++)s[e]+=h*(this._datas[i][e]-t[e])}return s.map((i=>i/(this._datas.length*s.length**(t.length+2))))}fit(){if(1===this._version)for(let t=0;t<this._x.length;t++){const s=this._dp(this._x[t]),i=Math.sqrt(s.reduce(((t,s)=>t+s**2),0));for(let h=0;h<this._x[t].length;h++)this._x[t][h]+=this._delta*s[h]/i}else for(let t=0;t<this._x.length;t++){const s=this._x[t];let i=0;const h=Array(s.length).fill(0);for(let e=0;e<this._datas.length;e++){let _;_=this._k&&this._k[t][e].low?this._k[t][e].k:this._kernel(this._datas[e].map(((t,i)=>(s[i]-t)/this._h)));for(let t=0;t<s.length;t++)h[t]+=_*this._datas[e][t];i+=_}for(let t=0;t<h.length;t++)h[t]/=i;const e=Math.sqrt(s.reduce(((t,s,i)=>t+(s-h[i])**2),0));this._x[t]=h,e>1e-8&&this._radius[t].push(e)}}predict(){const t=[];let s=-1;for(let i=0;i<this._x.length;i++){if(this._probs&&this._probs[i]<this._xi){t[i]=-1;continue}const h=1===this._version?this._delta:this._radius[i].reduce(((t,s)=>t+s),0);let e=-1,_=1/0;for(let t=0;t<i;t++){const s=Math.sqrt(this._x[t].reduce(((t,s,h)=>t+(s-this._x[i][h])**2),0));s<2*h&&s<_&&(e=t,_=s)}t[i]=e<0?++s:t[e]}return t}}