const argmin=function(t,e){return 0===t.length?-1:(t=e?t.map(e):t).indexOf(Math.min(...t))};export class KMeansModel{constructor(t=null){this._centroids=[],this._method=t||new KMeans}get centroids(){return this._centroids}get size(){return this._centroids.length}get method(){return this._method}set method(t){this._method=t}_distance(t,e){let n=0;for(let r=t.length-1;r>=0;r--)n+=(t[r]-e[r])**2;return Math.sqrt(n)}add(t){const e=this._method.add(this._centroids,t);return this._centroids.push(e),e}clear(){this._centroids=[]}predict(t){if(0!==this._centroids.length)return t.map((t=>argmin(this._centroids,(e=>this._distance(t,e)))))}fit(t){if(0===this._centroids.length||0===t.length)return 0;const e=this._centroids;this._centroids=this._method.move(this,this._centroids,t);return e.reduce(((t,e,n)=>t+this._distance(e,this._centroids[n])),0)}}export class KMeans{_distance(t,e){return Math.sqrt(t.reduce(((t,n,r)=>t+(n-e[r])**2),0))}add(t,e){for(;;){const n=e[Math.floor(Math.random()*e.length)];if(Math.min.apply(null,t.map((t=>this._distance(n,t))))>1e-8)return n.concat()}}_mean(t){const e=t.length,n=t[0].length,r=Array(n).fill(0);for(let s=0;s<e;s++)for(let e=0;e<n;e++)r[e]+=t[s][e];return r.map((t=>t/e))}move(t,e,n){let r=t.predict(n);return e.map(((t,e)=>{let s=n.filter(((t,n)=>r[n]===e));return this._mean(s)}))}}export class KMeanspp extends KMeans{add(t,e){if(0===t.length)return e[Math.floor(Math.random()*e.length)];const n=e.map((e=>Math.min.apply(null,t.map((t=>this._distance(e,t))))**2)),r=n.reduce(((t,e)=>t+e),0);let s=Math.random()*r;for(var i=0;i<n.length;i++){if(s<n[i])return e[i];s-=n[i]}}}export class KMedoids extends KMeans{move(t,e,n){let r=t.predict(n);return e.map(((t,e)=>{let s=n.filter(((t,n)=>r[n]===e));if(s.length>0){let t=argmin(s,(t=>s.map((e=>this._distance(e,t))).reduce(((t,e)=>t+e),0)));return s[t]}return t}))}}export class KMedians extends KMeans{move(t,e,n){const r=t.predict(n);return e.map(((t,e)=>{const s=n.filter(((t,n)=>r[n]===e)),i=s.length;if(s.length>0){const e=[];for(let n=0;n<t.length;n++){const t=s.map((t=>t[n]));t.sort(((t,e)=>t-e)),i%2==0?e.push((t[i/2]+t[i/2-1])/2):e.push(t[(i-1)/2])}return e}return t}))}}export class SemiSupervisedKMeansModel extends KMeansModel{constructor(){super(null)}_mean(t){const e=t.length,n=t[0].length,r=Array(n).fill(0);for(let s=0;s<e;s++)for(let e=0;e<n;e++)r[e]+=t[s][e];return r.map((t=>t/e))}init(t,e){this.clear();const n=[...new Set(e.filter((t=>t>0)))];for(let r=0;r<n.length;r++){const n=t.filter(((t,n)=>e[n]===r+1));this._centroids.push(this._mean(n))}}add(){}fit(t,e){if(0===this._centroids.length||0===t.length)return 0;const n=this._centroids,r=this.predict(t);for(let t=0;t<e.length;t++)e[t]>0&&e[t]<=this._centroids.length&&(r[t]=e[t]-1);this._centroids=this._centroids.map(((e,n)=>{const s=t.filter(((t,e)=>r[e]===n));return this._mean(s)}));return n.reduce(((t,e,n)=>t+this._distance(e,this._centroids[n])),0)}}