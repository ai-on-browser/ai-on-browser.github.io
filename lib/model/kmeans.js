const argmin=function(t,e){return 0===t.length?-1:(t=e?t.map(e):t).indexOf(Math.min(...t))};class KMeansBase{constructor(){this._centroids=[]}get centroids(){return this._centroids}get size(){return this._centroids.length}_distance(t,e){let s=0;for(let n=t.length-1;n>=0;n--)s+=(t[n]-e[n])**2;return Math.sqrt(s)}add(t){const e=this._add(this._centroids,t);return this._centroids.push(e),e}clear(){this._centroids=[]}predict(t){if(0!==this._centroids.length)return t.map((t=>argmin(this._centroids,(e=>this._distance(t,e)))))}fit(t){if(0===this._centroids.length||0===t.length)return 0;const e=this._centroids;this._centroids=this._move(this._centroids,t);return e.reduce(((t,e,s)=>t+this._distance(e,this._centroids[s])),0)}}export class KMeans extends KMeansBase{_distance(t,e){return Math.sqrt(t.reduce(((t,s,n)=>t+(s-e[n])**2),0))}_add(t,e){for(;;){const s=e[Math.floor(Math.random()*e.length)];if(Math.min.apply(null,t.map((t=>this._distance(s,t))))>1e-8)return s.concat()}}_mean(t){const e=t.length,s=t[0].length,n=Array(s).fill(0);for(let r=0;r<e;r++)for(let e=0;e<s;e++)n[e]+=t[r][e];return n.map((t=>t/e))}_move(t,e){let s=this.predict(e);return t.map(((t,n)=>{let r=e.filter(((t,e)=>s[e]===n));return this._mean(r)}))}}export class KMeanspp extends KMeans{_add(t,e){if(0===t.length)return e[Math.floor(Math.random()*e.length)];const s=e.map((e=>Math.min.apply(null,t.map((t=>this._distance(e,t))))**2)),n=s.reduce(((t,e)=>t+e),0);let r=Math.random()*n;for(var i=0;i<s.length;i++){if(r<s[i])return e[i];r-=s[i]}}}export class KMedoids extends KMeans{_move(t,e){let s=this.predict(e);return t.map(((t,n)=>{let r=e.filter(((t,e)=>s[e]===n));if(r.length>0){let t=argmin(r,(t=>r.map((e=>this._distance(e,t))).reduce(((t,e)=>t+e),0)));return r[t]}return t}))}}export class KMedians extends KMeans{_move(t,e){const s=this.predict(e);return t.map(((t,n)=>{const r=e.filter(((t,e)=>s[e]===n)),i=r.length;if(r.length>0){const e=[];for(let s=0;s<t.length;s++){const t=r.map((t=>t[s]));t.sort(((t,e)=>t-e)),i%2==0?e.push((t[i/2]+t[i/2-1])/2):e.push(t[(i-1)/2])}return e}return t}))}}export class SemiSupervisedKMeansModel extends KMeansBase{constructor(){super()}get categories(){return this._classes}_mean(t){const e=t.length,s=t[0].length,n=Array(s).fill(0);for(let r=0;r<e;r++)for(let e=0;e<s;e++)n[e]+=t[r][e];return n.map((t=>t/e))}init(t,e){this.clear(),this._classes=[...new Set(e.filter((t=>null!=t)))];for(let s=0;s<this._classes.length;s++){const n=t.filter(((t,n)=>e[n]===this._classes[s]));this._centroids.push(this._mean(n))}}add(){}fit(t,e){if(0===this._centroids.length||0===t.length)return 0;const s=this._centroids,n=this.predict(t);for(let t=0;t<e.length;t++){const s=this._classes.indexOf(e[t]);s>=0&&(n[t]=s)}this._centroids=this._centroids.map(((e,s)=>{const r=t.filter(((t,e)=>n[e]===this._classes[s]));return this._mean(r)}));return s.reduce(((t,e,s)=>t+this._distance(e,this._centroids[s])),0)}predict(t){if(0!==this._centroids.length)return super.predict(t).map((t=>this._classes[t]))}}