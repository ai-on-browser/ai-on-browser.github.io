class KMeansBase{constructor(){this._centroids=[]}get centroids(){return this._centroids}get size(){return this._centroids.length}_distance(t,e){let s=0;for(let r=t.length-1;r>=0;r--)s+=(t[r]-e[r])**2;return Math.sqrt(s)}add(t){const e=this._add(this._centroids,t);return this._centroids.push(e),e}clear(){this._centroids=[]}predict(t){if(0===this._centroids.length)throw new Error("Call fit before predict.");return t.map((t=>{let e=1/0,s=-1;for(let r=0;r<this._centroids.length;r++){const n=this._distance(t,this._centroids[r]);n<e&&(e=n,s=r)}return s}))}fit(t){if(0===this._centroids.length||0===t.length)return 0;const e=this._centroids;this._centroids=this._move(this._centroids,t);return e.reduce(((t,e,s)=>t+this._distance(e,this._centroids[s])),0)}}export class KMeans extends KMeansBase{_distance(t,e){return Math.sqrt(t.reduce(((t,s,r)=>t+(s-e[r])**2),0))}_add(t,e){for(;;){const s=e[Math.floor(Math.random()*e.length)];if(Math.min.apply(null,t.map((t=>this._distance(s,t))))>1e-8)return s.concat()}}_mean(t){const e=t.length,s=t[0].length,r=Array(s).fill(0);for(let n=0;n<e;n++)for(let e=0;e<s;e++)r[e]+=t[n][e];return r.map((t=>t/e))}_move(t,e){let s=this.predict(e);return t.map(((t,r)=>{let n=e.filter(((t,e)=>s[e]===r));return this._mean(n)}))}}export class KMeanspp extends KMeans{_add(t,e){if(0===t.length)return e[Math.floor(Math.random()*e.length)];const s=e.map((e=>Math.min.apply(null,t.map((t=>this._distance(e,t))))**2)),r=s.reduce(((t,e)=>t+e),0);let n=Math.random()*r;for(var i=0;i<s.length;i++){if(n<s[i])return e[i];n-=s[i]}}}export class KMedoids extends KMeans{_move(t,e){let s=this.predict(e);return t.map(((t,r)=>{let n=e.filter(((t,e)=>s[e]===r));if(n.length>0){let t=1/0,e=-1;for(let s=0;s<n.length;s++){let r=0;for(let t=0;t<n.length;t++)r+=this._distance(n[s],n[t]);r<t&&(t=r,e=s)}return n[e]}return t}))}}export class KMedians extends KMeans{_move(t,e){const s=this.predict(e);return t.map(((t,r)=>{const n=e.filter(((t,e)=>s[e]===r)),i=n.length;if(n.length>0){const e=[];for(let s=0;s<t.length;s++){const t=n.map((t=>t[s]));t.sort(((t,e)=>t-e)),i%2==0?e.push((t[i/2]+t[i/2-1])/2):e.push(t[(i-1)/2])}return e}return t}))}}export class SemiSupervisedKMeansModel extends KMeansBase{constructor(){super()}get categories(){return this._classes}_mean(t){const e=t.length,s=t[0].length,r=Array(s).fill(0);for(let n=0;n<e;n++)for(let e=0;e<s;e++)r[e]+=t[n][e];return r.map((t=>t/e))}init(t,e){this.clear(),this._classes=[...new Set(e.filter((t=>null!=t)))];for(let s=0;s<this._classes.length;s++){const r=t.filter(((t,r)=>e[r]===this._classes[s]));this._centroids.push(this._mean(r))}}add(){}fit(t,e){if(0===this._centroids.length||0===t.length)return 0;const s=this._centroids,r=this.predict(t);for(let t=0;t<e.length;t++){const s=this._classes.indexOf(e[t]);s>=0&&(r[t]=s)}this._centroids=this._centroids.map(((e,s)=>{const n=t.filter(((t,e)=>r[e]===this._classes[s]));return this._mean(n)}));return s.reduce(((t,e,s)=>t+this._distance(e,this._centroids[s])),0)}predict(t){if(0===this._centroids.length)throw new Error("Call fit before predict.");return super.predict(t).map((t=>this._classes[t]))}}