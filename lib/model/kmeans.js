var u=Object.defineProperty;var p=(d,s)=>u(d,"name",{value:s,configurable:!0});class _{static{p(this,"KMeansBase")}constructor(){this._centroids=[]}get centroids(){return this._centroids}get size(){return this._centroids.length}_distance(s,e){let n=0;for(let r=s.length-1;r>=0;r--)n+=(s[r]-e[r])**2;return Math.sqrt(n)}add(s){const e=this._add(this._centroids,s);return this._centroids.push(e),e}clear(){this._centroids=[]}predict(s){if(this._centroids.length===0)throw new Error("Call fit before predict.");return s.map(e=>{let n=1/0,r=-1;for(let i=0;i<this._centroids.length;i++){const t=this._distance(e,this._centroids[i]);t<n&&(n=t,r=i)}return r})}fit(s){if(this._centroids.length===0||s.length===0)return 0;const e=this._centroids;return this._centroids=this._move(this._centroids,s),e.reduce((r,i,t)=>r+this._distance(i,this._centroids[t]),0)}}export class KMeans extends _{static{p(this,"KMeans")}_distance(s,e){return Math.sqrt(s.reduce((n,r,i)=>n+(r-e[i])**2,0))}_add(s,e){for(;;){const n=e[Math.floor(Math.random()*e.length)];if(Math.min.apply(null,s.map(r=>this._distance(n,r)))>1e-8)return n.concat()}}_mean(s){const e=s.length,n=s[0].length,r=Array(n).fill(0);for(let i=0;i<e;i++)for(let t=0;t<n;t++)r[t]+=s[i][t];return r.map(i=>i/e)}_move(s,e){let n=this.predict(e);return s.map((r,i)=>{let t=e.filter((o,c)=>n[c]===i);return this._mean(t)})}}export class KMeanspp extends KMeans{static{p(this,"KMeanspp")}_add(s,e){if(s.length===0)return e[Math.floor(Math.random()*e.length)];const n=e.map(o=>Math.min.apply(null,s.map(c=>this._distance(o,c)))**2),r=n.reduce((o,c)=>o+c,0);let i=Math.random()*r;for(var t=0;t<n.length;t++){if(i<n[t])return e[t];i-=n[t]}}}export class KMedoids extends KMeans{static{p(this,"KMedoids")}_move(s,e){let n=this.predict(e);return s.map((r,i)=>{let t=e.filter((o,c)=>n[c]===i);if(t.length>0){let o=1/0,c=-1;for(let l=0;l<t.length;l++){let h=0;for(let a=0;a<t.length;a++)h+=this._distance(t[l],t[a]);h<o&&(o=h,c=l)}return t[c]}else return r})}}export class KMedians extends KMeans{static{p(this,"KMedians")}_move(s,e){const n=this.predict(e);return s.map((r,i)=>{const t=e.filter((c,l)=>n[l]===i),o=t.length;if(t.length>0){const c=[];for(let l=0;l<r.length;l++){const h=t.map(a=>a[l]);h.sort((a,f)=>a-f),o%2===0?c.push((h[o/2]+h[o/2-1])/2):c.push(h[(o-1)/2])}return c}else return r})}}export class SemiSupervisedKMeansModel extends _{static{p(this,"SemiSupervisedKMeansModel")}constructor(){super()}get categories(){return this._classes}_mean(s){const e=s.length,n=s[0].length,r=Array(n).fill(0);for(let i=0;i<e;i++)for(let t=0;t<n;t++)r[t]+=s[i][t];return r.map(i=>i/e)}init(s,e){this.clear(),this._classes=[...new Set(e.filter(n=>n!=null))];for(let n=0;n<this._classes.length;n++){const r=s.filter((i,t)=>e[t]===this._classes[n]);this._centroids.push(this._mean(r))}}add(){}fit(s,e){if(this._centroids.length===0||s.length===0)return 0;const n=this._centroids,r=this.predict(s);for(let t=0;t<e.length;t++){const o=this._classes.indexOf(e[t]);o>=0&&(r[t]=o)}return this._centroids=this._centroids.map((t,o)=>{const c=s.filter((l,h)=>r[h]===this._classes[o]);return this._mean(c)}),n.reduce((t,o,c)=>t+this._distance(o,this._centroids[c]),0)}predict(s){if(this._centroids.length===0)throw new Error("Call fit before predict.");return super.predict(s).map(e=>this._classes[e])}}
