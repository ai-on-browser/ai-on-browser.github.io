import{Tensor}from"../util/math.js";import{RLRealRange,RLIntRange}from"../rl/base.js";export class QTableBase{constructor(t,e=20){this._env=t,this._resolution=e,this._state_sizes=t.states.map((t=>Array.isArray(t)?t.length:t.toArray(e).length)),this._action_sizes=t.actions.map((t=>Array.isArray(t)?t.length:t.toArray(e).length)),this._sizes=[...this._state_sizes,...this._action_sizes],this._tensor=new Tensor(this._sizes),this._table=this._tensor.value}get tensor(){return this._tensor}get states(){return this._env.states}get actions(){return this._env.actions}get resolution(){return this._resolution}_state_index(t){return t.map(((t,e)=>{const s=this.states[e];if(Array.isArray(s))return s.indexOf(t);if(s instanceof RLIntRange)return s.indexOf(t,this.resolution);if(s instanceof RLRealRange)return s.indexOf(t,this.resolution);throw"Not implemented"}))}_state_value(t){return t.map(((t,e)=>{const s=this.states[e];if(Array.isArray(s))return s[t];if(s instanceof RLIntRange)return s.toArray(this.resolution)[t];if(s instanceof RLRealRange)return t*(s.max-s.min)/this.resolution+s.min;throw"Not implemented"}))}_action_index(t){return t.map(((t,e)=>{const s=this.actions[e];if(Array.isArray(s))return s.indexOf(t);if(s instanceof RLRealRange)return s.indexOf(t,this.resolution);throw"Not implemented"}))}_action_value(t){return t.map(((t,e)=>{const s=this.actions[e];if(Array.isArray(s))return s[t];if(s instanceof RLRealRange)return t*(s.max-s.min)/this.resolution+s.min;throw"Not implemented"}))}_to_position(t,e){let s=0;for(let i=0;i<e.length;i++)s=s*t[i]+e[i];let i=s+1;for(let n=e.length;n<t.length;n++)s*=t[n],i*=t[n];return[s,i]}_to_index(t,e){const s=Array(t.length);for(let i=t.length-1;i>=0;i--)s[i]=e%t[i],e=Math.floor(e/t[i]);return s}_q(t,e){if(!e){const[e,s]=this._to_position(this._sizes,t);return[this._table.slice(e,s),[e,s]]}const[s,i]=this._to_position(this._sizes,[...t,...e]);return[this._table[s],s]}toArray(){return this._tensor.toArray()}best_action(t){const[e]=this._q(this._state_index(t)),s=Math.max(...e),i=[];for(let t=0;t<e.length;t++)e[t]===s&&i.push(t);let n=i[Math.floor(Math.random()*i.length)];const r=this._to_index(this._action_sizes,n);return this._action_value(r)}}class QTable extends QTableBase{constructor(t,e=20,s=.2,i=.99){super(t,e),this._alpha=s,this._gamma=i}update(t,e,s,i){t=this._action_index(t),e=this._state_index(e),s=this._state_index(s);const[n]=this._q(s),r=Math.max(...n),[a,o]=this._q(e,t);this._table[o]+=this._alpha*(i+this._gamma*r-a)}}export default class QAgent{constructor(t,e=20){this._table=new QTable(t,e)}get_score(t){return this._table.toArray()}get_action(t,e,s=.002){return Math.random()>s?this._table.best_action(e):t.sample_action(this)}update(t,e,s,i){this._table.update(t,e,s,i)}}