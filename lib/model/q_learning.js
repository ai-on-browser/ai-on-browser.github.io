import Tensor from"../util/tensor.js";import{RLEnvironmentBase,RLRealRange,RLIntRange}from"../rl/base.js";export class QTableBase{constructor(t,e=20){this._env=t,this._resolution=e,this._state_sizes=t.states.map((t=>Array.isArray(t)?t.length:t.toArray(e).length)),this._action_sizes=t.actions.map((t=>Array.isArray(t)?t.length:t.toArray(e).length)),this._sizes=[...this._state_sizes,...this._action_sizes],this._tensor=new Tensor(this._sizes),this._table=this._tensor.value}get tensor(){return this._tensor}get states(){return this._env.states}get actions(){return this._env.actions}get resolution(){return this._resolution}_state_index(t){return t.map(((t,e)=>{const s=this.states[e];if(Array.isArray(s))return s.indexOf(t);if(s instanceof RLIntRange)return s.indexOf(t,this.resolution);if(s instanceof RLRealRange)return s.indexOf(t,this.resolution);throw"Not implemented"}))}_state_value(t){return t.map(((t,e)=>{const s=this.states[e];if(Array.isArray(s))return s[t];if(s instanceof RLIntRange)return s.toArray(this.resolution)[t];if(s instanceof RLRealRange)return t*(s.max-s.min)/this.resolution+s.min;throw"Not implemented"}))}_action_index(t){return t.map(((t,e)=>{const s=this.actions[e];if(Array.isArray(s))return s.indexOf(t);if(s instanceof RLRealRange)return s.indexOf(t,this.resolution);throw"Not implemented"}))}_action_value(t){return t.map(((t,e)=>{const s=this.actions[e];if(Array.isArray(s))return s[t];if(s instanceof RLRealRange)return t*(s.max-s.min)/this.resolution+s.min;throw"Not implemented"}))}_to_position(t,e){let s=0;for(let n=0;n<e.length;n++)s=s*t[n]+e[n];let n=s+1;for(let i=e.length;i<t.length;i++)s*=t[i],n*=t[i];return[s,n]}_to_index(t,e){const s=Array(t.length);for(let n=t.length-1;n>=0;n--)s[n]=e%t[n],e=Math.floor(e/t[n]);return s}_q(t,e){if(!e){const[e,s]=this._to_position(this._sizes,t);return[this._table.slice(e,s),[e,s]]}const[s]=this._to_position(this._sizes,[...t,...e]);return[this._table[s],s]}toArray(){return this._tensor.toArray()}best_action(t){const[e]=this._q(this._state_index(t)),s=Math.max(...e),n=[];for(let t=0;t<e.length;t++)e[t]===s&&n.push(t);let i=n[Math.floor(Math.random()*n.length)];const r=this._to_index(this._action_sizes,i);return this._action_value(r)}}class QTable extends QTableBase{constructor(t,e=20,s=.2,n=.99){super(t,e),this._alpha=s,this._gamma=n}update(t,e,s,n){t=this._action_index(t),e=this._state_index(e),s=this._state_index(s);const[i]=this._q(s),r=Math.max(...i),[a,o]=this._q(e,t);this._table[o]+=this._alpha*(n+this._gamma*r-a)}}export default class QAgent{constructor(t,e=20){this._env=t,this._table=new QTable(t,e)}get_score(){return this._table.toArray()}get_action(t,e=.002){return Math.random()>e?this._table.best_action(t):this._env.sample_action(this)}update(t,e,s,n){this._table.update(t,e,s,n)}}