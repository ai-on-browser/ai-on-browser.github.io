var c=Object.defineProperty;var o=(a,s)=>c(a,"name",{value:s,configurable:!0});import m from"../util/tensor.js";import{RLRealRange as h,RLIntRange as l}from"../rl/base.js";export class QTableBase{static{o(this,"QTableBase")}constructor(s,e=20){this._env=s,this._resolution=e,this._state_sizes=s.states.map(r=>Array.isArray(r)?r.length:r.toArray(e).length),this._action_sizes=s.actions.map(r=>Array.isArray(r)?r.length:r.toArray(e).length),this._sizes=[...this._state_sizes,...this._action_sizes],this._tensor=new m(this._sizes),this._table=this._tensor.value}get tensor(){return this._tensor}get states(){return this._env.states}get actions(){return this._env.actions}get resolution(){return this._resolution}_state_index(s){return s.map((e,r)=>{const t=this.states[r];if(Array.isArray(t))return t.indexOf(e);if(t instanceof l)return t.indexOf(e,this.resolution);if(t instanceof h)return t.indexOf(e,this.resolution);throw"Not implemented"})}_state_value(s){return s.map((e,r)=>{const t=this.states[r];if(Array.isArray(t))return t[e];if(t instanceof l)return t.toArray(this.resolution)[e];if(t instanceof h)return e*(t.max-t.min)/this.resolution+t.min;throw"Not implemented"})}_action_index(s){return s.map((e,r)=>{const t=this.actions[r];if(Array.isArray(t))return t.indexOf(e);if(t instanceof h)return t.indexOf(e,this.resolution);throw"Not implemented"})}_action_value(s){return s.map((e,r)=>{const t=this.actions[r];if(Array.isArray(t))return t[e];if(t instanceof h)return e*(t.max-t.min)/this.resolution+t.min;throw"Not implemented"})}_to_position(s,e){let r=0;for(let i=0;i<e.length;i++)r=r*s[i]+e[i];let t=r+1;for(let i=e.length;i<s.length;i++)r*=s[i],t*=s[i];return[r,t]}_to_index(s,e){const r=Array(s.length);for(let t=s.length-1;t>=0;t--)r[t]=e%s[t],e=Math.floor(e/s[t]);return r}_q(s,e){if(!e){const[t,i]=this._to_position(this._sizes,s);return[this._table.slice(t,i),[t,i]]}const[r]=this._to_position(this._sizes,[...s,...e]);return[this._table[r],r]}toArray(){return this._tensor.toArray()}best_action(s){const[e]=this._q(this._state_index(s)),r=Math.max(...e),t=[];for(let n=0;n<e.length;n++)e[n]===r&&t.push(n);let i=t[Math.floor(Math.random()*t.length)];const _=this._to_index(this._action_sizes,i);return this._action_value(_)}}class f extends QTableBase{static{o(this,"QTable")}constructor(s,e=20,r=.2,t=.99){super(s,e),this._alpha=r,this._gamma=t}update(s,e,r,t){s=this._action_index(s),e=this._state_index(e),r=this._state_index(r);const[i]=this._q(r),_=Math.max(...i),[n,u]=this._q(e,s);this._table[u]+=this._alpha*(t+this._gamma*_-n)}}export default class d{static{o(this,"QAgent")}constructor(s,e=20){this._env=s,this._table=new f(s,e)}get_score(){return this._table.toArray()}get_action(s,e=.002){return Math.random()>e?this._table.best_action(s):this._env.sample_action(this)}update(s,e,r,t){this._table.update(s,e,r,t)}}
