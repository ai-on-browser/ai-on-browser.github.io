var A=Object.defineProperty;var m=(l,t)=>A(l,"name",{value:t,configurable:!0});import i from"../util/matrix.js";class k{static{m(this,"GaussianFunction")}constructor(t=0,o=1,r=1){this._m=t,this._s=o,this._a=r,this._e=1}calc(t){return this._a*Math.exp(-((t-this._m)**2)/(2*this._s))}update(t,o){const r=i.map(t,c=>this.calc(c)/this._a);r.mult(o),this._a+=this._e*r.mean();const h=i.map(t,c=>-this.calc(c)*((c-this._m)**2/(2*this._s**2)));h.mult(o),this._s+=this._e*h.mean();const e=i.map(t,c=>this.calc(c)*(c-this._m));e.mult(o),this._m+=this._e*e.mean()}grad(t){return this.calc(t)*(this._m-t)}}export default class b{static{m(this,"ProjectionPursuit")}constructor(t=5){this._r=t,this._w=null,this._f=[];for(let o=0;o<t;o++)this._f[o]=new k(0,10)}fit(t,o){t=i.fromArray(t),o=i.fromArray(o);const r=t.rows,h=i.resize(t,r,t.cols+1,1);if(this._w===null){this._w=[];for(let s=0;s<this._r;s++)this._w[s]=i.random(h.cols,1,-1,1)}const e=new i(r,this._r),c=new i(r,this._r);for(let s=0;s<this._r;s++){const a=h.dot(this._w[s]);e.set(0,s,a),c.set(0,s,i.map(a,n=>this._f[s].calc(n)))}for(let s=0;s<this._r;s++){const a=i.sub(o,c.sum(1));this._f[s].update(e.col(s),a);const n=new i(r,1),f=new i(r,1);for(let _=0;_<r;_++){const p=e.at(_,s);let d=this._f[s].grad(p);n.set(_,0,d**2),f.set(_,0,p+a.at(_,0)/d)}const u=i.mult(h,n);this._w[s]=u.tDot(h).solve(u.tDot(f));const w=h.dot(this._w[s]);e.set(0,s,w),c.set(0,s,i.map(w,_=>this._f[s].calc(_)))}}predict(t){t=i.fromArray(t);const o=i.resize(t,t.rows,t.cols+1,1),r=new i(o.rows,this._r);for(let h=0;h<this._r;h++){const e=o.dot(this._w[h]);r.set(0,h,i.map(e,c=>this._f[h].calc(c)))}return r.sum(1).toArray()}}
