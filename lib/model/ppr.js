import{Matrix}from"../util/math.js";class GaussianFunction{constructor(t=0,s=1,i=1){this._m=t,this._s=s,this._a=i,this._e=1}calc(t){return this._a*Math.exp(-((t-this._m)**2)/(2*this._s))}update(t,s){const i=t.copyMap((t=>this.calc(t)/this._a));i.mult(s),this._a+=this._e*i.mean();const r=t.copyMap((t=>-this.calc(t)*((t-this._m)**2/(2*this._s**2))));r.mult(s),this._s+=this._e*r.mean();const o=t.copyMap((t=>this.calc(t)*(t-this._m)));o.mult(s),this._m+=this._e*o.mean()}grad(t){return this.calc(t)*(this._m-t)}}export default class ProjectionPursuit{constructor(t=5){this._r=t,this._w=null,this._f=[];for(let s=0;s<t;s++)this._f[s]=new GaussianFunction(0,10)}fit(t,s){t=Matrix.fromArray(t),s=Matrix.fromArray(s);const i=t.rows,r=t.resize(i,t.cols+1,1);if(null===this._w){this._w=[];for(let t=0;t<this._r;t++)this._w[t]=Matrix.random(r.cols,1,-1,1)}const o=new Matrix(i,this._r),a=new Matrix(i,this._r);for(let t=0;t<this._r;t++){const s=r.dot(this._w[t]);o.set(0,t,s),a.set(0,t,s.copyMap((s=>this._f[t].calc(s))))}for(let t=0;t<this._r;t++){const c=s.copySub(a.sum(1));this._f[t].update(o.col(t),c);const h=new Matrix(i,1),e=new Matrix(i,1);for(let s=0;s<i;s++){const i=o.at(s,t);let r=this._f[t].grad(i);h.set(s,0,r**2),e.set(s,0,i+c.at(s,0)/r)}const _=r.copyMult(h);this._w[t]=_.tDot(r).solve(_.tDot(e));const n=r.dot(this._w[t]);o.set(0,t,n),a.set(0,t,n.copyMap((s=>this._f[t].calc(s))))}}predict(t){let s=(t=Matrix.fromArray(t)).resize(t.rows,t.cols+1,1);const i=new Matrix(s.rows,this._r);for(let t=0;t<this._r;t++){const r=s.dot(this._w[t]);i.set(0,t,r.copyMap((s=>this._f[t].calc(s))))}return i.sum(1).toArray()}}