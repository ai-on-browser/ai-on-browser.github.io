import Matrix from"../util/matrix.js";class GaussianFunction{constructor(t=0,s=1,i=1){this._m=t,this._s=s,this._a=i,this._e=1}calc(t){return this._a*Math.exp(-((t-this._m)**2)/(2*this._s))}update(t,s){const i=Matrix.map(t,(t=>this.calc(t)/this._a));i.mult(s),this._a+=this._e*i.mean();const r=Matrix.map(t,(t=>-this.calc(t)*((t-this._m)**2/(2*this._s**2))));r.mult(s),this._s+=this._e*r.mean();const a=Matrix.map(t,(t=>this.calc(t)*(t-this._m)));a.mult(s),this._m+=this._e*a.mean()}grad(t){return this.calc(t)*(this._m-t)}}export default class ProjectionPursuit{constructor(t=5){this._r=t,this._w=null,this._f=[];for(let s=0;s<t;s++)this._f[s]=new GaussianFunction(0,10)}fit(t,s){t=Matrix.fromArray(t),s=Matrix.fromArray(s);const i=t.rows,r=Matrix.resize(t,i,t.cols+1,1);if(null===this._w){this._w=[];for(let t=0;t<this._r;t++)this._w[t]=Matrix.random(r.cols,1,-1,1)}const a=new Matrix(i,this._r),o=new Matrix(i,this._r);for(let t=0;t<this._r;t++){const s=r.dot(this._w[t]);a.set(0,t,s),o.set(0,t,Matrix.map(s,(s=>this._f[t].calc(s))))}for(let t=0;t<this._r;t++){const h=Matrix.sub(s,o.sum(1));this._f[t].update(a.col(t),h);const c=new Matrix(i,1),e=new Matrix(i,1);for(let s=0;s<i;s++){const i=a.at(s,t);let r=this._f[t].grad(i);c.set(s,0,r**2),e.set(s,0,i+h.at(s,0)/r)}const _=Matrix.mult(r,c);this._w[t]=_.tDot(r).solve(_.tDot(e));const n=r.dot(this._w[t]);a.set(0,t,n),o.set(0,t,Matrix.map(n,(s=>this._f[t].calc(s))))}}predict(t){t=Matrix.fromArray(t);const s=Matrix.resize(t,t.rows,t.cols+1,1),i=new Matrix(s.rows,this._r);for(let t=0;t<this._r;t++){const r=s.dot(this._w[t]);i.set(0,t,Matrix.map(r,(s=>this._f[t].calc(s))))}return i.sum(1).toArray()}}