var A=Object.defineProperty;var l=(y,t)=>A(y,"name",{value:t,configurable:!0});import g from"../util/matrix.js";import d from"../util/tensor.js";export{default as Layer}from"./nns/layer/base.js";import _ from"./nns/graph.js";export{default as ComputationalGraph}from"./nns/graph.js";import*as m from"./nns/optimizer.js";export class NeuralnetworkException extends Error{static{l(this,"NeuralnetworkException")}constructor(t,e){super(t),this.value=e,this.name="NeuralnetworkException"}}export default class p{static{l(this,"NeuralNetwork")}static fromObject(t,e,s="sgd"){t.filter(i=>i.type==="output").length===0&&t.push({type:"output"}),e&&t.push({type:e});const a=new _;for(const i of t)a.add(i,i.name,i.input);return new p(a,s)}static async fromONNX(t){return new p(await _.fromONNX(t))}constructor(t,e="sgd"){this._graph=t,this._optimizer=e,Object.keys(m).includes(e)?this._opt=new m[e]:this._opt=new m.sgd,this._opt_managers=[];for(let s=0;s<this._graph.size;s++)this._opt_managers.push(this._opt.manager())}_getDatasize(t){if(Array.isArray(t))return t.length;if(t instanceof g||t instanceof d)return t.sizes[0];for(const e of Object.keys(t)){if(Array.isArray(t[e]))return t[e].length;if(t[e]instanceof g||t[e]instanceof d)return t[e].sizes[0];break}return 0}copy(){return new p(_.fromObject(this._graph.toObject()),this._optimizer)}toObject(){return this._graph.toObject()}calc(t,e,s,a={}){const i=this._getDatasize(t);if(this._graph.bind({input:t,supervisor:e,n:i,...a}),!s&&!e){const n=this._graph.outputNodes;for(let r=0;r<this._graph.nodes.length;r++)if(this._graph.nodes[r]===n[0])return this._graph.calc([r]),this._graph.nodes[r].outputValue}if(this._graph.calc(s),s){const n={};for(const r of this._graph.nodes)s.includes(r.name)&&(n[r.name]=r.outputValue);return n}return this._graph.nodes[this._graph.size-1].outputValue}grad(t){return this._graph.grad(t),this._graph.inputNodes[0].gradientValue[0]}update(t){this._opt.learningRate=t;for(let e=0;e<this._graph.size;e++)this._graph.nodes[e].layer.update(this._opt_managers[e])}fit(t,e,s=1,a=.1,i=null,n={}){const r=this._getDatasize(t);let c;for(;s-- >0;)if(i)for(let h=0;h<r;h+=i){const f=Math.min(r,h+i);let u;if(Array.isArray(t)||t instanceof g||t instanceof d)u=t.slice(h,f);else{u={};for(const o of Object.keys(t)){if(!t[o])continue;const z=Array.isArray(t[o])?t[o].length:t[o].sizes[0];u[o]=z<r?t[o]:t[o].slice(h,f)}}c=this.calc(u,e?.slice(h,f),null,{training:!0,...n}),this.grad(),this.update(a)}else c=this.calc(t,e,null,{training:!0,...n}),this.grad(),this.update(a);return c.toArray().flat()}predict(t){return this.calc(t).toArray()}}
