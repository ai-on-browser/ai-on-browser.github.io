import Matrix from"../util/matrix.js";import Tensor from"../util/tensor.js";import Layer from"./nns/layer/base.js";export{default as Layer}from"./nns/layer/base.js";import ComputationalGraph from"./nns/graph.js";export{default as ComputationalGraph}from"./nns/graph.js";import{SGDOptimizer,MomentumOptimizer,RMSPropOptimizer,AdamOptimizer}from"./nns/optimizer.js";export class NeuralnetworkException extends Error{constructor(t,r){super(t),this.value=r,this.name="NeuralnetworkException"}}export default class NeuralNetwork{static fromObject(t,r,e="sgd"){0===t.filter((t=>"output"===t.type)).length&&t.push({type:"output"}),r&&t.push({type:r});const i=new Set;for(const r of t)if(r.input&&Array.isArray(r.input))for(let t=0;t<r.input.length;t++)"number"==typeof r.input[t]&&(i.add(r.input[t]),r.input[t]=`__const_number_${r.input[t]}`);i.size&&(t[0].input=[]);const s=new ComputationalGraph;for(const t of i){const r=Layer.fromObject({type:"const",value:[[t]]});s.add(r,`__const_number_${t}`,[])}for(const r of t){const t=Layer.fromObject(r);s.add(t,r.name,r.input)}return new NeuralNetwork(s,e)}static async fromONNX(t){return new NeuralNetwork(await ComputationalGraph.fromONNX(t))}constructor(t,r="sgd"){this._graph=t,this._optimizer=r,this._opt="adam"===r?new AdamOptimizer:"momentum"===r?new MomentumOptimizer:"rmsprop"===r?new RMSPropOptimizer:new SGDOptimizer,this._opt_managers=[];for(let t=0;t<this._graph.size;t++)this._opt_managers.push(this._opt.manager())}_getDatasize(t){if(Array.isArray(t))return t.length;if(t instanceof Matrix||t instanceof Tensor)return t.sizes[0];for(const r of Object.keys(t)){if(Array.isArray(t[r]))return t[r].length;if(t[r]instanceof Matrix||t[r]instanceof Tensor)return t[r].sizes[0];break}return 0}copy(){return new NeuralNetwork(ComputationalGraph.fromObject(this._graph.toObject()),this._optimizer)}toObject(){return this._graph.toObject()}calc(t,r,e,i={}){const s=this._getDatasize(t);if(this._graph.bind({input:t,supervisor:r,n:s,...i}),!e&&!r){const t=this._graph.outputNodes;for(let r=0;r<this._graph.nodes.length;r++)if(this._graph.nodes[r]===t[0])return this._graph.calc([r]),this._graph.nodes[r].outputValue}if(this._graph.calc(e),e){const t={};for(const r of this._graph.nodes)e.includes(r.name)&&(t[r.name]=r.outputValue);return t}return this._graph.nodes[this._graph.size-1].outputValue}grad(t){this._graph.grad(t);return this._graph.inputNodes[0].gradientValue[0]}update(t){this._opt.learningRate=t;for(let t=0;t<this._graph.size;t++)this._graph.nodes[t].layer.update(this._opt_managers[t])}fit(t,r,e=1,i=.1,s=null,a={}){const n=this._getDatasize(t);let o;for(;e-- >0;)if(s)for(let e=0;e<n;e+=s){const p=Math.min(n,e+s);let u;if(Array.isArray(t)||t instanceof Matrix||t instanceof Tensor)u=t.slice(e,p);else{u={};for(const r of Object.keys(t)){if(!t[r])continue;const i=Array.isArray(t[r])?t[r].length:t[r].sizes[0];u[r]=i<n?t[r]:t[r].slice(e,p)}}o=this.calc(u,r?.slice(e,p),null,{training:!0,...a}),this.grad(),this.update(i)}else o=this.calc(t,r,null,{training:!0,...a}),this.grad(),this.update(i);return o.toArray().flat()}predict(t){return this.calc(t).toArray()}}