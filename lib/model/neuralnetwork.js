import Matrix from"../util/matrix.js";import Tensor from"../util/tensor.js";import{Layer,LossLayer}from"./layer/index.js";export{Layer}from"./layer/index.js";import InputLayer from"./layer/input.js";import OutputLayer from"./layer/output.js";export class NeuralnetworkException extends Error{constructor(t,r){super(t),this.value=r,this.name="NeuralnetworkException"}}export class Graph{constructor(){this._nodes=[]}get nodes(){return this._nodes}get size(){return this._nodes.length}static fromObject(t){const r=new Graph;for(const e of t){const t=Layer.fromObject(e);"string"==typeof e.input&&(e.input=[e.input]),r.add(t,e.name,e.input)}return r}toObject(){const t=[];for(let r=0;r<this._nodes.length;r++){const e=this._nodes[r],s=e.layer.toObject();e.name&&(s.name=e.name),e.input&&(s.input=e.input),t.push(s)}return t}add(t,r,e){let s=[];e?("string"==typeof e&&(e=[e]),s=e.map((t=>{const r=t&&t.match(/\[([0-9]+)\]$/),e=r?+r[1]:null,s=r?t.slice(0,-r[0].length):t;for(let t=0;t<this._nodes.length;t++)if(this._nodes[t].name===s)return{index:t,subscript:e};throw new NeuralnetworkException(`Unknown input name '${t}'.`)}))):this._nodes.length>0&&s.push({index:this._nodes.length-1,subscript:null}),this._nodes.push({layer:t,name:r,input:e,parents:s})}}export default class NeuralNetwork{static fromObject(t,r,e="sgd"){0===t.filter((t=>"output"===t.type)).length&&t.push({type:"output"}),r&&t.push({type:r});const s=new Set;for(const r of t)if(r.input&&Array.isArray(r.input))for(let t=0;t<r.input.length;t++)"number"==typeof r.input[t]&&(s.add(r.input[t]),r.input[t]=`__const_number_${r.input[t]}`);s.size&&(t[0].input=[]);const n=new Graph;for(const t of s){const r=Layer.fromObject({type:"const",value:t});n.add(r,`__const_number_${t}`,[])}let a=!1;for(const r of t){const t=Layer.fromObject(r);n.add(t,r.name,r.input),a||=t instanceof LossLayer}return a||n.add(new LossLayer({})),new NeuralNetwork(n,e)}constructor(t,r="sgd"){this._graph=t,this._optimizer=r,this._opt="adam"===r?new AdamOptimizer:"momentum"===r?new MomentumOptimizer:"rmsprop"===r?new RMSPropOptimizer:new SGDOptimizer,this._opt_managers=[];for(let t=0;t<this._graph.size;t++)this._opt_managers.push(this._opt.manager())}copy(){return new NeuralNetwork(Graph.fromObject(this._graph.toObject()),this._optimizer)}toObject(){return this._graph.toObject()}calc(t,r,e,s={}){let n=0;if(Array.isArray(t))2===(t=Tensor.fromArray(t)).dimension&&(t=t.toMatrix()),n=t.sizes[0];else if(t instanceof Matrix||t instanceof Tensor)n=t.sizes[0];else for(const r of Object.keys(t))t[r]=Tensor.fromArray(t[r]),2===t[r].dimension&&(t[r]=t[r].toMatrix()),n=t[r].sizes[0];for(const e of this._graph.nodes)e.layer.bind({input:t,supervisor:r,n:n,...s});const a=[],i={};for(let t=0;t<this._graph.size;t++){const s=this._graph.nodes[t];if(a[t]=s.layer.calc(...s.parents.map((t=>null!==t.subscript?a[t.index][t.subscript]:a[t.index]))),e&&e.indexOf(s.name)>=0&&(i[s.name]=a[t],Object.keys(i).length===e.length))return i;if(!r&&s.layer instanceof OutputLayer)return e?i:a[t]}return e?i:a[a.length-1]}grad(t){const r=[];let e=null;for(let t=0;t<this._graph.size;r[t++]=[]);for(let s=this._graph.size-1;s>=0;s--){const n=this._graph.nodes[s];if(t){if(!(n.layer instanceof OutputLayer))continue;r[s]=[t],t=null}if(!(n.layer instanceof LossLayer)&&0===r[s].length)continue;for(let t=0;t<r[s].length;t++)void 0===r[s][t]&&(r[s][t]=null);let a=n.layer.grad(...r[s]);Array.isArray(a)||(a=Array(n.parents.length).fill(a)),n.parents.forEach(((t,e)=>{if(!a[e])return;const s=t.subscript||0;r[t.index][s]?r[t.index][s].add(a[e]):r[t.index][s]=a[e].copy()})),n.layer instanceof InputLayer&&(e=r[s][0])}return e}update(t){this._opt.learningRate=t;for(let t=0;t<this._graph.size;t++)this._graph.nodes[t].layer.update(this._opt_managers[t])}fit(t,r,e=1,s=.1,n=null,a={}){if(Array.isArray(t))2===(t=Tensor.fromArray(t)).dimension&&(t=t.toMatrix());else if(!(t instanceof Matrix||t instanceof Tensor))for(const r of Object.keys(t))t[r]=Tensor.fromArray(t[r]),2===t[r].dimension&&(t[r]=t[r].toMatrix());let i;for(r=Matrix.fromArray(r);e-- >0;)if(n)for(let e=0;e<r.rows;e+=n){const o=Math.min(r.rows,e+n);let p;if(t instanceof Matrix||t instanceof Tensor)p=t.slice(e,o);else{p={};for(const r of Object.keys(t))p[r]=(t[r],t[r].slice(e,o))}i=this.calc(p,r.slice(e,o),null,a),this.grad(),this.update(s)}else i=this.calc(t,r,null,a),this.grad(),this.update(s);return i.toArray().flat()}predict(t){return this.calc(t).toArray()}}class SGDOptimizer{constructor(t){this._learningrate=t}set learningRate(t){this._learningrate=t}manager(){const t=this;return{get lr(){return t._learningrate},delta(t,r){return r.copyMult(this.lr)}}}}class MomentumOptimizer{constructor(t,r=.9){this._learningrate=t,this._beta=r}set learningRate(t){this._learningrate=t}manager(){const t=this;return{get lr(){return t._learningrate},params:{},delta(r,e){if(!this.params[r])return this.params[r]=e,e.copyMult(this.lr);const s=this.params[r].copyMult(t._beta);return s.add(e.copyMult(1-t._beta)),this.params[r]=s,s.copyMult(this.lr)}}}}class RMSPropOptimizer{constructor(t,r=.999){this._learningrate=t,this._beta=r}set learningRate(t){this._learningrate=t}manager(){const t=this;return{get lr(){return t._learningrate},params:{},delta(r,e){if(!this.params[r])return this.params[r]=e.copyMult(e),e.copyMult(this.lr);const s=this.params[r].copyMult(t._beta);return s.add(e.copyMap((r=>(1-t._beta)*r*r))),this.params[r]=s,e.copyMult(s.copyMap((t=>this.lr/Math.sqrt(t+1e-12))))}}}}class AdamOptimizer{constructor(t=.001,r=.9,e=.999){this._learningrate=t,this._beta1=r,this._beta2=e}set learningRate(t){this._learningrate=t}manager(){const t=this;return{get lr(){return t._learningrate},params:{},delta(r,e){if(!this.params[r])return this.params[r]={v:e,s:e.copyMult(e)},e.copyMult(this.lr);const s=this.params[r].v.copyMult(t._beta1);s.add(e.copyMult(1-t._beta1));const n=this.params[r].s.copyMult(t._beta2);return n.add(e.copyMap((r=>(1-t._beta2)*r*r))),this.params[r]={v:s,s:n},s.copyMult(n.copyMap((t=>this.lr/Math.sqrt(t+1e-12))))}}}}