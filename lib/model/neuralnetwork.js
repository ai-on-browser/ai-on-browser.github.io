var O=Object.defineProperty;var l=(y,t)=>O(y,"name",{value:t,configurable:!0});import g from"../util/matrix.js";import d from"../util/tensor.js";import b from"./nns/layer/base.js";export{default as Layer}from"./nns/layer/base.js";import _ from"./nns/graph.js";export{default as ComputationalGraph}from"./nns/graph.js";import*as m from"./nns/optimizer.js";export class NeuralnetworkException extends Error{static{l(this,"NeuralnetworkException")}constructor(t,e){super(t),this.value=e,this.name="NeuralnetworkException"}}export default class u{static{l(this,"NeuralNetwork")}static fromObject(t,e,i="sgd"){t.filter(r=>r.type==="output").length===0&&t.push({type:"output"}),e&&t.push({type:e});const o=new Set;for(const r of t)if(r.input&&Array.isArray(r.input))for(let s=0;s<r.input.length;s++)typeof r.input[s]=="number"&&(o.add(r.input[s]),r.input[s]=`__const_number_${r.input[s]}`);o.size&&(t[0].input=[]);const n=new _;for(const r of o){const s=b.fromObject({type:"const",value:[[r]]});n.add(s,`__const_number_${r}`,[])}for(const r of t){const s=b.fromObject(r);n.add(s,r.name,r.input)}return new u(n,i)}static async fromONNX(t){return new u(await _.fromONNX(t))}constructor(t,e="sgd"){this._graph=t,this._optimizer=e,Object.keys(m).includes(e)?this._opt=new m[e]:this._opt=new m.sgd,this._opt_managers=[];for(let i=0;i<this._graph.size;i++)this._opt_managers.push(this._opt.manager())}_getDatasize(t){if(Array.isArray(t))return t.length;if(t instanceof g||t instanceof d)return t.sizes[0];for(const e of Object.keys(t)){if(Array.isArray(t[e]))return t[e].length;if(t[e]instanceof g||t[e]instanceof d)return t[e].sizes[0];break}return 0}copy(){return new u(_.fromObject(this._graph.toObject()),this._optimizer)}toObject(){return this._graph.toObject()}calc(t,e,i,o={}){const n=this._getDatasize(t);if(this._graph.bind({input:t,supervisor:e,n,...o}),!i&&!e){const r=this._graph.outputNodes;for(let s=0;s<this._graph.nodes.length;s++)if(this._graph.nodes[s]===r[0])return this._graph.calc([s]),this._graph.nodes[s].outputValue}if(this._graph.calc(i),i){const r={};for(const s of this._graph.nodes)i.includes(s.name)&&(r[s.name]=s.outputValue);return r}return this._graph.nodes[this._graph.size-1].outputValue}grad(t){return this._graph.grad(t),this._graph.inputNodes[0].gradientValue[0]}update(t){this._opt.learningRate=t;for(let e=0;e<this._graph.size;e++)this._graph.nodes[e].layer.update(this._opt_managers[e])}fit(t,e,i=1,o=.1,n=null,r={}){const s=this._getDatasize(t);let h;for(;i-- >0;)if(n)for(let p=0;p<s;p+=n){const f=Math.min(s,p+n);let c;if(Array.isArray(t)||t instanceof g||t instanceof d)c=t.slice(p,f);else{c={};for(const a of Object.keys(t)){if(!t[a])continue;const A=Array.isArray(t[a])?t[a].length:t[a].sizes[0];c[a]=A<s?t[a]:t[a].slice(p,f)}}h=this.calc(c,e?.slice(p,f),null,{training:!0,...r}),this.grad(),this.update(o)}else h=this.calc(t,e,null,{training:!0,...r}),this.grad(),this.update(o);return h.toArray().flat()}predict(t){return this.calc(t).toArray()}}
