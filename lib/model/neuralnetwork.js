import Matrix from"../util/matrix.js";import Tensor from"../util/tensor.js";import Layer,{LossLayer}from"./nns/layer/base.js";export{default as Layer}from"./nns/layer/base.js";import ComputationalGraph from"./nns/graph.js";export{default as ComputationalGraph}from"./nns/graph.js";import{SGDOptimizer,MomentumOptimizer,RMSPropOptimizer,AdamOptimizer}from"./nns/optimizer.js";import InputLayer from"./nns/layer/input.js";import OutputLayer from"./nns/layer/output.js";let ONNXImporter=null;export class NeuralnetworkException extends Error{constructor(t,r){super(t),this.value=r,this.name="NeuralnetworkException"}}export default class NeuralNetwork{static fromObject(t,r,e="sgd"){0===t.filter((t=>"output"===t.type)).length&&t.push({type:"output"}),r&&t.push({type:r});const o=new Set;for(const r of t)if(r.input&&Array.isArray(r.input))for(let t=0;t<r.input.length;t++)"number"==typeof r.input[t]&&(o.add(r.input[t]),r.input[t]=`__const_number_${r.input[t]}`);o.size&&(t[0].input=[]);const s=new ComputationalGraph;for(const t of o){const r=Layer.fromObject({type:"const",value:[[t]]});s.add(r,`__const_number_${t}`,[])}let n=!1;for(const r of t){const t=Layer.fromObject(r);s.add(t,r.name,r.input),n||=t instanceof LossLayer}return n||s.add(new LossLayer({})),new NeuralNetwork(s,e)}static async fromONNX(t){return ONNXImporter||(ONNXImporter=(await import("./nns/onnx/onnx_importer.js")).default),ONNXImporter.load(t)}constructor(t,r="sgd"){this._graph=t,this._optimizer=r,this._opt="adam"===r?new AdamOptimizer:"momentum"===r?new MomentumOptimizer:"rmsprop"===r?new RMSPropOptimizer:new SGDOptimizer,this._opt_managers=[];for(let t=0;t<this._graph.size;t++)this._opt_managers.push(this._opt.manager())}copy(){return new NeuralNetwork(ComputationalGraph.fromObject(this._graph.toObject()),this._optimizer)}toObject(){return this._graph.toObject()}calc(t,r,e,o={}){let s=0;if(Array.isArray(t))2===(t=Tensor.fromArray(t)).dimension&&(t=t.toMatrix()),s=t.sizes[0];else if(t instanceof Matrix||t instanceof Tensor)s=t.sizes[0];else for(const r of Object.keys(t))t[r]=Tensor.fromArray(t[r]),2===t[r].dimension&&(t[r]=t[r].toMatrix()),s=t[r].sizes[0];if(this._graph.bind({input:t,supervisor:r,n:s,...o}),!e&&!r)for(let t=0;t<this._graph.nodes.length;t++)if(this._graph.nodes[t].layer instanceof OutputLayer)return this._graph.calc([t]),this._graph.nodes[t].outputValue;if(this._graph.calc(e),e){const t={};for(const r of this._graph.nodes)e.indexOf(r.name)>=0&&(t[r.name]=r.outputValue);return t}return this._graph.nodes[this._graph.size-1].outputValue}grad(t){this._graph.grad(t);for(const t of this._graph.nodes)if(t.layer instanceof InputLayer)return t.gradientValue[0]}update(t){this._opt.learningRate=t;for(let t=0;t<this._graph.size;t++)this._graph.nodes[t].layer.update(this._opt_managers[t])}fit(t,r,e=1,o=.1,s=null,n={}){if(Array.isArray(t))2===(t=Tensor.fromArray(t)).dimension&&(t=t.toMatrix());else if(!(t instanceof Matrix||t instanceof Tensor))for(const r of Object.keys(t))t[r]=Tensor.fromArray(t[r]),2===t[r].dimension&&(t[r]=t[r].toMatrix());let i;for(r=Matrix.fromArray(r);e-- >0;)if(s)for(let e=0;e<r.rows;e+=s){const a=Math.min(r.rows,e+s);let p;if(t instanceof Matrix||t instanceof Tensor)p=t.slice(e,a);else{p={};for(const o of Object.keys(t))p[o]=t[o].sizes[0]<r.rows?t[o]:t[o].slice(e,a)}i=this.calc(p,r.slice(e,a),null,{training:!0,...n}),this.grad(),this.update(o)}else i=this.calc(t,r,null,{training:!0,...n}),this.grad(),this.update(o);return i.toArray().flat()}predict(t){return this.calc(t).toArray()}}