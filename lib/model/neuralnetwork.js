var A=Object.defineProperty;var d=(O,t)=>A(O,"name",{value:t,configurable:!0});import m from"../util/matrix.js";import _ from"../util/tensor.js";import y from"./nns/layer/base.js";export{default as Layer}from"./nns/layer/base.js";import g from"./nns/graph.js";export{default as ComputationalGraph}from"./nns/graph.js";import*as a from"./nns/optimizer.js";export class NeuralnetworkException extends Error{static{d(this,"NeuralnetworkException")}constructor(t,e){super(t),this.value=e,this.name="NeuralnetworkException"}}export default class u{static{d(this,"NeuralNetwork")}static fromObject(t,e,i="sgd"){t.filter(r=>r.type==="output").length===0&&t.push({type:"output"}),e&&t.push({type:e});const o=new Set;for(const r of t)if(r.input&&Array.isArray(r.input))for(let s=0;s<r.input.length;s++)typeof r.input[s]=="number"&&(o.add(r.input[s]),r.input[s]=`__const_number_${r.input[s]}`);o.size&&(t[0].input=[]);const n=new g;for(const r of o){const s=y.fromObject({type:"const",value:[[r]]});n.add(s,`__const_number_${r}`,[])}for(const r of t){const s=y.fromObject(r);n.add(s,r.name,r.input)}return new u(n,i)}static async fromONNX(t){return new u(await g.fromONNX(t))}constructor(t,e="sgd"){this._graph=t,this._optimizer=e,e==="adam"?this._opt=new a.AdamOptimizer:e==="momentum"?this._opt=new a.MomentumOptimizer:e==="adagrad"?this._opt=new a.AdaGradOptimizer:e==="rmsprop"?this._opt=new a.RMSPropOptimizer:e==="adadelta"?this._opt=new a.AdaDeltaOptimizer:e==="rmspropgraves"?this._opt=new a.RMSPropGravesOptimizer:e==="smorms3"?this._opt=new a.SMORMS3Optimizer:e==="adamax"?this._opt=new a.AdaMaxOptimizer:e==="nadam"?this._opt=new a.NadamOptimizer:this._opt=new a.SGDOptimizer,this._opt_managers=[];for(let i=0;i<this._graph.size;i++)this._opt_managers.push(this._opt.manager())}_getDatasize(t){if(Array.isArray(t))return t.length;if(t instanceof m||t instanceof _)return t.sizes[0];for(const e of Object.keys(t)){if(Array.isArray(t[e]))return t[e].length;if(t[e]instanceof m||t[e]instanceof _)return t[e].sizes[0];break}return 0}copy(){return new u(g.fromObject(this._graph.toObject()),this._optimizer)}toObject(){return this._graph.toObject()}calc(t,e,i,o={}){const n=this._getDatasize(t);if(this._graph.bind({input:t,supervisor:e,n,...o}),!i&&!e){const r=this._graph.outputNodes;for(let s=0;s<this._graph.nodes.length;s++)if(this._graph.nodes[s]===r[0])return this._graph.calc([s]),this._graph.nodes[s].outputValue}if(this._graph.calc(i),i){const r={};for(const s of this._graph.nodes)i.includes(s.name)&&(r[s.name]=s.outputValue);return r}return this._graph.nodes[this._graph.size-1].outputValue}grad(t){return this._graph.grad(t),this._graph.inputNodes[0].gradientValue[0]}update(t){this._opt.learningRate=t;for(let e=0;e<this._graph.size;e++)this._graph.nodes[e].layer.update(this._opt_managers[e])}fit(t,e,i=1,o=.1,n=null,r={}){const s=this._getDatasize(t);let c;for(;i-- >0;)if(n)for(let h=0;h<s;h+=n){const l=Math.min(s,h+n);let f;if(Array.isArray(t)||t instanceof m||t instanceof _)f=t.slice(h,l);else{f={};for(const p of Object.keys(t)){if(!t[p])continue;const w=Array.isArray(t[p])?t[p].length:t[p].sizes[0];f[p]=w<s?t[p]:t[p].slice(h,l)}}c=this.calc(f,e?.slice(h,l),null,{training:!0,...r}),this.grad(),this.update(o)}else c=this.calc(t,e,null,{training:!0,...r}),this.grad(),this.update(o);return c.toArray().flat()}predict(t){return this.calc(t).toArray()}}
