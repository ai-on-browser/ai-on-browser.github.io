import Matrix from"../util/matrix.js";import Tensor from"../util/tensor.js";import{Layer,LossLayer}from"./nns/layer/index.js";export{Layer}from"./nns/layer/index.js";import ComputationalGraph from"./nns/graph.js";export{default as ComputationalGraph}from"./nns/graph.js";import{SGDOptimizer,MomentumOptimizer,RMSPropOptimizer,AdamOptimizer}from"./nns/optimizer.js";import InputLayer from"./nns/layer/input.js";import OutputLayer from"./nns/layer/output.js";export class NeuralnetworkException extends Error{constructor(t,r){super(t),this.value=r,this.name="NeuralnetworkException"}}export default class NeuralNetwork{static fromObject(t,r,e="sgd"){0===t.filter((t=>"output"===t.type)).length&&t.push({type:"output"}),r&&t.push({type:r});const n=new Set;for(const r of t)if(r.input&&Array.isArray(r.input))for(let t=0;t<r.input.length;t++)"number"==typeof r.input[t]&&(n.add(r.input[t]),r.input[t]=`__const_number_${r.input[t]}`);n.size&&(t[0].input=[]);const s=new ComputationalGraph;for(const t of n){const r=Layer.fromObject({type:"const",value:t});s.add(r,`__const_number_${t}`,[])}let o=!1;for(const r of t){const t=Layer.fromObject(r);s.add(t,r.name,r.input),o||=t instanceof LossLayer}return o||s.add(new LossLayer({})),new NeuralNetwork(s,e)}constructor(t,r="sgd"){this._graph=t,this._optimizer=r,this._opt="adam"===r?new AdamOptimizer:"momentum"===r?new MomentumOptimizer:"rmsprop"===r?new RMSPropOptimizer:new SGDOptimizer,this._opt_managers=[];for(let t=0;t<this._graph.size;t++)this._opt_managers.push(this._opt.manager())}copy(){return new NeuralNetwork(ComputationalGraph.fromObject(this._graph.toObject()),this._optimizer)}toObject(){return this._graph.toObject()}calc(t,r,e,n={}){let s=0;if(Array.isArray(t))2===(t=Tensor.fromArray(t)).dimension&&(t=t.toMatrix()),s=t.sizes[0];else if(t instanceof Matrix||t instanceof Tensor)s=t.sizes[0];else for(const r of Object.keys(t))t[r]=Tensor.fromArray(t[r]),2===t[r].dimension&&(t[r]=t[r].toMatrix()),s=t[r].sizes[0];for(const e of this._graph.nodes)e.layer.bind({input:t,supervisor:r,n:s,...n});const o=[],i={};for(let t=0;t<this._graph.size;t++)try{const n=this._graph.nodes[t];if(o[t]=n.layer.calc(...n.parents.map((t=>null!==t.subscript?o[t.index][t.subscript]:o[t.index]))),n.lastOutputValue=o[t],e&&e.indexOf(n.name)>=0&&(i[n.name]=o[t],Object.keys(i).length===e.length))return i;if(!r&&n.layer instanceof OutputLayer)return e?i:o[t]}catch(r){throw new Error(`Error raises at ${t} layer. ${r.stack}`)}return e?i:o[o.length-1]}grad(t){const r=[];let e=null;for(let t=0;t<this._graph.size;r[t++]=[]);for(let n=this._graph.size-1;n>=0;n--){const s=this._graph.nodes[n];if(t){if(!(s.layer instanceof OutputLayer))continue;r[n]=[t],t=null}if(!(s.layer instanceof LossLayer)&&0===r[n].length)continue;for(let t=0;t<r[n].length;t++)void 0===r[n][t]&&(r[n][t]=null);let o=s.layer.grad(...r[n]);s.lastGradientValue=o,Array.isArray(o)||(o=Array(s.parents.length).fill(o)),s.parents.forEach(((t,e)=>{if(!o[e])return;const n=t.subscript||0;r[t.index][n]?r[t.index][n].add(o[e]):r[t.index][n]=o[e].copy()})),s.layer instanceof InputLayer&&(e=r[n][0])}return e}update(t){this._opt.learningRate=t;for(let t=0;t<this._graph.size;t++)this._graph.nodes[t].layer.update(this._opt_managers[t])}fit(t,r,e=1,n=.1,s=null,o={}){if(Array.isArray(t))2===(t=Tensor.fromArray(t)).dimension&&(t=t.toMatrix());else if(!(t instanceof Matrix||t instanceof Tensor))for(const r of Object.keys(t))t[r]=Tensor.fromArray(t[r]),2===t[r].dimension&&(t[r]=t[r].toMatrix());let i;for(r=Matrix.fromArray(r);e-- >0;)if(s)for(let e=0;e<r.rows;e+=s){const a=Math.min(r.rows,e+s);let p;if(t instanceof Matrix||t instanceof Tensor)p=t.slice(e,a);else{p={};for(const n of Object.keys(t))p[n]=t[n].sizes[0]<r.rows?t[n]:t[n].slice(e,a)}i=this.calc(p,r.slice(e,a),null,o),this.grad(),this.update(n)}else i=this.calc(t,r,null,o),this.grad(),this.update(n);return i.toArray().flat()}predict(t){return this.calc(t).toArray()}}