import Matrix from"../util/matrix.js";import Tensor from"../util/tensor.js";import{Layer,LossLayer}from"./nns/layer/index.js";export{Layer}from"./nns/layer/index.js";import ComputationalGraph from"./nns/graph.js";export{default as ComputationalGraph}from"./nns/graph.js";import{SGDOptimizer,MomentumOptimizer,RMSPropOptimizer,AdamOptimizer}from"./nns/optimizer.js";import InputLayer from"./nns/layer/input.js";import OutputLayer from"./nns/layer/output.js";let ONNXImporter=null;export class NeuralnetworkException extends Error{constructor(t,r){super(t),this.value=r,this.name="NeuralnetworkException"}}export default class NeuralNetwork{static fromObject(t,r,e="sgd"){0===t.filter((t=>"output"===t.type)).length&&t.push({type:"output"}),r&&t.push({type:r});const n=new Set;for(const r of t)if(r.input&&Array.isArray(r.input))for(let t=0;t<r.input.length;t++)"number"==typeof r.input[t]&&(n.add(r.input[t]),r.input[t]=`__const_number_${r.input[t]}`);n.size&&(t[0].input=[]);const o=new ComputationalGraph;for(const t of n){const r=Layer.fromObject({type:"const",value:t});o.add(r,`__const_number_${t}`,[])}let s=!1;for(const r of t){const t=Layer.fromObject(r);o.add(t,r.name,r.input),s||=t instanceof LossLayer}return s||o.add(new LossLayer({})),new NeuralNetwork(o,e)}static async fromONNX(t){return ONNXImporter||(ONNXImporter=(await import("./nns/onnx/onnx_importer.js")).default),ONNXImporter.load(t)}constructor(t,r="sgd"){this._graph=t,this._optimizer=r,this._opt="adam"===r?new AdamOptimizer:"momentum"===r?new MomentumOptimizer:"rmsprop"===r?new RMSPropOptimizer:new SGDOptimizer,this._opt_managers=[];for(let t=0;t<this._graph.size;t++)this._opt_managers.push(this._opt.manager())}copy(){return new NeuralNetwork(ComputationalGraph.fromObject(this._graph.toObject()),this._optimizer)}toObject(){return this._graph.toObject()}calc(t,r,e,n={}){let o=0;if(Array.isArray(t))2===(t=Tensor.fromArray(t)).dimension&&(t=t.toMatrix()),o=t.sizes[0];else if(t instanceof Matrix||t instanceof Tensor)o=t.sizes[0];else for(const r of Object.keys(t))t[r]=Tensor.fromArray(t[r]),2===t[r].dimension&&(t[r]=t[r].toMatrix()),o=t[r].sizes[0];for(const e of this._graph.nodes)e.layer.bind({input:t,supervisor:r,n:o,...n});const s=[],i={};for(let t=0;t<this._graph.size;t++)try{const n=this._graph.nodes[t];if(s[t]=n.layer.calc(...n.parents.map((t=>null!==t.subscript?s[t.index][t.subscript]:s[t.index]))),n.lastOutputValue=s[t],e&&e.indexOf(n.name)>=0&&(i[n.name]=s[t],Object.keys(i).length===e.length))return i;if(!r&&n.layer instanceof OutputLayer)return e?i:s[t]}catch(r){throw new Error(`Error raises at ${t} layer. ${r.stack}`)}return e?i:s[s.length-1]}grad(t){const r=[];let e=null;for(let t=0;t<this._graph.size;r[t++]=[]);for(let n=this._graph.size-1;n>=0;n--){const o=this._graph.nodes[n];if(t){if(!(o.layer instanceof OutputLayer))continue;r[n]=[t],t=null}if(!(o.layer instanceof LossLayer)&&0===r[n].length)continue;for(let t=0;t<r[n].length;t++)void 0===r[n][t]&&(r[n][t]=null);let s=o.layer.grad(...r[n]);o.lastGradientValue=s,Array.isArray(s)||(s=Array(o.parents.length).fill(s)),o.parents.forEach(((t,e)=>{if(!s[e])return;const n=t.subscript||0;r[t.index][n]?r[t.index][n].add(s[e]):r[t.index][n]=s[e].copy()})),o.layer instanceof InputLayer&&(e=r[n][0])}return e}update(t){this._opt.learningRate=t;for(let t=0;t<this._graph.size;t++)this._graph.nodes[t].layer.update(this._opt_managers[t])}fit(t,r,e=1,n=.1,o=null,s={}){if(Array.isArray(t))2===(t=Tensor.fromArray(t)).dimension&&(t=t.toMatrix());else if(!(t instanceof Matrix||t instanceof Tensor))for(const r of Object.keys(t))t[r]=Tensor.fromArray(t[r]),2===t[r].dimension&&(t[r]=t[r].toMatrix());let i;for(r=Matrix.fromArray(r);e-- >0;)if(o)for(let e=0;e<r.rows;e+=o){const a=Math.min(r.rows,e+o);let p;if(t instanceof Matrix||t instanceof Tensor)p=t.slice(e,a);else{p={};for(const n of Object.keys(t))p[n]=t[n].sizes[0]<r.rows?t[n]:t[n].slice(e,a)}i=this.calc(p,r.slice(e,a),null,s),this.grad(),this.update(n)}else i=this.calc(t,r,null,s),this.grad(),this.update(n);return i.toArray().flat()}predict(t){return this.calc(t).toArray()}}