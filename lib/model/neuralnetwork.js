var z=Object.defineProperty;var l=(_,t)=>z(_,"name",{value:t,configurable:!0});import m from"../util/matrix.js";import g from"../util/tensor.js";import y from"./nns/layer/base.js";export{default as Layer}from"./nns/layer/base.js";import d from"./nns/graph.js";export{default as ComputationalGraph}from"./nns/graph.js";import{SGDOptimizer as b,MomentumOptimizer as A,RMSPropOptimizer as w,AdamOptimizer as j}from"./nns/optimizer.js";export class NeuralnetworkException extends Error{static{l(this,"NeuralnetworkException")}constructor(t,e){super(t),this.value=e,this.name="NeuralnetworkException"}}export default class u{static{l(this,"NeuralNetwork")}static fromObject(t,e,s="sgd"){t.filter(r=>r.type==="output").length===0&&t.push({type:"output"}),e&&t.push({type:e});const o=new Set;for(const r of t)if(r.input&&Array.isArray(r.input))for(let i=0;i<r.input.length;i++)typeof r.input[i]=="number"&&(o.add(r.input[i]),r.input[i]=`__const_number_${r.input[i]}`);o.size&&(t[0].input=[]);const n=new d;for(const r of o){const i=y.fromObject({type:"const",value:[[r]]});n.add(i,`__const_number_${r}`,[])}for(const r of t){const i=y.fromObject(r);n.add(i,r.name,r.input)}return new u(n,s)}static async fromONNX(t){return new u(await d.fromONNX(t))}constructor(t,e="sgd"){this._graph=t,this._optimizer=e,e==="adam"?this._opt=new j:e==="momentum"?this._opt=new A:e==="rmsprop"?this._opt=new w:this._opt=new b,this._opt_managers=[];for(let s=0;s<this._graph.size;s++)this._opt_managers.push(this._opt.manager())}_getDatasize(t){if(Array.isArray(t))return t.length;if(t instanceof m||t instanceof g)return t.sizes[0];for(const e of Object.keys(t)){if(Array.isArray(t[e]))return t[e].length;if(t[e]instanceof m||t[e]instanceof g)return t[e].sizes[0];break}return 0}copy(){return new u(d.fromObject(this._graph.toObject()),this._optimizer)}toObject(){return this._graph.toObject()}calc(t,e,s,o={}){const n=this._getDatasize(t);if(this._graph.bind({input:t,supervisor:e,n,...o}),!s&&!e){const r=this._graph.outputNodes;for(let i=0;i<this._graph.nodes.length;i++)if(this._graph.nodes[i]===r[0])return this._graph.calc([i]),this._graph.nodes[i].outputValue}if(this._graph.calc(s),s){const r={};for(const i of this._graph.nodes)s.includes(i.name)&&(r[i.name]=i.outputValue);return r}return this._graph.nodes[this._graph.size-1].outputValue}grad(t){return this._graph.grad(t),this._graph.inputNodes[0].gradientValue[0]}update(t){this._opt.learningRate=t;for(let e=0;e<this._graph.size;e++)this._graph.nodes[e].layer.update(this._opt_managers[e])}fit(t,e,s=1,o=.1,n=null,r={}){const i=this._getDatasize(t);let c;for(;s-- >0;)if(n)for(let p=0;p<i;p+=n){const f=Math.min(i,p+n);let h;if(Array.isArray(t)||t instanceof m||t instanceof g)h=t.slice(p,f);else{h={};for(const a of Object.keys(t)){if(!t[a])continue;const O=Array.isArray(t[a])?t[a].length:t[a].sizes[0];h[a]=O<i?t[a]:t[a].slice(p,f)}}c=this.calc(h,e?.slice(p,f),null,{training:!0,...r}),this.grad(),this.update(o)}else c=this.calc(t,e,null,{training:!0,...r}),this.grad(),this.update(o);return c.toArray().flat()}predict(t){return this.calc(t).toArray()}}
