import{Tensor,Matrix}from"../util/math.js";import Layer from"./layer/base.js";export function NeuralnetworkException(r,t){this.message=r,this.value=t,this.name=NeuralnetworkException}export default class NeuralNetwork{static fromObject(r,t,e="sgd"){const a=[];0===r.filter((r=>"output"===r.type)).length&&r.push({type:"output"}),t&&r.push({type:t});const s=new Set;for(const t of r)if(t.input&&Array.isArray(t.input))for(let r=0;r<t.input.length;r++)"number"==typeof t.input[r]&&(s.add(t.input[r]),t.input[r]=`__const_number_${t.input[r]}`);s.size&&(r[0].input=[]);for(const r of s){const t=new ConstLayer({value:r,input:[]});t.name=`__const_number_${r}`,t.parent=[],a.push(t)}for(const t of r){const r=Layer.fromObject(t);if(r.name=t.name,r.parent=[],r.input=t.input,t.input){"string"==typeof t.input&&(t.input=[t.input]);for(const e of t.input){const t=/\[([0-9]+)\]$/,s=e&&e.match(t),o=s?+s[1]:null,i=s?e.slice(0,-s[0].length):e,n=a.filter((r=>i===r.name));r.parent.push({layer:n[0],index:a.indexOf(n[0]),subscript:o})}}else{const t=a.length-1;t>=0&&r.parent.push({layer:a[t],index:t,subscript:null})}a.push(r)}return new NeuralNetwork(a,null,e)}constructor(r,t,e="sgd"){if(this._layers=r,t){const r=Layer.fromObject({type:t});r.parent=[{layer:this._layers[this._layers.length-1],index:this._layers.length-1,subscript:null}],this._layers.push(r)}this._optimizer=e,this._opt="adam"===e?new AdamOptimizer:"momentum"===e?new MomentumOptimizer:"rmsprop"===e?new RMSPropOptimizer:new SGDOptimizer,this._opt_managers=[];for(let r=0;r<this._layers.length;r++)this._opt_managers.push(this._opt.manager())}copy(){return NeuralNetwork.fromObject(this.toObject(),null,this._optimizer)}toObject(){const r=[];for(let t=0;t<this._layers.length;t++){const e=this._layers[t],a=e.toObject();e.name&&(a.name=e.name),e.input&&(a.input=e.input),r.push(a)}return r}calc(r,t,e,a={}){let s=0;if(Array.isArray(r))2===(r=Tensor.fromArray(r)).dimension&&(r=r.toMatrix()),s=r.sizes[0];else if(r instanceof Matrix||r instanceof Tensor)s=r.sizes[0];else for(const t of Object.keys(r))r[t]=Tensor.fromArray(r[t]),2===r[t].dimension&&(r[t]=r[t].toMatrix()),s=r[t].sizes[0];for(const e of this._layers)e.bind({input:r,supervisor:t,n:s,...a});const o=[],i={};for(let r=0;r<this._layers.length;r++){const a=this._layers[r];if(o[r]=a.calc(...a.parent.map((r=>null!==r.subscript?o[r.index][r.subscript]:o[r.index]))),e&&e.indexOf(a.name)>=0&&(i[a.name]=o[r],Object.keys(i).length===e.length))return i;if(!t&&a instanceof OutputLayer)return e?i:o[r]}return e?i:o[o.length-1]}grad(r){const t=[];let e=null;for(let r=0;r<this._layers.length;t[r++]=[]);t[t.length-1]=[new Matrix(1,1,1)];for(let a=this._layers.length-1;a>=0;a--){const s=this._layers[a];if(r){if(!(s instanceof OutputLayer))continue;t[a]=[r],r=null}if(0===t[a].length)continue;for(let r=0;r<t[a].length;r++)void 0===t[a][r]&&(t[a][r]=null);let o=s.grad(...t[a]);Array.isArray(o)||(o=Array(s.parent.length).fill(o)),s.parent.forEach(((r,e)=>{if(!o[e])return;const a=r.subscript||0;t[r.index][a]?t[r.index][a].add(o[e]):t[r.index][a]=o[e].copy()})),s instanceof InputLayer&&(e=t[a][0])}return e}update(r){this._opt.learningRate=r;for(let r=0;r<this._layers.length;r++)this._layers[r].update(this._opt_managers[r])}fit(r,t,e=1,a=.1,s=null,o={}){if(Array.isArray(r))2===(r=Tensor.fromArray(r)).dimension&&(r=r.toMatrix());else if(!(r instanceof Matrix||r instanceof Tensor))for(const t of Object.keys(r))r[t]=Tensor.fromArray(r[t]),2===r[t].dimension&&(r[t]=r[t].toMatrix());let i;for(t=Matrix.fromArray(t);e-- >0;)if(s)for(let e=0;e<t.rows;e+=s){const n=Math.min(t.rows,e+s);let l;if(r instanceof Matrix||r instanceof Tensor)l=r instanceof Matrix?r.sliceRow(e,n):r.slice(e,n);else{l={};for(const t of Object.keys(r))l[t]=r[t]instanceof Matrix?r[t].sliceRow(e,n):r[t].slice(e,n)}i=this.calc(l,t.sliceRow(e,n),null,o),this.grad(),this.update(a)}else i=this.calc(r,t,null,o),this.grad(),this.update(a);return i.toArray().flat()}}class SGDOptimizer{constructor(r){this._learningrate=r}set learningRate(r){this._learningrate=r}manager(){const r=this;return{get lr(){return r._learningrate},delta(r,t){return t.copyMult(this.lr)}}}}class MomentumOptimizer{constructor(r,t=.9){this._learningrate=r,this._beta=t}set learningRate(r){this._learningrate=r}manager(){const r=this;return{get lr(){return r._learningrate},params:{},delta(t,e){if(!this.params[t])return this.params[t]=e,e.copyMult(this.lr);const a=this.params[t].copyMult(r._beta);return a.add(e.copyMult(1-r._beta)),this.params[t]=a,a.copyMult(this.lr)}}}}class RMSPropOptimizer{constructor(r,t=.999){this._learningrate=r,this._beta=t}set learningRate(r){this._learningrate=r}manager(){const r=this;return{get lr(){return r._learningrate},params:{},delta(t,e){if(!this.params[t])return this.params[t]=e.copyMult(e),e.copyMult(this.lr);const a=this.params[t].copyMult(r._beta);return a.add(e.copyMap((t=>(1-r._beta)*t*t))),this.params[t]=a,e.copyMult(a.copyMap((r=>this.lr/Math.sqrt(r+1e-12))))}}}}class AdamOptimizer{constructor(r=.001,t=.9,e=.999){this._learningrate=r,this._beta1=t,this._beta2=e}set learningRate(r){this._learningrate=r}manager(){const r=this;return{get lr(){return r._learningrate},params:{},delta(t,e){if(!this.params[t])return this.params[t]={v:e,s:e.copyMult(e)},e.copyMult(this.lr);const a=this.params[t].v.copyMult(r._beta1);a.add(e.copyMult(1-r._beta1));const s=this.params[t].s.copyMult(r._beta2);return s.add(e.copyMap((t=>(1-r._beta2)*t*t))),this.params[t]={v:a,s:s},a.copyMult(s.copyMap((r=>this.lr/Math.sqrt(r+1e-12))))}}}}import InputLayer from"./layer/input.js";import OutputLayer from"./layer/output.js";import SupervisorLayer from"./layer/supervisor.js";import IncludeLayer from"./layer/include.js";import ConstLayer from"./layer/const.js";import RandomLayer from"./layer/random.js";import VariableLayer from"./layer/variable.js";import FullyConnected from"./layer/full.js";import LinearLayer from"./layer/linear.js";import NegativeLayer from"./layer/negative.js";import SigmoidLayer from"./layer/sigmoid.js";import TanhLayer from"./layer/tanh.js";import SoftsignLayer from"./layer/softsign.js";import SoftplusLayer from"./layer/softplus.js";import AbsLayer from"./layer/abs.js";import ReluLayer from"./layer/relu.js";import LeakyReluLayer from"./layer/leaky_relu.js";import ELULayer from"./layer/elu.js";import PReLULayer from"./layer/prelu.js";import RReluLayer from"./layer/rrelu.js";import SoftmaxLayer from"./layer/softmax.js";import SoftargmaxLayer from"./layer/softargmax.js";import LogLayer from"./layer/log.js";import ExpLayer from"./layer/exp.js";import SquareLayer from"./layer/square.js";import SqrtLayer from"./layer/sqrt.js";import PowerLayer from"./layer/power.js";import GaussianLayer from"./layer/gaussian.js";import BatchNormalizationLayer from"./layer/batch_normalization.js";import SparseLayer from"./layer/sparse.js";import DropoutLayer from"./layer/dropout.js";import DetachLayer from"./layer/detach.js";import ClipLayer from"./layer/clip.js";import AddLayer from"./layer/add.js";import SubLayer from"./layer/sub.js";import MultLayer from"./layer/mult.js";import DivLayer from"./layer/div.js";import MatmulLayer from"./layer/matmul.js";import ConvLayer from"./layer/conv.js";import RNNLayer from"./layer/rnn.js";import LSTMLayer from"./layer/lstm.js";import GRULayer from"./layer/gru.js";import SumLayer from"./layer/sum.js";import MeanLayer from"./layer/mean.js";import VarLayer from"./layer/variance.js";import ReshapeLayer from"./layer/reshape.js";import ReverseLayer from"./layer/reverse.js";import TransposeLayer from"./layer/transpose.js";import FlattenLayer from"./layer/flatten.js";import ConcatLayer from"./layer/concat.js";import SplitLayer from"./layer/split.js";import OnehotLayer from"./layer/onehot.js";import ArgmaxLayer from"./layer/argmax.js";import LessLayer from"./layer/less.js";import CondLayer from"./layer/cond.js";import MSELayer from"./layer/mse.js";import HuberLayer from"./layer/huber.js";