var M=Object.defineProperty;var g=(f,i)=>M(f,"name",{value:i,configurable:!0});import x from"../util/matrix.js";class k{static{g(this,"KMeans")}constructor(i,o){this._x=i,this._k=o;const e=this._x.length,n=[];for(let s=0;s<this._k;s++)n.push(Math.floor(Math.random()*(e-s)));for(let s=n.length-1;s>=0;s--)for(let t=n.length-1;t>s;t--)n[s]<=n[t]&&n[t]++;this._c=n.map(s=>this._x[s]),this._d=(s,t)=>Math.sqrt(s.reduce((c,r,h)=>c+(r-t[h])**2,0))}get centroids(){return this._c}fit(){const i=this.predict(),o=this._c.map(t=>Array.from(t,()=>0)),e=Array(this._k).fill(0),n=this._x.length;for(let t=0;t<n;t++){for(let c=0;c<this._x[t].length;c++)o[i[t]][c]+=this._x[t][c];e[i[t]]++}let s=0;for(let t=0;t<this._k;t++){const c=o[t].map(r=>r/e[t]);s+=this._c[t].reduce((r,h,d)=>r+(h-c[d])**2,0),this._c[t]=o[t].map(r=>r/e[t])}return s}predict(){const i=[],o=this._x.length;for(let e=0;e<o;e++){let n=1/0;i[e]=-1;for(let s=0;s<this._k;s++){const t=this._d(this._x[e],this._c[s]);t<n&&(n=t,i[e]=s)}}return i}}export default class w{static{g(this,"XMeans")}constructor(){this._centroids=[],this._init_k=2}get centroids(){return this._centroids}get size(){return this._centroids.length}_distance(i,o){return Math.sqrt(i.reduce((e,n,s)=>e+(n-o[s])**2,0))}clear(){this._centroids=[]}fit(i,o=-1){let e=null;this._centroids.length===0?(e=this._split_cluster(i,this._init_k),o--):e=this._create_clusters(this,i);const n=[];for(;e.length>0&&(o<0||o-- >0);){const s=[];for(;e.length>0;){const t=e.shift();if(t.size<=3){n.push(t.centroid);continue}const[c,r]=this._split_cluster(t.data),h=Math.sqrt(c.centroid.reduce((p,l,_)=>p+(l-r.centroid[_])**2,0)/(c.cov.det()+r.cov.det())),u=.5/(1/(1+Math.exp(-1.7*h))),m=t.cols*(t.cols+3)/2;-2*(t.size*Math.log(u)+c.llh+r.llh)+2*m*Math.log(t.size)<t.bic?s.push(c,r):n.push(t.centroid)}e=s}e.length>0&&n.push(...e.map(s=>s.centroid)),this._centroids=n}_split_cluster(i,o=2){const e=new k(i,o);for(;e.fit()>0;);return this._create_clusters(e,i)}_create_clusters(i,o){const e=i.centroids.length,n=i.predict(o),s=[];for(let c=0;c<e;s[c++]=[]);o.forEach((c,r)=>s[n[r]].push(c));const t=[];for(let c=0;c<e;c++){const r=x.fromArray(s[c]),h=r.cov(),d=h.inv(),u=r.mean(0);let a=Math.log(1/Math.sqrt((2*Math.PI)**r.cols*h.det()))*r.rows;for(let l=0;l<r.rows;l++){const _=r.row(l);_.sub(u),a-=_.dot(d).dot(_.t).toScaler()/2}const p=r.cols*(r.cols+3)/2;t[c]={size:s[c].length,cols:r.cols,data:s[c],cov:h,centroid:i.centroids[c],llh:a,bic:-2*a+p*Math.log(s[c].length)}}return t}predict(i){if(this._centroids.length===0)throw new Error("Call fit before predict.");return i.map(o=>{let e=1/0,n=-1;for(let s=0;s<this._centroids.length;s++){const t=this._distance(o,this._centroids[s]);t<e&&(e=t,n=s)}return n})}}
