import{Matrix}from"../util/math.js";import{KMeansModel}from"./kmeans.js";const argmin=function(t,e){return 0===t.length?-1:(t=e?t.map(e):t).indexOf(Math.min(...t))};export default class XMeans{constructor(){this._centroids=[],this._init_k=2}get centroids(){return this._centroids}get size(){return this._centroids.length}_distance(t,e){return Math.sqrt(t.reduce(((t,s,r)=>t+(s-e[r])**2),0))}clear(){this._centroids=[]}fit(t,e=-1){let s=null;0===this._centroids.length?(s=this._split_cluster(t,this._init_k),e--):s=this._create_clusters(this,t);const r=[];for(;s.length>0&&(e<0||e-- >0);){const t=[];for(;s.length>0;){const e=s.shift();if(e.size<=3){r.push(e.centroid);continue}const[i,n]=this._split_cluster(e.data),o=Math.sqrt(i.centroid.reduce(((t,e,s)=>t+(e-n.centroid[s])**2),0)/(i.cov.det()+n.cov.det())),c=.5/(1/(1+Math.exp(-1.7*o))),l=e.cols*(e.cols+3)/2;-2*(e.size*Math.log(c)+i.llh+n.llh)+2*l*Math.log(e.size)<e.bic?t.push(i,n):r.push(e.centroid)}s=t}s.length>0&&r.push(...s.map((t=>t.centroid))),this._centroids=r}_split_cluster(t,e=2){const s=new KMeansModel;for(let r=0;r<e;r++)s.add(t);for(;s.fit(t)>0;);return this._create_clusters(s,t)}_create_clusters(t,e){const s=t.size,r=t.predict(e),i=[];for(let t=0;t<s;i[t++]=[]);e.forEach(((t,e)=>i[r[e]].push(t)));const n=[];for(let e=0;e<s;e++){const s=Matrix.fromArray(i[e]),r=s.cov(),o=r.inv(),c=s.mean(0);let l=Math.log(1/Math.sqrt((2*Math.PI)**s.cols*r.det()))*s.rows;for(let t=0;t<s.rows;t++){const e=s.row(t);e.sub(c),l-=e.dot(o).dot(e.t).value[0]/2}const h=s.cols*(s.cols+3)/2;n[e]={size:i[e].length,cols:s.cols,data:i[e],cov:r,centroid:t.centroids[e],llh:l,bic:-2*l+h*Math.log(i[e].length)}}return n}predict(t){if(0!==this._centroids.length)return t.map((t=>{return e=this._centroids,s=e=>this._distance(t,e),0===e.length?-1:(e=s?e.map(s):e).indexOf(Math.min(...e));var e,s}))}}