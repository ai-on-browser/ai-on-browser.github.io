import Matrix from"../util/matrix.js";import{KMeans}from"./kmeans.js";export default class XMeans{constructor(){this._centroids=[],this._init_k=2}get centroids(){return this._centroids}get size(){return this._centroids.length}_distance(t,e){return Math.sqrt(t.reduce(((t,s,r)=>t+(s-e[r])**2),0))}clear(){this._centroids=[]}fit(t,e=-1){let s=null;0===this._centroids.length?(s=this._split_cluster(t,this._init_k),e--):s=this._create_clusters(this,t);const r=[];for(;s.length>0&&(e<0||e-- >0);){const t=[];for(;s.length>0;){const e=s.shift();if(e.size<=3){r.push(e.centroid);continue}const[o,i]=this._split_cluster(e.data),c=Math.sqrt(o.centroid.reduce(((t,e,s)=>t+(e-i.centroid[s])**2),0)/(o.cov.det()+i.cov.det())),n=.5/(1/(1+Math.exp(-1.7*c))),l=e.cols*(e.cols+3)/2;-2*(e.size*Math.log(n)+o.llh+i.llh)+2*l*Math.log(e.size)<e.bic?t.push(o,i):r.push(e.centroid)}s=t}s.length>0&&r.push(...s.map((t=>t.centroid))),this._centroids=r}_split_cluster(t,e=2){const s=new KMeans;for(let r=0;r<e;r++)s.add(t);for(;s.fit(t)>0;);return this._create_clusters(s,t)}_create_clusters(t,e){const s=t.size,r=t.predict(e),o=[];for(let t=0;t<s;o[t++]=[]);e.forEach(((t,e)=>o[r[e]].push(t)));const i=[];for(let e=0;e<s;e++){const s=Matrix.fromArray(o[e]),r=s.cov(),c=r.inv(),n=s.mean(0);let l=Math.log(1/Math.sqrt((2*Math.PI)**s.cols*r.det()))*s.rows;for(let t=0;t<s.rows;t++){const e=s.row(t);e.sub(n),l-=e.dot(c).dot(e.t).toScaler()/2}const h=s.cols*(s.cols+3)/2;i[e]={size:o[e].length,cols:s.cols,data:o[e],cov:r,centroid:t.centroids[e],llh:l,bic:-2*l+h*Math.log(o[e].length)}}return i}predict(t){if(0===this._centroids.length)throw new Error("Call fit before predict.");return t.map((t=>{let e=1/0,s=-1;for(let r=0;r<this._centroids.length;r++){const o=this._distance(t,this._centroids[r]);o<e&&(e=o,s=r)}return s}))}}