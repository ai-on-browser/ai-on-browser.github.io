var M=Object.defineProperty;var m=(f,c)=>M(f,"name",{value:c,configurable:!0});import w from"../util/matrix.js";import{KMeans as v}from"./kmeans.js";export default class b{static{m(this,"XMeans")}constructor(){this._centroids=[],this._init_k=2}get centroids(){return this._centroids}get size(){return this._centroids.length}_distance(c,o){return Math.sqrt(c.reduce((t,n,e)=>t+(n-o[e])**2,0))}clear(){this._centroids=[]}fit(c,o=-1){let t=null;this._centroids.length===0?(t=this._split_cluster(c,this._init_k),o--):t=this._create_clusters(this,c);const n=[];for(;t.length>0&&(o<0||o-- >0);){const e=[];for(;t.length>0;){const r=t.shift();if(r.size<=3){n.push(r.centroid);continue}const[s,i]=this._split_cluster(r.data),l=Math.sqrt(s.centroid.reduce((u,h,d)=>u+(h-i.centroid[d])**2,0)/(s.cov.det()+i.cov.det())),a=.5/(1/(1+Math.exp(-1.7*l))),g=r.cols*(r.cols+3)/2;-2*(r.size*Math.log(a)+s.llh+i.llh)+2*g*Math.log(r.size)<r.bic?e.push(s,i):n.push(r.centroid)}t=e}t.length>0&&n.push(...t.map(e=>e.centroid)),this._centroids=n}_split_cluster(c,o=2){const t=new v;for(let n=0;n<o;n++)t.add(c);for(;t.fit(c)>0;);return this._create_clusters(t,c)}_create_clusters(c,o){const t=c.size,n=c.predict(o),e=[];for(let s=0;s<t;e[s++]=[]);o.forEach((s,i)=>e[n[i]].push(s));const r=[];for(let s=0;s<t;s++){const i=w.fromArray(e[s]),l=i.cov(),p=l.inv(),a=i.mean(0);let _=Math.log(1/Math.sqrt((2*Math.PI)**i.cols*l.det()))*i.rows;for(let h=0;h<i.rows;h++){const d=i.row(h);d.sub(a),_-=d.dot(p).dot(d.t).toScaler()/2}const u=i.cols*(i.cols+3)/2;r[s]={size:e[s].length,cols:i.cols,data:e[s],cov:l,centroid:c.centroids[s],llh:_,bic:-2*_+u*Math.log(e[s].length)}}return r}predict(c){if(this._centroids.length===0)throw new Error("Call fit before predict.");return c.map(o=>{let t=1/0,n=-1;for(let e=0;e<this._centroids.length;e++){const r=this._distance(o,this._centroids[e]);r<t&&(t=r,n=e)}return n})}}
