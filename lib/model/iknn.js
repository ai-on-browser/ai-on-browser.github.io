import Matrix from"../util/matrix.js";export default class IKNN{constructor(t,i){this._k=t,this._i=i,this._gamma=2}_pr(t,i){let h=0;for(let s=0;s<t.length;s++)h+=this._w[s]*(i[s]-t[s])**2;return Math.exp(-h/this._gamma)}fit(t,i){this._x=t,this._y=i,this._c=[...new Set(i)];const h=t[0].length;this._w=Array(h).fill(0),this._eta=[];for(let t=0;t<this._c.length;t++){const i=this._x.filter(((i,h)=>this._y[h]===this._c[t])),s=Matrix.fromArray(i).variance(0).value;for(let t=0;t<h;t++)this._w[t]+=s[t];this._eta[t]=i.length}this._w=this._w.map((t=>t/this._c.length)),this._eta=this._eta.map((t=>t/this._x.length)),this._logp2t=Array(this._x.length).fill(0);for(let t=0;t<this._x.length;t++){for(let i=0;i<this._x.length;i++)t!==i&&(this._logp2t[t]+=Math.log(1-this._pr(this._x[t],this._x[i])));for(let i=0;i<this._c.length;i++)this._y[t]===this._c[i]&&(this._logp2t[t]*=1-this._eta[i])}}predict(t){return t.map((t=>{const i=this._x.map(((i,h)=>({i:h,d:Math.sqrt(i.reduce(((i,h,s)=>i+(t[s]-h)**2),0)),pr:this._pr(i,t)}))),h=i.reduce(((t,i)=>t+i.pr),0);i.sort(((t,i)=>t.d-i.d));const s=[];for(let t=0;t<this._i&&t<this._k;t++){const _=Math.exp(this._eta*Math.log(i[t].pr)+this._logp2t[i[t].i]-h);s.push({info:-Math.log(1-_)*_,i:i[t].i})}const _={};for(let t=0;t<s.length;t++){const i=s[t].i;_[this._y[i]]?(_[this._y[i]].count++,_[this._y[i]].max_info=Math.max(_[this._y[i]].max_info,s[t].info)):_[this._y[i]]={category:this._y[i],count:1,max_info:s[t].info}}let e=0,o=-1/0,r=null;for(const t of Object.keys(_))(e<_[t].count||e===_[t].count&&_[t].max_info<o)&&(e=_[t].count,o=_[t].max_info,r=_[t].category);return r}))}}