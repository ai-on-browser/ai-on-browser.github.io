var n=Object.defineProperty;var l=(e,r)=>n(e,"name",{value:r,configurable:!0});import a from"../util/matrix.js";export default class c{static{l(this,"NMF")}constructor(){}init(r,h=0){if(this._x=a.fromArray(r).t,this._x.value.some(_=>_<0))throw"Non-negative Matrix Fractorization only can process non negative matrix.";this._r=h,this._W=a.random(this._x.rows,this._r),this._H=a.random(this._r,this._x.cols)}fit(){const r=this._W.rows,h=this._H.cols;let _=this._W.dot(this._H);for(let i=0;i<h;i++)for(let s=0;s<this._r;s++){let o=0;for(let t=0;t<r;t++)o+=this._W.at(t,s)*this._x.at(t,i)/_.at(t,i);this._H.multAt(s,i,o)}for(let i=0;i<this._r;i++)for(let s=0;s<r;s++){let o=0;for(let t=0;t<h;t++)o+=this._x.at(s,t)/_.at(s,t)*this._H.at(i,t);this._W.multAt(s,i,o)}this._W.div(this._W.sum(0))}predict(){return this._H.t.toArray()}}
