var c=Object.defineProperty;var _=(h,s)=>c(h,"name",{value:s,configurable:!0});import o from"../util/matrix.js";export default class p{static{_(this,"LabelSpreading")}constructor(s=.2,a="rbf"){typeof a=="string"?this._affinity={name:a}:this._affinity=a,this._alpha=s}_affinity_matrix(s){const a=s.rows,l=o.zeros(a,a);for(let t=0;t<a;t++)for(let e=t+1;e<a;e++){let n=o.sub(s.row(t),s.row(e)).norm();l.set(t,e,n),l.set(e,t,n)}const r=o.zeros(a,a),i=this._affinity.k??1/0;if(i>=a)r.fill(1);else if(i>0){for(let t=0;t<a;t++){const e=l.row(t).value.map((n,f)=>[n,f]);e.sort((n,f)=>n[0]-f[0]);for(let n=1;n<Math.min(i+1,e.length);n++)r.set(t,e[n][1],1)}r.add(r.t),r.div(2)}if(this._affinity.name==="rbf"){const t=this._affinity.sigma??.1;return o.map(l,(e,n)=>r.at(n)>0?Math.exp(-(e**2)/t**2):0)}else if(this._affinity.name==="knn")return o.map(r,t=>t>0?1:0)}_laplacian(s){const a=s.rows,l=this._affinity_matrix(s);let r=l.sum(1).value;const i=o.diag(r);i.sub(l),r=r.map(t=>Math.sqrt(t));for(let t=0;t<a;t++)for(let e=0;e<a;e++)i.set(t,e,i.at(t,e)/(r[t]*r[e]));i.map(t=>-t);for(let t=0;t<i.rows;t++)i.set(t,t,0);return i}init(s,a){s=o.fromArray(s);const l=s.rows;this._y=a;const r=new Set;for(let i=0;i<l;i++)this._y[i]!=null&&r.add(this._y[i]);this._classes=[...r],this._l=this._laplacian(s),this._probs=o.zeros(l,this._classes.length);for(let i=0;i<l;i++)this._y[i]!=null&&this._probs.set(i,this._classes.indexOf(this._y[i]),1)}fit(){this._probs=this._l.dot(this._probs),this._probs.mult(this._alpha);for(let s=0;s<this._y.length;s++)this._y[s]!=null&&this._probs.addAt(s,this._classes.indexOf(this._y[s]),1-this._alpha)}predict(){return this._probs.argmax(1).value.map(s=>this._classes[s])}}
