var x=Object.defineProperty;var f=(a,_)=>x(a,"name",{value:_,configurable:!0});const u={euclid:f(()=>(a,_)=>Math.sqrt(a.reduce((i,s,l)=>i+(s-_[l])**2,0)),"euclid"),manhattan:f(()=>(a,_)=>a.reduce((i,s,l)=>i+Math.abs(s-_[l]),0),"manhattan"),chebyshev:f(()=>(a,_)=>Math.max(...a.map((i,s)=>Math.abs(i-_[s]))),"chebyshev"),minkowski:f(({p:a=2}={})=>(_,i)=>Math.pow(_.reduce((s,l,c)=>s+(l-i[c])**a,0),1/a),"minkowski")};export default class k{static{f(this,"ENN")}constructor(_=1,i=5,s="euclid"){this._k=i,this._v=_,this._metric=s,typeof this._metric=="function"?this._d=this._metric:this._d=u[this._metric]()}fit(_,i){this._x=_,this._c=i,this._classes=[...new Set(this._c)],this._nears=[],this._n=Array(this._classes.length).fill(0);for(let s=0;s<this._x.length;s++){const l=this._x.map((c,t)=>({d:this._d(this._x[s],c),idx:t}));l.sort((c,t)=>c.d-t.d),this._nears[s]=l,this._n[this._classes.indexOf(this._c[s])]++}if(this._v>=1){this._t=[];for(let s=0;s<this._classes.length;s++){let l=0;for(let c=0;c<this._nears.length;c++)if(this._c[c]===this._classes[s])for(let t=1;t<=this._k;t++)this._c[this._nears[c][t].idx]===this._classes[s]&&l++;this._t[s]=l/(this._n[s]*this._k)}}}predict(_){const i=[];for(let s=0;s<_.length;s++)this._v===0?i[s]=this._predict0(_[s]):this._v===1?i[s]=this._predict1(_[s]):this._v===2&&(i[s]=this._predict2(_[s]));return i}_predict0(_){const i=[],s=[{d:0,idx:-1}];for(let t=0;t<this._x.length;t++){const e=this._d(_,this._x[t]);s.push({d:e,idx:t}),i[t]=[];let h=!1;for(let d=0;d<this._nears[t].length;d++)!h&&e<this._nears[t][d].d&&(i[t].push({d:e,idx:-1}),h=!0),i[t].push(this._nears[t][d])}s.sort((t,e)=>t.d-e.d),i.push(s);let l=-1,c=0;for(let t=0;t<this._classes.length;t++){let e=0;for(let h=0;h<this._classes.length;h++){let d=0;for(let n=0;n<i.length;n++){if(n<this._c.length){if(this._c[n]!==this._classes[h])continue}else if(t!==h)continue;for(let o=1;o<=this._k;o++)i[n][o].idx<0?t===h&&d++:this._c[i[n][o].idx]===this._classes[h]&&d++}const r=this._n[h]+(t===h?1:0);e+=d/(r*this._k)}c<e&&(c=e,l=t)}return this._classes[l]}_predict1(_){const i=[{d:0,idx:-1}],s=[];for(let t=0;t<this._x.length;t++){const e=this._d(_,this._x[t]);i.push({d:e,idx:t}),s[t]=e}i.sort((t,e)=>t.d-e.d);let l=-1/0,c=-1;for(let t=0;t<this._classes.length;t++){let e=0;for(let h=0;h<this._classes.length;h++){let d=0;for(let n=1;n<=this._k;n++)this._c[i[n].idx]===this._classes[h]&&d++;let r=0;for(let n=0;n<this._nears.length;n++)s[n]<this._nears[n][this._k].d&&(t===h&&this._c[this._nears[n][this._k].idx]!==this._classes[h]||t!==h&&this._c[this._nears[n][this._k].idx]===this._classes[h])&&r++;t===h?e+=(r+d-this._k*this._t[h])/((this._n[h]+1)*this._k):e-=r/(this._n[h]*this._k)}l<e&&(l=e,c=t)}return this._classes[c]}_predict2(_){const i=[{d:0,idx:-1}],s=[];for(let t=0;t<this._x.length;t++){const e=this._d(_,this._x[t]);i.push({d:e,idx:t}),s[t]=e}i.sort((t,e)=>t.d-e.d);let l=-1/0,c=-1;for(let t=0;t<this._classes.length;t++){let e=0;for(let r=1;r<=this._k;r++)this._c[i[r].idx]===this._classes[t]&&e++;let h=0;for(let r=0;r<this._nears.length;r++)s[r]<this._nears[r][this._k].d&&h++;const d=h+e-this._k*this._t[t];l<d&&(l=d,c=t)}return this._classes[c]}}
