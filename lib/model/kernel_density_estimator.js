var u=Object.defineProperty;var l=(_,e)=>u(_,"name",{value:e,configurable:!0});export default class M{static{l(this,"KernelDensityEstimator")}constructor(e=0,s="gaussian"){if(this._h=e,typeof s=="function")this._kernel=s;else switch(s){case"gaussian":this._kernel=t=>Math.exp(-t*t/2)/Math.sqrt(2*Math.PI);break;case"rectangular":this._kernel=t=>Math.abs(t)<=1?.5:0;break;case"triangular":this._kernel=t=>Math.abs(t)<=1?1-Math.abs(t):0;break;case"epanechnikov":this._kernel=t=>Math.abs(t)<=1?3*(1-t**2)/4:0;break;case"biweight":this._kernel=t=>Math.abs(t)<=1?15/16*(1-t**2)**2:0;break;case"triweight":this._kernel=t=>Math.abs(t)<=1?35/32*(1-t**2)**3:0;break}}fit(e){if(this._x=e,this._h>0)return;const s=e.length,t=e.map(a=>Math.sqrt(a.reduce((r,n)=>r+n**2,0))),i=t.reduce((a,r)=>a+r,0)/s,h=Math.sqrt(t.reduce((a,r)=>a+(r-i)**2,0)/s);t.sort((a,r)=>a-r);const c=l(a=>{const r=(s-1)*a,n=Math.floor(r),b=Math.ceil(r);return t[n]+(r-n)*(t[b]-t[n])},"q"),o=Math.min(h,(c(.75)-c(.25))/1.34);this._h=1.06*o/Math.pow(s,.2)}probability(e){const s=this._x.length;return e.map(t=>{let i=0;for(let h=0;h<s;h++)i+=this._kernel(Math.sqrt(t.reduce((c,o,a)=>c+(o-this._x[h][a])**2,0))/this._h);return i/(s*this._h)})}predict(e){return this.probability(e)}}
