export default class KernelDensityEstimator{constructor(kernel="gaussian"){this._h=0;switch(kernel){case"gaussian":this._kernel=x=>Math.exp(-x*x/2)/Math.sqrt(2*Math.PI);break;case"rectangular":this._kernel=x=>Math.abs(x)<=1?.5:0;break;case"triangular":this._kernel=x=>Math.abs(x)<=1?1-Math.abs(x):0;break;case"epanechnikov":this._kernel=x=>Math.abs(x)<=1?3*(1-x**2)/4:0;break;case"biweight":this._kernel=x=>Math.abs(x)<=1?15/16*(1-x**2)**2:0;break;case"triweight":this._kernel=x=>Math.abs(x)<=1?35/32*(1-x**2)**3:0;break}}fit(x,h=0){this._x=x;if(h>0){this._h=h;return}const n=x.length;const k=x.map((d=>Math.sqrt(d.reduce(((s,v)=>s+v**2),0))));const mean=k.reduce(((s,v)=>s+v),0)/n;const std=Math.sqrt(k.reduce(((s,v)=>s+(v-mean)**2),0)/n);k.sort(((a,b)=>a-b));const q=p=>{const np=n*p;const np_l=Math.floor(np);const np_h=Math.ceil(np);return k[np_l]+(np_h-np_l)*(k[np_l]-k[np_h])};const sgm=Math.min(std,(q(.75)-q(.25))/1.34);this._h=1.06*sgm/Math.pow(n,.2)}probability(x){const n=this._x.length;return x.map((d=>{let s=0;for(let i=0;i<n;i++){s+=this._kernel(Math.sqrt(d.reduce(((a,v,j)=>a+(v-this._x[i][j])**2),0))/this._h)}return s/(n*this._h)}))}predict(x){return this.probability(x)}}