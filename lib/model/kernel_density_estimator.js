export default class KernelDensityEstimator{constructor(t="gaussian"){switch(this._h=0,t){case"gaussian":this._kernel=t=>Math.exp(-t*t/2)/Math.sqrt(2*Math.PI);break;case"rectangular":this._kernel=t=>Math.abs(t)<=1?.5:0;break;case"triangular":this._kernel=t=>Math.abs(t)<=1?1-Math.abs(t):0;break;case"epanechnikov":this._kernel=t=>Math.abs(t)<=1?3*(1-t**2)/4:0;break;case"biweight":this._kernel=t=>Math.abs(t)<=1?15/16*(1-t**2)**2:0;break;case"triweight":this._kernel=t=>Math.abs(t)<=1?35/32*(1-t**2)**3:0}}fit(t,e=0){if(this._x=t,e>0)return void(this._h=e);const a=t.length,s=t.map((t=>Math.sqrt(t.reduce(((t,e)=>t+e**2),0)))),r=s.reduce(((t,e)=>t+e),0)/a,h=Math.sqrt(s.reduce(((t,e)=>t+(e-r)**2),0)/a);s.sort(((t,e)=>t-e));const i=t=>{const e=a*t,r=Math.floor(e),h=Math.ceil(e);return s[r]+(h-r)*(s[r]-s[h])},n=Math.min(h,(i(.75)-i(.25))/1.34);this._h=1.06*n/Math.pow(a,.2)}probability(t){const e=this._x.length;return t.map((t=>{let a=0;for(let s=0;s<e;s++)a+=this._kernel(Math.sqrt(t.reduce(((t,e,a)=>t+(e-this._x[s][a])**2),0))/this._h);return a/(e*this._h)}))}predict(t){return this.probability(t)}}