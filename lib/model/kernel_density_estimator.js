export default class KernelDensityEstimator{constructor(t=0,e="gaussian"){if(this._h=t,"function"==typeof e)this._kernel=e;else switch(e){case"gaussian":this._kernel=t=>Math.exp(-t*t/2)/Math.sqrt(2*Math.PI);break;case"rectangular":this._kernel=t=>Math.abs(t)<=1?.5:0;break;case"triangular":this._kernel=t=>Math.abs(t)<=1?1-Math.abs(t):0;break;case"epanechnikov":this._kernel=t=>Math.abs(t)<=1?3*(1-t**2)/4:0;break;case"biweight":this._kernel=t=>Math.abs(t)<=1?15/16*(1-t**2)**2:0;break;case"triweight":this._kernel=t=>Math.abs(t)<=1?35/32*(1-t**2)**3:0}}fit(t){if(this._x=t,this._h>0)return;const e=t.length,a=t.map((t=>Math.sqrt(t.reduce(((t,e)=>t+e**2),0)))),s=a.reduce(((t,e)=>t+e),0)/e,r=Math.sqrt(a.reduce(((t,e)=>t+(e-s)**2),0)/e);a.sort(((t,e)=>t-e));const h=t=>{const s=(e-1)*t,r=Math.floor(s),h=Math.ceil(s);return a[r]+(s-r)*(a[h]-a[r])},i=Math.min(r,(h(.75)-h(.25))/1.34);this._h=1.06*i/Math.pow(e,.2)}probability(t){const e=this._x.length;return t.map((t=>{let a=0;for(let s=0;s<e;s++)a+=this._kernel(Math.sqrt(t.reduce(((t,e,a)=>t+(e-this._x[s][a])**2),0))/this._h);return a/(e*this._h)}))}predict(t){return this.probability(t)}}