export default class SezanThresholding{constructor(t=.5,e=5){this._gamma=t,this._sigma=e}predict(t){const e=256,h=t.reduce(((t,e)=>Math.max(t,e)),-1/0),l=t.reduce(((t,e)=>Math.min(t,e)),1/0),o=Array(e).fill(0);for(let s=0;s<t.length;s++)t[s]===h?o[255]++:o[Math.floor((t[s]-l)/(h-l)*e)]++;const s=[],r=Math.floor(27.5);let a=0;for(let t=0;t<55;t++)s[t]=Math.exp(-((t-r)**2)/(2*this._sigma**2)),a+=s[t];for(let t=0;t<s.length;t++)s[t]/=a;const n=[];for(let t=0;t<o.length;t++){n[t]=0;for(let e=t-r;e<=t+r;e++)e>=0&&e<o.length&&(n[t]+=o[e]*s[e-t+r])}const g=[0];for(let t=1;t<n.length;t++)g[t]=n[t-1]-n[t];g.push(0);const i=[],c=[];for(let t=0;t<g.length-1;t++)g[t+1]>=0&&g[t]<=0&&i.push(t),g[t+1]<=0&&g[t]>=0&&c.push(t);const f=i[0],m=i[i.length-1];let u=0,p=0,_=0,d=0;for(let t=0;t<c.length;t++)c[t]<f?u=c[t]:c[t]>f&&0===p&&(p=c[t]),c[t]<m?_=c[t]:c[t]>m&&0===d&&(d=c[t]);return this._th=((1-this._gamma)*p+this._gamma*_+.5)*(h-l)/e+l,t.map((t=>t<this._th?0:1))}}