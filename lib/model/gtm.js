import Matrix from"../util/matrix.js";export default class GTM{constructor(t,i,s=20,h=10){this.in_size=t,this.out_size=i,this._k=s,this._lambda=.001,this._w=null,this._b=1,this._init_method="PCA",this._fit_method="mean",this._epoch=0,this._z=this._make_grid(Array(i).fill(this._k)),this._t=this._make_grid(Array(i).fill(h))}_make_grid(t){const i=[],s=Array(t.length).fill(0);do{i.push(s.map(((i,s)=>2*i/(t[s]-1)-1)));for(let i=t.length-1;i>=0&&(s[i]++,!(s[i]<t[i]));i--)s[i]=0}while(s.reduce(((t,i)=>t+i),0)>0);return i}_phi(t,i=null,s=Math.SQRT2){if(null===i){const i=[];for(let h=0;h<this._t.length;h++)i.push(this._phi(t,h,s));return i}return Math.exp(-this._t[i].reduce(((i,s,h)=>i+(s-t[h])**2),0)/(2*s**2))}_prob(t,i){const s=[],h=Matrix.fromArray(this._phi(i)).tDot(this._w).value,e=(this._b/(2*Math.PI))**(t[0].length/2);for(let i=0;i<t.length;i++){const r=h.reduce(((s,h,e)=>s+(h-t[i][e])**2),0);s[i]=e*Math.exp(-this._b*r/2)}return s}probability(t){const i=Array(t.length).fill(0);for(let s=0;s<this._z.length;s++){const h=this._prob(t,this._z[s]);for(let t=0;t<h.length;t++)i[t]+=h[t]}return i.map((t=>t/this._z.length))}responsibility(t){const i=new Matrix(t.length,this._z.length);for(let s=0;s<this._z.length;s++){const h=this._prob(t,this._z[s]);for(let t=0;t<h.length;t++)i.set(t,s,h[t])}const s=i.sum(1);for(let h=0;h<t.length;h++)if(0===s.at(h,0)){s.set(h,0,1);for(let t=0;t<this._z.length;t++)i.set(h,t,1/this._z.length)}return i.div(s),i}fit(t){const i=t,s=i.length,h=this.in_size;if(!this._w)if("random"===this._init_method)this._w=Matrix.randn(this._t.length,h);else if("PCA"===this._init_method){const i=new Matrix(s,h,t),e=i.cov(),[r,l]=e.eigen(),n=new Matrix(1,r.length,r.map((t=>Math.sqrt(t))));n.repeat(this._t.length,0),n.mult(i.block(0,0,this._t.length,r.length)),this._w=n.dot(l.t)}const e=this.responsibility(i),r=Matrix.fromArray(this._z.map((t=>this._phi(t)))),l=Matrix.mult(r,e.sum(0).t).tDot(r);l.add(Matrix.eye(l.cols,l.cols,this._lambda/this._b));const n=Matrix.fromArray(i),o=l.solve(r.tDot(e.tDot(n))),_=new Matrix(s,this._z.length),a=r.dot(o);for(let t=0;t<s;t++){const i=Matrix.sub(a,n.row(t));i.mult(i),_.set(t,0,i.sum(1).t)}this._b=s*h/Matrix.mult(e,_).sum(),this._w=o.slice(0,this._t.length),this._epoch++}predictIndex(t){return this.responsibility(t).argmax(1).value}predict(t){const i=this.responsibility(t);if("mode"===this._fit_method)return i.argmax(1).value.map((t=>this._z[t]));{i.div(i.sum(1));const s=[];for(let h=0;h<t.length;h++){const t=Array(this._z[0].length).fill(0);for(let s=0;s<this._z.length;s++)for(let e=0;e<t.length;e++)t[e]+=this._z[s][e]*i.at(h,s);s.push(t)}return s}}}