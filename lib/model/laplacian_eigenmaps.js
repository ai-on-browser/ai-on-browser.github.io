var p=Object.defineProperty;var _=(m,a)=>p(m,"name",{value:a,configurable:!0});import o from"../util/matrix.js";export default class u{static{_(this,"LaplacianEigenmaps")}constructor(a,s="rbf",c=10,n=1,e="unnormalized"){this._rd=a,this._affinity=s,this._k=c,this._sigma=n,this._laplacian=e}predict(a){a=o.fromArray(a);const s=a.rows,c=this._rd,n=o.zeros(s,s);for(let t=0;t<s;t++)for(let i=t+1;i<s;i++){let r=o.sub(a.row(t),a.row(i)).norm();n.set(t,i,r),n.set(i,t,r)}const e=o.zeros(s,s);if(this._k>0){for(let t=0;t<s;t++){const i=n.row(t).value.map((r,d)=>[r,d]);i.sort((r,d)=>r[0]-d[0]);for(let r=1;r<Math.min(this._k+1,i.length);r++)e.set(t,i[r][1],1)}e.add(e.t),e.div(2)}let f;this._affinity==="rbf"?f=o.map(n,(t,i)=>e.at(i)>0?Math.exp(-(t**2)/this._sigma**2):0):this._affinity==="knn"&&(f=o.map(e,t=>t>0?1:0));let l=f.sum(1).value;const h=o.diag(l);if(h.sub(f),this._laplacian==="normalized"){l=l.map(t=>Math.sqrt(t));for(let t=0;t<s;t++)for(let i=0;i<s;i++)h.set(t,i,h.at(t,i)/(l[t]*l[i]))}return this._ev=h.eigenVectors(),this._ev.flip(1),this._ev.slice(1,c+1,1).toArray()}}
