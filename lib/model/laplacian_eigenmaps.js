var u=Object.defineProperty;var _=(d,a)=>u(d,"name",{value:a,configurable:!0});import r from"../util/matrix.js";export default class g{static{_(this,"LaplacianEigenmaps")}constructor(a,s="rbf",m="unnormalized"){this._rd=a,typeof s=="string"?this._affinity={name:s}:this._affinity=s,this._laplacian=m}predict(a){a=r.fromArray(a);const s=a.rows,m=this._rd,f=r.zeros(s,s);for(let t=0;t<s;t++)for(let i=t+1;i<s;i++){let e=r.sub(a.row(t),a.row(i)).norm();f.set(t,i,e),f.set(i,t,e)}const n=r.zeros(s,s),p=this._affinity.k??10;if(p>0){for(let t=0;t<s;t++){const i=f.row(t).value.map((e,h)=>[e,h]);i.sort((e,h)=>e[0]-h[0]);for(let e=1;e<Math.min(p+1,i.length);e++)n.set(t,i[e][1],1)}n.add(n.t),n.div(2)}let l;if(this._affinity.name==="rbf"){const t=this._affinity.sigma??1;l=r.map(f,(i,e)=>n.at(e)>0?Math.exp(-(i**2)/t**2):0)}else this._affinity.name==="knn"&&(l=r.map(n,t=>t>0?1:0));let o=l.sum(1).value;const c=r.diag(o);if(c.sub(l),this._laplacian==="normalized"){o=o.map(t=>Math.sqrt(t));for(let t=0;t<s;t++)for(let i=0;i<s;i++)c.set(t,i,c.at(t,i)/(o[t]*o[i]))}return this._ev=c.eigenVectors(),this._ev.flip(1),this._ev.slice(1,m+1,1).toArray()}}
