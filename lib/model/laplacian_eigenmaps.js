var d=Object.defineProperty;var _=(p,e)=>d(p,"name",{value:e,configurable:!0});import r from"../util/matrix.js";export default class u{static{_(this,"LaplacianEigenmaps")}constructor(e="rbf",c=10,s=1,o="unnormalized"){this._affinity=e,this._k=c,this._sigma=s,this._laplacian=o}predict(e,c){e=r.fromArray(e);const s=e.rows,o=r.zeros(s,s);for(let t=0;t<s;t++)for(let i=t+1;i<s;i++){let a=r.sub(e.row(t),e.row(i)).norm();o.set(t,i,a),o.set(i,t,a)}const n=r.zeros(s,s);if(this._k>0){for(let t=0;t<s;t++){const i=o.row(t).value.map((a,m)=>[a,m]);i.sort((a,m)=>a[0]-m[0]);for(let a=1;a<Math.min(this._k+1,i.length);a++)n.set(t,i[a][1],1)}n.add(n.t),n.div(2)}let f;this._affinity==="rbf"?f=r.map(o,(t,i)=>n.at(i)>0?Math.exp(-(t**2)/this._sigma**2):0):this._affinity==="knn"&&(f=r.map(n,t=>t>0?1:0));let l=f.sum(1).value;const h=r.diag(l);if(h.sub(f),this._laplacian==="normalized"){l=l.map(t=>Math.sqrt(t));for(let t=0;t<s;t++)for(let i=0;i<s;i++)h.set(t,i,h.at(t,i)/(l[t]*l[i]))}return this._ev=h.eigenVectors(),this._ev.flip(1),this._ev.slice(1,c+1,1).toArray()}}
