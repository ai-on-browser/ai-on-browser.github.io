var w=Object.defineProperty;var h=(s,t)=>w(s,"name",{value:t,configurable:!0});import d from"../util/matrix.js";import{adam as y}from"./nns/optimizer.js";const b={identity:{calc:h(s=>s,"calc"),grad:h(()=>1,"grad")},relu:{calc:h(s=>Math.max(0,s),"calc"),grad:h(s=>s>0?1:0,"grad")},sigmoid:{calc:h(s=>1/(1+Math.exp(-s)),"calc"),grad:h((s,t)=>t*(1-t),"grad")},tanh:{calc:Math.tanh,grad:h((s,t)=>1-t**2,"grad")}};export default class M{static{h(this,"RankNet")}constructor(t,a="tanh",n=.01){this._rate=n,this._layer_sizes=t,this._activations=a,this._a=[],this._w=[],this._b=[],this._optimizer=new y(n).manager()}_init(t){typeof this._activations=="string"&&(this._activations=Array(t.length-2).fill(this._activations));for(let a=0;a<t.length-1;a++)this._a[a]=b[this._activations[a]],this._w[a]=d.randn(t[a],t[a+1],0,.1),this._b[a]=d.zeros(1,t[a+1])}_calc(t){const a=[t],n=[t];for(let e=0;e<this._w.length;e++)a[e+1]=t=t.dot(this._w[e]),t.add(this._b[e]),n[e+1]=t=t.copy(),this._a[e]&&t.map(this._a[e].calc);return[a,n]}fit(t,a,n){if(this._w.length===0){const i=[t[0].length,...this._layer_sizes,1];this._init(i)}const e=t.length;t=d.fromArray(t),a=d.fromArray(a);const[m,u]=this._calc(t),[p,g]=this._calc(a),f=d.sub(u[u.length-1],g[g.length-1]);let l=f.copy(),_=f.copy(),v=0;for(let i=0;i<e;i++){const r=n[i]>0?1:n[i]===0?.5:0,c=f.value[i];l.value[i]=-r+1/(1+Math.exp(-c)),_.value[i]=r-1/(1+Math.exp(-c)),v+=-r*c+Math.log(1+Math.exp(c))}for(let i=this._w.length-1;i>=0;i--){if(this._a[i])for(let o=0;o<l.length;o++)l.value[o]*=this._a[i].grad(m[i+1].value[o],u[i+1].value[o]),_.value[o]*=this._a[i].grad(p[i+1].value[o],g[i+1].value[o]);const r=u[i].tDot(l);r.add(g[i].tDot(_)),r.div(e);const c=l.mean(0);c.add(_.mean(0)),l=l.dot(this._w[i].t),_=_.dot(this._w[i].t),this._w[i].sub(this._optimizer.delta(`w${i}`,r)),this._b[i].sub(this._optimizer.delta(`b${i}`,c))}return v}predict(t){t=d.fromArray(t);const[,a]=this._calc(t);return a[a.length-1].value}}
