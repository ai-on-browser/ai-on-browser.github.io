var w=Object.defineProperty;var f=(s,t)=>w(s,"name",{value:t,configurable:!0});import _ from"../util/matrix.js";import{AdamOptimizer as y}from"./nns/optimizer.js";const b={identity:{calc:s=>s,grad:()=>1},relu:{calc:s=>Math.max(0,s),grad:s=>s>0?1:0},sigmoid:{calc:s=>1/(1+Math.exp(-s)),grad:(s,t)=>t*(1-t)},tanh:{calc:Math.tanh,grad:(s,t)=>1-t**2}};export default class M{static{f(this,"RankNet")}constructor(t,a="tanh",h=.01){this._rate=h,this._layer_sizes=t,this._activations=a,this._a=[],this._w=[],this._b=[],this._optimizer=new y(h).manager()}_init(t){typeof this._activations=="string"&&(this._activations=Array(t.length-2).fill(this._activations));for(let a=0;a<t.length-1;a++)this._a[a]=b[this._activations[a]],this._w[a]=_.randn(t[a],t[a+1],0,.1),this._b[a]=_.zeros(1,t[a+1])}_calc(t){const a=[t],h=[t];for(let e=0;e<this._w.length;e++)a[e+1]=t=t.dot(this._w[e]),t.add(this._b[e]),h[e+1]=t=t.copy(),this._a[e]&&t.map(this._a[e].calc);return[a,h]}fit(t,a,h){if(this._w.length===0){const i=[t[0].length,...this._layer_sizes,1];this._init(i)}const e=t.length;t=_.fromArray(t),a=_.fromArray(a);const[p,u]=this._calc(t),[v,d]=this._calc(a),g=_.sub(u[u.length-1],d[d.length-1]);let r=g.copy(),c=g.copy(),m=0;for(let i=0;i<e;i++){const l=h[i]>0?1:h[i]===0?.5:0,n=g.value[i];r.value[i]=-l+1/(1+Math.exp(-n)),c.value[i]=l-1/(1+Math.exp(-n)),m+=-l*n+Math.log(1+Math.exp(n))}for(let i=this._w.length-1;i>=0;i--){if(this._a[i])for(let o=0;o<r.length;o++)r.value[o]*=this._a[i].grad(p[i+1].value[o],u[i+1].value[o]),c.value[o]*=this._a[i].grad(v[i+1].value[o],d[i+1].value[o]);const l=u[i].tDot(r);l.add(d[i].tDot(c)),l.mult(this._rate/e);const n=r.mean(0);n.add(c.mean(0)),n.mult(this._rate),r=r.dot(this._w[i].t),c=c.dot(this._w[i].t),this._w[i].sub(this._optimizer.delta(`w${i}`,l)),this._b[i].sub(this._optimizer.delta(`b${i}`,n))}return m}predict(t){t=_.fromArray(t);const[,a]=this._calc(t);return a[a.length-1].value}}
