var g=Object.defineProperty;var c=(r,a)=>g(r,"name",{value:a,configurable:!0});const _={euclid:c((r,a)=>Math.sqrt(r.reduce((e,i,t)=>e+(i-a[t])**2,0)),"euclid"),manhattan:c((r,a)=>r.reduce((e,i,t)=>e+Math.abs(i-a[t]),0),"manhattan"),chebyshev:c((r,a)=>r.reduce((e,i,t)=>Math.max(e,Math.abs(i-a[t])),-1/0),"chebyshev")};class m{static{c(this,"AgglomerativeClustering")}constructor(a="euclid"){this._root=null,this._metric=a,typeof this._metric=="function"?this._d=this._metric:this._d=_[this._metric]}fit(a){const e=[];a.forEach((t,n)=>{e.push({point:t,index:n,distances:a.map(s=>this._d(t,s)),size:1,get leafs(){return[this]}})});const i=[];for(let t=0;t<e.length;t++){i[t]||(i[t]=[]);for(let n=0;n<t;n++)i[t][n]||(i[t][n]=i[n][t]=this.distance(e[t],e[n]))}for(;e.length>1;){const t=e.length;let n=0,s=1,l=i[0][1];for(let o=1;o<t;o++)i[o].forEach((h,d)=>{h<l&&(n=o,s=d,l=h)});const u=e[n].size,p=e[s].size;i.forEach((o,h)=>{h!=s&&h!=n&&(o[n]=this.update(u,p,e[h].size,o[n],o[s],i[s][n]),i[n][h]=o[n],o.splice(s,1))}),i[n].splice(s,1),i.splice(s,1),e[n]={distance:l,size:e[n].size+e[s].size,children:[e[n],e[s]],get leafs(){return[...this.children[0].leafs,...this.children[1].leafs]}},e.splice(s,1)}this._root=e[0]}getClusters(a){const e=[this._root];for(;e.length<a;){let i=0,t=-1;for(let s=0;s<e.length;s++){const l=e[s];l.children&&l.distance>i&&(t=s,i=l.distance)}if(t===-1)break;const n=e[t];e.splice(t,1,n.children[0],n.children[1])}return e}predict(a){const e=[],i=this.getClusters(a);for(let t=0;t<i.length;t++){const n=i[t].leafs;for(let s=0;s<n.length;s++)e[n[s].index]=t}return e}distance(a,e){throw new Error("Not Implemented")}_mean(a){const e=Array(a[0].length).fill(0);for(let i=0;i<a.length;i++)for(let t=0;t<a[i].length;t++)e[t]+=a[i][t];return e.map(i=>i/a.length)}_lanceWilliamsUpdater(a,e,i,t){return(n,s,l)=>a*n+e*s+i*l+t*Math.abs(n-s)}update(a,e,i,t,n,s){throw new Error("Not Implemented")}}export class CompleteLinkageAgglomerativeClustering extends m{static{c(this,"CompleteLinkageAgglomerativeClustering")}distance(a,e){const i=a.leafs,t=e.leafs;return Math.max.apply(null,i.map(n=>Math.max.apply(null,t.map(s=>n.distances[s.index]))))}update(a,e,i,t,n,s){return this._lanceWilliamsUpdater(.5,.5,0,.5)(t,n,s)}}export class SingleLinkageAgglomerativeClustering extends m{static{c(this,"SingleLinkageAgglomerativeClustering")}distance(a,e){const i=a.leafs,t=e.leafs;return Math.min.apply(null,i.map(s=>Math.min.apply(null,t.map(l=>s.distances[l.index]))))}update(a,e,i,t,n,s){return this._lanceWilliamsUpdater(.5,.5,0,-.5)(t,n,s)}}export class GroupAverageAgglomerativeClustering extends m{static{c(this,"GroupAverageAgglomerativeClustering")}distance(a,e){const i=a.leafs,t=e.leafs;return i.reduce((s,l)=>s+t.reduce((u,p)=>u+l.distances[p.index],0),0)/(i.length*t.length)}update(a,e,i,t,n,s){return this._lanceWilliamsUpdater(a/(a+e),e/(a+e),0,0)(t,n,s)}}export class WardsAgglomerativeClustering extends m{static{c(this,"WardsAgglomerativeClustering")}distance(a,e){const i=a.leafs.map(d=>d.point),t=e.leafs.map(d=>d.point),n=i.concat(t),s=this._mean(i),l=this._mean(t),u=this._mean(n),p=i.reduce((d,f)=>d+this._d(f,s)**2,0),o=t.reduce((d,f)=>d+this._d(f,l)**2,0);return n.reduce((d,f)=>d+this._d(f,u)**2,0)-p-o}update(a,e,i,t,n,s){return this._lanceWilliamsUpdater((i+a)/(i+a+e),(i+e)/(i+a+e),-i/(i+a+e),0)(t,n,s)}}export class CentroidAgglomerativeClustering extends m{static{c(this,"CentroidAgglomerativeClustering")}distance(a,e){const i=a.leafs.map(s=>s.point),t=e.leafs.map(s=>s.point),n=this._d(this._mean(i),this._mean(t));return n*n}update(a,e,i,t,n,s){return this._lanceWilliamsUpdater(a/(a+e),e/(a+e),-a*e/((a+e)*(a+e)),0)(t,n,s)}}export class WeightedAverageAgglomerativeClustering extends m{static{c(this,"WeightedAverageAgglomerativeClustering")}distance(a,e){return c(function t(n,s){return n.size===1&&s.size===1?n.distances[s.index]:s.size===1?(t(s,n.children[0])+t(s,n.children[1]))/2:(t(n,s.children[0])+t(n,s.children[1]))/2},"calcDistRec")(a,e)}update(a,e,i,t,n,s){return this._lanceWilliamsUpdater(.5,.5,0,0)(t,n,s)}}export class MedianAgglomerativeClustering extends m{static{c(this,"MedianAgglomerativeClustering")}distance(a,e){const i=this._mean(a.leafs.map(s=>s.point)),t=this._mean(e.leafs.map(s=>s.point)),n=i.map((s,l)=>(s+t[l])/2);return this._d(n,t)**2}update(a,e,i,t,n,s){return this._lanceWilliamsUpdater(.5,.5,-.25,0)(t,n,s)}}
