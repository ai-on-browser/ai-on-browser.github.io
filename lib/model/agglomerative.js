class AgglomerativeClustering{constructor(e="euclid"){switch(this._root=null,this._metric=e,this._metric){case"euclid":this._d=(e,t)=>Math.sqrt(e.reduce(((e,s,i)=>e+(s-t[i])**2),0));break;case"manhattan":this._d=(e,t)=>e.reduce(((e,s,i)=>e+Math.abs(s-t[i])),0);break;case"chebyshev":this._d=(e,t)=>e.reduce(((e,s,i)=>Math.max(e,Math.abs(s-t[i]))),-1/0)}}fit(e){const t=[];e.forEach(((s,i)=>{t.push({point:s,index:i,distances:e.map((e=>this._d(s,e))),size:1,get leafs(){return[this]}})}));const s=[];for(let e=0;e<t.length;e++){s[e]||(s[e]=[]);for(let i=0;i<e;i++)s[e][i]||(s[e][i]=s[i][e]=this.distance(t[e],t[i]))}for(;t.length>1;){let e=t.length,i=0,a=1,l=s[0][1];for(let t=1;t<e;t++)s[t].forEach(((e,s)=>{e<l&&(i=t,a=s,l=e)}));let r=t[i].size,n=t[a].size;s.forEach(((e,l)=>{l!=a&&l!=i&&(e[i]=this.update(r,n,t[l].size,e[i],e[a],s[a][i]),s[i][l]=e[i],e.splice(a,1))})),s[i].splice(a,1),s.splice(a,1),t[i]={distance:l,size:t[i].size+t[a].size,children:[t[i],t[a]],get leafs(){return[...this.children[0].leafs,...this.children[1].leafs]}},t.splice(a,1)}this._root=t[0]}getClusters(e){const t=[this._root];for(;t.length<e;){let e=0,s=-1;for(let i=0;i<t.length;i++){const a=t[i];a.children&&a.distance>e&&(s=i,e=a.distance)}if(-1===s)break;const i=t[s];t.splice(s,1,i.children[0],i.children[1])}return t}predict(e){const t=[],s=this.getClusters(e);for(let e=0;e<s.length;e++){const i=s[e].leafs;for(let s=0;s<i.length;s++)t[i[s].index]=e}return t}distance(e,t){throw new Error("Not Implemented")}_mean(e){const t=Array(e[0].length).fill(0);for(let s=0;s<e.length;s++)for(let i=0;i<e[s].length;i++)t[i]+=e[s][i];return t.map((t=>t/e.length))}_lanceWilliamsUpdater(e,t,s,i){return(a,l,r)=>e*a+t*l+s*r+i*Math.abs(a-l)}update(e,t,s,i,a,l){throw new Error("Not Implemented")}}export class CompleteLinkageAgglomerativeClustering extends AgglomerativeClustering{distance(e,t){let s=e.leafs,i=t.leafs;return Math.max.apply(null,s.map((e=>Math.max.apply(null,i.map((t=>e.distances[t.index]))))))}update(e,t,s,i,a,l){return this._lanceWilliamsUpdater(.5,.5,0,.5)(i,a,l)}}export class SingleLinkageAgglomerativeClustering extends AgglomerativeClustering{distance(e,t){let s=e.leafs,i=t.leafs;return Math.min.apply(null,s.map((e=>Math.min.apply(null,i.map((t=>e.distances[t.index]))))))}update(e,t,s,i,a,l){return this._lanceWilliamsUpdater(.5,.5,0,-.5)(i,a,l)}}export class GroupAverageAgglomerativeClustering extends AgglomerativeClustering{distance(e,t){let s=e.leafs,i=t.leafs;return s.reduce(((e,t)=>e+i.reduce(((e,s)=>e+t.distances[s.index]),0)),0)/(s.length*i.length)}update(e,t,s,i,a,l){return this._lanceWilliamsUpdater(e/(e+t),t/(e+t),0,0)(i,a,l)}}export class WardsAgglomerativeClustering extends AgglomerativeClustering{distance(e,t){let s=e.leafs.map((e=>e.point)),i=t.leafs.map((e=>e.point)),a=s.concat(i),l=this._mean(s),r=this._mean(i),n=this._mean(a),d=s.reduce(((e,t)=>e+this._d(t,l)**2),0),c=i.reduce(((e,t)=>e+this._d(t,r)**2),0);return a.reduce(((e,t)=>e+this._d(t,n)**2),0)-d-c}update(e,t,s,i,a,l){return this._lanceWilliamsUpdater((s+e)/(s+e+t),(s+t)/(s+e+t),-s/(s+e+t),0)(i,a,l)}}export class CentroidAgglomerativeClustering extends AgglomerativeClustering{distance(e,t){let s=e.leafs.map((e=>e.point)),i=t.leafs.map((e=>e.point)),a=this._d(this._mean(s),this._mean(i));return a*a}update(e,t,s,i,a,l){return this._lanceWilliamsUpdater(e/(e+t),t/(e+t),-e*t/((e+t)*(e+t)),0)(i,a,l)}}export class WeightedAverageAgglomerativeClustering extends AgglomerativeClustering{distance(e,t){return function e(t,s){return 1===t.size&&1===s.size?t.distances[s.index]:1===s.size?(e(s,t.children[0])+e(s,t.children[1]))/2:(e(t,s.children[0])+e(t,s.children[1]))/2}(e,t)}update(e,t,s,i,a,l){return this._lanceWilliamsUpdater(.5,.5,0,0)(i,a,l)}}export class MedianAgglomerativeClustering extends AgglomerativeClustering{distance(e,t){let s=this._mean(e.leafs.map((e=>e.point))),i=this._mean(t.leafs.map((e=>e.point))),a=s.map(((e,t)=>(e+i[t])/2));return this._d(a,i)**2}update(e,t,s,i,a,l){return this._lanceWilliamsUpdater(.5,.5,-.25,0)(i,a,l)}}