var g=Object.defineProperty;var d=(h,a)=>g(h,"name",{value:a,configurable:!0});class u{static{d(this,"AgglomerativeClustering")}constructor(a="euclid"){if(this._root=null,this._metric=a,typeof this._metric=="function")this._d=this._metric;else switch(this._metric){case"euclid":this._d=(e,l)=>Math.sqrt(e.reduce((t,s,i)=>t+(s-l[i])**2,0));break;case"manhattan":this._d=(e,l)=>e.reduce((t,s,i)=>t+Math.abs(s-l[i]),0);break;case"chebyshev":this._d=(e,l)=>e.reduce((t,s,i)=>Math.max(t,Math.abs(s-l[i])),-1/0);break}}fit(a){const e=[];a.forEach((t,s)=>{e.push({point:t,index:s,distances:a.map(i=>this._d(t,i)),size:1,get leafs(){return[this]}})});const l=[];for(let t=0;t<e.length;t++){l[t]||(l[t]=[]);for(let s=0;s<t;s++)l[t][s]||(l[t][s]=l[s][t]=this.distance(e[t],e[s]))}for(;e.length>1;){let t=e.length,s=0,i=1,n=l[0][1];for(let r=1;r<t;r++)l[r].forEach((o,c)=>{o<n&&(s=r,i=c,n=o)});let m=e[s].size,p=e[i].size;l.forEach((r,o)=>{o!=i&&o!=s&&(r[s]=this.update(m,p,e[o].size,r[s],r[i],l[i][s]),l[s][o]=r[s],r.splice(i,1))}),l[s].splice(i,1),l.splice(i,1),e[s]={distance:n,size:e[s].size+e[i].size,children:[e[s],e[i]],get leafs(){return[...this.children[0].leafs,...this.children[1].leafs]}},e.splice(i,1)}this._root=e[0]}getClusters(a){const e=[this._root];for(;e.length<a;){let l=0,t=-1;for(let i=0;i<e.length;i++){const n=e[i];n.children&&n.distance>l&&(t=i,l=n.distance)}if(t===-1)break;const s=e[t];e.splice(t,1,s.children[0],s.children[1])}return e}predict(a){const e=[],l=this.getClusters(a);for(let t=0;t<l.length;t++){const s=l[t].leafs;for(let i=0;i<s.length;i++)e[s[i].index]=t}return e}distance(a,e){throw new Error("Not Implemented")}_mean(a){const e=Array(a[0].length).fill(0);for(let l=0;l<a.length;l++)for(let t=0;t<a[l].length;t++)e[t]+=a[l][t];return e.map(l=>l/a.length)}_lanceWilliamsUpdater(a,e,l,t){return(s,i,n)=>a*s+e*i+l*n+t*Math.abs(s-i)}update(a,e,l,t,s,i){throw new Error("Not Implemented")}}export class CompleteLinkageAgglomerativeClustering extends u{static{d(this,"CompleteLinkageAgglomerativeClustering")}distance(a,e){let l=a.leafs,t=e.leafs;return Math.max.apply(null,l.map(s=>Math.max.apply(null,t.map(i=>s.distances[i.index]))))}update(a,e,l,t,s,i){return this._lanceWilliamsUpdater(.5,.5,0,.5)(t,s,i)}}export class SingleLinkageAgglomerativeClustering extends u{static{d(this,"SingleLinkageAgglomerativeClustering")}distance(a,e){let l=a.leafs,t=e.leafs;return Math.min.apply(null,l.map(i=>Math.min.apply(null,t.map(n=>i.distances[n.index]))))}update(a,e,l,t,s,i){return this._lanceWilliamsUpdater(.5,.5,0,-.5)(t,s,i)}}export class GroupAverageAgglomerativeClustering extends u{static{d(this,"GroupAverageAgglomerativeClustering")}distance(a,e){let l=a.leafs,t=e.leafs;return l.reduce((i,n)=>i+t.reduce((m,p)=>m+n.distances[p.index],0),0)/(l.length*t.length)}update(a,e,l,t,s,i){return this._lanceWilliamsUpdater(a/(a+e),e/(a+e),0,0)(t,s,i)}}export class WardsAgglomerativeClustering extends u{static{d(this,"WardsAgglomerativeClustering")}distance(a,e){let l=a.leafs.map(c=>c.point),t=e.leafs.map(c=>c.point),s=l.concat(t),i=this._mean(l),n=this._mean(t),m=this._mean(s),p=l.reduce((c,f)=>c+this._d(f,i)**2,0),r=t.reduce((c,f)=>c+this._d(f,n)**2,0);return s.reduce((c,f)=>c+this._d(f,m)**2,0)-p-r}update(a,e,l,t,s,i){return this._lanceWilliamsUpdater((l+a)/(l+a+e),(l+e)/(l+a+e),-l/(l+a+e),0)(t,s,i)}}export class CentroidAgglomerativeClustering extends u{static{d(this,"CentroidAgglomerativeClustering")}distance(a,e){let l=a.leafs.map(i=>i.point),t=e.leafs.map(i=>i.point),s=this._d(this._mean(l),this._mean(t));return s*s}update(a,e,l,t,s,i){return this._lanceWilliamsUpdater(a/(a+e),e/(a+e),-a*e/((a+e)*(a+e)),0)(t,s,i)}}export class WeightedAverageAgglomerativeClustering extends u{static{d(this,"WeightedAverageAgglomerativeClustering")}distance(a,e){return d(function t(s,i){return s.size===1&&i.size===1?s.distances[i.index]:i.size===1?(t(i,s.children[0])+t(i,s.children[1]))/2:(t(s,i.children[0])+t(s,i.children[1]))/2},"calcDistRec")(a,e)}update(a,e,l,t,s,i){return this._lanceWilliamsUpdater(.5,.5,0,0)(t,s,i)}}export class MedianAgglomerativeClustering extends u{static{d(this,"MedianAgglomerativeClustering")}distance(a,e){let l=this._mean(a.leafs.map(i=>i.point)),t=this._mean(e.leafs.map(i=>i.point)),s=l.map((i,n)=>(i+t[n])/2);return this._d(s,t)**2}update(a,e,l,t,s,i){return this._lanceWilliamsUpdater(.5,.5,-.25,0)(t,s,i)}}
