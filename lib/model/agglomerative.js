import Tree from"../util/tree.js";class AgglomerativeClustering{constructor(e="euclid"){switch(this._root=null,this._metric=e,this._metric){case"euclid":this._d=(e,t)=>Math.sqrt(e.reduce(((e,a,l)=>e+(a-t[l])**2),0));break;case"manhattan":this._d=(e,t)=>e.reduce(((e,a,l)=>e+Math.abs(a-t[l])),0);break;case"chebyshev":this._d=(e,t)=>e.reduce(((e,a,l)=>Math.max(e,Math.abs(a-t[l]))),-1/0)}}fit(e){const t=[];e.forEach(((a,l)=>{t.push(new Tree({point:a,index:l,distances:e.map((e=>this._d(a,e)))}))}));const a=[];for(let e=0;e<t.length;e++){a[e]||(a[e]=[]);for(let l=0;l<e;l++)a[e][l]||(a[e][l]=a[l][e]=this.distance(t[e],t[l]))}for(;t.length>1;){let e=t.length,l=0,s=1,r=a[0][1];for(let t=1;t<e;t++)a[t].forEach(((e,a)=>{e<r&&(l=t,s=a,r=e)}));let n=t[l].leafCount(),i=t[s].leafCount();a.forEach(((e,r)=>{r!=s&&r!=l&&(e[l]=this.update(n,i,t[r].leafCount(),e[l],e[s],a[s][l]),a[l][r]=e[l],e.splice(s,1))})),a[l].splice(s,1),a.splice(s,1),t[l]=new Tree({distance:r},[t[l],t[s]]),t.splice(s,1)}this._root=t[0]}getClusters(e){const t=[this._root];for(;t.length<e;){let e=0,a=-1;for(let l=0;l<t.length;l++){const s=t[l];!s.isLeaf()&&s.value.distance>e&&(a=l,e=s.value.distance)}if(-1===a)break;const l=t[a];t.splice(a,1,l.at(0),l.at(1))}return t}predict(e){const t=[],a=this.getClusters(e);for(let e=0;e<a.length;e++){const l=a[e].leafValues();for(let a=0;a<l.length;a++)t[l[a].index]=e}return t}distance(e,t){throw new Error("Not Implemented")}_mean(e){const t=Array(e[0].length).fill(0);for(let a=0;a<e.length;a++)for(let l=0;l<e[a].length;l++)t[l]+=e[a][l];return t.map((t=>t/e.length))}_lanceWilliamsUpdater(e,t,a,l){return(s,r,n)=>e*s+t*r+a*n+l*Math.abs(s-r)}update(e,t,a,l,s,r){throw new Error("Not Implemented")}}export class CompleteLinkageAgglomerativeClustering extends AgglomerativeClustering{distance(e,t){let a=e.leafValues(),l=t.leafValues();return Math.max.apply(null,a.map((e=>Math.max.apply(null,l.map((t=>e.distances[t.index]))))))}update(e,t,a,l,s,r){return this._lanceWilliamsUpdater(.5,.5,0,.5)(l,s,r)}}export class SingleLinkageAgglomerativeClustering extends AgglomerativeClustering{distance(e,t){let a=e.leafValues(),l=t.leafValues();return Math.min.apply(null,a.map((e=>Math.min.apply(null,l.map((t=>e.distances[t.index]))))))}update(e,t,a,l,s,r){return this._lanceWilliamsUpdater(.5,.5,0,-.5)(l,s,r)}}export class GroupAverageAgglomerativeClustering extends AgglomerativeClustering{distance(e,t){let a=e.leafValues(),l=t.leafValues();return a.reduce(((e,t)=>e+l.reduce(((e,a)=>e+t.distances[a.index]),0)),0)/(a.length*l.length)}update(e,t,a,l,s,r){return this._lanceWilliamsUpdater(e/(e+t),t/(e+t),0,0)(l,s,r)}}export class WardsAgglomerativeClustering extends AgglomerativeClustering{distance(e,t){let a=e.leafValues().map((e=>e.point)),l=t.leafValues().map((e=>e.point)),s=a.concat(l),r=this._mean(a),n=this._mean(l),i=this._mean(s),u=a.reduce(((e,t)=>e+this._d(t,r)**2),0),o=l.reduce(((e,t)=>e+this._d(t,n)**2),0);return s.reduce(((e,t)=>e+this._d(t,i)**2),0)-u-o}update(e,t,a,l,s,r){return this._lanceWilliamsUpdater((a+e)/(a+e+t),(a+t)/(a+e+t),-a/(a+e+t),0)(l,s,r)}}export class CentroidAgglomerativeClustering extends AgglomerativeClustering{distance(e,t){let a=e.leafValues().map((e=>e.point)),l=t.leafValues().map((e=>e.point)),s=this._d(this._mean(a),this._mean(l));return s*s}update(e,t,a,l,s,r){return this._lanceWilliamsUpdater(e/(e+t),t/(e+t),-e*t/((e+t)*(e+t)),0)(l,s,r)}}export class WeightedAverageAgglomerativeClustering extends AgglomerativeClustering{distance(e,t){return function e(t,a){return 1===t.leafCount()&&1===a.leafCount()?t.value.distances[a.value.index]:1===a.leafCount()?(e(a,t.at(0))+e(a,t.at(1)))/2:(e(t,a.at(0))+e(t,a.at(1)))/2}(e,t)}update(e,t,a,l,s,r){return this._lanceWilliamsUpdater(.5,.5,0,0)(l,s,r)}}export class MedianAgglomerativeClustering extends AgglomerativeClustering{distance(e,t){let a=this._mean(e.leafValues().map((e=>e.point))),l=this._mean(t.leafValues().map((e=>e.point))),s=a.map(((e,t)=>(e+l[t])/2));return this._d(s,l)**2}update(e,t,a,l,s,r){return this._lanceWilliamsUpdater(.5,.5,-.25,0)(l,s,r)}}