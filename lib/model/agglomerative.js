var g=Object.defineProperty;var d=(h,a)=>g(h,"name",{value:a,configurable:!0});class o{static{d(this,"AgglomerativeClustering")}constructor(a="euclid"){switch(this._root=null,this._metric=a,this._metric){case"euclid":this._d=(e,l)=>Math.sqrt(e.reduce((t,i,s)=>t+(i-l[s])**2,0));break;case"manhattan":this._d=(e,l)=>e.reduce((t,i,s)=>t+Math.abs(i-l[s]),0);break;case"chebyshev":this._d=(e,l)=>e.reduce((t,i,s)=>Math.max(t,Math.abs(i-l[s])),-1/0);break}}fit(a){const e=[];a.forEach((t,i)=>{e.push({point:t,index:i,distances:a.map(s=>this._d(t,s)),size:1,get leafs(){return[this]}})});const l=[];for(let t=0;t<e.length;t++){l[t]||(l[t]=[]);for(let i=0;i<t;i++)l[t][i]||(l[t][i]=l[i][t]=this.distance(e[t],e[i]))}for(;e.length>1;){let t=e.length,i=0,s=1,n=l[0][1];for(let r=1;r<t;r++)l[r].forEach((u,c)=>{u<n&&(i=r,s=c,n=u)});let m=e[i].size,p=e[s].size;l.forEach((r,u)=>{u!=s&&u!=i&&(r[i]=this.update(m,p,e[u].size,r[i],r[s],l[s][i]),l[i][u]=r[i],r.splice(s,1))}),l[i].splice(s,1),l.splice(s,1),e[i]={distance:n,size:e[i].size+e[s].size,children:[e[i],e[s]],get leafs(){return[...this.children[0].leafs,...this.children[1].leafs]}},e.splice(s,1)}this._root=e[0]}getClusters(a){const e=[this._root];for(;e.length<a;){let l=0,t=-1;for(let s=0;s<e.length;s++){const n=e[s];n.children&&n.distance>l&&(t=s,l=n.distance)}if(t===-1)break;const i=e[t];e.splice(t,1,i.children[0],i.children[1])}return e}predict(a){const e=[],l=this.getClusters(a);for(let t=0;t<l.length;t++){const i=l[t].leafs;for(let s=0;s<i.length;s++)e[i[s].index]=t}return e}distance(a,e){throw new Error("Not Implemented")}_mean(a){const e=Array(a[0].length).fill(0);for(let l=0;l<a.length;l++)for(let t=0;t<a[l].length;t++)e[t]+=a[l][t];return e.map(l=>l/a.length)}_lanceWilliamsUpdater(a,e,l,t){return(i,s,n)=>a*i+e*s+l*n+t*Math.abs(i-s)}update(a,e,l,t,i,s){throw new Error("Not Implemented")}}export class CompleteLinkageAgglomerativeClustering extends o{static{d(this,"CompleteLinkageAgglomerativeClustering")}distance(a,e){let l=a.leafs,t=e.leafs;return Math.max.apply(null,l.map(i=>Math.max.apply(null,t.map(s=>i.distances[s.index]))))}update(a,e,l,t,i,s){return this._lanceWilliamsUpdater(.5,.5,0,.5)(t,i,s)}}export class SingleLinkageAgglomerativeClustering extends o{static{d(this,"SingleLinkageAgglomerativeClustering")}distance(a,e){let l=a.leafs,t=e.leafs;return Math.min.apply(null,l.map(s=>Math.min.apply(null,t.map(n=>s.distances[n.index]))))}update(a,e,l,t,i,s){return this._lanceWilliamsUpdater(.5,.5,0,-.5)(t,i,s)}}export class GroupAverageAgglomerativeClustering extends o{static{d(this,"GroupAverageAgglomerativeClustering")}distance(a,e){let l=a.leafs,t=e.leafs;return l.reduce((s,n)=>s+t.reduce((m,p)=>m+n.distances[p.index],0),0)/(l.length*t.length)}update(a,e,l,t,i,s){return this._lanceWilliamsUpdater(a/(a+e),e/(a+e),0,0)(t,i,s)}}export class WardsAgglomerativeClustering extends o{static{d(this,"WardsAgglomerativeClustering")}distance(a,e){let l=a.leafs.map(c=>c.point),t=e.leafs.map(c=>c.point),i=l.concat(t),s=this._mean(l),n=this._mean(t),m=this._mean(i),p=l.reduce((c,f)=>c+this._d(f,s)**2,0),r=t.reduce((c,f)=>c+this._d(f,n)**2,0);return i.reduce((c,f)=>c+this._d(f,m)**2,0)-p-r}update(a,e,l,t,i,s){return this._lanceWilliamsUpdater((l+a)/(l+a+e),(l+e)/(l+a+e),-l/(l+a+e),0)(t,i,s)}}export class CentroidAgglomerativeClustering extends o{static{d(this,"CentroidAgglomerativeClustering")}distance(a,e){let l=a.leafs.map(s=>s.point),t=e.leafs.map(s=>s.point),i=this._d(this._mean(l),this._mean(t));return i*i}update(a,e,l,t,i,s){return this._lanceWilliamsUpdater(a/(a+e),e/(a+e),-a*e/((a+e)*(a+e)),0)(t,i,s)}}export class WeightedAverageAgglomerativeClustering extends o{static{d(this,"WeightedAverageAgglomerativeClustering")}distance(a,e){return d(function t(i,s){return i.size===1&&s.size===1?i.distances[s.index]:s.size===1?(t(s,i.children[0])+t(s,i.children[1]))/2:(t(i,s.children[0])+t(i,s.children[1]))/2},"calcDistRec")(a,e)}update(a,e,l,t,i,s){return this._lanceWilliamsUpdater(.5,.5,0,0)(t,i,s)}}export class MedianAgglomerativeClustering extends o{static{d(this,"MedianAgglomerativeClustering")}distance(a,e){let l=this._mean(a.leafs.map(s=>s.point)),t=this._mean(e.leafs.map(s=>s.point)),i=l.map((s,n)=>(s+t[n])/2);return this._d(i,t)**2}update(a,e,l,t,i,s){return this._lanceWilliamsUpdater(.5,.5,-.25,0)(t,i,s)}}
