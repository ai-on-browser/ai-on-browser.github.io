var g=Object.defineProperty;var c=(r,n)=>g(r,"name",{value:n,configurable:!0});const _={euclid:c((r,n)=>Math.sqrt(r.reduce((e,l,t)=>e+(l-n[t])**2,0)),"euclid"),manhattan:c((r,n)=>r.reduce((e,l,t)=>e+Math.abs(l-n[t]),0),"manhattan"),chebyshev:c((r,n)=>r.reduce((e,l,t)=>Math.max(e,Math.abs(l-n[t])),-1/0),"chebyshev")};class m{static{c(this,"AgglomerativeClustering")}constructor(n="euclid"){this._root=null,this._metric=n,typeof this._metric=="function"?this._d=this._metric:this._d=_[this._metric]}fit(n){const e=[];n.forEach((t,s)=>{e.push({point:t,index:s,distances:n.map(i=>this._d(t,i)),size:1,get leafs(){return[this]}})});const l=[];for(let t=0;t<e.length;t++){l[t]||(l[t]=[]);for(let s=0;s<t;s++)l[t][s]||(l[t][s]=l[s][t]=this.distance(e[t],e[s]))}for(;e.length>1;){let t=e.length,s=0,i=1,a=l[0][1];for(let d=1;d<t;d++)l[d].forEach((o,h)=>{o<a&&(s=d,i=h,a=o)});let u=e[s].size,p=e[i].size;l.forEach((d,o)=>{o!=i&&o!=s&&(d[s]=this.update(u,p,e[o].size,d[s],d[i],l[i][s]),l[s][o]=d[s],d.splice(i,1))}),l[s].splice(i,1),l.splice(i,1),e[s]={distance:a,size:e[s].size+e[i].size,children:[e[s],e[i]],get leafs(){return[...this.children[0].leafs,...this.children[1].leafs]}},e.splice(i,1)}this._root=e[0]}getClusters(n){const e=[this._root];for(;e.length<n;){let l=0,t=-1;for(let i=0;i<e.length;i++){const a=e[i];a.children&&a.distance>l&&(t=i,l=a.distance)}if(t===-1)break;const s=e[t];e.splice(t,1,s.children[0],s.children[1])}return e}predict(n){const e=[],l=this.getClusters(n);for(let t=0;t<l.length;t++){const s=l[t].leafs;for(let i=0;i<s.length;i++)e[s[i].index]=t}return e}distance(n,e){throw new Error("Not Implemented")}_mean(n){const e=Array(n[0].length).fill(0);for(let l=0;l<n.length;l++)for(let t=0;t<n[l].length;t++)e[t]+=n[l][t];return e.map(l=>l/n.length)}_lanceWilliamsUpdater(n,e,l,t){return(s,i,a)=>n*s+e*i+l*a+t*Math.abs(s-i)}update(n,e,l,t,s,i){throw new Error("Not Implemented")}}export class CompleteLinkageAgglomerativeClustering extends m{static{c(this,"CompleteLinkageAgglomerativeClustering")}distance(n,e){let l=n.leafs,t=e.leafs;return Math.max.apply(null,l.map(s=>Math.max.apply(null,t.map(i=>s.distances[i.index]))))}update(n,e,l,t,s,i){return this._lanceWilliamsUpdater(.5,.5,0,.5)(t,s,i)}}export class SingleLinkageAgglomerativeClustering extends m{static{c(this,"SingleLinkageAgglomerativeClustering")}distance(n,e){let l=n.leafs,t=e.leafs;return Math.min.apply(null,l.map(i=>Math.min.apply(null,t.map(a=>i.distances[a.index]))))}update(n,e,l,t,s,i){return this._lanceWilliamsUpdater(.5,.5,0,-.5)(t,s,i)}}export class GroupAverageAgglomerativeClustering extends m{static{c(this,"GroupAverageAgglomerativeClustering")}distance(n,e){let l=n.leafs,t=e.leafs;return l.reduce((i,a)=>i+t.reduce((u,p)=>u+a.distances[p.index],0),0)/(l.length*t.length)}update(n,e,l,t,s,i){return this._lanceWilliamsUpdater(n/(n+e),e/(n+e),0,0)(t,s,i)}}export class WardsAgglomerativeClustering extends m{static{c(this,"WardsAgglomerativeClustering")}distance(n,e){let l=n.leafs.map(h=>h.point),t=e.leafs.map(h=>h.point),s=l.concat(t),i=this._mean(l),a=this._mean(t),u=this._mean(s),p=l.reduce((h,f)=>h+this._d(f,i)**2,0),d=t.reduce((h,f)=>h+this._d(f,a)**2,0);return s.reduce((h,f)=>h+this._d(f,u)**2,0)-p-d}update(n,e,l,t,s,i){return this._lanceWilliamsUpdater((l+n)/(l+n+e),(l+e)/(l+n+e),-l/(l+n+e),0)(t,s,i)}}export class CentroidAgglomerativeClustering extends m{static{c(this,"CentroidAgglomerativeClustering")}distance(n,e){let l=n.leafs.map(i=>i.point),t=e.leafs.map(i=>i.point),s=this._d(this._mean(l),this._mean(t));return s*s}update(n,e,l,t,s,i){return this._lanceWilliamsUpdater(n/(n+e),e/(n+e),-n*e/((n+e)*(n+e)),0)(t,s,i)}}export class WeightedAverageAgglomerativeClustering extends m{static{c(this,"WeightedAverageAgglomerativeClustering")}distance(n,e){return c(function t(s,i){return s.size===1&&i.size===1?s.distances[i.index]:i.size===1?(t(i,s.children[0])+t(i,s.children[1]))/2:(t(s,i.children[0])+t(s,i.children[1]))/2},"calcDistRec")(n,e)}update(n,e,l,t,s,i){return this._lanceWilliamsUpdater(.5,.5,0,0)(t,s,i)}}export class MedianAgglomerativeClustering extends m{static{c(this,"MedianAgglomerativeClustering")}distance(n,e){let l=this._mean(n.leafs.map(i=>i.point)),t=this._mean(e.leafs.map(i=>i.point)),s=l.map((i,a)=>(i+t[a])/2);return this._d(s,t)**2}update(n,e,l,t,s,i){return this._lanceWilliamsUpdater(.5,.5,-.25,0)(t,s,i)}}
