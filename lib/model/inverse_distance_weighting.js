var d=Object.defineProperty;var n=(c,a)=>d(c,"name",{value:a,configurable:!0});export default class p{static{n(this,"InverseDistanceWeighting")}constructor(a=5,e=2,r="euclid"){if(this._k=a,this._p=e,this._metric=r,typeof this._metric=="function")this._d=this._metric;else switch(this._metric){case"euclid":this._d=(s,i)=>Math.sqrt(s.reduce((t,h,_)=>t+(h-i[_])**2,0));break;case"manhattan":this._d=(s,i)=>s.reduce((t,h,_)=>t+Math.abs(h-i[_]),0);break;case"chebyshev":this._d=(s,i)=>Math.max(...s.map((t,h)=>Math.abs(t-i[h])));break;case"minkowski":this._dp=2,this._d=(s,i)=>Math.pow(s.reduce((t,h,_)=>t+(h-i[_])**this._dp,0),1/this._dp);break}}_near_points(a){const e=[];return this._x.forEach((r,s)=>{const i=this._d(a,r);if(e.length<this._k||i<e[this._k-1].d){e.length>=this._k&&e.pop(),e.push({d:i,value:this._y[s],idx:s});for(let t=e.length-1;t>0;t--)e[t-1].d>e[t].d&&([e[t],e[t-1]]=[e[t-1],e[t]])}}),e}fit(a,e){this._x=a,this._y=e}predict(a){return a.map(e=>{const r=this._near_points(e);if(r[0].d===0)return r[0].value;let s=0,i=0;for(let t=0;t<r.length;t++){const h=1/r[t].d**this._p;i+=h*r[t].value,s+=h}return i/s})}}
