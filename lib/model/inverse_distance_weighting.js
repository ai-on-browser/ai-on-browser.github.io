var n=Object.defineProperty;var d=(c,a)=>n(c,"name",{value:a,configurable:!0});export default class p{static{d(this,"InverseDistanceWeighting")}constructor(a=5,s=2,r="euclid"){switch(this._k=a,this._p=s,this._metric=r,this._metric){case"euclid":this._d=(e,i)=>Math.sqrt(e.reduce((t,h,_)=>t+(h-i[_])**2,0));break;case"manhattan":this._d=(e,i)=>e.reduce((t,h,_)=>t+Math.abs(h-i[_]),0);break;case"chebyshev":this._d=(e,i)=>Math.max(...e.map((t,h)=>Math.abs(t-i[h])));break;case"minkowski":this._dp=2,this._d=(e,i)=>Math.pow(e.reduce((t,h,_)=>t+(h-i[_])**this._dp,0),1/this._dp);break}}_near_points(a){const s=[];return this._x.forEach((r,e)=>{const i=this._d(a,r);if(s.length<this._k||i<s[this._k-1].d){s.length>=this._k&&s.pop(),s.push({d:i,value:this._y[e],idx:e});for(let t=s.length-1;t>0;t--)s[t-1].d>s[t].d&&([s[t],s[t-1]]=[s[t-1],s[t]])}}),s}fit(a,s){this._x=a,this._y=s}predict(a){return a.map(s=>{const r=this._near_points(s);if(r[0].d===0)return r[0].value;let e=0,i=0;for(let t=0;t<r.length;t++){const h=1/r[t].d**this._p;i+=h*r[t].value,e+=h}return i/e})}}
