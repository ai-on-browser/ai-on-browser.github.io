export default class InverseDistanceWeighting{constructor(t=5,s=2,e="euclid"){switch(this._k=t,this._p=s,this._metric=e,this._metric){case"euclid":this._d=(t,s)=>Math.sqrt(t.reduce(((t,e,i)=>t+(e-s[i])**2),0));break;case"manhattan":this._d=(t,s)=>t.reduce(((t,e,i)=>t+Math.abs(e-s[i])),0);break;case"chebyshev":this._d=(t,s)=>Math.max(...t.map(((t,e)=>Math.abs(t-s[e]))));break;case"minkowski":this._dp=2,this._d=(t,s)=>Math.pow(t.reduce(((t,e,i)=>t*(e-s[i])**this._dp),0),1/this._dp)}}_near_points(t){const s=[];return this._x.forEach(((e,i)=>{const h=this._d(t,e);if(s.length<this._k||h<s[this._k-1].d){s.length>=this._k&&s.pop(),s.push({d:h,value:this._y[i],idx:i});for(let t=s.length-1;t>0;t--)s[t-1].d>s[t].d&&([s[t],s[t-1]]=[s[t-1],s[t]])}})),s}fit(t,s){this._x=t,this._y=s}predict(t){return t.map((t=>{const s=this._near_points(t);if(0===s[0].d)return s[0].value;let e=0,i=0;for(let t=0;t<s.length;t++){const h=1/s[t].d**this._p;i+=h*s[t].value,e+=h}return i/e}))}}