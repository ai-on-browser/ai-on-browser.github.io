var _=Object.defineProperty;var c=(h,e)=>_(h,"name",{value:e,configurable:!0});const d={euclid:c(()=>(h,e)=>Math.sqrt(h.reduce((t,i,r)=>t+(i-e[r])**2,0)),"euclid"),manhattan:c(()=>(h,e)=>h.reduce((t,i,r)=>t+Math.abs(i-e[r]),0),"manhattan"),chebyshev:c(()=>(h,e)=>Math.max(...h.map((t,i)=>Math.abs(t-e[i]))),"chebyshev"),minkowski:c(({p:h=2}={})=>(e,t)=>Math.pow(e.reduce((i,r,n)=>i+(r-t[n])**h,0),1/h),"minkowski")};export default class o{static{c(this,"InverseDistanceWeighting")}constructor(e=5,t=2,i="euclid"){this._k=e,this._p=t,this._metric=i,typeof this._metric=="function"?this._d=this._metric:this._d=d[this._metric]()}_near_points(e){const t=[];return this._x.forEach((i,r)=>{const n=this._d(e,i);if(t.length<this._k||n<t[this._k-1].d){t.length>=this._k&&t.pop(),t.push({d:n,value:this._y[r],idx:r});for(let s=t.length-1;s>0;s--)t[s-1].d>t[s].d&&([t[s],t[s-1]]=[t[s-1],t[s]])}}),t}fit(e,t){this._x=e,this._y=t}predict(e){return e.map(t=>{const i=this._near_points(t);if(i[0].d===0)return i[0].value;let r=0,n=0;for(let s=0;s<i.length;s++){const a=1/i[s].d**this._p;n+=a*i[s].value,r+=a}return n/r})}}
