import Matrix from"../util/matrix.js";const logGamma=t=>{if(Number.isInteger(t)&&t>0){let a=0;for(let r=2;r<t;r++)a+=Math.log(r);return a}if(Number.isInteger(t-.5)&&t>0){const a=t-.5;let r=Math.log(Math.sqrt(Math.PI))-Math.log(2)*a;for(let t=2*a-1;t>0;t-=2)r+=Math.log(t);return r}throw""},beta=(t,a)=>Math.exp(logGamma(t)+logGamma(a)-logGamma(t+a)),ibeta=(t,a,r)=>{if(t>(a+1)/(a+r+1))return 1-ibeta(1-t,r,a);let e,o,l,s=-t*(a+r)/(a+1),n=2,h=1+s/n,i=1,m=1+s/i,u=1,f=n/i*u,M=h/m*f;for(let g=1;g<1e3&&!(Math.abs(M-u)<1e-12);g++){const c=2*g*a;e=t*g*(r-g)/(c*(c-1)),s=-t*(a+g)*(a+r+g)/(c*(c+1)),o=h,n=1+e/o,h=1+s/n,l=m,i=1+e/l,m=1+s/i,u=M,f=n/i*u,M=h/m*f}return t**a*(1-t)**r*(M-1)/(a*(g=a,c=r,Math.exp(logGamma(g)+logGamma(c)-logGamma(g+c))));var g,c},ct=(t,a)=>{if(1===a)return.5+Math.atan(t)/Math.PI;if(2===a)return(1+t/Math.sqrt(2+t**2))/2;const r=Math.sqrt(t**2+a);return ibeta((t+r)/(2*r),a/2,a/2)},qt=(t,a)=>{if(Math.abs(a)>1)throw"absolute of 'a' need less than or equals to 1.";if(1===Math.abs(a))return Math.sign(a)*(1/0);if(a>.5)return-qt(t,1-a);a=1-a;let r=1,e=null,o=0;let l=1e4;for(;l-- >0;){const l=ct(r,t);if(isNaN(l))return l;if(Math.abs(l-a)<1e-5)return r;l<a?(o=r,null===e?r*=2:r=(r+e)/2):(e=r,r=(r+o)/2)}throw"qt not converged."};export default class Thompson{constructor(t){this._alpha=t}predict(t){const a=Matrix.fromArray(t),r=a.rows,e=Array(t.length).fill(!1);if(r<=2||this._alpha>r)return e;const o=a.mean(0),l=a.std(0);a.sub(o),a.abs(),a.div(l);const s=a.max(1),n=s.argmax(0).toScaler(),h=s.at(n,0),i=h*Math.sqrt((r-2)/(r-1-h**2)),m=this._alpha/r;return i>qt(r-2,m)&&(e[n]=!0),e}}