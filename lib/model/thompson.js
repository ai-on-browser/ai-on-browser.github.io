import Matrix from"../util/matrix.js";const logGamma=t=>{if(Number.isInteger(t)&&t>0){let a=0;for(let r=2;r<t;r++)a+=Math.log(r);return a}if(Number.isInteger(t-.5)&&t>0){const a=t-.5;let r=Math.log(Math.sqrt(Math.PI))-Math.log(2)*a;for(let t=2*a-1;t>0;t-=2)r+=Math.log(t);return r}throw""},beta=(t,a)=>Math.exp(logGamma(t)+logGamma(a)-logGamma(t+a)),ibeta=(t,a,r)=>{if(t>(a+1)/(a+r+1))return 1-ibeta(1-t,r,a);let e,o,s,n=-t*(a+r)/(a+1),l=2,h=1+n/l,i=1,u=1+n/i,f=1,M=l/i*f,m=h/u*M;for(let c=1;c<1e3&&!(Math.abs(m-f)<1e-12);c++){const b=2*c*a;e=t*c*(r-c)/(b*(b-1)),n=-t*(a+c)*(a+r+c)/(b*(b+1)),o=h,l=1+e/o,h=1+n/l,s=u,i=1+e/s,u=1+n/i,f=m,M=l/i*f,m=h/u*M}return t**a*(1-t)**r*(m-1)/(a*beta(a,r))},ct=(t,a)=>{if(1===a)return.5+Math.atan(t)/Math.PI;if(2===a)return(1+t/Math.sqrt(2+t**2))/2;const r=Math.sqrt(t**2+a);return ibeta((t+r)/(2*r),a/2,a/2)},qt=(t,a)=>{if(Math.abs(a)>1)throw"absolute of 'a' need less than or equals to 1.";if(1===Math.abs(a))return Math.sign(a)*(1/0);if(a>.5)return-qt(t,1-a);a=1-a;let r=1,e=null,o=0;let s=1e4;for(;s-- >0;){const s=ct(r,t);if(isNaN(s))return s;if(Math.abs(s-a)<1e-5)return r;s<a?(o=r,null===e?r*=2:r=(r+e)/2):(e=r,r=(r+o)/2)}throw"qt not converged."};export default class Thompson{constructor(t){this._alpha=t}predict(t){const a=Matrix.fromArray(t),r=a.rows,e=Array(t.length).fill(!1);if(r<=2||this._alpha>r)return e;const o=a.mean(0),s=a.std(0);a.sub(o),a.abs(),a.div(s);const n=a.max(1),l=n.argmax(0).toScaler(),h=n.at(l,0),i=h*Math.sqrt((r-2)/(r-1-h**2)),u=this._alpha/r;return i>qt(r-2,u)&&(e[l]=!0),e}}