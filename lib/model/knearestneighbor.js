var _=Object.defineProperty;var c=(n,e)=>_(n,"name",{value:e,configurable:!0});const u={euclid:c(()=>(n,e)=>Math.sqrt(n.reduce((t,s,i)=>t+(s-e[i])**2,0)),"euclid"),manhattan:c(()=>(n,e)=>n.reduce((t,s,i)=>t+Math.abs(s-e[i]),0),"manhattan"),chebyshev:c(()=>(n,e)=>Math.max(...n.map((t,s)=>Math.abs(t-e[s]))),"chebyshev"),minkowski:c(({p:n=2}={})=>(e,t)=>e.reduce((s,i,r)=>s+(i-t[r])**n,0)**(1/n),"minkowski")};class a{static{c(this,"KNNBase")}constructor(e=5,t="euclid"){this._p=[],this._c=[],this._k=e,this._metric=t,typeof this._metric=="function"?this._d=this._metric:this._d=u[this._metric]()}_near_points(e){const t=[];return this._p.forEach((s,i)=>{const r=this._d(e,s);if(t.length<this._k||r<t[this._k-1].d){t.length>=this._k&&t.pop(),t.push({d:r,category:this._c[i],idx:i});for(let o=t.length-1;o>0;o--)t[o-1].d>t[o].d&&([t[o],t[o-1]]=[t[o-1],t[o]])}}),t}_add(e,t){this._p.push(e),this._c.push(t)}}export class KNN extends a{static{c(this,"KNN")}constructor(e=5,t="euclid"){super(e,t)}add(e,t){super._add(e,t)}fit(e,t){for(let s=0;s<e.length;s++)this.add(e[s],t[s])}predict(e){return e.map(t=>{const s=this._near_points(t),i={};s.forEach(h=>{const d=h.category;i[d]?(i[d].count+=1,i[d].min_d=Math.min(i[d].min_d,h.d)):i[d]={category:d,count:1,min_d:h.d}});let r=0,o=-1,l=null;for(const h of Object.keys(i))(r<i[h].count||r===i[h].count&&i[h].min_d<o)&&(r=i[h].count,o=i[h].min_d,l=i[h].category);return l})}}export class KNNRegression extends a{static{c(this,"KNNRegression")}constructor(e=5,t="euclid"){super(e,t)}add(e,t){super._add(e,t)}fit(e,t){for(let s=0;s<e.length;s++)this.add(e[s],t[s])}predict(e){return e.map(t=>{const s=this._near_points(t);return s.reduce((i,r)=>i+r.category,0)/s.length})}}export class KNNAnomaly extends a{static{c(this,"KNNAnomaly")}constructor(e=5,t="euclid"){super(e,t)}add(e){super._add(e)}fit(e){for(let t=0;t<e.length;t++)this.add(e[t])}predict(e){return e.map(t=>{const s=this._near_points(t);return s[s.length-1].d})}}export class KNNDensityEstimation extends a{static{c(this,"KNNDensityEstimation")}constructor(e=5,t="euclid"){super(e,t)}add(e){super._add(e)}fit(e){for(let t=0;t<e.length;t++)this.add(e[t])}_logGamma(e){let t=0;if(Number.isInteger(e))for(let s=2;s<e;s++)t+=Math.log(s);else{const s=e-.5;t=Math.log(Math.sqrt(Math.PI))-Math.log(2)*s;for(let i=2*s-1;i>0;i-=2)t+=Math.log(i)}return t}predict(e){return e.map(t=>{const s=this._near_points(t),i=s[s.length-1].d,r=t.length,o=this._logGamma(r/2+1)-r/2*Math.log(Math.PI)-r*Math.log(i);return Math.exp(o)*this._k/this._p.length})}}export class SemiSupervisedKNN extends a{static{c(this,"SemiSupervisedKNN")}constructor(e=5,t="euclid"){super(e,t),this._k=1/0,this._orgk=e}add(e,t){super._add(e,t)}fit(e,t){for(let s=0;s<e.length;s++)this.add(e[s],t[s])}predict(){for(;;){const e=[];for(let t=0;t<this._p.length;t++)if(this._c[t]!=null){let s=0;const i=this._near_points(this._p[t]);for(const r of i)if(r.category==null&&(r.d<(e[r.idx]?.d??1/0)&&(e[r.idx]={d:r.d,category:this._c[t]}),++s>=this._orgk))break}if(e.length===0)break;for(let t=0;t<this._p.length;t++)e[t]&&(this._c[t]=e[t].category)}return this._c}}
