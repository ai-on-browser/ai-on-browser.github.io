export class KNN{constructor(t=5,e="euclid"){switch(this._p=[],this._c=[],this._k=t,this._metric=e,this._metric){case"euclid":this._d=(t,e)=>Math.sqrt(t.reduce(((t,s,i)=>t+(s-e[i])**2),0));break;case"manhattan":this._d=(t,e)=>t.reduce(((t,s,i)=>t+Math.abs(s-e[i])),0);break;case"chebyshev":this._d=(t,e)=>Math.max(...t.map(((t,s)=>Math.abs(t-e[s]))));break;case"minkowski":this._dp=2,this._d=(t,e)=>Math.pow(t.reduce(((t,s,i)=>t*(s-e[i])**this._dp),0),1/this._dp)}}get k(){return this._k}set k(t){this._k=t}_near_points(t){const e=[];return this._p.forEach(((s,i)=>{const r=this._d(t,s);if(e.length<this._k||r<e[this._k-1].d){e.length>=this._k&&e.pop(),e.push({d:r,category:this._c[i],idx:i});for(let t=e.length-1;t>0;t--)e[t-1].d>e[t].d&&([e[t],e[t-1]]=[e[t-1],e[t]])}})),e}add(t,e){this._p.push(t),this._c.push(e)}fit(t,e){for(let s=0;s<t.length;s++)this.add(t[s],e&&e[s])}predict(t){const e=this._near_points(t),s={};e.forEach((t=>{let e=t.category;s[e]?(s[e].count+=1,s[e].min_d=Math.min(s[e].min_d,t.d)):s[e]={count:1,min_d:t.d}}));let i=0,r=-1,h=-1;for(let t of Object.keys(s))(i<s[t].count||i===s[t].count&&s[t].min_d<r)&&(i=s[t].count,r=s[t].min_d,h=+t);return h}}export class KNNRegression extends KNN{constructor(t=5,e="euclid"){super(t,e)}predict(t){const e=this._near_points(t);return e.reduce(((t,e)=>t+e.category),0)/e.length}}export class KNNAnomaly extends KNN{constructor(t=5,e="euclid"){super(t,e)}predict(t){const e=this._near_points(t);return e[e.length-1].d}}export class KNNDensityEstimation extends KNN{constructor(t=5,e="euclid"){super(t,e)}_logGamma(t){let e=0;if(Number.isInteger(t))for(let s=2;s<t;s++)e+=Math.log(s);else{const s=t-.5;e=Math.log(Math.sqrt(Math.PI))-Math.log(2)*s;for(let t=2*s-1;t>0;t-=2)e+=Math.log(t)}return e}predict(t){const e=this._near_points(t),s=e[e.length-1].d,i=t.length,r=this._logGamma(i/2+1)-i/2*Math.log(Math.PI)-i*Math.log(s);return Math.exp(r)*this.k/this._p.length}}export class SemiSupervisedKNN extends KNN{constructor(t=5,e="euclid"){super(t,e),this._k=1/0,this._orgk=t}predict(){for(;;){const t=[];for(let e=0;e<this._p.length;e++)if(null!=this._c[e]){let s=0;const i=this._near_points(this._p[e]);for(const r of i)if(null==r.category&&(r.d<(t[r.idx]?.d??1/0)&&(t[r.idx]={d:r.d,category:this._c[e]}),++s>=this._orgk))break}if(0===t.length)break;for(let e=0;e<this._p.length;e++)t[e]&&(this._c[e]=t[e].category)}return this._c}}