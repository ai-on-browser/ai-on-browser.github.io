class KNNBase{constructor(t=5,e="euclid"){switch(this._p=[],this._c=[],this._k=t,this._metric=e,this._metric){case"euclid":this._d=(t,e)=>Math.sqrt(t.reduce(((t,s,r)=>t+(s-e[r])**2),0));break;case"manhattan":this._d=(t,e)=>t.reduce(((t,s,r)=>t+Math.abs(s-e[r])),0);break;case"chebyshev":this._d=(t,e)=>Math.max(...t.map(((t,s)=>Math.abs(t-e[s]))));break;case"minkowski":this._dp=2,this._d=(t,e)=>Math.pow(t.reduce(((t,s,r)=>t+(s-e[r])**this._dp),0),1/this._dp)}}_near_points(t){const e=[];return this._p.forEach(((s,r)=>{const i=this._d(t,s);if(e.length<this._k||i<e[this._k-1].d){e.length>=this._k&&e.pop(),e.push({d:i,category:this._c[r],idx:r});for(let t=e.length-1;t>0;t--)e[t-1].d>e[t].d&&([e[t],e[t-1]]=[e[t-1],e[t]])}})),e}_add(t,e){this._p.push(t),this._c.push(e)}}export class KNN extends KNNBase{constructor(t=5,e="euclid"){super(t,e)}add(t,e){super._add(t,e)}fit(t,e){for(let s=0;s<t.length;s++)this.add(t[s],e[s])}predict(t){return t.map((t=>{const e=this._near_points(t),s={};e.forEach((t=>{let e=t.category;s[e]?(s[e].count+=1,s[e].min_d=Math.min(s[e].min_d,t.d)):s[e]={category:e,count:1,min_d:t.d}}));let r=0,i=-1,a=null;for(let t of Object.keys(s))(r<s[t].count||r===s[t].count&&s[t].min_d<i)&&(r=s[t].count,i=s[t].min_d,a=s[t].category);return a}))}}export class KNNRegression extends KNNBase{constructor(t=5,e="euclid"){super(t,e)}add(t,e){super._add(t,e)}fit(t,e){for(let s=0;s<t.length;s++)this.add(t[s],e[s])}predict(t){return t.map((t=>{const e=this._near_points(t);return e.reduce(((t,e)=>t+e.category),0)/e.length}))}}export class KNNAnomaly extends KNNBase{constructor(t=5,e="euclid"){super(t,e)}add(t){super._add(t)}fit(t){for(let e=0;e<t.length;e++)this.add(t[e])}predict(t){return t.map((t=>{const e=this._near_points(t);return e[e.length-1].d}))}}export class KNNDensityEstimation extends KNNBase{constructor(t=5,e="euclid"){super(t,e)}add(t){super._add(t)}fit(t){for(let e=0;e<t.length;e++)this.add(t[e])}_logGamma(t){let e=0;if(Number.isInteger(t))for(let s=2;s<t;s++)e+=Math.log(s);else{const s=t-.5;e=Math.log(Math.sqrt(Math.PI))-Math.log(2)*s;for(let t=2*s-1;t>0;t-=2)e+=Math.log(t)}return e}predict(t){return t.map((t=>{const e=this._near_points(t),s=e[e.length-1].d,r=t.length,i=this._logGamma(r/2+1)-r/2*Math.log(Math.PI)-r*Math.log(s);return Math.exp(i)*this._k/this._p.length}))}}export class SemiSupervisedKNN extends KNNBase{constructor(t=5,e="euclid"){super(t,e),this._k=1/0,this._orgk=t}add(t,e){super._add(t,e)}fit(t,e){for(let s=0;s<t.length;s++)this.add(t[s],e[s])}predict(){for(;;){const t=[];for(let e=0;e<this._p.length;e++)if(null!=this._c[e]){let s=0;const r=this._near_points(this._p[e]);for(const i of r)if(null==i.category&&(i.d<(t[i.idx]?.d??1/0)&&(t[i.idx]={d:i.d,category:this._c[e]}),++s>=this._orgk))break}if(0===t.length)break;for(let e=0;e<this._p.length;e++)t[e]&&(this._c[e]=t[e].category)}return this._c}}