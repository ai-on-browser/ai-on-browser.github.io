var _=Object.defineProperty;var d=(o,e)=>_(o,"name",{value:e,configurable:!0});class l{static{d(this,"KNNBase")}constructor(e=5,t="euclid"){if(this._p=[],this._c=[],this._k=e,this._metric=t,typeof this._metric=="function")this._d=this._metric;else switch(this._metric){case"euclid":this._d=(s,i)=>Math.sqrt(s.reduce((r,n,c)=>r+(n-i[c])**2,0));break;case"manhattan":this._d=(s,i)=>s.reduce((r,n,c)=>r+Math.abs(n-i[c]),0);break;case"chebyshev":this._d=(s,i)=>Math.max(...s.map((r,n)=>Math.abs(r-i[n])));break;case"minkowski":this._dp=2,this._d=(s,i)=>Math.pow(s.reduce((r,n,c)=>r+(n-i[c])**this._dp,0),1/this._dp);break}}_near_points(e){const t=[];return this._p.forEach((s,i)=>{const r=this._d(e,s);if(t.length<this._k||r<t[this._k-1].d){t.length>=this._k&&t.pop(),t.push({d:r,category:this._c[i],idx:i});for(let n=t.length-1;n>0;n--)t[n-1].d>t[n].d&&([t[n],t[n-1]]=[t[n-1],t[n]])}}),t}_add(e,t){this._p.push(e),this._c.push(t)}}export class KNN extends l{static{d(this,"KNN")}constructor(e=5,t="euclid"){super(e,t)}add(e,t){super._add(e,t)}fit(e,t){for(let s=0;s<e.length;s++)this.add(e[s],t[s])}predict(e){return e.map(t=>{const s=this._near_points(t),i={};s.forEach(h=>{let a=h.category;i[a]?(i[a].count+=1,i[a].min_d=Math.min(i[a].min_d,h.d)):i[a]={category:a,count:1,min_d:h.d}});let r=0,n=-1,c=null;for(let h of Object.keys(i))(r<i[h].count||r===i[h].count&&i[h].min_d<n)&&(r=i[h].count,n=i[h].min_d,c=i[h].category);return c})}}export class KNNRegression extends l{static{d(this,"KNNRegression")}constructor(e=5,t="euclid"){super(e,t)}add(e,t){super._add(e,t)}fit(e,t){for(let s=0;s<e.length;s++)this.add(e[s],t[s])}predict(e){return e.map(t=>{const s=this._near_points(t);return s.reduce((i,r)=>i+r.category,0)/s.length})}}export class KNNAnomaly extends l{static{d(this,"KNNAnomaly")}constructor(e=5,t="euclid"){super(e,t)}add(e){super._add(e)}fit(e){for(let t=0;t<e.length;t++)this.add(e[t])}predict(e){return e.map(t=>{const s=this._near_points(t);return s[s.length-1].d})}}export class KNNDensityEstimation extends l{static{d(this,"KNNDensityEstimation")}constructor(e=5,t="euclid"){super(e,t)}add(e){super._add(e)}fit(e){for(let t=0;t<e.length;t++)this.add(e[t])}_logGamma(e){let t=0;if(Number.isInteger(e))for(let s=2;s<e;s++)t+=Math.log(s);else{const s=e-.5;t=Math.log(Math.sqrt(Math.PI))-Math.log(2)*s;for(let i=2*s-1;i>0;i-=2)t+=Math.log(i)}return t}predict(e){return e.map(t=>{const s=this._near_points(t),i=s[s.length-1].d,r=t.length,n=this._logGamma(r/2+1)-r/2*Math.log(Math.PI)-r*Math.log(i);return Math.exp(n)*this._k/this._p.length})}}export class SemiSupervisedKNN extends l{static{d(this,"SemiSupervisedKNN")}constructor(e=5,t="euclid"){super(e,t),this._k=1/0,this._orgk=e}add(e,t){super._add(e,t)}fit(e,t){for(let s=0;s<e.length;s++)this.add(e[s],t[s])}predict(){for(;;){const e=[];for(let t=0;t<this._p.length;t++)if(this._c[t]!=null){let s=0;const i=this._near_points(this._p[t]);for(const r of i)if(r.category==null&&(r.d<(e[r.idx]?.d??1/0)&&(e[r.idx]={d:r.d,category:this._c[t]}),++s>=this._orgk))break}if(e.length===0)break;for(let t=0;t<this._p.length;t++)e[t]&&(this._c[t]=e[t].category)}return this._c}}
