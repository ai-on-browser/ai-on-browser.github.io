export default class GrowingCellStructures{constructor(){this._nodes=[],this._edges=[],this._err=[],this._k=0,this._eps_b=.06,this._eps_n=.002,this._alpha=1,this._beta=5e-4,this._inserted_iteration=200}get size(){return this._nodes.length}_init(t){const s=t.length;this._d=t[0].length;const e=[];for(let i=0;i<Math.min(this._d+1,s);i++){const i=Math.floor(Math.random()*s);e.push(t[i].map((t=>t*Math.sqrt(-2*Math.log(Math.random()))*Math.cos(2*Math.PI*Math.random()))))}this._nodes=e,this._edges=e.map((t=>Array(e.length).fill(1))),this._err=Array(e.length).fill(0)}_distance(t,s){return t.reduce(((t,e,i)=>t+(e-s[i])**2),0)}_topological_neighbor(t){const s=[],e=[t];for(;e.length>0;){const t=e.pop();if(!(s.indexOf(t)>=0)){s.push(t);for(let s=0;s<this._edges[t].length;s++)this._connected(t,s)&&e.push(s)}}return s}_connected(t,s){return Number.isFinite(this._edges[t][s])}update(t){const s=this._nodes.map(((s,e)=>[this._distance(t,s),e]));s.sort(((t,s)=>t[0]-s[0]));const e=s[0][1];this._err[e]+=s[0][0];const i=this._topological_neighbor(e);s.sort(((t,s)=>t[1]-s[1]));for(let s=0;s<i.length;s++){const h=this._nodes[i[s]];for(let n=0;n<h.length;n++){const o=i[s]===e?this._eps_b:this._eps_n;h[n]+=(t[n]-h[n])*o}}if(this._k++,this._k%this._inserted_iteration==0){const t=this._err.map(((t,s)=>[t,s]));t.sort(((t,s)=>s[0]-t[0]));const s=t[0][1];let e=-1,i=1/0;for(let t=0;t<this._nodes.length;t++){if(t===s)continue;const h=this._distance(this._nodes[t],this._nodes[s]);h<i&&(i=h,e=t)}const h=this._nodes[e].map(((t,e)=>(t+this._nodes[s][e])/2));this._nodes.push(h),this._edges[s][e]=this._edges[e][s]=null;const n=[];for(let t=0;t<this._nodes.length;t++)this._connected(s,t)&&this._connected(e,t)&&(n[t]=1);n[s]=n[e]=1,this._edges.push(n);const o=n.reduce(((t,s)=>t+Number.isFinite(s)?1:0),0);let r=0;for(let t=0;t<n.length;t++)Number.isFinite(n[t])&&(this._err[t]-=this._alpha/o*this._err[t],r+=this._err[t]);this._err.push(r/o)}this._err=this._err.map((t=>t-t*this._beta))}fit(t){0===this._nodes.length&&this._init(t);for(let s=0;s<t.length;s++)this.update(t[s])}predict(t){if(0!==this._nodes.length)return t.map((t=>{let s=1/0,e=-1;for(let i=0;i<this._nodes.length;i++){const h=this._distance(this._nodes[i],t);h<s&&(s=h,e=i)}return e}))}}