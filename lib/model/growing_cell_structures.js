export default class GrowingCellStructures{constructor(){this._nodes=[],this._edges=[],this._err=[],this._k=0,this._eps_b=.06,this._eps_n=.002,this._alpha=1,this._beta=5e-4,this._inserted_iteration=200}get size(){return this._nodes.length}_init(t){const e=t.length;this._d=t[0].length;const s=[];for(let i=0;i<Math.min(this._d+1,e);i++){const i=Math.floor(Math.random()*e);s.push(t[i].map((t=>t*Math.sqrt(-2*Math.log(Math.random()))*Math.cos(2*Math.PI*Math.random()))))}this._nodes=s,this._edges=s.map((()=>Array(s.length).fill(1))),this._err=Array(s.length).fill(0)}_distance(t,e){return t.reduce(((t,s,i)=>t+(s-e[i])**2),0)}_topological_neighbor(t){const e=[],s=[t];for(;s.length>0;){const t=s.pop();if(!(e.indexOf(t)>=0)){e.push(t);for(let e=0;e<this._edges[t].length;e++)this._connected(t,e)&&s.push(e)}}return e}_connected(t,e){return Number.isFinite(this._edges[t][e])}update(t){const e=this._nodes.map(((e,s)=>[this._distance(t,e),s]));e.sort(((t,e)=>t[0]-e[0]));const s=e[0][1];this._err[s]+=e[0][0];const i=this._topological_neighbor(s);e.sort(((t,e)=>t[1]-e[1]));for(let e=0;e<i.length;e++){const h=this._nodes[i[e]];for(let n=0;n<h.length;n++){const r=i[e]===s?this._eps_b:this._eps_n;h[n]+=(t[n]-h[n])*r}}if(this._k++,this._k%this._inserted_iteration==0){const t=this._err.map(((t,e)=>[t,e]));t.sort(((t,e)=>e[0]-t[0]));const e=t[0][1];let s=-1,i=1/0;for(let t=0;t<this._nodes.length;t++){if(t===e)continue;const h=this._distance(this._nodes[t],this._nodes[e]);h<i&&(i=h,s=t)}const h=this._nodes[s].map(((t,s)=>(t+this._nodes[e][s])/2));this._nodes.push(h),this._edges[e][s]=this._edges[s][e]=null;const n=[];for(let t=0;t<this._nodes.length;t++)this._connected(e,t)&&this._connected(s,t)&&(n[t]=1);n[e]=n[s]=1,this._edges.push(n);const r=n.reduce(((t,e)=>t+Number.isFinite(e)?1:0),0);let o=0;for(let t=0;t<n.length;t++)Number.isFinite(n[t])&&(this._err[t]-=this._alpha/r*this._err[t],o+=this._err[t]);this._err.push(o/r)}this._err=this._err.map((t=>t-t*this._beta))}fit(t){0===this._nodes.length&&this._init(t);for(let e=0;e<t.length;e++)this.update(t[e])}predict(t){if(0===this._nodes.length)throw new Error("Call fit before predict.");return t.map((t=>{let e=1/0,s=-1;for(let i=0;i<this._nodes.length;i++){const h=this._distance(this._nodes[i],t);h<e&&(e=h,s=i)}return s}))}}