var u=Object.defineProperty;var f=(c,n)=>u(c,"name",{value:n,configurable:!0});export default class m{static{f(this,"GrowingCellStructures")}constructor(){this._nodes=[],this._edges=[],this._err=[],this._k=0,this._eps_b=.06,this._eps_n=.002,this._alpha=1,this._beta=5e-4,this._inserted_iteration=200}get size(){return this._nodes.length}_init(n){const i=n.length;this._d=n[0].length;const h=[];for(let r=0;r<Math.min(this._d+1,i);r++){const t=Math.floor(Math.random()*i);h.push(n[t].map(s=>s*Math.sqrt(-2*Math.log(Math.random()))*Math.cos(2*Math.PI*Math.random())))}this._nodes=h,this._edges=h.map(()=>Array(h.length).fill(1)),this._err=Array(h.length).fill(0)}_distance(n,i){return n.reduce((h,r,t)=>h+(r-i[t])**2,0)}_topological_neighbor(n){const i=[],h=[n];for(;h.length>0;){const r=h.pop();if(!i.includes(r)){i.push(r);for(let t=0;t<this._edges[r].length;t++)this._connected(r,t)&&h.push(t)}}return i}_connected(n,i){return Number.isFinite(this._edges[n][i])}update(n){const i=this._nodes.map((t,s)=>[this._distance(n,t),s]);i.sort((t,s)=>t[0]-s[0]);const h=i[0][1];this._err[h]+=i[0][0];const r=this._topological_neighbor(h);i.sort((t,s)=>t[1]-s[1]);for(let t=0;t<r.length;t++){const s=this._nodes[r[t]];for(let o=0;o<s.length;o++){const d=r[t]===h?this._eps_b:this._eps_n;s[o]+=(n[o]-s[o])*d}}if(this._k++,this._k%this._inserted_iteration===0){const t=this._err.map((e,_)=>[e,_]);t.sort((e,_)=>_[0]-e[0]);const s=t[0][1];let o=-1,d=1/0;for(let e=0;e<this._nodes.length;e++){if(e===s)continue;const _=this._distance(this._nodes[e],this._nodes[s]);_<d&&(d=_,o=e)}const p=this._nodes[o].map((e,_)=>(e+this._nodes[s][_])/2);this._nodes.push(p),this._edges[s][o]=this._edges[o][s]=null;const l=[];for(let e=0;e<this._nodes.length;e++)this._connected(s,e)&&this._connected(o,e)&&(l[e]=1);l[s]=l[o]=1,this._edges.push(l);const a=l.reduce((e,_)=>e+Number.isFinite(_)?1:0,0);let g=0;for(let e=0;e<l.length;e++)Number.isFinite(l[e])&&(this._err[e]-=this._alpha/a*this._err[e],g+=this._err[e]);this._err.push(g/a)}this._err=this._err.map(t=>t-t*this._beta)}fit(n){this._nodes.length===0&&this._init(n);for(let i=0;i<n.length;i++)this.update(n[i])}predict(n){if(this._nodes.length===0)throw new Error("Call fit before predict.");return n.map(i=>{let h=1/0,r=-1;for(let t=0;t<this._nodes.length;t++){const s=this._distance(this._nodes[t],i);s<h&&(h=s,r=t)}return r})}}
