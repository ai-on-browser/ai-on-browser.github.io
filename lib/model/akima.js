export default class AkimaInterpolation{constructor(t=!1){this._modified=t}fit(t,s){const h=t.length,i=t.map(((t,h)=>[t,s[h]]));i.sort(((t,s)=>t[0]-s[0])),this._x=i.map((t=>t[0])),this._y=i.map((t=>t[1])),this._x1=this._x[0]+this._x[1]-this._x[2],this._x0=2*this._x[0]-this._x[2];const _=(this._y[2]-this._y[1])/(this._x[2]-this._x[1]),x=(this._y[1]-this._y[0])/(this._x[1]-this._x[0]);this._y1=this._y[0]-(this._x[0]-this._x1)*(2*x-_),this._y0=this._y1-(this._x1-this._x0)*(3*x-2*_),this._xn0=this._x[h-1]+this._x[h-2]-this._x[h-3],this._xn1=2*this._x[h-1]-this._x[h-3];const a=(this._y[h-3]-this._y[h-2])/(this._x[h-3]-this._x[h-2]),n=(this._y[h-2]-this._y[h-1])/(this._x[h-2]-this._x[h-1]);this._yn0=this._y[h-1]-(this._xn0-this._x[h-1])*(2*n-a),this._yn1=this._y1-(this._xn1-this._xn0)*(3*n-2*a)}predict(t){const s=this._x.length,h=this._x,i=this._y;return t.map((t=>{if(t<=h[0])return i[0];if(t>=h[s-1])return i[s-1];let _=1;for(;t>h[_];_++);if(t===h[_])return i[_];const x=[1===_?this._x0:2===_?this._x1:h[_-3],1===_?this._x1:h[_-2],h[_-1],h[_],_===s-1?this._xn0:h[_+1],_===s-1?this._xn1:_===s-2?this._xn0:h[_+2]],a=[1===_?this._y0:2===_?this._y1:i[_-3],1===_?this._y1:i[_-2],i[_-1],i[_],_===s-1?this._yn0:i[_+1],_===s-1?this._yn1:_===s-2?this._yn0:i[_+2]],n=[];for(let t=0;t<5;t++)n[t]=(a[t+1]-a[t])/(x[t+1]-x[t]);let y,r;this._modified?(y=(Math.abs(n[1]-n[0])+Math.abs(n[1]+n[0])/2)/(Math.abs(n[3]-n[2])+Math.abs(n[3]+n[2])/2),r=(Math.abs(n[2]-n[1])+Math.abs(n[2]+n[1])/2)/(Math.abs(n[4]-n[3])+Math.abs(n[4]+n[3])/2)):(y=Math.abs(n[1]-n[0])/Math.abs(n[3]-n[2]),r=Math.abs(n[2]-n[1])/Math.abs(n[4]-n[3]));const e=(n[1]-n[2])/(1+y),o=(n[3]-n[2])/(1+r);return a[2]+(e+n[2])*(t-x[2])+-1*(2*e+o)/(x[3]-x[2])*(t-x[2])**2+(e+o)/(x[3]-x[2])**2*(t-x[2])**3}))}}