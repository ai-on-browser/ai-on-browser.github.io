var A=Object.defineProperty;var S=(w,e)=>A(w,"name",{value:e,configurable:!0});import q from"../util/matrix.js";const y={gaussian:S(({s:w=1})=>(e,r)=>Math.exp(-(e.reduce((s,a,f)=>s+(a-r[f])**2,0)**2)/w**2),"gaussian"),polynomial:S(({d:w=2})=>(e,r)=>(1+e.reduce((s,a,f)=>s+a*r[f]))**w,"polynomial")};export default class B{static{S(this,"BPA")}constructor(e=1,r=10,s="simple",a="gaussian"){this._c=e,this._b=r,this._version=s,typeof a=="function"?this._kernel=a:(typeof a=="string"&&(a={name:a}),this._kernel=y[a.name](a)),this._sv=[],this._nn=1}fit(e,r){for(let s=0;s<e.length;s++){let a=0;for(let h=0;h<this._sv.length;h++){const k=this._sv[h];a+=k.a*this._kernel(e[s],k.x)}const f=Math.max(0,1-r[s]*a);if(f===0)continue;const K=r[s]*Math.min(this._c,f/e[s].reduce((h,k)=>h+k**2,0));if(this._sv.length<this._b){this._sv.push({x:e[s],a:K});continue}if(this._version==="simple"){const h=this._kernel(e[s],e[s]),k=Math.min(this._c,f/h);let g=K**2*h/2+this._c*f,u=-1,i=-1;for(let t=0;t<this._sv.length;t++){const l=this._sv[t],_=this._kernel(l.x,e[s]),o=l.a*_/h+k*r[s],c=a-l.a*_+o*h,m=(l.a**2*this._kernel(l.x,l.x)+o**2*h-2*l.a*o*_)/2+this._c*Math.max(0,1-r[s]*c);m<g&&(g=m,u=t,i=o)}u>=0&&(this._sv.splice(u,1),this._sv.push({x:e[s],a:i}))}else if(this._version==="projecting"){const h=new q(this._sv.length+1,this._sv.length+1);for(let i=0;i<this._sv.length;i++){h.set(i,i,this._kernel(this._sv[i].x,this._sv[i].x));for(let l=0;l<i;l++){const _=this._kernel(this._sv[i].x,this._sv[l].x);h.set(i,l,_),h.set(l,i,_)}const t=this._kernel(this._sv[i].x,e[s]);h.set(i,this._sv.length,t),h.set(this._sv.length,i,t)}h.set(this._sv.length,this._sv.length,this._kernel(e[s],e[s]));let k=1/0,g=-1,u=null;for(let i=0;i<h.rows;i++){const t=h.copy();t.remove(i,0);const l=t.col(i),_=t.col(this._sv.length);t.remove(i,1);const o=t.inv(),c=i<this._sv.length?this._sv[i]:{x:e[s],a:K},m=o.dot(l),b=o.dot(_),D=Math.min(this._c,Math.max(0,(1-r[s]*(a-c.a*h.at(i,this._sv.length)+c.a*m.tDot(_).toScaler()))/b.tDot(_).toScaler())),d=q.mult(m,c.a);d.add(q.mult(b,r[s]*D));let M=c.a**2*h.at(i,i);for(let v=0;v<t.rows;v++){M+=d.at(v,0)**2*t.at(v,v);for(let p=0;p<v;p++)M+=2*d.at(v,0)*d.at(p,0)*t.at(v,p);M-=2*c.a*d.at(v,0)*l.at(v,0)}M<k&&(k=M,g=i,u=d)}if(0<=g&&g<this._sv.length){this._sv.splice(g,1),this._sv.push({x:e[s],a:0});for(let i=0;i<this._sv.length;i++)this._sv[i].a+=u.at(i,0)}}else if(this._version==="nn"){const h=Array.from({length:this._sv.length+1},()=>[]);for(let t=0;t<this._sv.length;t++){const l=this._sv[t];h[t][t]=[1/0,-1];for(let _=0;_<t&&_<this._sv.length;_++){const o=l.x.reduce((c,m,b)=>c+(m-this._sv[_].x[b])**2,0);h[t][_]=[o,_],h[_][t]=[o,t]}h[this._sv.length][t]=[e[s].reduce((_,o,c)=>_+(o-l.x[c])**2,0),t]}let k=1/0,g=-1,u=null,i=[];for(let t=0;t<=this._sv.length;t++){const l=t<this._sv.length?this._sv[t]:{x:e[s],a:K};h[t].sort((n,x)=>n[0]-x[0]);const _=h[t].map(n=>n[1]),o=new q(this._nn+1,this._nn+1),c=new q(this._nn+1,1);for(let n=0;n<this._nn;n++){o.set(n,n,this._kernel(this._sv[_[n]].x,this._sv[_[n]].x));for(let j=0;j<n;j++){const I=this._kernel(this._sv[_[n]].x,this._sv[_[j]].x);o.set(n,j,I),o.set(j,n,I)}const x=this._kernel(this._sv[_[n]].x,e[s]);o.set(n,this._nn,x),o.set(this._nn,n,x),c.set(n,0,this._kernel(l.x,this._sv[_[n]].x))}o.set(this._nn,this._nn,this._kernel(e[s],e[s])),c.set(this._nn,0,this._kernel(l.x,e[s]));const m=o.col(1),b=o.inv(),D=b.dot(c),d=b.dot(m),M=Math.min(this._c,Math.max(0,(1-r[s]*(a-l.a*c.at(1,0)+l.a*D.tDot(m).toScaler()))/d.tDot(m).toScaler())),v=q.mult(D,l.a);v.add(q.mult(d,r[s]*M));let p=l.a**2*this._kernel(l.x,l.x);for(let n=0;n<o.rows;n++){p+=v.at(n,0)**2*o.at(n,n);for(let x=0;x<n;x++)p+=2*v.at(n,0)*v.at(x,0)*o.at(n,x);p-=2*l.a*v.at(n,0)*c.at(n,0)}p<k&&(k=p,g=t,u=v,i=_.slice(0,this._nn))}if(0<=g&&g<this._sv.length){this._sv.splice(g,1),this._sv.push({x:e[s],a:u.at(this._nn,0)});for(let t=0;t<i.length;t++)this._sv[i[t]].a+=u.at(t,0)}}}}predict(e){const r=[];for(let s=0;s<e.length;s++){let a=0;for(let f=0;f<this._sv.length;f++){const K=this._sv[f];a+=K.a*this._kernel(e[s],K.x)}r[s]=a<0?-1:1}return r}}
