import Matrix from"../util/matrix.js";export default class BPA{constructor(t=1,s=10,e="simple",i="gaussian"){if(this._c=t,this._b=s,this._version=e,"function"==typeof i)this._kernel=i;else switch(i){case"gaussian":this._s=1,this._kernel=(t,s)=>Math.exp(-(t.reduce(((t,e,i)=>t+(e-s[i])**2),0)**2)/this._s**2);break;case"polynomial":this._d=2,this._kernel=(t,s)=>(1+t.reduce(((t,e,i)=>t+e*s[i])))**this._d}this._sv=[],this._nn=1}fit(t,s){for(let e=0;e<t.length;e++){let i=0;for(let s=0;s<this._sv.length;s++){const h=this._sv[s];i+=h.a*this._kernel(t[e],h.x)}const h=Math.max(0,1-s[e]*i);if(0===h)continue;const n=s[e]*Math.min(this._c,h/t[e].reduce(((t,s)=>t+s**2),0));if(this._sv.length<this._b)this._sv.push({x:t[e],a:n});else if("simple"===this._version){const l=this._kernel(t[e],t[e]),_=Math.min(this._c,h/l);let a=n**2*l/2+this._c*h,r=-1,o=-1;for(let h=0;h<this._sv.length;h++){const n=this._sv[h],v=this._kernel(n.x,t[e]),c=n.a*v/l+_*s[e],x=i-n.a*v+c*l,f=(n.a**2*this._kernel(n.x,n.x)+c**2*l-2*n.a*c*v)/2+this._c*Math.max(0,1-s[e]*x);f<a&&(a=f,r=h,o=c)}r>=0&&(this._sv.splice(r,1),this._sv.push({x:t[e],a:o}))}else if("projecting"===this._version){const h=new Matrix(this._sv.length+1,this._sv.length+1);for(let s=0;s<this._sv.length;s++){h.set(s,s,this._kernel(this._sv[s].x,this._sv[s].x));for(let t=0;t<s;t++){const e=this._kernel(this._sv[s].x,this._sv[t].x);h.set(s,t,e),h.set(t,s,e)}const i=this._kernel(this._sv[s].x,t[e]);h.set(s,this._sv.length,i),h.set(this._sv.length,s,i)}h.set(this._sv.length,this._sv.length,this._kernel(t[e],t[e]));let l=1/0,_=-1,a=null;for(let r=0;r<h.rows;r++){const o=h.copy();o.remove(r,0);const v=o.col(r),c=o.col(this._sv.length);o.remove(r,1);const x=o.inv(),f=r<this._sv.length?this._sv[r]:{x:t[e],a:n},g=x.dot(v),u=x.dot(c),m=Math.min(this._c,Math.max(0,(1-s[e]*(i-f.a*h.at(r,this._sv.length)+f.a*g.tDot(c).toScaler()))/u.tDot(c).toScaler())),k=Matrix.mult(g,f.a);k.add(Matrix.mult(u,s[e]*m));let p=f.a**2*h.at(r,r);for(let t=0;t<o.rows;t++){p+=k.at(t,0)**2*o.at(t,t);for(let s=0;s<t;s++)p+=2*k.at(t,0)*k.at(s,0)*o.at(t,s);p-=2*f.a*k.at(t,0)*v.at(t,0)}p<l&&(l=p,_=r,a=k)}if(0<=_&&_<this._sv.length){this._sv.splice(_,1),this._sv.push({x:t[e],a:0});for(let t=0;t<this._sv.length;t++)this._sv[t].a+=a.at(t,0)}}else if("nn"===this._version){const h=Array.from({length:this._sv.length+1},(()=>[]));for(let s=0;s<this._sv.length;s++){const i=this._sv[s];h[s][s]=[1/0,-1];for(let t=0;t<s&&t<this._sv.length;t++){const e=i.x.reduce(((s,e,i)=>s+(e-this._sv[t].x[i])**2),0);h[s][t]=[e,t],h[t][s]=[e,s]}h[this._sv.length][s]=[t[e].reduce(((t,s,e)=>t+(s-i.x[e])**2),0),s]}let l=1/0,_=-1,a=null,r=[];for(let o=0;o<=this._sv.length;o++){const v=o<this._sv.length?this._sv[o]:{x:t[e],a:n};h[o].sort(((t,s)=>t[0]-s[0]));const c=h[o].map((t=>t[1])),x=new Matrix(this._nn+1,this._nn+1),f=new Matrix(this._nn+1,1);for(let s=0;s<this._nn;s++){x.set(s,s,this._kernel(this._sv[c[s]].x,this._sv[c[s]].x));for(let t=0;t<s;t++){const e=this._kernel(this._sv[c[s]].x,this._sv[c[t]].x);x.set(s,t,e),x.set(t,s,e)}const i=this._kernel(this._sv[c[s]].x,t[e]);x.set(s,this._nn,i),x.set(this._nn,s,i),f.set(s,0,this._kernel(v.x,this._sv[c[s]].x))}x.set(this._nn,this._nn,this._kernel(t[e],t[e])),f.set(this._nn,0,this._kernel(v.x,t[e]));const g=x.col(1),u=x.inv(),m=u.dot(f),k=u.dot(g),p=Math.min(this._c,Math.max(0,(1-s[e]*(i-v.a*f.at(1,0)+v.a*m.tDot(g).toScaler()))/k.tDot(g).toScaler())),d=Matrix.mult(m,v.a);d.add(Matrix.mult(k,s[e]*p));let M=v.a**2*this._kernel(v.x,v.x);for(let t=0;t<x.rows;t++){M+=d.at(t,0)**2*x.at(t,t);for(let s=0;s<t;s++)M+=2*d.at(t,0)*d.at(s,0)*x.at(t,s);M-=2*v.a*d.at(t,0)*f.at(t,0)}M<l&&(l=M,_=o,a=d,r=c.slice(0,this._nn))}if(0<=_&&_<this._sv.length){this._sv.splice(_,1),this._sv.push({x:t[e],a:a.at(this._nn,0)});for(let t=0;t<r.length;t++)this._sv[r[t]].a+=a.at(t,0)}}}}predict(t){const s=[];for(let e=0;e<t.length;e++){let i=0;for(let s=0;s<this._sv.length;s++){const h=this._sv[s];i+=h.a*this._kernel(t[e],h.x)}s[e]=i<0?-1:1}return s}}