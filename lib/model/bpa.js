var A=Object.defineProperty;var I=(D,l)=>A(D,"name",{value:l,configurable:!0});import q from"../util/matrix.js";export default class y{static{I(this,"BPA")}constructor(l=1,k=10,i="simple",a="gaussian"){if(this._c=l,this._b=k,this._version=i,typeof a=="function")this._kernel=a;else switch(typeof a=="string"&&(a={name:a}),a.name){case"gaussian":this._s=a.s??1,this._kernel=(g,m)=>Math.exp(-(g.reduce((e,v,f)=>e+(v-m[f])**2,0)**2)/this._s**2);break;case"polynomial":this._d=a.d??2,this._kernel=(g,m)=>(1+g.reduce((e,v,f)=>e+v*m[f]))**this._d;break}this._sv=[],this._nn=1}fit(l,k){for(let i=0;i<l.length;i++){let a=0;for(let e=0;e<this._sv.length;e++){const v=this._sv[e];a+=v.a*this._kernel(l[i],v.x)}const g=Math.max(0,1-k[i]*a);if(g===0)continue;const m=k[i]*Math.min(this._c,g/l[i].reduce((e,v)=>e+v**2,0));if(this._sv.length<this._b){this._sv.push({x:l[i],a:m});continue}if(this._version==="simple"){const e=this._kernel(l[i],l[i]),v=Math.min(this._c,g/e);let f=m**2*e/2+this._c*g,d=-1,s=-1;for(let t=0;t<this._sv.length;t++){const h=this._sv[t],_=this._kernel(h.x,l[i]),o=h.a*_/e+v*k[i],r=a-h.a*_+o*e,u=(h.a**2*this._kernel(h.x,h.x)+o**2*e-2*h.a*o*_)/2+this._c*Math.max(0,1-k[i]*r);u<f&&(f=u,d=t,s=o)}d>=0&&(this._sv.splice(d,1),this._sv.push({x:l[i],a:s}))}else if(this._version==="projecting"){const e=new q(this._sv.length+1,this._sv.length+1);for(let s=0;s<this._sv.length;s++){e.set(s,s,this._kernel(this._sv[s].x,this._sv[s].x));for(let h=0;h<s;h++){const _=this._kernel(this._sv[s].x,this._sv[h].x);e.set(s,h,_),e.set(h,s,_)}const t=this._kernel(this._sv[s].x,l[i]);e.set(s,this._sv.length,t),e.set(this._sv.length,s,t)}e.set(this._sv.length,this._sv.length,this._kernel(l[i],l[i]));let v=1/0,f=-1,d=null;for(let s=0;s<e.rows;s++){const t=e.copy();t.remove(s,0);const h=t.col(s),_=t.col(this._sv.length);t.remove(s,1);const o=t.inv(),r=s<this._sv.length?this._sv[s]:{x:l[i],a:m},u=o.dot(h),b=o.dot(_),j=Math.min(this._c,Math.max(0,(1-k[i]*(a-r.a*e.at(s,this._sv.length)+r.a*u.tDot(_).toScaler()))/b.tDot(_).toScaler())),x=q.mult(u,r.a);x.add(q.mult(b,k[i]*j));let M=r.a**2*e.at(s,s);for(let c=0;c<t.rows;c++){M+=x.at(c,0)**2*t.at(c,c);for(let p=0;p<c;p++)M+=2*x.at(c,0)*x.at(p,0)*t.at(c,p);M-=2*r.a*x.at(c,0)*h.at(c,0)}M<v&&(v=M,f=s,d=x)}if(0<=f&&f<this._sv.length){this._sv.splice(f,1),this._sv.push({x:l[i],a:0});for(let s=0;s<this._sv.length;s++)this._sv[s].a+=d.at(s,0)}}else if(this._version==="nn"){const e=Array.from({length:this._sv.length+1},()=>[]);for(let t=0;t<this._sv.length;t++){const h=this._sv[t];e[t][t]=[1/0,-1];for(let _=0;_<t&&_<this._sv.length;_++){const o=h.x.reduce((r,u,b)=>r+(u-this._sv[_].x[b])**2,0);e[t][_]=[o,_],e[_][t]=[o,t]}e[this._sv.length][t]=[l[i].reduce((_,o,r)=>_+(o-h.x[r])**2,0),t]}let v=1/0,f=-1,d=null,s=[];for(let t=0;t<=this._sv.length;t++){const h=t<this._sv.length?this._sv[t]:{x:l[i],a:m};e[t].sort((n,K)=>n[0]-K[0]);const _=e[t].map(n=>n[1]),o=new q(this._nn+1,this._nn+1),r=new q(this._nn+1,1);for(let n=0;n<this._nn;n++){o.set(n,n,this._kernel(this._sv[_[n]].x,this._sv[_[n]].x));for(let w=0;w<n;w++){const S=this._kernel(this._sv[_[n]].x,this._sv[_[w]].x);o.set(n,w,S),o.set(w,n,S)}const K=this._kernel(this._sv[_[n]].x,l[i]);o.set(n,this._nn,K),o.set(this._nn,n,K),r.set(n,0,this._kernel(h.x,this._sv[_[n]].x))}o.set(this._nn,this._nn,this._kernel(l[i],l[i])),r.set(this._nn,0,this._kernel(h.x,l[i]));const u=o.col(1),b=o.inv(),j=b.dot(r),x=b.dot(u),M=Math.min(this._c,Math.max(0,(1-k[i]*(a-h.a*r.at(1,0)+h.a*j.tDot(u).toScaler()))/x.tDot(u).toScaler())),c=q.mult(j,h.a);c.add(q.mult(x,k[i]*M));let p=h.a**2*this._kernel(h.x,h.x);for(let n=0;n<o.rows;n++){p+=c.at(n,0)**2*o.at(n,n);for(let K=0;K<n;K++)p+=2*c.at(n,0)*c.at(K,0)*o.at(n,K);p-=2*h.a*c.at(n,0)*r.at(n,0)}p<v&&(v=p,f=t,d=c,s=_.slice(0,this._nn))}if(0<=f&&f<this._sv.length){this._sv.splice(f,1),this._sv.push({x:l[i],a:d.at(this._nn,0)});for(let t=0;t<s.length;t++)this._sv[s[t]].a+=d.at(t,0)}}}}predict(l){const k=[];for(let i=0;i<l.length;i++){let a=0;for(let g=0;g<this._sv.length;g++){const m=this._sv[g];a+=m.a*this._kernel(l[i],m.x)}k[i]=a<0?-1:1}return k}}
