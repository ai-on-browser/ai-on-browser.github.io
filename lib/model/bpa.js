var A=Object.defineProperty;var I=(D,_)=>A(D,"name",{value:_,configurable:!0});import q from"../util/matrix.js";export default class B{static{I(this,"BPA")}constructor(_=1,f=10,e="simple",k="gaussian"){if(this._c=_,this._b=f,this._version=e,typeof k=="function")this._kernel=k;else switch(k){case"gaussian":this._s=1,this._kernel=(g,u)=>Math.exp(-(g.reduce((i,c,v)=>i+(c-u[v])**2,0)**2)/this._s**2);break;case"polynomial":this._d=2,this._kernel=(g,u)=>(1+g.reduce((i,c,v)=>i+c*u[v]))**this._d;break}this._sv=[],this._nn=1}fit(_,f){for(let e=0;e<_.length;e++){let k=0;for(let i=0;i<this._sv.length;i++){const c=this._sv[i];k+=c.a*this._kernel(_[e],c.x)}const g=Math.max(0,1-f[e]*k);if(g===0)continue;const u=f[e]*Math.min(this._c,g/_[e].reduce((i,c)=>i+c**2,0));if(this._sv.length<this._b){this._sv.push({x:_[e],a:u});continue}if(this._version==="simple"){const i=this._kernel(_[e],_[e]),c=Math.min(this._c,g/i);let v=u**2*i/2+this._c*g,d=-1,s=-1;for(let t=0;t<this._sv.length;t++){const h=this._sv[t],l=this._kernel(h.x,_[e]),o=h.a*l/i+c*f[e],a=k-h.a*l+o*i,m=(h.a**2*this._kernel(h.x,h.x)+o**2*i-2*h.a*o*l)/2+this._c*Math.max(0,1-f[e]*a);m<v&&(v=m,d=t,s=o)}d>=0&&(this._sv.splice(d,1),this._sv.push({x:_[e],a:s}))}else if(this._version==="projecting"){const i=new q(this._sv.length+1,this._sv.length+1);for(let s=0;s<this._sv.length;s++){i.set(s,s,this._kernel(this._sv[s].x,this._sv[s].x));for(let h=0;h<s;h++){const l=this._kernel(this._sv[s].x,this._sv[h].x);i.set(s,h,l),i.set(h,s,l)}const t=this._kernel(this._sv[s].x,_[e]);i.set(s,this._sv.length,t),i.set(this._sv.length,s,t)}i.set(this._sv.length,this._sv.length,this._kernel(_[e],_[e]));let c=1/0,v=-1,d=null;for(let s=0;s<i.rows;s++){const t=i.copy();t.remove(s,0);const h=t.col(s),l=t.col(this._sv.length);t.remove(s,1);const o=t.inv(),a=s<this._sv.length?this._sv[s]:{x:_[e],a:u},m=o.dot(h),b=o.dot(l),j=Math.min(this._c,Math.max(0,(1-f[e]*(k-a.a*i.at(s,this._sv.length)+a.a*m.tDot(l).toScaler()))/b.tDot(l).toScaler())),x=q.mult(m,a.a);x.add(q.mult(b,f[e]*j));let M=a.a**2*i.at(s,s);for(let r=0;r<t.rows;r++){M+=x.at(r,0)**2*t.at(r,r);for(let p=0;p<r;p++)M+=2*x.at(r,0)*x.at(p,0)*t.at(r,p);M-=2*a.a*x.at(r,0)*h.at(r,0)}M<c&&(c=M,v=s,d=x)}if(0<=v&&v<this._sv.length){this._sv.splice(v,1),this._sv.push({x:_[e],a:0});for(let s=0;s<this._sv.length;s++)this._sv[s].a+=d.at(s,0)}}else if(this._version==="nn"){const i=Array.from({length:this._sv.length+1},()=>[]);for(let t=0;t<this._sv.length;t++){const h=this._sv[t];i[t][t]=[1/0,-1];for(let l=0;l<t&&l<this._sv.length;l++){const o=h.x.reduce((a,m,b)=>a+(m-this._sv[l].x[b])**2,0);i[t][l]=[o,l],i[l][t]=[o,t]}i[this._sv.length][t]=[_[e].reduce((l,o,a)=>l+(o-h.x[a])**2,0),t]}let c=1/0,v=-1,d=null,s=[];for(let t=0;t<=this._sv.length;t++){const h=t<this._sv.length?this._sv[t]:{x:_[e],a:u};i[t].sort((n,K)=>n[0]-K[0]);const l=i[t].map(n=>n[1]),o=new q(this._nn+1,this._nn+1),a=new q(this._nn+1,1);for(let n=0;n<this._nn;n++){o.set(n,n,this._kernel(this._sv[l[n]].x,this._sv[l[n]].x));for(let w=0;w<n;w++){const S=this._kernel(this._sv[l[n]].x,this._sv[l[w]].x);o.set(n,w,S),o.set(w,n,S)}const K=this._kernel(this._sv[l[n]].x,_[e]);o.set(n,this._nn,K),o.set(this._nn,n,K),a.set(n,0,this._kernel(h.x,this._sv[l[n]].x))}o.set(this._nn,this._nn,this._kernel(_[e],_[e])),a.set(this._nn,0,this._kernel(h.x,_[e]));const m=o.col(1),b=o.inv(),j=b.dot(a),x=b.dot(m),M=Math.min(this._c,Math.max(0,(1-f[e]*(k-h.a*a.at(1,0)+h.a*j.tDot(m).toScaler()))/x.tDot(m).toScaler())),r=q.mult(j,h.a);r.add(q.mult(x,f[e]*M));let p=h.a**2*this._kernel(h.x,h.x);for(let n=0;n<o.rows;n++){p+=r.at(n,0)**2*o.at(n,n);for(let K=0;K<n;K++)p+=2*r.at(n,0)*r.at(K,0)*o.at(n,K);p-=2*h.a*r.at(n,0)*a.at(n,0)}p<c&&(c=p,v=t,d=r,s=l.slice(0,this._nn))}if(0<=v&&v<this._sv.length){this._sv.splice(v,1),this._sv.push({x:_[e],a:d.at(this._nn,0)});for(let t=0;t<s.length;t++)this._sv[s[t]].a+=d.at(t,0)}}}}predict(_){const f=[];for(let e=0;e<_.length;e++){let k=0;for(let g=0;g<this._sv.length;g++){const u=this._sv[g];k+=u.a*this._kernel(_[e],u.x)}f[e]=k<0?-1:1}return f}}
