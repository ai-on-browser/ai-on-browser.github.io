var u=Object.defineProperty;var m=(o,i)=>u(o,"name",{value:i,configurable:!0});const y={gaussian:m(({s:o=1})=>(i,t)=>Math.exp(-(i.reduce((s,e,_)=>s+(e-t[_])**2,0)**2)/o**2),"gaussian"),polynomial:m(({d:o=2})=>(i,t)=>(1+i.reduce((s,e,_)=>s+e*t[_]))**o,"polynomial")};export default class x{static{m(this,"Forgetron")}constructor(i,t="gaussian"){this._b=i,typeof t=="function"?this._kernel=t:(typeof t=="string"&&(t={name:t}),this._kernel=y[t.name](t)),this._i=[],this._q=0,this._m=0,this._sigma=[]}fit(i,t){for(let s=0;s<i.length;s++){let e=0;for(let h=0;h<this._i.length;h++){const a=this._i[h];e+=this._sigma[h]*a.y*this._kernel(i[s],a.x)}if((e<0?-1:1)*t[s]<=0)if(this._m+=1,this._i.push({x:i[s],y:t[s]}),this._i.length<this._b)this._sigma.push(1);else{const h=this._i[0],a=this._sigma[0];let g=t[s]*this._kernel(h.x,i[s]);for(let f=0;f<this._i.length;f++){const p=this._i[f];g+=p.y*this._kernel(h.x,p.x)}g*=h.y;const l=a**2-2*a*g,r=2*a,c=this._q-15/32*this._m;let n=0;l===0?n=Math.max(0,Math.min(1,-c/r)):l>0?n=(-r+Math.sqrt(r**2-4*l*c))/(2*l):n=(-r-Math.sqrt(r**2-4*l*c))/(2*l),isNaN(n)&&(n=1),this._sigma.push(1),this._sigma=this._sigma.map(f=>f*n),this._q+=(a*n)**2+2*a*n*(1-n*g),this._i.shift(),this._sigma.shift()}}}predict(i){const t=[];for(let s=0;s<i.length;s++){let e=0;for(let _=0;_<this._i.length;_++){const h=this._i[_];e+=this._sigma[_]*h.y*this._kernel(i[s],h.x)}t[s]=e<0?-1:1}return t}}
