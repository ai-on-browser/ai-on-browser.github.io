import{RLEnvironmentBase}from"./base.js";const EMPTY=1,RED=2,WHITE=4,KING=8,RED2=10,WHITE2=12;export default class DraughtsRLEnvironment extends RLEnvironmentBase{constructor(){super(),this._size=[8,8],this._board=new DraughtsBoard(this._size,this._evaluation),this._reward={goal:1,step:1,fail:0}}static EMPTY=1;static RED=2;static WHITE=4;static KING=8;get actions(){const t=[];for(let s=0;s<this._size[0];s++)for(let e=0;e<this._size[1];e++)t.push(`${s}_${e}`);return[t]}get states(){const t=[];for(let s=0;s<this._size[0]*this._size[1]/2;s++)t.push([1,2,4]);return t}set reward(t){}set evaluation(t){this._evaluation=t}reset(){return super.reset(),this._board.reset(),this.state()}state(t){const s=[];for(let t=0;t<this._size[0];t++)for(let e=0;e<this._size[1];e++)s.push(this._board.at([t,e]));return s}step(t,s){super.step(t,s);return this.test(this.state,t,s)}test(t,s,e){return{state:[],reward:0,done:!1}}}class DraughtsBoard{constructor(t,s){this._evaluator=s,this._size=t,this.reset()}get size(){return this._size}get count(){const t={};for(let s=0;s<this._size[0];s++)for(let e=0;e<this._size[1];e++)t[this._board[s][e]]||(t[this._board[s][e]]=0),t[this._board[s][e]]++;return{red:t[2]||0,white:t[4]||0,redking:t[10]||0,whiteking:t[12]||0}}get finish(){return 0===this.choices(2).length||0===this.choices(4).length}get winner(){return 0===this.choices(2).length?4:0===this.choices(4).length?2:null}nextTurn(t){return 4===t?2:4}copy(){const t=new DraughtsBoard(this._size,this._evaluator);for(let s=0;s<this._size[0];s++)for(let e=0;e<this._size[1];e++)t._board[s][e]=this._board[s][e];return t}score(t){if(this._evaluator)return this._evaluator(this,t);const s=this.count;return 2===t?s.red+2*s.redking-s.white-4*s.whiteking:s.white+2*s.whiteking-s.red-4*s.redking}at(t){return this._board[t[0]][t[1]]}set(t,s){let e=this._board[t.from[0]][t.from[1]];this._board[t.from[0]][t.from[1]]=1;for(const[s,e]of t.jump)this._board[s][e]=1;const r=t.path[t.path.length-1];return(2===s&&r[0]===this._size[0]-1||4===s&&0===r[0])&&(e|=8),this._board[r[0]][r[1]]=e,!0}reset(){this._board=[];for(let t=0;t<this._size[0];t++)this._board[t]=Array(this._size[1]).fill(1);for(let t=0;t<this._size[0];t++)for(let s=0;s<this._size[1];s++)t<3&&(t+s)%2==0?this._board[t][s]=2:this._size[0]-3<=t&&(t+s)%2==0&&(this._board[t][s]=4)}choices(t){const s=[];for(let e=0;e<this._size[0];e++)for(let r=0;r<this._size[1];r++)this._board[e][r]&t&&s.push(...this.allPath(e,r,t));return s.some((t=>t.jump.length>0))?s.filter((t=>t.jump.length>0)):s}allPath(t,s,e,r=!0){if(!(this._board[t][s]&e))return[];const i=(t,s)=>0<=t&&t<this._size[0]&&0<=s&&s<this._size[1],h=2===e?4:2,o=[];8&this._board[t][s]?o.push([1,1],[-1,1],[-1,-1],[1,-1]):2===e?o.push([1,1],[1,-1]):o.push([-1,1],[-1,-1]);const a=[];for(const[n,_]of o)if(i(t+n,s+_)&&(r&&1===this._board[t+n][s+_]&&a.push({from:[t,s],path:[[t+n,s+_]],jump:[]}),this._board[t+n][s+_]&h&&i(t+2*n,s+2*_)&&1===this._board[t+2*n][s+2*_])){const r=this.copy();r._board[t+2*n][s+2*_]=this._board[t][s],r._board[t][s]=1,r._board[t+n][s+_]=1,(2===e&&t*n*2==this._size[0]-1||4===e&&t*n*2==0)&&(r._board[t+2*n][s+2*_]|=8);const i=r.allPath(t+2*n,s+2*_,e,!1);if(0===i.length)a.push({from:[t,s],path:[[t+2*n,s+2*_]],jump:[[t+n,s+_]]});else for(const e of i)a.push({from:[t,s],path:[[t+2*n,s+2*_],...e.path],jump:[[t+n,s+_],...e.jump]})}return a}}