var g=Object.defineProperty;var p=(o,t)=>g(o,"name",{value:t,configurable:!0});import{RLRealRange as m,RLIntRange as u,RLEnvironmentBase as c}from"./base.js";export default class M extends c{static{p(this,"SmoothMazeRLEnvironment")}constructor(t,i){super(),this._width=t,this._height=i,this._points=[],this._map_resolution=[100,50],this._goal_size=[50,50],this._position=Array(2).fill(0),this._orient=0,this._velocity=10,this._rotate=5,this._max_step=3e3,this.__map=[];for(let s=0;s<this._map_resolution[0];s++)this.__map[s]=Array(this._map_resolution[1]);this._reward={step:-1,wall:-2,goal:200,fail:-100}}get actions(){return[[0,1,2,3]]}get states(){return[new m(0,this._width),new m(0,this._height),new u(0,359)]}get map(){for(let t=0;t<this._map_resolution[0];t++)this.__map[t].fill(0);return this._points.forEach(t=>{this.__map[t[0]][t[1]]=1-this.__map[t[0]][t[1]]}),this.__map[0][0]=0,this.__map[this._map_resolution[0]-1][this._map_resolution[1]-1]=0,this.__map}set reward(t){if(this._reward={step:-1,wall:-2,goal:200,fail:-100},t==="achieve"){const i=this;this._reward={get step(){return Math.sqrt(i._position[0]**2+i._position[1]**2)},wall:0,goal:0,fail:0}}}reset(){return super.reset(),this._position=Array(2).fill(0),this._position[0]=Math.random()*this._width/4,this._position[1]=Math.random()*this._height/4,this._orient=Math.random()*360,this.state()}state(){return[this._position[0],this._position[1],this._orient]}setState(t){this._position=[t[0],t[1]],this._orient=t[2]}test(t,i){let s=this._reward.step,[h,e,_]=t;const d=this.map,f=this._width/this._map_resolution[0],w=this._height/this._map_resolution[1],r=Math.cos(_/180*Math.PI)*this._velocity,a=Math.sin(_/180*Math.PI)*this._velocity;i[0]===0?(h+=r,e+=a):i[0]===1?(h-=r,e-=a):i[0]===2?_+=this._rotate:i[0]===3&&(_-=this._rotate),_=(_+360)%360,h<0||e<0||h>=this._width||e>=this._height?(s=this._reward.wall,[h,e,_]=t):d[Math.floor(h/f)][Math.floor(e/w)]!==0&&(s=this._reward.wall,[h,e,_]=t);const n=this._max_step&&this._max_step<=this.epoch,l=h>this._width-this._goal_size[0]&&e>this._height-this._goal_size[1]||n;return l&&(s=this._reward.goal),n&&(s=this._reward.fail),{state:[h,e,_],reward:s,done:l}}}
