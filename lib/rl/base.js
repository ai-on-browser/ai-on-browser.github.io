export class RLRealRange{constructor(t,s,e="equal"){this.min=t,this.max=s,this._space=e}toSpace(t){const s=[this.min];if("equal"===this._space){const e=(this.max-this.min)/t;for(let i=1;i<t;i++)s.push(this.min+i*e)}else if("log"===this._space){const e=t%2,i=Math.floor((t-1)/2);let n=this.max,h=this.min;const r=[];for(let t=0;t<i;t++)s.push(h/=3),r.push(n/=3);e||s.push(0);for(let t=0;t<i;t++)s.push(r[i-t-1])}return s.push(this.max),s}toArray(t){const s=this.toSpace(t);return s.slice(1).map(((t,e)=>(t+s[e])/2))}indexOf(t,s){if(t<=this.min)return 0;if(t>=this.max)return s-1;if("equal"===this._space)return Math.floor((t-this.min)/(this.max-this.min)*s);{const e=this.toSpace(s);for(let s=0;s<e.length-1;s++)if(t<e[s+1])return s;return e.length-1}}}export class RLIntRange{constructor(t,s){this.min=t,this.max=s}get length(){return this.max-this.min+1}toArray(t){const s=[];if(this.length<=t)for(let t=this.min;t<=this.max;s.push(t++));else{const e=(this.max-this.min)/(t-1);for(let i=0;i<t-1;i++)s[i]=this.min+Math.round(i*e);s.push(this.max)}return s}indexOf(t,s){return this.length<=s?Math.max(0,Math.min(this.length-1,Math.round(t-this.min))):t<=this.min?0:t>=this.max?s-1:Math.floor((t-this.min)/(this.max-this.min)*s)}}export class RLEnvironmentBase{constructor(){this._epoch=0}get epoch(){return this._epoch}set reward(t){}close(){}reset(){this._epoch=0}state(t){throw"Not implemented"}setState(t,s){throw"Not implemented"}step(t,s){const e=this.state(s),i=this.test(e,t,s);return i.invalid||(this._epoch++,this.setState(i.state,s)),i}test(t,s,e){throw"Not implemented"}sample_action(t){return this.actions.map((t=>Array.isArray(t)?t[Math.floor(Math.random()*t.length)]:t instanceof RLRealRange?Math.random()*(t.max-t.min)+t.min:void 0))}}export default class EmptyRLEnvironment extends RLEnvironmentBase{constructor(){super(),this.actions=[],this.states=[],this.reward=null}reset(){return this.state()}state(){return[]}setState(){}test(){return{state:this.state(),reward:0,done:!0}}}