export class RLRealRange{constructor(t,e){this.min=t,this.max=e}toSpace(t){const e=[this.min],s=(this.max-this.min)/t;for(let i=1;i<t;i++)e.push(this.min+i*s);return e.push(this.max),e}toArray(t){const e=this.toSpace(t);return e.slice(1).map(((t,s)=>(t+e[s])/2))}indexOf(t,e){return t<=this.min?0:t>=this.max?e-1:Math.floor((t-this.min)/(this.max-this.min)*e)}}export class RLIntRange{constructor(t,e){this.min=t,this.max=e}get length(){return this.max-this.min+1}toArray(t){const e=[];if(this.length<=t)for(let t=this.min;t<=this.max;e.push(t++));else{const s=(this.max-this.min)/(t-1);for(let i=0;i<t-1;i++)e[i]=this.min+Math.round(i*s);e.push(this.max)}return e}indexOf(t,e){return this.length<=e?Math.max(0,Math.min(this.length-1,Math.round(t-this.min))):t<=this.min?0:t>=this.max?e-1:Math.floor((t-this.min)/(this.max-this.min)*e)}}export class RLEnvironmentBase{constructor(){this._epoch=0}get epoch(){return this._epoch}set reward(t){}clone(){const t=Object.create(Object.getPrototypeOf(this)),e=t=>{if(null===t)return null;if(Array.isArray(t))return t.map((t=>e(t)));if("object"==typeof t){const s=Object.create(Object.getPrototypeOf(t));for(const i in t)s[i]=e(t[i]);return s}return t};for(const s in this)t[s]=e(this[s]);return t}close(){}reset(){this._epoch=0}state(t){throw"Not implemented"}setState(t,e){throw"Not implemented"}step(t,e){const s=this.state(e),i=this.test(s,t,e);return i.invalid||(this._epoch++,this.setState(i.state,e)),i}test(t,e,s){throw"Not implemented"}sample_action(t){return this.actions.map((t=>Array.isArray(t)?t[Math.floor(Math.random()*t.length)]:t instanceof RLRealRange?Math.random()*(t.max-t.min)+t.min:void 0))}}export default class EmptyRLEnvironment extends RLEnvironmentBase{constructor(){super(),this.actions=[],this.states=[],this.reward=null}reset(){return this.state()}state(){return[]}setState(){}test(){return{state:this.state(),reward:0,done:!0}}}