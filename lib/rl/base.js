export class RLRealRange{constructor(t,s){this.min=t,this.max=s}toSpace(t){const s=[this.min],e=(this.max-this.min)/t;for(let i=1;i<t;i++)s.push(this.min+i*e);return s.push(this.max),s}toArray(t){const s=this.toSpace(t);return s.slice(1).map(((t,e)=>(t+s[e])/2))}indexOf(t,s){return t<=this.min?0:t>=this.max?s-1:Math.floor((t-this.min)/(this.max-this.min)*s)}}export class RLIntRange{constructor(t,s){this.min=t,this.max=s}get length(){return this.max-this.min+1}toArray(t){const s=[];if(this.length<=t)for(let t=this.min;t<=this.max;s.push(t++));else{const e=(this.max-this.min)/(t-1);for(let i=0;i<t-1;i++)s[i]=this.min+Math.round(i*e);s.push(this.max)}return s}indexOf(t,s){return this.length<=s?Math.max(0,Math.min(this.length-1,Math.round(t-this.min))):t<=this.min?0:t>=this.max?s-1:Math.floor((t-this.min)/(this.max-this.min)*s)}}export class RLEnvironmentBase{constructor(){this._epoch=0}get epoch(){return this._epoch}set reward(t){}close(){}reset(){this._epoch=0}state(t){throw"Not implemented"}setState(t,s){throw"Not implemented"}step(t,s){const e=this.state(s),i=this.test(e,t,s);return i.invalid||(this._epoch++,this.setState(i.state,s)),i}test(t,s,e){throw"Not implemented"}sample_action(t){return this.actions.map((t=>Array.isArray(t)?t[Math.floor(Math.random()*t.length)]:t instanceof RLRealRange?Math.random()*(t.max-t.min)+t.min:void 0))}}export default class EmptyRLEnvironment extends RLEnvironmentBase{constructor(){super(),this.actions=[],this.states=[],this.reward=null}reset(){return this.state()}state(){return[]}setState(){}test(){return{state:this.state(),reward:0,done:!0}}}