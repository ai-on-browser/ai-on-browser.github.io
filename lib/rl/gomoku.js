var O=Object.defineProperty;var b=(x,t)=>O(x,"name",{value:t,configurable:!0});import{RLEnvironmentBase as k}from"./base.js";const l=1,f=2,d=3;export default class z extends k{static{b(this,"GomokuRLEnvironment")}constructor(){super(),this._size=[8,8],this._board=new T(this._size,this._evaluation),this._reward={win:1,lose:-1,step:0}}static BLACK=f;static WHITE=d;static EMPTY=l;static OWN=2;static OTHER=3;get actions(){const t=[];for(let s=0;s<this._size[0];s++)for(let i=0;i<this._size[1];i++)t.push(`${s}_${i}`);return[t]}get states(){const t=[[f,d]];for(let s=0;s<this._size[0]*this._size[1];s++)t.push([l,z.OWN,z.OTHER]);return t}set evaluation(t){t?this._board._evaluator=this._evaluation=(s,i)=>t(this._makeState(s,i,this._turn)):this._board._evaluator=this._evaluation=null}_makeState(t,s,i){const _=[i];for(let r=0;r<this._size[0];r++)for(let h=0;h<this._size[1];h++){const e=t.at([r,h]);_.push(e===l?e:e===s?z.OWN:z.OTHER)}return _}_state2board(t,s){const i=new T(this._size,this._evaluation),_=i.nextTurn(s);for(let r=0,h=1;r<this._size[0];r++)for(let e=0;e<this._size[1];e++,h++)t[h]===z.OWN?i.set([r,e],s):t[h]===z.OTHER&&i.set([r,e],_);return i}_checkAgent(t){if(!this._agents)throw new Error("Agent does not exist. Call reset to set agents.");if(t!==f&&t!==d)throw new Error("Unknown agent.")}reset(){return super.reset(),this._agents=[f,d],this._board.reset(),this._turn=f,this.state(f)}state(t){return t||(t=this._turn),this._checkAgent(t),this._makeState(this._board,t,this._turn)}setState(t,s){this._turn=t[0],this._board=this._state2board(t,s)}step(t,s){return s||(s=this._turn),super.step(t,s)}test(t,s,i){i||(i=this._turn),this._checkAgent(i);const _=t[0],r=b(o=>o?h.winner===i?this._reward.win:this._reward.lose:this._reward.step,"getreward"),h=this._state2board(t,i);if(i!==_){const o=h.finish;return{state:t,reward:r(o),done:o,invalid:!0}}const e=s[0].split("_").map(o=>+o),n=h.set(e,i),a=h.finish;return n?{state:this._makeState(h,i,h.nextTurn(_)),reward:r(a),done:a}:{state:t,reward:r(a),done:a,invalid:!0}}}class T{static{b(this,"GomokuBoard")}constructor(t,s){this._evaluator=s,this._size=t,this._a=5,this._count=0,this.reset()}get size(){return this._size}get finish(){return this.winner!==null||this._count===this._size[0]*this._size[1]}get winner(){return this.row(d,this._a).length>0?d:this.row(f,this._a).length>0?f:null}toString(){let t="";for(let s=0;s<this._size[0];s++){for(let i=0;i<this._size[1];i++)i>0&&(t+=" "),this._board[s][i]===f?t+="x":this._board[s][i]===d?t+="o":t+="-";t+=`
`}return t}nextTurn(t){return t===f?d:f}copy(){const t=new T(this._size,this._evaluator);for(let s=0;s<this._size[0];s++)for(let i=0;i<this._size[1];i++)t._board[s][i]=this._board[s][i];return t._count=this._count,t}score(t){if(this._evaluator)return this._evaluator(this,t);const s=this.winner,i=this.nextTurn(t);return s===t?this._size[0]*this._size[1]*100-this._count:s===i?-this._size[0]*this._size[1]*100+this._count:0}at(t){return this._board[t[0]][t[1]]}set(t,s){return this.at(t)!==l?!1:(this._board[t[0]][t[1]]=s,this._count++,!0)}reset(){this._count=0,this._board=[];for(let t=0;t<this._size[0];t++)this._board[t]=Array(this._size[1]).fill(l)}choices(t){const s=[];if(this.finish)return s;for(let i=0;i<this._size[0];i++)for(let _=0;_<this._size[1];_++)this._board[i][_]===l&&s.push([i,_]);return s}row(t,s,i=!1){const _=[],r=b((e,n)=>0<=e&&e<this._size[0]&&0<=n&&n<this._size[1],"checkInbound"),h=[[1,1],[1,0],[1,-1],[0,1]];for(let e=0;e<this._size[0];e++)for(let n=0;n<this._size[1];n++)if(this._board[e][n]===t)for(const[a,o]of h){if(r(e-a,n-o)&&this._board[e-a][n-o]===t)continue;if(!r(e+a*(s-1),n+o*(s-1)))continue;const j=[[e,n]];let u=e+a,c=n+o,v=!1;const p=[];for(let w=1;w<s&&r(u,c);w++,u+=a,c+=o){if(i&&!v&&this._board[u][c]===l){v=!0,w--,p.push([u,c]);continue}else if(this._board[u][c]!==t)break;if(j.push([u,c]),w===s-1){if(u+=a,c+=o,r(u,c)&&this._board[u][c]===t)break;v||(r(u,c)&&this._board[u][c]===l&&p.push([u,c]),r(e-a,n-o)&&this._board[e-a][n-o]===l&&p.push([e-a,n-o])),_.push({path:j,s:p})}}}return _}}
