import{RLEnvironmentBase}from"./base.js";const EMPTY=1,BLACK=2,WHITE=3;export default class GomokuRLEnvironment extends RLEnvironmentBase{constructor(){super(),this._size=[8,8],this._board=new GomokuBoard(this._size,this._evaluation),this._reward={goal:1,step:1,fail:0}}static BLACK=2;static WHITE=3;static EMPTY=1;get actions(){const t=[];for(let s=0;s<this._size[0];s++)for(let i=0;i<this._size[1];i++)t.push(`${s}_${i}`);return[t]}get states(){const t=[];for(let s=0;s<this._size[0]*this._size[1];s++)t.push([1,2,3]);return t}set evaluation(t){this._evaluation=t}reset(){return super.reset(),this._board.reset(),this.state()}state(t){const s=[];for(let t=0;t<this._size[0];t++)for(let i=0;i<this._size[1];i++)s.push(this._board.at([t,i]));return s}setState(t){}test(t,s,i){return{state:[],reward:0,done:!1}}}class GomokuBoard{constructor(t,s){this._evaluator=s,this._size=t,this._a=5,this._count=0,this.reset()}get size(){return this._size}get finish(){return null!==this.winner||this._count===this._size[0]*this._size[1]}get winner(){return this.row(3,this._a).length>0?3:this.row(2,this._a).length>0?2:null}nextTurn(t){return 2===t?3:2}copy(){const t=new GomokuBoard(this._size,this._evaluator);for(let s=0;s<this._size[0];s++)for(let i=0;i<this._size[1];i++)t._board[s][i]=this._board[s][i];return t._count=this._count,t}score(t){if(this._evaluator)return this._evaluator(this,t);const s=this.winner,i=this.nextTurn(t);return s===t?this._size[0]*this._size[1]*100-this._count:s===i?-this._size[0]*this._size[1]*100+this._count:0}at(t){return this._board[t[0]][t[1]]}set(t,s){return 1===this.at(t)&&(this._board[t[0]][t[1]]=s,this._count++,!0)}reset(){this._count=0,this._board=[];for(let t=0;t<this._size[0];t++)this._board[t]=Array(this._size[1]).fill(1)}choices(t){const s=[];if(this.finish)return s;for(let t=0;t<this._size[0];t++)for(let i=0;i<this._size[1];i++)1===this._board[t][i]&&s.push([t,i]);return s}row(t,s,i=!1){const e=[],r=(t,s)=>0<=t&&t<this._size[0]&&0<=s&&s<this._size[1],o=[[1,1],[1,0],[1,-1],[0,1]];for(let h=0;h<this._size[0];h++)for(let n=0;n<this._size[1];n++)if(this._board[h][n]===t)for(const[a,_]of o){if(r(h-a,n-_)&&this._board[h-a][n-_]===t)continue;if(!r(h+a*(s-1),n+_*(s-1)))continue;const o=[[h,n]];let u=h+a,c=n+_,l=!1;const f=[];for(let z=1;z<s&&r(u,c);z++,u+=a,c+=_)if(!i||l||1!==this._board[u][c]){if(this._board[u][c]!==t)break;if(o.push([u,c]),z===s-1){if(u+=a,c+=_,r(u,c)&&this._board[u][c]===t)break;l||(r(u,c)&&1===this._board[u][c]&&f.push([u,c]),r(h-a,n-_)&&1===this._board[h-a][n-_]&&f.push([h-a,n-_])),e.push({path:o,s:f})}}else l=!0,z--,f.push([u,c])}return e}}