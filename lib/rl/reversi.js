import{RLEnvironmentBase}from"./base.js";const EMPTY=1,BLACK=2,WHITE=3,flipPiece=t=>2===t?3:3===t?2:1;export default class ReversiRLEnvironment extends RLEnvironmentBase{constructor(){super(),this._size=[8,8],this._board=new ReversiBoard(this._size,this._evaluation),this._reward={goal:1,step:1,fail:0}}static BLACK=2;static WHITE=3;static EMPTY=1;get actions(){const t=[];for(let s=0;s<this._size[0];s++)for(let e=0;e<this._size[1];e++)t.push(`${s}_${e}`);return[t]}get states(){const t=[];for(let s=0;s<this._size[0]*this._size[1];s++)t.push([1,2,3]);return t}set reward(t){}set evaluation(t){this._evaluation=t}reset(){return super.reset(),this._board.reset(),this.state()}state(t){const s=[];for(let t=0;t<this._size[0];t++)for(let e=0;e<this._size[1];e++)s.push(this._board.at([t,e]));return s}step(t,s){super.step(t,s);return this.test(this.state,t,s)}test(t,s,e){return{state:[],reward:0,done:!1}}}class ReversiBoard{constructor(t,s){this._evaluator=s,this._size=t,this.reset()}get size(){return this._size}get count(){let t=0,s=0;for(let e=0;e<this._size[0];e++)for(let i=0;i<this._size[1];i++)3===this._board[e][i]?s++:2===this._board[e][i]&&t++;return{black:t,white:s}}get finish(){return this.choices(2).length+this.choices(3).length===0}get winner(){if(!this.finish)return null;const t=this.count;return t.black>t.white?2:t.black<t.white?3:null}nextTurn(t){return 2===(s=t)?3:3===s?2:1;var s}copy(){const t=new ReversiBoard(this._size,this._evaluator);for(let s=0;s<this._size[0];s++)for(let e=0;e<this._size[1];e++)t._board[s][e]=this._board[s][e];return t}score(t){if(this._evaluator)return this._evaluator(this,t);const s=this.count;return 2===t?s.black-s.white:s.white-s.black}at(t){return this._board[t[0]][t[1]]}set(t,s){const e=this.flipPositions(t[0],t[1],s);if(0===e.length)return!1;this._board[t[0]][t[1]]=s;for(const[t,i]of e)this._board[t][i]=s;return!0}reset(){this._board=[];for(let t=0;t<this._size[0];t++)this._board[t]=Array(this._size[1]).fill(1);const t=Math.floor(this._size[0]/2),s=Math.floor(this._size[1]/2);this._board[t-1][s-1]=2,this._board[t-1][s]=3,this._board[t][s-1]=3,this._board[t][s]=2}choices(t){const s=[];for(let e=0;e<this._size[0];e++)for(let i=0;i<this._size[1];i++)this.flipPositions(e,i,t).length>0&&s.push([e,i]);return s}flipPositions(t,s,e){if(t<0||s<0||this._size[0]<=t||this._size[1]<=s)return[];if(1===e||1!==this._board[t][s])return[];const i=[];for(const[r,o]of[[1,1],[1,0],[1,-1],[0,-1],[-1,-1],[-1,0],[-1,1],[0,1]]){let h=t,n=s;const a=[];for(;h+=r,n+=o,!(h<0||n<0||this._size[0]<=h||this._size[1]<=n);){if(this._board[h][n]===e){i.push(...a);break}if(1===this._board[h][n])break;a.push([h,n])}}return i}}