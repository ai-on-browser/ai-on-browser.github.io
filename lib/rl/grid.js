var f=Object.defineProperty;var p=(l,t)=>f(l,"name",{value:t,configurable:!0});import{RLIntRange as m,RLEnvironmentBase as c}from"./base.js";export default class d extends c{static{p(this,"GridMazeRLEnvironment")}constructor(){super(),this._points=[],this._dim=2,this._size=[20,10],this._position=Array(this._dim).fill(0),this._max_step=0,this._reward={step:-1,wall:-2,goal:5,fail:-100},this.__map=null}get size(){return this._size}get actions(){return this._dim===1?[[0,1]]:[[0,1,2,3]]}get _action_move(){return this._dim===1?[[1],[-1]]:[[1,0],[0,1],[-1,0],[0,-1]]}get states(){const t=[];for(let s=0;s<this._dim;s++)t.push(new m(0,this._size[s]-1));return t}get map(){if(this.__map??=[],this.__map.length<this._size[0])for(let t=this.__map.length;t<this._size[0];t++)this.__map[t]=Array(this._size[1]);for(let t=0;t<this._size[0];t++)this.__map[t].fill(!1);return this._points.forEach(t=>{this.__map[t[0]][t[1]]=1-this.__map[t[0]][t[1]]}),this.__map[0][0]=!1,this.__map[this._size[0]-1][this._size[1]-1]=!1,this.__map}set reward(t){if(this._reward={step:-1,wall:-2,goal:5,fail:-100},t==="achieve"){const s=this;this._reward={get step(){return Math.sqrt(s._position[0]**2+s._position[1]**2)},wall:0,goal:0,fail:0}}}reset(){return super.reset(),this._position=Array(this._dim).fill(0),this._position}resetMap(){this._points=[]}resetMapAsMaze(){const t=this._size,s=Array.from({length:t[0]},()=>Array(t[1]).fill(!0)),a=[[0,0]];for(s[0][0]=!1;a.length>0;){for(let e=a.length-1;e>0;e--){const r=Math.floor(Math.random()*(e+1));[a[e],a[r]]=[a[r],a[e]]}const[i,_]=a.pop();let h=i,o=_;for(;;){const e=[];if(h>0&&s[h-2][o]&&e.push([-1,0]),h<t[0]-2&&s[h+2][o]&&e.push([1,0]),o>0&&s[h][o-2]&&e.push([0,-1]),o<t[1]-2&&s[h][o+2]&&e.push([0,1]),e.length===0)break;const[r,n]=e[Math.floor(Math.random()*e.length)];s[h+r][o+n]=!1,s[h+r*2][o+n*2]=!1,h+=r*2,o+=n*2,a.push([h,o])}}this._points=[];for(let i=0;i<t[0];i++)for(let _=0;_<t[1];_++)t[0]%2===0&&i===t[0]-1&&!s[i-1][_]||t[1]%2===0&&_===t[1]-1&&!s[i][_-1]||s[i][_]&&this._points.push([i,_])}state(){return this._position}setState(t){this._position=t}test(t,s){let a=this._reward.step,i=[].concat(t);const _=this.map,h=this._action_move[s[0]];for(let r=0;r<h.length;r++)i[r]+=h[r];i.some((r,n)=>r<0||this._size[n]<=r)?(a=this._reward.wall,i=[].concat(t)):_[i[0]][i[1]||0]&&(a=this._reward.wall,i=[].concat(t));const o=this._max_step&&this._max_step<=this.epoch,e=i.every((r,n)=>r===this._size[n]-1)||o;return e&&(a=this._reward.goal),o&&(a=this._reward.fail),{state:i,reward:a,done:e}}}
