import{RLIntRange,RLEnvironmentBase}from"./base.js";export default class GridMazeRLEnvironment extends RLEnvironmentBase{constructor(){super(),this._points=[],this._dim=2,this._size=[20,10],this._position=Array(this._dim).fill(0),this._max_step=0,this._reward={step:-1,wall:-2,goal:5,fail:-100},this.__map=null}get size(){return this._size}get actions(){return 1===this._dim?[[0,1]]:[[0,1,2,3]]}get _action_move(){return 1===this._dim?[[1],[-1]]:[[1,0],[0,1],[-1,0],[0,-1]]}get states(){const t=[];for(let s=0;s<this._dim;s++)t.push(new RLIntRange(0,this._size[s]-1));return t}get map(){if(!this.__map){this.__map=[];for(let t=0;t<this._size[0];t++)this.__map[t]=Array(this._size[1])}for(let t=0;t<this._size[0];t++)this.__map[t].fill(!1);return this._points.forEach((t=>{this.__map[t[0]][t[1]]=1-this.__map[t[0]][t[1]]})),this.__map[0][0]=!1,this.__map[this._size[0]-1][this._size[1]-1]=!1,this.__map}set reward(t){if(this._reward={step:-1,wall:-2,goal:5,fail:-100},"achieve"===t){const t=this;this._reward={get step(){return Math.sqrt(t._position[0]**2+t._position[1]**2)},wall:0,goal:0,fail:0}}}reset(){return super.reset(),this._position=Array(this._dim).fill(0),this._position}state(){return this._position}setState(t){this._position=t}test(t,s){let i=this._reward.step,e=[].concat(t);const r=this.map,_=this._action_move[s[0]];for(let t=0;t<_.length;t++)e[t]+=_[t];(e.some(((t,s)=>t<0||this._size[s]<=t))||r[e[0]][e[1]||0])&&(i=this._reward.wall,e=[].concat(t));const a=this._max_step&&this._max_step<=this.epoch,h=e.every(((t,s)=>t===this._size[s]-1))||a;return h&&(i=this._reward.goal),a&&(i=this._reward.fail),{state:e,reward:i,done:h}}}