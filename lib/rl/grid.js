var f=Object.defineProperty;var p=(l,t)=>f(l,"name",{value:t,configurable:!0});import{RLEnvironmentBase as m,RLIntRange as c,RLStepResult as u}from"./base.js";export default class d extends m{static{p(this,"GridMazeRLEnvironment")}constructor(){super(),this._points=[],this._dim=2,this._size=[20,10],this._position=Array(this._dim).fill(0),this._max_step=0,this._reward={step:-1,wall:-2,goal:5,fail:-100},this.__map=null}get size(){return this._size}get actions(){return this._dim===1?[[0,1]]:[[0,1,2,3]]}get _action_move(){return this._dim===1?[[1],[-1]]:[[1,0],[0,1],[-1,0],[0,-1]]}get states(){const t=[];for(let i=0;i<this._dim;i++)t.push(new c(0,this._size[i]-1));return t}get map(){if(this.__map??=[],this.__map.length<this._size[0])for(let t=this.__map.length;t<this._size[0];t++)this.__map[t]=Array(this._size[1]);for(let t=0;t<this._size[0];t++)this.__map[t].fill(!1);return this._points.forEach(t=>{this.__map[t[0]][t[1]]=1-this.__map[t[0]][t[1]]}),this.__map[0][0]=!1,this.__map[this._size[0]-1][this._size[1]-1]=!1,this.__map}reset(){return super.reset(),this._position=Array(this._dim).fill(0),this._position}resetMap(){this._points=[]}resetMapAsMaze(){const t=this._size,i=Array.from({length:t[0]},()=>Array(t[1]).fill(!0)),r=[[0,0]];for(i[0][0]=!1;r.length>0;){for(let e=r.length-1;e>0;e--){const h=Math.floor(Math.random()*(e+1));[r[e],r[h]]=[r[h],r[e]]}const[s,_]=r.pop();let a=s,o=_;for(;;){const e=[];if(a>0&&i[a-2][o]&&e.push([-1,0]),a<t[0]-2&&i[a+2][o]&&e.push([1,0]),o>0&&i[a][o-2]&&e.push([0,-1]),o<t[1]-2&&i[a][o+2]&&e.push([0,1]),e.length===0)break;const[h,n]=e[Math.floor(Math.random()*e.length)];i[a+h][o+n]=!1,i[a+h*2][o+n*2]=!1,a+=h*2,o+=n*2,r.push([a,o])}}this._points=[];for(let s=0;s<t[0];s++)for(let _=0;_<t[1];_++)t[0]%2===0&&s===t[0]-1&&!i[s-1][_]||t[1]%2===0&&_===t[1]-1&&!i[s][_-1]||i[s][_]&&this._points.push([s,_])}state(){return this._position}setState(t){this._position=t}test(t,i){let r=this._reward.step,s=[].concat(t);const _=this.map,a=this._action_move[i[0]];for(let h=0;h<a.length;h++)s[h]+=a[h];s.some((h,n)=>h<0||this._size[n]<=h)?(r=this._reward.wall,s=[].concat(t)):_[s[0]][s[1]||0]&&(r=this._reward.wall,s=[].concat(t));const o=this._max_step&&this._max_step<=this.epoch,e=s.every((h,n)=>h===this._size[n]-1)||o;return e&&(r=this._reward.goal),o&&(r=this._reward.fail),new u(this,s,r,e)}}
