import{RLIntRange,RLEnvironmentBase}from"./base.js";export default class GridMazeRLEnvironment extends RLEnvironmentBase{constructor(){super(),this._points=[],this._dim=2,this._size=[20,10],this._position=Array(this._dim).fill(0),this._max_step=0,this._reward={step:-1,wall:-2,goal:5,fail:-100},this.__map=null}get size(){return this._size}get actions(){return 1===this._dim?[[0,1]]:[[0,1,2,3]]}get _action_move(){return 1===this._dim?[[1],[-1]]:[[1,0],[0,1],[-1,0],[0,-1]]}get states(){const t=[];for(let s=0;s<this._dim;s++)t.push(new RLIntRange(0,this._size[s]-1));return t}get map(){if(this.__map??=[],this.__map.length<this._size[0])for(let t=this.__map.length;t<this._size[0];t++)this.__map[t]=Array(this._size[1]);for(let t=0;t<this._size[0];t++)this.__map[t].fill(!1);return this._points.forEach((t=>{this.__map[t[0]][t[1]]=1-this.__map[t[0]][t[1]]})),this.__map[0][0]=!1,this.__map[this._size[0]-1][this._size[1]-1]=!1,this.__map}set reward(t){if(this._reward={step:-1,wall:-2,goal:5,fail:-100},"achieve"===t){const t=this;this._reward={get step(){return Math.sqrt(t._position[0]**2+t._position[1]**2)},wall:0,goal:0,fail:0}}}reset(){return super.reset(),this._position=Array(this._dim).fill(0),this._position}resetMap(){this._points=[]}resetMapAsMaze(){const t=this._size,s=Array.from({length:t[0]},(()=>Array(t[1]).fill(!0))),i=[[0,0]];for(s[0][0]=!1;i.length>0;){for(let t=i.length-1;t>0;t--){const s=Math.floor(Math.random()*(t+1));[i[t],i[s]]=[i[s],i[t]]}const[e,r]=i.pop();let h=e,a=r;for(;;){const e=[];if(h>0&&s[h-2][a]&&e.push([-1,0]),h<t[0]-2&&s[h+2][a]&&e.push([1,0]),a>0&&s[h][a-2]&&e.push([0,-1]),a<t[1]-2&&s[h][a+2]&&e.push([0,1]),0===e.length)break;const[r,_]=e[Math.floor(Math.random()*e.length)];s[h+r][a+_]=!1,s[h+2*r][a+2*_]=!1,h+=2*r,a+=2*_,i.push([h,a])}}this._points=[];for(let i=0;i<t[0];i++)for(let e=0;e<t[1];e++)(t[0]%2!=0||i!==t[0]-1||s[i-1][e])&&(t[1]%2!=0||e!==t[1]-1||s[i][e-1])&&s[i][e]&&this._points.push([i,e])}state(){return this._position}setState(t){this._position=t}test(t,s){let i=this._reward.step,e=[].concat(t);const r=this.map,h=this._action_move[s[0]];for(let t=0;t<h.length;t++)e[t]+=h[t];(e.some(((t,s)=>t<0||this._size[s]<=t))||r[e[0]][e[1]||0])&&(i=this._reward.wall,e=[].concat(t));const a=this._max_step&&this._max_step<=this.epoch,_=e.every(((t,s)=>t===this._size[s]-1))||a;return _&&(i=this._reward.goal),a&&(i=this._reward.fail),{state:e,reward:i,done:_}}}