var d=Object.defineProperty;var l=(f,t)=>d(f,"name",{value:t,configurable:!0});import{RLEnvironmentBase as c}from"./base.js";class s{static{l(this,"GemPuzzleBoard")}constructor(t,e){this._evaluator=e,this._size=t,this.reset(),this.random()}static UP=0;static RIGHT=1;static DOWN=2;static LEFT=3;get size(){return this._size}get finish(){const t=this._size[0]*this._size[1]-1;for(let e=0,i=0;e<this._size[0];e++)for(let h=0;h<this._size[1];h++,i++)if(i!==t&&this._board[e][h]!==i)return!1;return this._board[this._size[0]-1][this._size[1]-1]==null}get emptyPosition(){return this.find(null)}toString(){let t="";const e=(""+(this._size[0]*this._size[1]-1)).length;for(let i=0;i<this._size[0];i++){for(let h=0;h<this._size[1];h++)if(h>0&&(t+=" "),this._board[i][h]===null)t+=" ".repeat(e);else{const r=""+this._board[i][h],_=e-r.length;t+=r.padStart(Math.floor(_/2)," ").padEnd(e," ")}t=t.trimEnd(),t+=`
`}return t}copy(){const t=new s(this._size,this._evaluator);for(let e=0;e<this._size[0];e++)for(let i=0;i<this._size[1];i++)t._board[e][i]=this._board[e][i];return t}score(){if(this._evaluator)return this._evaluator(this);let t=0;for(let e=0;e<this._size[0];e++)for(let i=0;i<this._size[1];i++){const h=this._board[e][i];h!==null&&(t-=Math.abs(e-Math.floor(h/this._size[1])),t-=Math.abs(i-h%this._size[1]))}return t}at(t){return this._board[t[0]][t[1]]}find(t){for(let e=0;e<this._size[0];e++)for(let i=0;i<this._size[1];i++)if(this._board[e][i]===t)return[e,i];return null}move(t){const e=this.emptyPosition;if(t===s.UP){if(e[0]<=0)return!1;this._board[e[0]][e[1]]=this._board[e[0]-1][e[1]],this._board[e[0]-1][e[1]]=null}else if(t===s.RIGHT){if(e[1]>=this._size[1]-1)return!1;this._board[e[0]][e[1]]=this._board[e[0]][e[1]+1],this._board[e[0]][e[1]+1]=null}else if(t===s.DOWN){if(e[0]>=this._size[0]-1)return!1;this._board[e[0]][e[1]]=this._board[e[0]+1][e[1]],this._board[e[0]+1][e[1]]=null}else{if(e[1]<=0)return!1;this._board[e[0]][e[1]]=this._board[e[0]][e[1]-1],this._board[e[0]][e[1]-1]=null}return!0}reset(){this._board=[];for(let t=0;t<this._size[0];t++)this._board[t]=[];for(let t=0,e=0;t<this._size[0];t++)for(let i=0;i<this._size[1];i++,e++)this._board[t][i]=e;this._board[this._size[0]-1][this._size[1]-1]=null}random(){this.reset();const t=this._size[0]*this._size[1],e=this._size[1],i=4;if(t-1>=i)for(let r=0;r<t;r++){const _=[];for(let a=0;a<i;a++)_.push(Math.floor(Math.random()*(t-a-1)));for(let a=i-1;a>=0;a--)for(let p=i-1;p>a;p--)_[a]<=_[p]&&_[p]++;const o=_.map(a=>[Math.floor(a/e),a%e]);[this._board[o[0][0]][o[0][1]],this._board[o[1][0]][o[1][1]]]=[this._board[o[1][0]][o[1][1]],this._board[o[0][0]][o[0][1]]],[this._board[o[2][0]][o[2][1]],this._board[o[3][0]][o[3][1]]]=[this._board[o[3][0]][o[3][1]],this._board[o[2][0]][o[2][1]]]}let h=null;for(let r=0;r<this._size[0]*this._size[1]*2;r++){const _=this.choices();let o=_[Math.floor(Math.random()*_.length)];(h===s.DOWN&&o===s.UP||h===s.UP&&o===s.DOWN||h===s.LEFT&&o===s.RIGHT||h===s.RIGHT&&o===s.LEFT)&&(o=_[Math.floor(Math.random()*_.length)]),this.move(o),h=o}}choices(){const t=this.emptyPosition,e=[];return t[0]>0&&e.push(s.UP),t[1]<this._size[1]-1&&e.push(s.RIGHT),t[0]<this._size[0]-1&&e.push(s.DOWN),t[1]>0&&e.push(s.LEFT),e}solve(){const t=new b(this.copy());return t.solve(),t.path}}class b{static{l(this,"GemPuzzleSolver")}constructor(t){this._board=t,this._path=[]}get path(){return this._path}solve(){let t=this._board.emptyPosition;const e=this._board.size[0],i=this._board.size[1];for(let h=0;h<e-2;h++){for(let r=0;r<i-2;r++)t=this._move(h*i+r,[h,r]);if(!(this._board.at([h,i-2])===h*i+i-2&&this._board.at([h,i-1])===h*i+i-1)){for(t=this._move(h*i+i-1,[h,i-2]);t[1]<i-1;)this._step(s.RIGHT),t[1]++;for(;t[0]>h+1;)this._step(s.UP),t[0]--;if(t[0]<h+1&&(this._step(s.DOWN),t[0]++),this._board.at([h,i-1])===h*i+i-2){this._step(s.UP),this._step(s.LEFT),this._step(s.DOWN),this._step(s.RIGHT),this._step(s.DOWN),this._step(s.LEFT),this._step(s.UP),this._step(s.UP),this._step(s.RIGHT),this._step(s.DOWN),this._step(s.LEFT),this._step(s.DOWN),this._step(s.RIGHT),this._step(s.UP),this._step(s.UP),this._step(s.LEFT),this._step(s.DOWN),t[1]--;continue}if(t=this._move(h*i+i-2,[h+1,i-2]),this._board.at([h,i-1])!==h*i+i-1){for(;t[0]<=h+1;)this._step(s.DOWN),t[0]++;for(;t[1]<i-1;)this._step(s.RIGHT),t[1]++;this._step(s.UP),this._step(s.UP),this._step(s.LEFT),this._step(s.DOWN),t[0]--,t[1]--}}}for(let h=0;h<i-2;h++){const r=(e-2)*i+h,_=(e-1)*i+h;if(!(this._board.at([e-2,h])===r&&this._board.at([e-1,h])===_)){for(t=this._move(_,[e-2,h]);t[0]<e-1;)this._step(s.DOWN),t[0]++;for(;t[1]>h+1;)this._step(s.LEFT),t[1]--;if(t[1]<h+1&&(this._step(s.RIGHT),t[1]++),this._board.at([e-1,h])===r){this._step(s.LEFT),this._step(s.UP),this._step(s.RIGHT),this._step(s.DOWN),this._step(s.RIGHT),this._step(s.UP),this._step(s.LEFT),this._step(s.LEFT),this._step(s.DOWN),this._step(s.RIGHT),this._step(s.UP),this._step(s.RIGHT),this._step(s.DOWN),this._step(s.LEFT),this._step(s.LEFT),this._step(s.UP),this._step(s.RIGHT),t[0]--;continue}for(t=this._move(r,[e-2,h+1]);t[0]<e-1;)this._step(s.DOWN),t[0]++;for(;t[1]>h;)this._step(s.LEFT),t[1]--;this._step(s.UP),this._step(s.RIGHT)}}t=this._move((e-2)*i+i-2,[e-2,i-2]),t[0]<e-1&&this._step(s.DOWN),t[1]<i-1&&this._step(s.RIGHT)}_step(t){if(this._board.move(t),this._path.length>0){const e=this._path.at(-1);if(t===s.UP&&e===s.DWON||t===s.DOWN&&e===s.UP||t===s.LEFT&&e===s.RIGHT||t===s.RIGHT&&e===s.LEFT){this._path.pop();return}}this._path.push(t)}_move(t,e){const i=this._board.emptyPosition,h=this._board.size[0];for(;i[0]<=e[0];)this._step(s.DOWN),i[0]++;if(this._board.at(e)===t)return i;const r=this._board.find(t);if(r[1]!==e[1]){for(r[0]===i[0]&&(r[0]===h-1?(this._step(s.UP),i[0]--):(this._step(s.DOWN),i[0]++));i[1]<r[1];)this._step(s.RIGHT),i[1]++;for(;i[1]>r[1];)this._step(s.LEFT),i[1]--;if(i[0]<r[0]){for(;i[0]<r[0];)this._step(s.DOWN),i[0]++;r[0]--}else for(;i[0]>r[0]+1;)this._step(s.UP),i[0]--;if(r[1]<e[1])for(let _=0;_<e[1]-r[1];_++)this._step(s.RIGHT),this._step(s.UP),this._step(s.LEFT),this._step(s.DOWN),this._step(s.RIGHT),i[1]++;else for(let _=0;_<r[1]-e[1];_++)this._step(s.LEFT),this._step(s.UP),this._step(s.RIGHT),this._step(s.DOWN),this._step(s.LEFT),i[1]--;r[1]=e[1]}if(r[0]!==e[0]){if(r[0]===i[0]&&(r[0]===h-1?(this._step(s.UP),i[0]--):(this._step(s.DOWN),i[0]++)),i[1]<=r[1])for(;i[1]<=r[1];)this._step(s.RIGHT),i[1]++;else for(;i[1]>r[1]+1;)this._step(s.LEFT),i[1]--;for(;i[0]<r[0];)this._step(s.DOWN),i[0]++;for(;i[0]>r[0];)this._step(s.UP),i[0]--;for(let _=0;_<r[0]-e[0];_++)this._step(s.UP),this._step(s.LEFT),this._step(s.DOWN),this._step(s.RIGHT),this._step(s.UP),i[0]--;r[0]=e[0]}return i}}export default class n extends c{static{l(this,"GemPuzzleRLEnvironment")}constructor(){super(),this._size=[4,4],this._board=new s(this._size,this._evaluation),this._reward={win:10,step:0,invalid:-100}}static UP=s.UP;static RIGHT=s.RIGHT;static DOWN=s.DOWN;static LEFT=s.LEFT;get actions(){return[[n.UP,n.RIGHT,n.DOWN,n.LEFT]]}get states(){const t=[],e=this._size[0]*this._size[1],i=Array.from({length:e},(h,r)=>r-1);for(let h=0;h<e;h++)t.push(i);return t}set evaluation(t){t?this._board._evaluator=this._evaluation=e=>t(this._makeState(e)):this._board._evaluator=this._evaluation=null}_makeState(t){const e=[];for(let i=0;i<this._size[0];i++)for(let h=0;h<this._size[1];h++){const r=t.at([i,h]);e.push(r===null?-1:r)}return e}_state2board(t){const e=new s(this._size,this._evaluation);for(let i=0,h=0;i<this._size[0];i++)for(let r=0;r<this._size[1];r++,h++)e._board[i][r]=t[h]===-1?null:t[h];return e}reset(){return super.reset(),this._board.reset(),this._board.random(),this.state()}state(){return this._makeState(this._board)}setState(t){this._board=this._state2board(t)}step(t){return super.step(t)}test(t,e){const i=this._state2board(t),h=i.move(e[0]),r=i.finish,_=(r?this._reward.win:this._reward.step)+i.score();return h?{state:this._makeState(i),reward:_,done:r}:{state:t,reward:_+this._reward.invalid,done:r,invalid:!0}}}
