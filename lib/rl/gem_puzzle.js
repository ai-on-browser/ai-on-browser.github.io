var d=Object.defineProperty;var l=(f,s)=>d(f,"name",{value:s,configurable:!0});import{RLEnvironmentBase as b,RLStepResult as c}from"./base.js";class t{static{l(this,"GemPuzzleBoard")}constructor(s){this._size=s,this.reset(),this.random()}static UP=0;static RIGHT=1;static DOWN=2;static LEFT=3;get size(){return this._size}get finish(){const s=this._size[0]*this._size[1]-1;for(let e=0,i=0;e<this._size[0];e++)for(let h=0;h<this._size[1];h++,i++)if(i!==s&&this._board[e][h]!==i)return!1;return this._board[this._size[0]-1][this._size[1]-1]==null}get emptyPosition(){return this.find(null)}toString(){let s="";const e=`${this._size[0]*this._size[1]-1}`.length;for(let i=0;i<this._size[0];i++){for(let h=0;h<this._size[1];h++)if(h>0&&(s+=" "),this._board[i][h]===null)s+=" ".repeat(e);else{const r=`${this._board[i][h]}`,_=e-r.length;s+=r.padStart(Math.floor(_/2)," ").padEnd(e," ")}s=s.trimEnd(),s+=`
`}return s}copy(){const s=new t(this._size);for(let e=0;e<this._size[0];e++)for(let i=0;i<this._size[1];i++)s._board[e][i]=this._board[e][i];return s}score(){let s=0;for(let e=0;e<this._size[0];e++)for(let i=0;i<this._size[1];i++){const h=this._board[e][i];h!==null&&(s-=Math.abs(e-Math.floor(h/this._size[1])),s-=Math.abs(i-h%this._size[1]))}return s}at(s){return this._board[s[0]][s[1]]}find(s){for(let e=0;e<this._size[0];e++)for(let i=0;i<this._size[1];i++)if(this._board[e][i]===s)return[e,i];return null}move(s){const e=this.emptyPosition;if(s===t.UP){if(e[0]<=0)return!1;this._board[e[0]][e[1]]=this._board[e[0]-1][e[1]],this._board[e[0]-1][e[1]]=null}else if(s===t.RIGHT){if(e[1]>=this._size[1]-1)return!1;this._board[e[0]][e[1]]=this._board[e[0]][e[1]+1],this._board[e[0]][e[1]+1]=null}else if(s===t.DOWN){if(e[0]>=this._size[0]-1)return!1;this._board[e[0]][e[1]]=this._board[e[0]+1][e[1]],this._board[e[0]+1][e[1]]=null}else{if(e[1]<=0)return!1;this._board[e[0]][e[1]]=this._board[e[0]][e[1]-1],this._board[e[0]][e[1]-1]=null}return!0}reset(){this._board=[];for(let s=0;s<this._size[0];s++)this._board[s]=[];for(let s=0,e=0;s<this._size[0];s++)for(let i=0;i<this._size[1];i++,e++)this._board[s][i]=e;this._board[this._size[0]-1][this._size[1]-1]=null}random(){this.reset();const s=this._size[0]*this._size[1],e=this._size[1],i=4;if(s-1>=i)for(let r=0;r<s;r++){const _=[];for(let p=0;p<i;p++)_.push(Math.floor(Math.random()*(s-p-1)));for(let p=i-1;p>=0;p--)for(let n=i-1;n>p;n--)_[p]<=_[n]&&_[n]++;const o=_.map(p=>[Math.floor(p/e),p%e]);[this._board[o[0][0]][o[0][1]],this._board[o[1][0]][o[1][1]]]=[this._board[o[1][0]][o[1][1]],this._board[o[0][0]][o[0][1]]],[this._board[o[2][0]][o[2][1]],this._board[o[3][0]][o[3][1]]]=[this._board[o[3][0]][o[3][1]],this._board[o[2][0]][o[2][1]]]}let h=null;for(let r=0;r<this._size[0]*this._size[1]*2;r++){const _=this.choices();let o=_[Math.floor(Math.random()*_.length)];(h===t.DOWN&&o===t.UP||h===t.UP&&o===t.DOWN||h===t.LEFT&&o===t.RIGHT||h===t.RIGHT&&o===t.LEFT)&&(o=_[Math.floor(Math.random()*_.length)]),this.move(o),h=o}}choices(){const s=this.emptyPosition,e=[];return s[0]>0&&e.push(t.UP),s[1]<this._size[1]-1&&e.push(t.RIGHT),s[0]<this._size[0]-1&&e.push(t.DOWN),s[1]>0&&e.push(t.LEFT),e}solve(){const s=new T(this.copy());return s.solve(),s.path}}class T{static{l(this,"GemPuzzleSolver")}constructor(s){this._board=s,this._path=[]}get path(){return this._path}solve(){let s=this._board.emptyPosition;const e=this._board.size[0],i=this._board.size[1];for(let h=0;h<e-2;h++){for(let r=0;r<i-2;r++)s=this._move(h*i+r,[h,r]);if(!(this._board.at([h,i-2])===h*i+i-2&&this._board.at([h,i-1])===h*i+i-1)){for(s=this._move(h*i+i-1,[h,i-2]);s[1]<i-1;)this._step(t.RIGHT),s[1]++;for(;s[0]>h+1;)this._step(t.UP),s[0]--;if(s[0]<h+1&&(this._step(t.DOWN),s[0]++),this._board.at([h,i-1])===h*i+i-2){this._step(t.UP),this._step(t.LEFT),this._step(t.DOWN),this._step(t.RIGHT),this._step(t.DOWN),this._step(t.LEFT),this._step(t.UP),this._step(t.UP),this._step(t.RIGHT),this._step(t.DOWN),this._step(t.LEFT),this._step(t.DOWN),this._step(t.RIGHT),this._step(t.UP),this._step(t.UP),this._step(t.LEFT),this._step(t.DOWN),s[1]--;continue}if(s=this._move(h*i+i-2,[h+1,i-2]),this._board.at([h,i-1])!==h*i+i-1){for(;s[0]<=h+1;)this._step(t.DOWN),s[0]++;for(;s[1]<i-1;)this._step(t.RIGHT),s[1]++;this._step(t.UP),this._step(t.UP),this._step(t.LEFT),this._step(t.DOWN),s[0]--,s[1]--}}}for(let h=0;h<i-2;h++){const r=(e-2)*i+h,_=(e-1)*i+h;if(!(this._board.at([e-2,h])===r&&this._board.at([e-1,h])===_)){for(s=this._move(_,[e-2,h]);s[0]<e-1;)this._step(t.DOWN),s[0]++;for(;s[1]>h+1;)this._step(t.LEFT),s[1]--;if(s[1]<h+1&&(this._step(t.RIGHT),s[1]++),this._board.at([e-1,h])===r){this._step(t.LEFT),this._step(t.UP),this._step(t.RIGHT),this._step(t.DOWN),this._step(t.RIGHT),this._step(t.UP),this._step(t.LEFT),this._step(t.LEFT),this._step(t.DOWN),this._step(t.RIGHT),this._step(t.UP),this._step(t.RIGHT),this._step(t.DOWN),this._step(t.LEFT),this._step(t.LEFT),this._step(t.UP),this._step(t.RIGHT),s[0]--;continue}for(s=this._move(r,[e-2,h+1]);s[0]<e-1;)this._step(t.DOWN),s[0]++;for(;s[1]>h;)this._step(t.LEFT),s[1]--;this._step(t.UP),this._step(t.RIGHT)}}s=this._move((e-2)*i+i-2,[e-2,i-2]),s[0]<e-1&&this._step(t.DOWN),s[1]<i-1&&this._step(t.RIGHT)}_step(s){if(this._board.move(s),this._path.length>0){const e=this._path.at(-1);if(s===t.UP&&e===t.DWON||s===t.DOWN&&e===t.UP||s===t.LEFT&&e===t.RIGHT||s===t.RIGHT&&e===t.LEFT){this._path.pop();return}}this._path.push(s)}_move(s,e){const i=this._board.emptyPosition,h=this._board.size[0];for(;i[0]<=e[0];)this._step(t.DOWN),i[0]++;if(this._board.at(e)===s)return i;const r=this._board.find(s);if(r[1]!==e[1]){for(r[0]===i[0]&&(r[0]===h-1?(this._step(t.UP),i[0]--):(this._step(t.DOWN),i[0]++));i[1]<r[1];)this._step(t.RIGHT),i[1]++;for(;i[1]>r[1];)this._step(t.LEFT),i[1]--;if(i[0]<r[0]){for(;i[0]<r[0];)this._step(t.DOWN),i[0]++;r[0]--}else for(;i[0]>r[0]+1;)this._step(t.UP),i[0]--;if(r[1]<e[1])for(let _=0;_<e[1]-r[1];_++)this._step(t.RIGHT),this._step(t.UP),this._step(t.LEFT),this._step(t.DOWN),this._step(t.RIGHT),i[1]++;else for(let _=0;_<r[1]-e[1];_++)this._step(t.LEFT),this._step(t.UP),this._step(t.RIGHT),this._step(t.DOWN),this._step(t.LEFT),i[1]--;r[1]=e[1]}if(r[0]!==e[0]){if(r[0]===i[0]&&(r[0]===h-1?(this._step(t.UP),i[0]--):(this._step(t.DOWN),i[0]++)),i[1]<=r[1])for(;i[1]<=r[1];)this._step(t.RIGHT),i[1]++;else for(;i[1]>r[1]+1;)this._step(t.LEFT),i[1]--;for(;i[0]<r[0];)this._step(t.DOWN),i[0]++;for(;i[0]>r[0];)this._step(t.UP),i[0]--;for(let _=0;_<r[0]-e[0];_++)this._step(t.UP),this._step(t.LEFT),this._step(t.DOWN),this._step(t.RIGHT),this._step(t.UP),i[0]--;r[0]=e[0]}return i}}export default class a extends b{static{l(this,"GemPuzzleRLEnvironment")}constructor(){super(),this._size=[4,4],this._board=new t(this._size),this._reward={win:10,step:0,invalid:-100}}static UP=t.UP;static RIGHT=t.RIGHT;static DOWN=t.DOWN;static LEFT=t.LEFT;get actions(){return[[a.UP,a.RIGHT,a.DOWN,a.LEFT]]}get states(){const s=[],e=this._size[0]*this._size[1],i=Array.from({length:e},(h,r)=>r-1);for(let h=0;h<e;h++)s.push(i);return s}_makeState(s){const e=[];for(let i=0;i<this._size[0];i++)for(let h=0;h<this._size[1];h++){const r=s.at([i,h]);e.push(r===null?-1:r)}return e}_state2board(s){const e=new t(this._size);for(let i=0,h=0;i<this._size[0];i++)for(let r=0;r<this._size[1];r++,h++)e._board[i][r]=s[h]===-1?null:s[h];return e}reset(){return super.reset(),this._board.reset(),this._board.random(),this.state()}state(){return this._makeState(this._board)}setState(s){this._board=this._state2board(s)}step(s){return super.step(s)}test(s,e){const i=this._state2board(s),h=i.move(e[0]),r=i.finish,_=(r?this._reward.win:this._reward.step)+i.score();return h?new c(this,this._makeState(i),_,r):new c(this,s,_+this._reward.invalid,r,!0)}}
