var w=Object.defineProperty;var I=(o,e)=>w(o,"name",{value:e,configurable:!0});export function davisBouldinIndex(o,e,s=2,h=1){const r=e.length,u=o[0].length,l=[...new Set(e)],t=l.length,i=Array(t).fill(0),a=[],j=[];for(let f=0;f<t;f++){a[f]=Array(u).fill(0);for(let m=0;m<r;m++)if(e[m]===l[f]){j[m]=f,i[f]++;for(let n=0;n<u;n++)a[f][n]+=o[m][n]}a[f]=a[f].map(m=>m/i[f])}const x=Array(t).fill(0);for(let f=0;f<r;f++){const m=a[j[f]],n=o[f].reduce((c,g,y)=>c+Math.abs(g-m[y])**s,0);x[j[f]]+=n**(h/s)}for(let f=0;f<x.length;f++)x[f]=(x[f]/i[f])**(1/h);const k=Array.from({length:t},()=>[]);let M=0;for(let f=0;f<t;f++){let m=-1/0;for(let n=0;n<f;n++)k[f][n]>m&&(m=k[f][n]);for(let n=f+1;n<t;n++){const c=a[f].reduce((g,y,A)=>g+Math.abs(y-a[n][A])**s,0);k[f][n]=k[n][f]=(x[f]+x[n])/c**(1/s),k[f][n]>m&&(m=k[f][n])}M+=m}return M/t}I(davisBouldinIndex,"davisBouldinIndex");export function silhouetteCoefficient(o,e){const s=e.length,h=[...new Set(e)],r=I((t,i)=>Math.sqrt(t.reduce((a,j,x)=>a+(j-i[x])**2,0)),"dist"),u=[];for(let t=0;t<s;t++){u[t]=[];for(let i=0;i<t;i++)u[t][i]=u[i][t]=r(o[t],o[i])}const l=[];for(let t=0;t<s;t++){let i=0,a=0;for(let x=0;x<s;x++)x===t||e[x]!==e[t]||(i+=u[t][x],a++);i/=a;let j=1/0;for(let x=0;x<h.length;x++){if(e[t]===h[x])continue;let k=0,M=0;for(let f=0;f<s;f++)e[f]===h[x]&&(k+=u[t][f],M++);k/=M,k<j&&(j=k)}l[t]=(j-i)/Math.max(i,j)}return l}I(silhouetteCoefficient,"silhouetteCoefficient");export function dunnIndex(o,e,s="max",h="centroid"){const r=e.length,u=o[0].length,l=[...new Set(e)],t=l.length,i=I((n,c)=>Math.sqrt(n.reduce((g,y,A)=>g+(y-c[A])**2,0)),"dist"),a=Array(t).fill(0),j=[];for(let n=0;n<r;n++){const c=l.indexOf(e[n]);j[n]=c,a[c]++}const x=[];if(s==="centroid"||h==="centroid")for(let n=0;n<t;n++){x[n]=Array(u).fill(0);for(let c=0;c<r;c++)if(e[c]===l[n])for(let g=0;g<u;g++)x[n][g]+=o[c][g];x[n]=x[n].map(c=>c/a[n])}const k=[];for(let n=0;n<t;n++)if(s==="max"){let c=0;for(let g=0;g<r;g++)if(e[g]===l[n])for(let y=0;y<g;y++){if(e[y]!==l[n])continue;const A=i(o[g],o[y]);c<A&&(c=A)}k[n]=c}else if(s==="mean"){let c=0;for(let g=0;g<r;g++)if(e[g]===l[n])for(let y=0;y<r;y++)g===y||e[y]!==l[n]||(c+=i(o[g],o[y]));k[n]=2*c/(a[n]*(a[n]-1))}else if(s==="centroid"){let c=0;for(let g=0;g<r;g++)e[g]===l[n]&&(c+=i(o[g],x[n]));k[n]=c/a[n]}const M=Array.from({length:t},()=>[]);if(h==="centroid")for(let n=0;n<t;n++)for(let c=0;c<n;c++)M[n][c]=i(x[n],x[c]);const f=Math.max(...k);let m=1/0;for(let n=0;n<t;n++)for(let c=0;c<n;c++)m>M[n][c]&&(m=M[n][c]);return m/f}I(dunnIndex,"dunnIndex");export function purity(o,e){const s=o.length,h=[...new Set(o)];let r=0;for(let u=0;u<h.length;u++){const l={};let t=0;for(let i=0;i<s;i++)o[i]===h[u]&&(l[e[i]]||(l[e[i]]=0),l[e[i]]++,t<l[e[i]]&&(t=l[e[i]]));r+=t}return r/s}I(purity,"purity");export function randIndex(o,e){const s=o.length;let h=0;for(let r=0;r<s;r++)for(let u=r+1;u<s;u++)(o[r]===o[u]&&e[r]===e[u]||o[r]!==o[u]&&e[r]!==e[u])&&h++;return h/(s*(s-1)/2)}I(randIndex,"randIndex");export function diceIndex(o,e,s=1){const h=o.length;let r=0,u=0,l=0;for(let t=0;t<h;t++)for(let i=t+1;i<h;i++)o[t]===o[i]&&e[t]===e[i]?r++:o[t]===o[i]&&e[t]!==e[i]?u++:o[t]!==o[i]&&e[t]===e[i]&&l++;return(1+s**2)*r/((1+s**2)*r+s**2*l+u)}I(diceIndex,"diceIndex");export function jaccardIndex(o,e){const s=o.length;let h=0,r=0,u=0;for(let l=0;l<s;l++)for(let t=l+1;t<s;t++)o[l]===o[t]&&e[l]===e[t]?h++:o[l]===o[t]&&e[l]!==e[t]?r++:o[l]!==o[t]&&e[l]===e[t]&&u++;return h/(h+r+u)}I(jaccardIndex,"jaccardIndex");export function fowlkesMallowsIndex(o,e){const s=o.length;let h=0,r=0,u=0;for(let l=0;l<s;l++)for(let t=l+1;t<s;t++)o[l]===o[t]&&e[l]===e[t]?h++:o[l]===o[t]&&e[l]!==e[t]?r++:o[l]!==o[t]&&e[l]===e[t]&&u++;return h/Math.sqrt((h+r)*(h+u))}I(fowlkesMallowsIndex,"fowlkesMallowsIndex");
