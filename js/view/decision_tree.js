import Matrix from"../../lib/util/matrix.js";import{DecisionTreeClassifier,DecisionTreeRegression}from"../../lib/model/decision_tree.js";class DecisionTreePlotter{constructor(t){this._platform=t,this._mode=t.task,this._svg=t.svg,this._r=null,this._lineEdge=[]}remove(){this._svg.select(".separation").remove()}plot(t){if(this._svg.select(".separation").remove(),0!==this._platform.datas.length&&(1===this._platform.datas.dimension?this._r=this._svg.insert("g").attr("class","separation"):this._r=this._svg.insert("g",":first-child").attr("class","separation").attr("opacity",.5),this._lineEdge=[],this._dispRange(t._tree),1===this._platform.datas.dimension)){const t=d3.line().x((t=>t[0])).y((t=>t[1]));this._r.append("path").attr("stroke","red").attr("fill-opacity",0).attr("d",t(this._lineEdge))}}_dispRange(t,e){if(e=e||this._platform.datas.domain,t.isLeaf()){const i=this._r;let a=0,s=0;if("CF"===this._mode?t.value.value.forEach(((t,e)=>{t>s&&(s=t,a=e)})):a=t.value.value,1===this._platform.datas.dimension){const t=this._platform._renderer.toPoint([e[0][0],a]),i=this._platform._renderer.toPoint([e[0][1],a]);this._lineEdge.push(t),this._lineEdge.push(i)}else{const t=this._platform._renderer.toPoint([e[0][0],e[1][0]]),s=this._platform._renderer.toPoint([e[0][1],e[1][1]]);i.append("rect").attr("x",t[0]).attr("y",t[1]).attr("width",s[0]-t[0]).attr("height",s[1]-t[1]).attr("fill",getCategoryColor(a))}}else t.forEach(((i,a)=>{let s=[[].concat(e[0]),[].concat(e[1])],r=0===a?1:0;s[t.value.feature][r]=t.value.threshold,this._dispRange(i,s)}))}}var dispDTree=function(t,e){const i=e.task,a=new DecisionTreePlotter(e);let s=null;const r=function(){if("FS"===e.task){const t=s.importance().map(((t,e)=>[t,e]));t.sort(((t,e)=>e[0]-t[0]));const i=e.dimension,a=t.map((t=>t[1])).slice(0,i),r=Matrix.fromArray(e.trainInput);e.trainResult=r.col(a).toArray()}else if(e.datas.dimension<=2)a.plot(s);else{let t=s.predict(e.testInput(2));e.testResult(t)}e.evaluate(((t,e)=>{e(s.predict(t))}))},n="CF"===i?["CART","ID3"]:["CART"];return t.append("select").attr("name","method").selectAll("option").data(n).enter().append("option").attr("value",(t=>t)).text((t=>t)),t.append("input").attr("type","button").attr("value","Initialize").on("click",(()=>{if("CF"===i){const e=t.select("[name=method]").property("value");s=new DecisionTreeClassifier(e)}else s=new DecisionTreeRegression;s.init(e.trainInput,e.trainOutput.map((t=>t[0]))),r(),t.select("[name=depthnumber]").text(s.depth)})),t.append("input").attr("type","button").attr("value","Separate").on("click",(()=>{s&&(s.fit(),r(),t.select("[name=depthnumber]").text(s.depth))})),t.append("span").attr("name","depthnumber").text("0"),t.append("span").text(" depth "),()=>{a.remove()}};export default function(t){t.setting.ml.usage='Click and add data point. Next, click "Initialize". Finally, click "Separate".',t.setting.terminate=dispDTree(t.setting.ml.configElement,t)}