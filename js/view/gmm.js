import Matrix from"../../lib/util/matrix.js";import{GMM,SemiSupervisedGMM,GMR}from"../../lib/model/gmm.js";import Controller from"../controller.js";class GMMPlotter{constructor(t,e,r=!1){this._r=t.append("g").attr("class","centroids2"),this._model=e,this._size=0,this._circle=[],this._grayscale=r,this._duration=200}terminate(){this._r.remove()}_set_el_attr(t,e){if(!this._model._m[e])return;const r=this._model._m[e].value,a=this._model._s[e].value,i=(a[0]+a[3]+Math.sqrt((a[0]-a[3])**2+4*a[1]**2))/2,s=(a[0]+a[3]-Math.sqrt((a[0]-a[3])**2+4*a[1]**2))/2;let n=360*Math.atan((i-a[0])/a[1])/(2*Math.PI);isNaN(n)&&(n=0),t.attr("rx",2.146*Math.sqrt(i)*1e3).attr("ry",2.146*Math.sqrt(s)*1e3).attr("transform","translate("+1e3*r[0]+","+1e3*r[1]+") rotate("+n+")")}add(t){this._size++;const e=this._r.append("ellipse").attr("cx",0).attr("cy",0).attr("stroke",this._grayscale?"gray":getCategoryColor(t||this._size)).attr("stroke-width",2).attr("fill-opacity",0);this._set_el_attr(e,this._size-1),this._circle.push(e)}clear(){this._circle.forEach((t=>t.remove())),this._circle=[],this._size=0}move(){this._circle.forEach(((t,e)=>{this._set_el_attr(t.transition().duration(this._duration),e)}))}}var dispGMM=function(t,e){const r=e.svg,a=e.task,i=new Controller(e),s="CT"!==a&&"SC"!==a&&"RG"!==a;let n=new GMM;"SC"===a?n=new SemiSupervisedGMM:"RG"===a&&(n=new GMR);const l=new GMMPlotter(r,n,s),p=(r,i)=>{if("AD"===a){const a=+t.select("[name=threshold]").property("value");r&&n.fit(e.trainInput);const i=n.probability(e.trainInput).map((t=>1-t.reduce(((t,e)=>t*Math.exp(-e)),1)<a));e.trainResult=i;const s=n.probability(e.testInput(3)).map((t=>1-t.reduce(((t,e)=>t*Math.exp(-e)),1)<a));e.testResult(s)}else if("DE"===a){r&&n.fit(e.trainInput);const t=n.probability(e.testInput(8)).map((t=>Math.max(...t))),a=Math.min(...t),i=Math.max(...t);e.testResult(t.map((t=>specialCategory.density((t-a)/(i-a)))))}else if("SC"===a){r&&n.fit(e.trainInput,e.trainOutput.map((t=>t[0]))),e.trainResult=n.predict(e.trainInput);const t=n.predict(e.testInput(4));e.testResult(t)}else if("GR"===a){const t=e.trainInput;r&&n.fit(t);const a=[];if(n._k>0)for(let e=0;e<t.length;e++){let e=Math.random(),r=0;for(;r<n._p.length&&!((e-=n._p[r])<=0);r++);a.push(Matrix.randn(1,t[0].length,n._m[r],n._s[r]).value)}e.trainResult=a}else if("RG"===a){if(r){n.fit(e.trainInput,e.trainOutput);const t=n.predict(e.testInput(4));e.testResult(t)}}else r&&n.fit(e.trainInput),e.trainResult=n.predict(e.trainInput).map((t=>t+1));"RG"===a||(l.move(),e.centroids(n._m.map((t=>t.value)),s?0:"SC"===a?n.categories:n._m.map(((t,e)=>e+1)),{duration:200})),t.select("[name=clusternumber]").text(n._k+" clusters")},o=i.stepLoopButtons();return"SC"===a?o.init((()=>{n.clear(),n.init(e.trainInput,e.trainOutput.map((t=>t[0])));for(let t=0;t<n._k;t++)l.add(n.categories[t]);p(!1)})):t.append("input").attr("type","button").attr("value","Add cluster").on("click",(()=>{n.add(),l.add(),p(!1)})),t.append("span").attr("name","clusternumber").style("padding","0 10px").text("0 clusters"),"AD"===a&&(t.append("span").text(" threshold = "),t.append("input").attr("type","number").attr("name","threshold").attr("value",.5).attr("min",0).attr("max",1).property("required",!0).attr("step",.1).on("change",(()=>p(!1)))),o.step((t=>{p(!0),setTimeout((()=>t&&t()),200)})),"SC"!==a&&t.append("input").attr("type","button").attr("value","Clear").on("click",(()=>{n&&n.clear(),l.clear(),t.select("[name=clusternumber]").text("0 clusters"),e.init()})),()=>{l.terminate()}};export default function(t){t.setting.ml.usage='Click and add data point. Finally, click "Step" button repeatedly.',t.setting.terminate=dispGMM(t.setting.ml.configElement,t)}