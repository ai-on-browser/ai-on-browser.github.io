var b=Object.defineProperty;var m=(t,n)=>b(t,"name",{value:n,configurable:!0});import v from"../../lib/util/matrix.js";import{GMM as k,SemiSupervisedGMM as w,GMR as y}from"../../lib/model/gmm.js";import f from"../controller.js";import{specialCategory as x,getCategoryColor as I}from"../utils.js";class C{static{m(this,"GMMPlotter")}constructor(n,i,c=!1){this._r=document.createElementNS("http://www.w3.org/2000/svg","g"),n.append(this._r),this._model=i,this._size=0,this._circle=[],this._grayscale=c,this._duration=200}terminate(){this._r.remove()}_set_el_attr(n,i){if(!this._model._m[i])return;const c=this._model._m[i].value,r=this._model._s[i].value,e=(r[0]+r[3]+Math.sqrt((r[0]-r[3])**2+4*r[1]**2))/2,_=(r[0]+r[3]-Math.sqrt((r[0]-r[3])**2+4*r[1]**2))/2,d=2.146;let p=360*Math.atan((e-r[0])/r[1])/(2*Math.PI);isNaN(p)&&(p=0),n.setAttribute("rx",d*Math.sqrt(e)*1e3),n.setAttribute("ry",d*Math.sqrt(_)*1e3),n.setAttribute("transform","translate("+c[0]*1e3+","+c[1]*1e3+") rotate("+p+")")}add(n){this._size++;const i=document.createElementNS("http://www.w3.org/2000/svg","ellipse");i.setAttribute("cx",0),i.setAttribute("cy",0),i.setAttribute("stroke",this._grayscale?"gray":I(n||this._size)),i.setAttribute("stroke-width",2),i.setAttribute("fill-opacity",0),i.style.transitionDuration=this._duration+"ms",this._r.append(i),this._set_el_attr(i,this._size-1),this._circle.push(i)}clear(){this._circle.forEach(n=>n.remove()),this._circle=[],this._size=0}move(){this._circle.forEach((n,i)=>{this._set_el_attr(n,i)})}}export default function R(t){t.setting.ml.usage='Click and add data point. Finally, click "Step" button repeatedly.',t.setting.ml.reference={title:"Mixture model (Wikipedia)",url:"https://en.wikipedia.org/wiki/Mixture_model#Gaussian_mixture_model"};const n=t.svg,i=t.task,c=new f(t),r=i!=="CT"&&i!=="SC"&&i!=="RG";let e=new k;i==="SC"?e=new w:i==="RG"&&(e=new y);const _=new C(n,e,r),d=m((a,A)=>{if(i==="AD"){a&&e.fit(t.trainInput);const s=e.probability(t.trainInput).map(h=>1-h.reduce((l,o)=>l*Math.exp(-o),1)<M.value);t.trainResult=s;const u=e.probability(t.testInput(3)).map(h=>1-h.reduce((l,o)=>l*Math.exp(-o),1)<M.value);t.testResult(u)}else if(i==="DE"){a&&e.fit(t.trainInput);const s=e.probability(t.testInput(8)).map(l=>Math.max(...l)),u=Math.min(...s),h=Math.max(...s);t.testResult(s.map(l=>x.density((l-u)/(h-u))))}else if(i==="SC"){a&&e.fit(t.trainInput,t.trainOutput.map(u=>u[0])),t.trainResult=e.predict(t.trainInput);const s=e.predict(t.testInput(4));t.testResult(s)}else if(i==="GR"){const s=t.trainInput;a&&e.fit(s);const u=[];if(e._k>0)for(let h=0;h<s.length;h++){let l=Math.random(),o=0;for(;o<e._p.length&&!((l-=e._p[o])<=0);o++);u.push(v.randn(1,s[0].length,e._m[o],e._s[o]).value)}t.trainResult=u}else if(i==="RG"){if(a){e.fit(t.trainInput,t.trainOutput);const s=e.predict(t.testInput(4));t.testResult(s)}}else a&&e.fit(t.trainInput),t.trainResult=e.predict(t.trainInput).map(s=>s+1);i==="RG"||(_.move(),t.centroids(e._m.map(s=>s.value),r?0:i==="SC"?e.categories:e._m.map((s,u)=>u+1),{duration:200})),g.value=e._k+" clusters"},"fitModel"),p=c.stepLoopButtons();i==="SC"?p.init(()=>{e.clear(),e.init(t.trainInput,t.trainOutput.map(a=>a[0]));for(let a=0;a<e._k;a++)_.add(e.categories[a]);d(!1)}):c.input.button("Add cluster").on("click",()=>{e.add(),_.add(),d(!1)});const g=c.text("0 clusters");let M=null;i==="AD"&&(M=c.input.number({label:" threshold = ",min:0,max:1,step:.1,value:.5}).on("change",()=>d(!1))),p.step(a=>{d(!0),setTimeout(()=>a&&a(),200)}),i!=="SC"&&c.input.button("Clear").on("click",()=>{e&&e.clear(),_.clear(),g.value="0 clusters",t.init()}),t.setting.terminate=()=>{_.terminate()}}m(R,"default");
