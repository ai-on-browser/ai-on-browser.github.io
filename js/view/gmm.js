var b=Object.defineProperty;var m=(e,n)=>b(e,"name",{value:n,configurable:!0});import v from"../../lib/util/matrix.js";import{GMM as w,SemiSupervisedGMM as k,GMR as y}from"../../lib/model/gmm.js";import f from"../controller.js";import{specialCategory as x,getCategoryColor as I}from"../utils.js";class C{static{m(this,"GMMPlotter")}constructor(n,s,c=!1){this._r=document.createElementNS("http://www.w3.org/2000/svg","g"),n.append(this._r),this._model=s,this._size=0,this._circle=[],this._grayscale=c,this._duration=200}terminate(){this._r.remove()}_set_el_attr(n,s){if(!this._model._m[s])return;const c=this._model._m[s].value,r=this._model._s[s].value,t=(r[0]+r[3]+Math.sqrt((r[0]-r[3])**2+4*r[1]**2))/2,_=(r[0]+r[3]-Math.sqrt((r[0]-r[3])**2+4*r[1]**2))/2,d=2.146;let p=360*Math.atan((t-r[0])/r[1])/(2*Math.PI);isNaN(p)&&(p=0),n.setAttribute("rx",d*Math.sqrt(t)*1e3),n.setAttribute("ry",d*Math.sqrt(_)*1e3),n.setAttribute("transform","translate("+c[0]*1e3+","+c[1]*1e3+") rotate("+p+")")}add(n){this._size++;const s=document.createElementNS("http://www.w3.org/2000/svg","ellipse");s.setAttribute("cx",0),s.setAttribute("cy",0),s.setAttribute("stroke",this._grayscale?"gray":I(n||this._size)),s.setAttribute("stroke-width",2),s.setAttribute("fill-opacity",0),s.style.transitionDuration=this._duration+"ms",this._r.append(s),this._set_el_attr(s,this._size-1),this._circle.push(s)}clear(){this._circle.forEach(n=>n.remove()),this._circle=[],this._size=0}move(){this._circle.forEach((n,s)=>{this._set_el_attr(n,s)})}}export default function R(e){e.setting.ml.usage='Click and add data point. Finally, click "Step" button repeatedly.',e.setting.ml.reference={title:"Mixture model (Wikipedia)",url:"https://en.wikipedia.org/wiki/Mixture_model#Gaussian_mixture_model"};const n=e.svg,s=e.task,c=new f(e),r=s!=="CT"&&s!=="SC"&&s!=="RG";let t=new w;s==="SC"?t=new k:s==="RG"&&(t=new y);const _=new C(n,t,r),d=m((a,A)=>{if(s==="AD"){a&&t.fit(e.trainInput);const i=t.probability(e.trainInput).map(h=>1-h.reduce((l,o)=>l*Math.exp(-o),1)<M.value);e.trainResult=i;const u=t.probability(e.testInput(3)).map(h=>1-h.reduce((l,o)=>l*Math.exp(-o),1)<M.value);e.testResult(u)}else if(s==="DE"){a&&t.fit(e.trainInput);const i=t.probability(e.testInput(8)).map(l=>Math.max(...l)),u=Math.min(...i),h=Math.max(...i);e.testResult(i.map(l=>x.density((l-u)/(h-u))))}else if(s==="SC"){a&&t.fit(e.trainInput,e.trainOutput.map(u=>u[0])),e.trainResult=t.predict(e.trainInput);const i=t.predict(e.testInput(4));e.testResult(i)}else if(s==="GR"){const i=e.trainInput;a&&t.fit(i);const u=[];if(t._k>0)for(let h=0;h<i.length;h++){let l=Math.random(),o=0;for(;o<t._p.length&&!((l-=t._p[o])<=0);o++);u.push(v.randn(1,i[0].length,t._m[o],t._s[o]).value)}e.trainResult=u}else if(s==="RG"){if(a){t.fit(e.trainInput,e.trainOutput);const i=t.predict(e.testInput(4));e.testResult(i)}}else a&&t.fit(e.trainInput),e.trainResult=t.predict(e.trainInput).map(i=>i+1);s==="RG"||(_.move(),e.centroids(t._m.map(i=>i.value),r?0:s==="SC"?t.categories:t._m.map((i,u)=>u+1),{duration:200})),g.value=t._k+" clusters"},"fitModel"),p=c.stepLoopButtons();s==="SC"?p.init(()=>{t.clear(),t.init(e.trainInput,e.trainOutput.map(a=>a[0]));for(let a=0;a<t._k;a++)_.add(t.categories[a]);d(!1)}):c.input.button("Add cluster").on("click",()=>{t.add(),_.add(),d(!1)});const g=c.text("0 clusters");let M=null;return s==="AD"&&(M=c.input.number({label:" threshold = ",min:0,max:1,step:.1,value:.5}).on("change",()=>d(!1))),p.step(async()=>{d(!0),await new Promise(a=>setTimeout(a,200))}),s!=="SC"&&c.input.button("Clear").on("click",()=>{t&&t.clear(),_.clear(),g.value="0 clusters",e.init()}),()=>{_.terminate()}}m(R,"default");
