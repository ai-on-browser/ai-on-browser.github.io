import{Matrix}from"../../lib/util/math.js";import{GMM,SemiSupervisedGMM,GMR}from"../../lib/model/gmm.js";class GMMPlotter{constructor(t,e,a=!1){this._r=t.append("g").attr("class","centroids2"),this._model=e,this._size=0,this._circle=[],this._grayscale=a,this._duration=200}terminate(){this._r.remove()}_set_el_attr(t,e){if(!this._model._m[e])return;const a=this._model._m[e].value,r=this._model._s[e].value,i=(r[0]+r[3]+Math.sqrt((r[0]-r[3])**2+4*r[1]**2))/2,s=(r[0]+r[3]-Math.sqrt((r[0]-r[3])**2+4*r[1]**2))/2;let n=360*Math.atan((i-r[0])/r[1])/(2*Math.PI);isNaN(n)&&(n=0),t.attr("rx",2.146*Math.sqrt(i)*1e3).attr("ry",2.146*Math.sqrt(s)*1e3).attr("transform","translate("+1e3*a[0]+","+1e3*a[1]+") rotate("+n+")")}add(){this._size++;const t=this._r.append("ellipse").attr("cx",0).attr("cy",0).attr("stroke",this._grayscale?"gray":getCategoryColor(this._size)).attr("stroke-width",2).attr("fill-opacity",0);this._set_el_attr(t,this._size-1),this._circle.push(t)}clear(){this._circle.forEach((t=>t.remove())),this._circle=[],this._size=0}move(){this._circle.forEach(((t,e)=>{this._set_el_attr(t.transition().duration(this._duration),e)}))}}var dispGMM=function(t,e){const a=e.svg,r=e.task,i="CT"!==r&&"SC"!==r&&"RG"!==r;let s=new GMM;"SC"===r?s=new SemiSupervisedGMM:"RG"===r&&(s=new GMR);const n=new GMMPlotter(a,s,i),l=(a,l)=>{"AD"===r?e.fit(((r,i,n)=>{const l=+t.select("[name=threshold]").property("value");a&&s.fit(r);n(s.probability(r).map((t=>1-t.reduce(((t,e)=>t*Math.exp(-e)),1)<l))),e.predict(((t,e)=>{e(s.probability(t).map((t=>1-t.reduce(((t,e)=>t*Math.exp(-e)),1)<l)))}),3)})):"DE"===r?e.fit(((t,r)=>{a&&s.fit(t),e.predict(((t,e)=>{const a=s.probability(t).map((t=>Math.max(...t))),r=Math.min(...a),i=Math.max(...a);e(a.map((t=>specialCategory.density((t-r)/(i-r)))))}),8)})):"SC"===r?e.fit(((t,r,i)=>{a&&s.fit(t,r.map((t=>t[0]))),i(s.predict(t).map((t=>t+1))),e.predict(((t,e)=>{e(s.predict(t).map((t=>t+1)))}),4)})):"GR"===r?e.fit(((t,e,r)=>{a&&s.fit(t);const i=[];if(s._k>0)for(let e=0;e<t.length;e++){let e=Math.random(),a=0;for(;a<s._p.length&&!((e-=s._p[a])<=0);a++);i.push(Matrix.randn(1,t[0].length,s._m[a],s._s[a]).value)}r(i)})):"RG"===r?e.fit(((t,r)=>{a&&(s.fit(t,r),e.predict(((t,e)=>{e(s.predict(t))}),4))})):e.fit(((t,e,r)=>{a&&s.fit(t),r(s.predict(t).map((t=>t+1)))})),"RG"===r||(n.move(),e.centroids(s._m.map((t=>t.value)),i?0:s._m.map(((t,e)=>e+1)),{duration:200})),t.select("[name=clusternumber]").text(s._k+" clusters")},p=e.setting.ml.controller.stepLoopButtons();return"SC"===r?p.init((()=>{e.fit(((t,e)=>{s.clear(),s.init(t,e.map((t=>t[0])));for(let t=0;t<s._k;t++)s.add(),n.add();l(!1)}))})):t.append("input").attr("type","button").attr("value","Add cluster").on("click",(()=>{s.add(),n.add(),l(!1)})),t.append("span").attr("name","clusternumber").style("padding","0 10px").text("0 clusters"),"AD"===r&&(t.append("span").text(" threshold = "),t.append("input").attr("type","number").attr("name","threshold").attr("value",.5).attr("min",0).attr("max",1).property("required",!0).attr("step",.1).on("change",(()=>l(!1)))),p.step((t=>{l(!0),setTimeout((()=>t&&t()),200)})),"SC"!==r&&t.append("input").attr("type","button").attr("value","Clear").on("click",(()=>{s&&s.clear(),n.clear(),t.select("[name=clusternumber]").text("0 clusters"),e.init()})),()=>{n.terminate()}};export default function(t){t.setting.ml.usage='Click and add data point. Finally, click "Step" button repeatedly.',t.setting.terminate=dispGMM(t.setting.ml.configElement,t)}