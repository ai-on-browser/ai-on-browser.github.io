var y=Object.defineProperty;var r=(t,a)=>y(t,"name",{value:a,configurable:!0});import{XGBoost as b,XGBoostClassifier as g}from"../../lib/model/xgboost.js";import C from"../controller.js";var k=r(function(t,a){const d=new C(a),l=a.task;let e=null;const c=r(p=>{const i=+t.select("[name=lambda]").property("value"),s=+t.select("[name=lr]").property("value"),u=+t.select("[name=maxd]").property("value"),x=+t.select("[name=itr]").property("value"),o=+t.select("input[name=srate]").property("value");e||(l==="CF"?(e=new g(u,o,i,s),e.init(a.trainInput,a.trainOutput.map(n=>n[0]))):(e=new b(u,o,i,s),e.init(a.trainInput,a.trainOutput)));for(let n=0;n<x;n++)e.fit();let v=e.predict(a.testInput(4));a.testResult(v),p&&p()},"fitModel");t.append("span").text(" max depth = "),t.append("input").attr("type","number").attr("name","maxd").attr("value",1).attr("min",1).attr("max",10),t.append("span").text(" Sampling rate "),t.append("input").attr("type","number").attr("name","srate").property("value",.8).attr("min",.1).attr("max",1).attr("step",.1),t.append("span").text(" lambda = "),t.append("input").attr("type","number").attr("name","lambda").attr("value",.1).attr("min",.1).attr("max",10).attr("step",.1),t.append("span").text(" learning rate = "),t.append("input").attr("type","number").attr("name","lr").attr("value",.1).attr("min",0).attr("max",10).attr("step",.1);const m=d.stepLoopButtons().init(()=>{e=null,a.init()});t.append("span").text(" Iteration "),t.append("input").attr("type","number").attr("name","itr").attr("value",1).attr("min",1).attr("max",100),m.step(c).epoch(()=>e.size)},"dispXGBoost");export default function B(t){t.setting.ml.usage='Click and add data point. Next, click "Fit" button.',k(t.setting.ml.configElement,t)}r(B,"default");
