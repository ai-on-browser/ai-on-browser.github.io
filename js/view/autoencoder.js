var B=Object.defineProperty;var v=(e,t)=>B(e,"name",{value:t,configurable:!0});import A from"../../lib/util/matrix.js";import C from"../controller.js";import f from"../neuralnetwork_builder.js";import{BaseWorker as D}from"../utils.js";class N extends D{static{v(this,"AutoencoderWorker")}constructor(){super("js/view/worker/model_worker.js",{type:"module"})}initialize(t,n,a,r,u){return this._postMessage({name:"autoencoder",method:"constructor",arguments:[t,n,a,r,u]})}epoch(){return this._postMessage({name:"autoencoder",method:"epoch"}).then(t=>t.data)}fit(t,n,a,r,u){return this._postMessage({name:"autoencoder",method:"fit",arguments:[t,n,a,r,u]}).then(p=>p.data)}predict(t){return this._postMessage({name:"autoencoder",method:"predict",arguments:[t]}).then(n=>n.data)}reduce(t){return this._postMessage({name:"autoencoder",method:"reduce",arguments:[t]}).then(n=>n.data)}}export default function j(e){e.setting.ml.usage='Click and add data point. Next, click "Initialize". Finally, click "Fit" button repeatedly.';const t=e.task,n=new C(e),a=new N;let r=0;const u=v(async()=>{if(t==="AD"){const s=e.trainInput,l=await a.fit(s,+g.value,w.value,b.value,x.value);e.plotLoss(l);const k=e.testInput(4),I=[].concat(s,k),y=await a.predict(I),c=y.data.slice(0,s.length),h=y.data.slice(s.length),z=s[0].length,M=[];for(let i=0;i<c.length;i++){let d=0;for(let o=0;o<z;o++)d+=(c[i][o]-s[i][o])**2;M.push(d>_.value)}const R=[];for(let i=0;i<h.length;i++){let d=0;for(let o=0;o<z;o++)d+=(h[i][o]-k[i][o])**2;R.push(d>_.value)}e.trainResult=M,e.testResult(R),r=await a.epoch()}else if(t==="CT"){const l=await a.fit(e.trainInput,+g.value,w.value,b.value,x.value);e.plotLoss(l);const I=A.fromArray(await a.reduce(e.trainInput)).argmax(1).value.map(h=>h+1),c=A.fromArray(await a.reduce(e.testInput(8))).argmax(1);c.add(1),e.trainResult=I,e.testResult(c.value),r=await a.epoch()}else{const s=await a.fit(e.trainInput,+g.value,w.value,b.value,x.value);e.plotLoss(s),e.trainResult=await a.reduce(e.trainInput),r=await a.epoch()}},"fitModel");let p=null;t!=="DR"&&(p=n.input.number({label:" Size ",min:1,max:100,value:10}));const m=new f;m.makeHtml(n,{optimizer:!0});const L=n.stepLoopButtons().init(s=>{if(e.init(),e.datas.length===0){s();return}const l=p?.value??e.dimension;a.initialize(e.datas.dimension,l,m.layers,m.invlayers,m.optimizer).then(s)}),g=n.select({label:" Iteration ",values:[1,10,100,1e3,1e4]}),w=n.input.number({label:" Learning rate ",min:0,max:100,step:.01,value:.001}),b=n.input.number({label:" Batch size ",min:1,max:100,value:10}),x=n.input.number({label:" Sparse rho ",min:0,max:1,step:.01,value:.02});let _=null;return t==="AD"&&(_=n.input.number({label:" threshold = ",min:0,max:10,step:.01,value:.02})),L.step(()=>u()).epoch(()=>r),()=>{a.terminate()}}v(j,"default");
