var I=Object.defineProperty;var v=(t,e)=>I(t,"name",{value:e,configurable:!0});import f from"../neuralnetwork_builder.js";import A from"../../lib/util/matrix.js";import z from"../controller.js";import{BaseWorker as M}from"../utils.js";class R extends M{static{v(this,"AutoencoderWorker")}constructor(){super("js/view/worker/autoencoder_worker.js",{type:"module"})}initialize(e,a,r,n,i){return this._postMessage({mode:"init",input_size:e,reduce_size:a,enc_layers:r,dec_layers:n,optimizer:i})}fit(e,a,r,n,i){return this._postMessage({mode:"fit",x:e,iteration:a,rate:r,batch:n,rho:i}).then(c=>c.data)}predict(e){return this._postMessage({mode:"predict",x:e})}reduce(e){return this._postMessage({mode:"reduce",x:e}).then(a=>a.data)}}var C=v(function(t,e,a){return async n=>{const i=+t.select("[name=iteration]").property("value"),c=+t.select("[name=batch]").property("value"),d=+t.select("[name=rate]").property("value"),o=+t.select("[name=rho]").property("value"),p=await e.fit(a.trainInput,i,d,c,o);a.plotLoss(p.loss);const h=A.fromArray(await e.reduce(a.trainInput)).argmax(1).value.map(m=>m+1);let y=A.fromArray(await e.reduce(a.testInput(8))).argmax(1);y.add(1),a.trainResult=h,a.testResult(y.value),n&&n(p.epoch)}},"dispAEClt"),E=v(function(t,e,a){return async r=>{const n=+t.select("[name=iteration]").property("value"),i=+t.select("[name=batch]").property("value"),c=+t.select("[name=rate]").property("value"),d=+t.select("[name=rho]").property("value"),o=+t.select("[name=threshold]").property("value"),p=a.trainInput,s=await e.fit(p,n,c,i,d);a.plotLoss(s.loss);const h=a.testInput(4);let g=[].concat(p,h);const y=await e.predict(g);let m=y.data.slice(0,p.length),w=y.data.slice(p.length),b=p[0].length;const k=[];for(let u=0;u<m.length;u++){let x=0;for(let l=0;l<b;l++)x+=(m[u][l]-p[u][l])**2;k.push(x>o)}const _=[];for(let u=0;u<w.length;u++){let x=0;for(let l=0;l<b;l++)x+=(w[u][l]-h[u][l])**2;_.push(x>o)}a.trainResult=k,a.testResult(_),r&&r(s.epoch)}},"dispAEad"),L=v(function(t,e,a){return async r=>{const n=+t.select("[name=iteration]").property("value"),i=+t.select("[name=batch]").property("value"),c=+t.select("[name=rate]").property("value"),d=+t.select("[name=rho]").property("value"),o=await e.fit(a.trainInput,n,c,i,d);a.plotLoss(o.loss),a.trainResult=await e.reduce(a.trainInput),r&&r(o.epoch)}},"dispAEdr"),B=v(function(t,e){const a=e.task,r=new z(e),n=new R;let i=0;const c=a==="AD"?E(t,n,e):a==="CT"?C(t,n,e):L(t,n,e);let d=null;a!=="DR"&&(d=r.input.number({label:" Size ",min:1,max:100,value:10}));const o=new f;o.makeHtml(t,{optimizer:!0});const p=r.stepLoopButtons().init(s=>{if(e.init(),e.datas.length===0){s();return}const h=d?.value??e.dimension;n.initialize(e.datas.dimension,h,o.layers,o.invlayers,o.optimizer).then(s)});return t.append("span").text(" Iteration "),t.append("select").attr("name","iteration").selectAll("option").data([1,10,100,1e3,1e4]).enter().append("option").property("value",s=>s).text(s=>s),t.append("span").text(" Learning rate "),t.append("input").attr("type","number").attr("name","rate").attr("min",0).attr("max",100).attr("step",.01).attr("value",.001),t.append("span").text(" Batch size "),t.append("input").attr("type","number").attr("name","batch").attr("value",10).attr("min",1).attr("max",100).attr("step",1),t.append("span").text(" Sparse rho "),t.append("input").attr("type","number").attr("name","rho").attr("value",.02).attr("min",0).attr("max",1).attr("step",.01),a==="AD"&&(t.append("span").text(" threshold = "),t.append("input").attr("type","number").attr("name","threshold").attr("value",.02).attr("min",0).attr("max",10).attr("step",.01)),p.step(s=>{c(h=>{i=h,s&&s()})}).epoch(()=>i),()=>{n.terminate()}},"dispAE");export default function D(t){t.setting.ml.usage='Click and add data point. Next, click "Initialize". Finally, click "Fit" button repeatedly.',t.setting.terminate=B(t.setting.ml.configElement,t)}v(D,"default");
