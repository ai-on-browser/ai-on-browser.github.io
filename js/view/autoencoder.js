import NeuralNetworkBuilder from"../neuralnetwork_builder.js";import Matrix from"../../lib/util/matrix.js";import Controller from"../controller.js";import{BaseWorker}from"../utils.js";class AutoencoderWorker extends BaseWorker{constructor(){super("js/view/worker/autoencoder_worker.js",{type:"module"})}initialize(t,e,a,r,n){return this._postMessage({mode:"init",input_size:t,reduce_size:e,enc_layers:a,dec_layers:r,optimizer:n})}fit(t,e,a,r,n){return this._postMessage({mode:"fit",x:t,iteration:e,rate:a,batch:r,rho:n}).then((t=>t.data))}predict(t){return this._postMessage({mode:"predict",x:t})}reduce(t){return this._postMessage({mode:"reduce",x:t}).then((t=>t.data))}}var dispAEClt=function(t,e,a){return async r=>{const n=+t.select("[name=iteration]").property("value"),i=+t.select("[name=batch]").property("value"),s=+t.select("[name=rate]").property("value"),o=+t.select("[name=rho]").property("value"),p=await e.fit(a.trainInput,n,s,i,o);a.plotLoss(p.loss);const l=Matrix.fromArray(await e.reduce(a.trainInput)).argmax(1).value.map((t=>t+1));let u=Matrix.fromArray(await e.reduce(a.testInput(8))).argmax(1);u.add(1),a.trainResult=l,a.testResult(u.value),r&&r(p.epoch)}},dispAEad=function(t,e,a){return async r=>{const n=+t.select("[name=iteration]").property("value"),i=+t.select("[name=batch]").property("value"),s=+t.select("[name=rate]").property("value"),o=+t.select("[name=rho]").property("value"),p=+t.select("[name=threshold]").property("value"),l=a.trainInput,u=await e.fit(l,n,s,i,o);a.plotLoss(u.loss);const c=a.testInput(4);let d=[].concat(l,c);const m=await e.predict(d);let h=m.data.slice(0,l.length),y=m.data.slice(l.length),v=l[0].length;const f=[];for(let t=0;t<h.length;t++){let e=0;for(let a=0;a<v;a++)e+=(h[t][a]-l[t][a])**2;f.push(e>p)}const x=[];for(let t=0;t<y.length;t++){let e=0;for(let a=0;a<v;a++)e+=(y[t][a]-c[t][a])**2;x.push(e>p)}a.trainResult=f,a.testResult(x),r&&r(u.epoch)}},dispAEdr=function(t,e,a){return async r=>{const n=+t.select("[name=iteration]").property("value"),i=+t.select("[name=batch]").property("value"),s=+t.select("[name=rate]").property("value"),o=+t.select("[name=rho]").property("value"),p=await e.fit(a.trainInput,n,s,i,o);a.plotLoss(p.loss),a.trainResult=await e.reduce(a.trainInput),r&&r(p.epoch)}},dispAE=function(t,e){const a=e.task,r=new Controller(e),n=new AutoencoderWorker;let i=0;const s="AD"===a?dispAEad(t,n,e):"CT"===a?dispAEClt(t,n,e):dispAEdr(t,n,e);let o=null;"DR"!==a&&(o=r.input.number({label:" Size ",min:1,max:100,value:10}));const p=new NeuralNetworkBuilder;p.makeHtml(t,{optimizer:!0});const l=r.stepLoopButtons().init((t=>{if(e.init(),0===e.datas.length)return void t();const a=o?.value??e.dimension;n.initialize(e.datas.dimension,a,p.layers,p.invlayers,p.optimizer).then(t)}));return t.append("span").text(" Iteration "),t.append("select").attr("name","iteration").selectAll("option").data([1,10,100,1e3,1e4]).enter().append("option").property("value",(t=>t)).text((t=>t)),t.append("span").text(" Learning rate "),t.append("input").attr("type","number").attr("name","rate").attr("min",0).attr("max",100).attr("step",.01).attr("value",.001),t.append("span").text(" Batch size "),t.append("input").attr("type","number").attr("name","batch").attr("value",10).attr("min",1).attr("max",100).attr("step",1),t.append("span").text(" Sparse rho "),t.append("input").attr("type","number").attr("name","rho").attr("value",.02).attr("min",0).attr("max",1).attr("step",.01),"AD"===a&&(t.append("span").text(" threshold = "),t.append("input").attr("type","number").attr("name","threshold").attr("value",.02).attr("min",0).attr("max",10).attr("step",.01)),l.step((t=>{s((e=>{i=e,t&&t()}))})).epoch((()=>i)),()=>{n.terminate()}};export default function(t){t.setting.ml.usage='Click and add data point. Next, click "Initialize". Finally, click "Fit" button repeatedly.',t.setting.terminate=dispAE(t.setting.ml.configElement,t)}