import NeuralNetworkBuilder from"../neuralnetwork_builder.js";import Matrix from"../../lib/util/matrix.js";import Controller from"../controller.js";import{BaseWorker}from"../utils.js";class AutoencoderWorker extends BaseWorker{constructor(){super("js/view/worker/autoencoder_worker.js",{type:"module"})}initialize(t,e,r,a,n,o){this._postMessage({mode:"init",input_size:t,reduce_size:e,enc_layers:r,dec_layers:a,optimizer:n},o)}fit(t,e,r,a,n,o){this._postMessage({mode:"fit",x:t,iteration:e,rate:r,batch:a,rho:n},(t=>o(t.data)))}predict(t,e){this._postMessage({mode:"predict",x:t},e)}reduce(t,e){this._postMessage({mode:"reduce",x:t},(t=>e(t.data)))}}var dispAEClt=function(t,e,r){return a=>{const n=+t.select("[name=iteration]").property("value"),o=+t.select("[name=batch]").property("value"),s=+t.select("[name=rate]").property("value"),i=+t.select("[name=rho]").property("value");e.fit(r.trainInput,n,s,o,i,(t=>{r.plotLoss(t.loss),e.reduce(r.trainInput,(n=>{let o=n;const s=Matrix.fromArray(o).argmax(1).value.map((t=>t+1));e.reduce(r.testInput(8),(e=>{let n=e,o=Matrix.fromArray(n).argmax(1);o.add(1),r.trainResult=s,r.testResult(o.value),a&&a(t.epoch)}))}))}))}},dispAEad=function(t,e,r){return a=>{const n=+t.select("[name=iteration]").property("value"),o=+t.select("[name=batch]").property("value"),s=+t.select("[name=rate]").property("value"),i=+t.select("[name=rho]").property("value"),p=+t.select("[name=threshold]").property("value"),l=r.trainInput;e.fit(l,n,s,o,i,(t=>{r.plotLoss(t.loss);const n=r.testInput(4);let o=[].concat(l,n);e.predict(o,(e=>{let o=e.data.slice(0,l.length),s=e.data.slice(l.length),i=l[0].length;const u=[];for(let t=0;t<o.length;t++){let e=0;for(let r=0;r<i;r++)e+=(o[t][r]-l[t][r])**2;u.push(e>p)}const c=[];for(let t=0;t<s.length;t++){let e=0;for(let r=0;r<i;r++)e+=(s[t][r]-n[t][r])**2;c.push(e>p)}r.trainResult=u,r.testResult(c),a&&a(t.epoch)}))}))}},dispAEdr=function(t,e,r){return a=>{const n=+t.select("[name=iteration]").property("value"),o=+t.select("[name=batch]").property("value"),s=+t.select("[name=rate]").property("value"),i=+t.select("[name=rho]").property("value");e.fit(r.trainInput,n,s,o,i,(t=>{r.plotLoss(t.loss),e.reduce(r.trainInput,(e=>{r.trainResult=e,a&&a(t.epoch)}))}))}},dispAE=function(t,e){const r=e.task,a=new Controller(e),n=new AutoencoderWorker;let o=0;const s="AD"===r?dispAEad(t,n,e):"CT"===r?dispAEClt(t,n,e):dispAEdr(t,n,e);let i=null;"DR"!==r&&(i=a.input.number({label:" Size ",min:1,max:100,value:10}));const p=new NeuralNetworkBuilder;p.makeHtml(t,{optimizer:!0});const l=a.stepLoopButtons().init((()=>{if(e.init(),0===e.datas.length)return;const t=i?.value??e.dimension;n.initialize(e.datas.dimension,t,p.layers,p.invlayers,p.optimizer)}));return t.append("span").text(" Iteration "),t.append("select").attr("name","iteration").selectAll("option").data([1,10,100,1e3,1e4]).enter().append("option").property("value",(t=>t)).text((t=>t)),t.append("span").text(" Learning rate "),t.append("input").attr("type","number").attr("name","rate").attr("min",0).attr("max",100).attr("step",.01).attr("value",.001),t.append("span").text(" Batch size "),t.append("input").attr("type","number").attr("name","batch").attr("value",10).attr("min",1).attr("max",100).attr("step",1),t.append("span").text(" Sparse rho "),t.append("input").attr("type","number").attr("name","rho").attr("value",.02).attr("min",0).attr("max",1).attr("step",.01),"AD"===r&&(t.append("span").text(" threshold = "),t.append("input").attr("type","number").attr("name","threshold").attr("value",.02).attr("min",0).attr("max",10).attr("step",.01)),l.step((t=>{s((e=>{o=e,t&&t()}))})).epoch((()=>o)),()=>{n.terminate()}};export default function(t){t.setting.ml.usage='Click and add data point. Next, click "Initialize". Finally, click "Fit" button repeatedly.',t.setting.terminate=dispAE(t.setting.ml.configElement,t)}