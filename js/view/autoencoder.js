var L=Object.defineProperty;var v=(e,t)=>L(e,"name",{value:t,configurable:!0});import B from"../neuralnetwork_builder.js";import R from"../../lib/util/matrix.js";import C from"../controller.js";import{BaseWorker as D}from"../utils.js";class N extends D{static{v(this,"AutoencoderWorker")}constructor(){super("js/view/worker/autoencoder_worker.js",{type:"module"})}initialize(t,i,n,r,u){return this._postMessage({mode:"init",input_size:t,reduce_size:i,enc_layers:n,dec_layers:r,optimizer:u})}fit(t,i,n,r,u){return this._postMessage({mode:"fit",x:t,iteration:i,rate:n,batch:r,rho:u}).then(p=>p.data)}predict(t){return this._postMessage({mode:"predict",x:t})}reduce(t){return this._postMessage({mode:"reduce",x:t}).then(i=>i.data)}}export default function j(e){e.setting.ml.usage='Click and add data point. Next, click "Initialize". Finally, click "Fit" button repeatedly.';const t=e.task,i=new C(e),n=new N;let r=0;const u=v(async()=>{if(t==="AD"){const s=e.trainInput,o=await n.fit(s,+g.value,x.value,b.value,w.value);e.plotLoss(o.loss);const _=e.testInput(4);let I=[].concat(s,_);const y=await n.predict(I);let c=y.data.slice(0,s.length),h=y.data.slice(s.length),z=s[0].length;const f=[];for(let a=0;a<c.length;a++){let d=0;for(let l=0;l<z;l++)d+=(c[a][l]-s[a][l])**2;f.push(d>k.value)}const M=[];for(let a=0;a<h.length;a++){let d=0;for(let l=0;l<z;l++)d+=(h[a][l]-_[a][l])**2;M.push(d>k.value)}e.trainResult=f,e.testResult(M),r=o.epoch}else if(t==="CT"){const o=await n.fit(e.trainInput,+g.value,x.value,b.value,w.value);e.plotLoss(o.loss);const I=R.fromArray(await n.reduce(e.trainInput)).argmax(1).value.map(h=>h+1);let c=R.fromArray(await n.reduce(e.testInput(8))).argmax(1);c.add(1),e.trainResult=I,e.testResult(c.value),r=o.epoch}else{const s=await n.fit(e.trainInput,+g.value,x.value,b.value,w.value);e.plotLoss(s.loss),e.trainResult=await n.reduce(e.trainInput),r=s.epoch}},"fitModel");let p=null;t!=="DR"&&(p=i.input.number({label:" Size ",min:1,max:100,value:10}));const m=new B;m.makeHtml(e.setting.ml.configElement,{optimizer:!0});const A=i.stepLoopButtons().init(s=>{if(e.init(),e.datas.length===0){s();return}const o=p?.value??e.dimension;n.initialize(e.datas.dimension,o,m.layers,m.invlayers,m.optimizer).then(s)}),g=i.select({label:" Iteration ",values:[1,10,100,1e3,1e4]}),x=i.input.number({label:" Learning rate ",min:0,max:100,step:.01,value:.001}),b=i.input.number({label:" Batch size ",min:1,max:100,value:10}),w=i.input.number({label:" Sparse rho ",min:0,max:1,step:.01,value:.02});let k=null;return t==="AD"&&(k=i.input.number({label:" threshold = ",min:0,max:10,step:.01,value:.02})),A.step(()=>u()).epoch(()=>r),()=>{n.terminate()}}v(j,"default");
