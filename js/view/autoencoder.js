var B=Object.defineProperty;var v=(e,t)=>B(e,"name",{value:t,configurable:!0});import C from"../neuralnetwork_builder.js";import A from"../../lib/util/matrix.js";import f from"../controller.js";import{BaseWorker as D}from"../utils.js";class N extends D{static{v(this,"AutoencoderWorker")}constructor(){super("js/view/worker/model_worker.js",{type:"module"})}initialize(t,a,n,l,r){return this._postMessage({name:"autoencoder",method:"constructor",arguments:[t,a,n,l,r]})}epoch(){return this._postMessage({name:"autoencoder",method:"epoch"}).then(t=>t.data)}fit(t,a,n,l,r){return this._postMessage({name:"autoencoder",method:"fit",arguments:[t,a,n,l,r]}).then(m=>m.data)}predict(t){return this._postMessage({name:"autoencoder",method:"predict",arguments:[t]}).then(a=>a.data)}reduce(t){return this._postMessage({name:"autoencoder",method:"reduce",arguments:[t]}).then(a=>a.data)}}export default function j(e){e.setting.ml.usage='Click and add data point. Next, click "Initialize". Finally, click "Fit" button repeatedly.';const t=e.task,a=new f(e),n=new N;let l=0;const r=v(async()=>{if(t==="AD"){const s=e.trainInput,u=await n.fit(s,+g.value,w.value,b.value,x.value);e.plotLoss(u);const k=e.testInput(4);let I=[].concat(s,k);const y=await n.predict(I);let c=y.data.slice(0,s.length),h=y.data.slice(s.length),z=s[0].length;const M=[];for(let i=0;i<c.length;i++){let d=0;for(let o=0;o<z;o++)d+=(c[i][o]-s[i][o])**2;M.push(d>_.value)}const R=[];for(let i=0;i<h.length;i++){let d=0;for(let o=0;o<z;o++)d+=(h[i][o]-k[i][o])**2;R.push(d>_.value)}e.trainResult=M,e.testResult(R),l=await n.epoch()}else if(t==="CT"){const u=await n.fit(e.trainInput,+g.value,w.value,b.value,x.value);e.plotLoss(u);const I=A.fromArray(await n.reduce(e.trainInput)).argmax(1).value.map(h=>h+1);let c=A.fromArray(await n.reduce(e.testInput(8))).argmax(1);c.add(1),e.trainResult=I,e.testResult(c.value),l=await n.epoch()}else{const s=await n.fit(e.trainInput,+g.value,w.value,b.value,x.value);e.plotLoss(s),e.trainResult=await n.reduce(e.trainInput),l=await n.epoch()}},"fitModel");let m=null;t!=="DR"&&(m=a.input.number({label:" Size ",min:1,max:100,value:10}));const p=new C;p.makeHtml(e.setting.ml.configElement,{optimizer:!0});const L=a.stepLoopButtons().init(s=>{if(e.init(),e.datas.length===0){s();return}const u=m?.value??e.dimension;n.initialize(e.datas.dimension,u,p.layers,p.invlayers,p.optimizer).then(s)}),g=a.select({label:" Iteration ",values:[1,10,100,1e3,1e4]}),w=a.input.number({label:" Learning rate ",min:0,max:100,step:.01,value:.001}),b=a.input.number({label:" Batch size ",min:1,max:100,value:10}),x=a.input.number({label:" Sparse rho ",min:0,max:1,step:.01,value:.02});let _=null;return t==="AD"&&(_=a.input.number({label:" threshold = ",min:0,max:10,step:.01,value:.02})),L.step(()=>r()).epoch(()=>l),()=>{n.terminate()}}v(j,"default");
