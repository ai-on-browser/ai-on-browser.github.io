var B=Object.defineProperty;var g=(e,t)=>B(e,"name",{value:t,configurable:!0});import C from"../neuralnetwork_builder.js";import A from"../../lib/util/matrix.js";import D from"../controller.js";import{BaseWorker as N}from"../utils.js";class j extends N{static{g(this,"AutoencoderWorker")}constructor(){super("js/view/worker/autoencoder_worker.js",{type:"module"})}initialize(t,n,s,o,u){return this._postMessage({mode:"init",input_size:t,reduce_size:n,enc_layers:s,dec_layers:o,optimizer:u})}fit(t,n,s,o,u){return this._postMessage({mode:"fit",x:t,iteration:n,rate:s,batch:o,rho:u}).then(m=>m.data)}predict(t){return this._postMessage({mode:"predict",x:t})}reduce(t){return this._postMessage({mode:"reduce",x:t}).then(n=>n.data)}}export default function F(e){e.setting.ml.usage='Click and add data point. Next, click "Initialize". Finally, click "Fit" button repeatedly.';const t=e.task,n=new D(e),s=new j;let o=0;const u=g(async a=>{if(t==="AD"){const i=e.trainInput,c=await s.fit(i,+x.value,w.value,k.value,_.value);e.plotLoss(c.loss);const I=e.testInput(4);let y=[].concat(i,I);const z=await s.predict(y);let d=z.data.slice(0,i.length),v=z.data.slice(i.length),f=i[0].length;const M=[];for(let l=0;l<d.length;l++){let p=0;for(let r=0;r<f;r++)p+=(d[l][r]-i[l][r])**2;M.push(p>b.value)}const R=[];for(let l=0;l<v.length;l++){let p=0;for(let r=0;r<f;r++)p+=(v[l][r]-I[l][r])**2;R.push(p>b.value)}e.trainResult=M,e.testResult(R),a&&a(c.epoch)}else if(t==="CT"){const c=await s.fit(e.trainInput,+x.value,w.value,k.value,_.value);e.plotLoss(c.loss);const y=A.fromArray(await s.reduce(e.trainInput)).argmax(1).value.map(v=>v+1);let d=A.fromArray(await s.reduce(e.testInput(8))).argmax(1);d.add(1),e.trainResult=y,e.testResult(d.value),a&&a(c.epoch)}else{const i=await s.fit(e.trainInput,+x.value,w.value,k.value,_.value);e.plotLoss(i.loss),e.trainResult=await s.reduce(e.trainInput),a&&a(i.epoch)}},"fitModel");let m=null;t!=="DR"&&(m=n.input.number({label:" Size ",min:1,max:100,value:10}));const h=new C;h.makeHtml(e.setting.ml.configElement,{optimizer:!0});const L=n.stepLoopButtons().init(a=>{if(e.init(),e.datas.length===0){a();return}const i=m?.value??e.dimension;s.initialize(e.datas.dimension,i,h.layers,h.invlayers,h.optimizer).then(a)}),x=n.select({label:" Iteration ",values:[1,10,100,1e3,1e4]}),w=n.input.number({label:" Learning rate ",min:0,max:100,step:.01,value:.001}),k=n.input.number({label:" Batch size ",min:1,max:100,value:10}),_=n.input.number({label:" Sparse rho ",min:0,max:1,step:.01,value:.02});let b=null;return t==="AD"&&(b=n.input.number({label:" threshold = ",min:0,max:10,step:.01,value:.02})),L.step(a=>{u(i=>{o=i,a&&a()})}).epoch(()=>o),()=>{s.terminate()}}g(F,"default");
