import NeuralNetworkBuilder from"../neuralnetwork_builder.js";import Matrix from"../../lib/util/matrix.js";import Controller from"../controller.js";class AutoencoderWorker extends BaseWorker{constructor(){super("js/view/worker/autoencoder_worker.js",{type:"module"})}initialize(t,e,r,a,n,p){this._postMessage({mode:"init",input_size:t,reduce_size:e,enc_layers:r,dec_layers:a,optimizer:n},p)}fit(t,e,r,a,n,p){this._postMessage({mode:"fit",x:t,iteration:e,rate:r,batch:a,rho:n},(t=>p(t.data)))}predict(t,e){this._postMessage({mode:"predict",x:t},e)}reduce(t,e){this._postMessage({mode:"reduce",x:t},(t=>e(t.data)))}}var dispAEClt=function(t,e,r){return a=>{const n=+t.select("[name=iteration]").property("value"),p=+t.select("[name=batch]").property("value"),o=+t.select("[name=rate]").property("value"),s=+t.select("[name=rho]").property("value");e.fit(r.trainInput,n,o,p,s,(t=>{r.plotLoss(t.loss),e.reduce(r.trainInput,(n=>{let p=n;const o=Matrix.fromArray(p).argmax(1).value.map((t=>t+1));e.reduce(r.testInput(8),(e=>{let n=e,p=Matrix.fromArray(n).argmax(1);p.add(1),r.trainResult=o,r.testResult(p.value),a&&a(t.epoch)}))}))}))}},dispAEad=function(t,e,r){return a=>{const n=+t.select("[name=iteration]").property("value"),p=+t.select("[name=batch]").property("value"),o=+t.select("[name=rate]").property("value"),s=+t.select("[name=rho]").property("value"),i=+t.select("[name=threshold]").property("value"),l=r.trainInput;e.fit(l,n,o,p,s,(t=>{r.plotLoss(t.loss);const n=r.testInput(4);let p=[].concat(l,n);e.predict(p,(e=>{let p=e.data.slice(0,l.length),o=e.data.slice(l.length),s=l[0].length;const u=[];for(let t=0;t<p.length;t++){let e=0;for(let r=0;r<s;r++)e+=(p[t][r]-l[t][r])**2;u.push(e>i)}const c=[];for(let t=0;t<o.length;t++){let e=0;for(let r=0;r<s;r++)e+=(o[t][r]-n[t][r])**2;c.push(e>i)}r.trainResult=u,r.testResult(c),a&&a(t.epoch)}))}))}},dispAEdr=function(t,e,r){return a=>{const n=+t.select("[name=iteration]").property("value"),p=+t.select("[name=batch]").property("value"),o=+t.select("[name=rate]").property("value"),s=+t.select("[name=rho]").property("value");e.fit(r.trainInput,n,o,p,s,(t=>{r.plotLoss(t.loss),e.reduce(r.trainInput,(e=>{r.trainResult=e,a&&a(t.epoch)}))}))}},dispAE=function(t,e){const r=e.task,a=new Controller(e),n=new AutoencoderWorker;let p=0;const o="AD"===r?dispAEad(t,n,e):"CT"===r?dispAEClt(t,n,e):dispAEdr(t,n,e);"DR"!==r&&(t.append("span").text(" Size "),t.append("input").attr("type","number").attr("name","node_number").attr("value",10).attr("min",1).attr("max",100).property("required",!0));const s=new NeuralNetworkBuilder;s.makeHtml(t,{optimizer:!0});const i=a.stepLoopButtons().init((()=>{if(e.init(),0===e.datas.length)return;const r=e.dimension||+t.select("[name=node_number]").property("value");n.initialize(e.datas.dimension,r,s.layers,s.invlayers,s.optimizer)}));return t.append("span").text(" Iteration "),t.append("select").attr("name","iteration").selectAll("option").data([1,10,100,1e3,1e4]).enter().append("option").property("value",(t=>t)).text((t=>t)),t.append("span").text(" Learning rate "),t.append("input").attr("type","number").attr("name","rate").attr("min",0).attr("max",100).attr("step",.01).attr("value",.001),t.append("span").text(" Batch size "),t.append("input").attr("type","number").attr("name","batch").attr("value",10).attr("min",1).attr("max",100).attr("step",1),t.append("span").text(" Sparse rho "),t.append("input").attr("type","number").attr("name","rho").attr("value",.02).attr("min",0).attr("max",1).attr("step",.01),"AD"===r&&(t.append("span").text(" threshold = "),t.append("input").attr("type","number").attr("name","threshold").attr("value",.02).attr("min",0).attr("max",10).attr("step",.01)),i.step((t=>{o((e=>{p=e,t&&t()}))})).epoch((()=>p)),()=>{n.terminate()}};export default function(t){t.setting.ml.usage='Click and add data point. Next, click "Initialize". Finally, click "Fit" button repeatedly.',t.setting.terminate=dispAE(t.setting.ml.configElement,t)}