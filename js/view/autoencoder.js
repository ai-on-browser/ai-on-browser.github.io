import NeuralNetworkBuilder from"../neuralnetwork_builder.js";import Matrix from"../../lib/util/matrix.js";import Controller from"../controller.js";class AutoencoderWorker extends BaseWorker{constructor(){super("js/view/worker/autoencoder_worker.js",{type:"module"})}initialize(e,t,r,a,n,p){this._postMessage({mode:"init",input_size:e,reduce_size:t,enc_layers:r,dec_layers:a,optimizer:n},p)}fit(e,t,r,a,n,p){this._postMessage({mode:"fit",x:e,iteration:t,rate:r,batch:a,rho:n},(e=>p(e.data)))}predict(e,t){this._postMessage({mode:"predict",x:e},t)}reduce(e,t){this._postMessage({mode:"reduce",x:e},(e=>t(e.data)))}}var dispAEClt=function(e,t,r){return a=>{const n=+e.select("[name=iteration]").property("value"),p=+e.select("[name=batch]").property("value"),i=+e.select("[name=rate]").property("value"),o=+e.select("[name=rho]").property("value");r.fit(((e,s,l)=>{t.fit(e,n,i,p,o,(n=>{t.reduce(e,(e=>{let p=e;const i=Matrix.fromArray(p).argmax(1).value.map((e=>e+1));r.predict(((e,r)=>{t.reduce(e,(e=>{let t=e,p=Matrix.fromArray(t).argmax(1);p.add(1),l(i),r(p.value),a&&a(n.epoch)}))}),8)}))}))}))}},dispAEad=function(e,t,r){return a=>{const n=+e.select("[name=iteration]").property("value"),p=+e.select("[name=batch]").property("value"),i=+e.select("[name=rate]").property("value"),o=+e.select("[name=rho]").property("value"),s=+e.select("[name=threshold]").property("value");r.fit(((e,l,c)=>{t.fit(e,n,i,p,o,(n=>{r.predict(((r,p)=>{let i=[].concat(e,r);t.predict(i,(t=>{let i=t.data.slice(0,e.length),o=t.data.slice(e.length),l=e[0].length;const d=[];for(let t=0;t<i.length;t++){let r=0;for(let a=0;a<l;a++)r+=(i[t][a]-e[t][a])**2;d.push(r>s)}const u=[];for(let e=0;e<o.length;e++){let t=0;for(let a=0;a<l;a++)t+=(o[e][a]-r[e][a])**2;u.push(t>s)}c(d),p(u),a&&a(n.epoch)}))}),4)}))}))}},dispAEdr=function(e,t,r){return a=>{const n=+e.select("[name=iteration]").property("value"),p=+e.select("[name=batch]").property("value"),i=+e.select("[name=rate]").property("value"),o=+e.select("[name=rho]").property("value");r.fit(((e,r,s)=>{t.fit(e,n,i,p,o,(r=>{t.reduce(e,(e=>{s(e),a&&a(r.epoch)}))}))}))}},dispAE=function(e,t){const r=t.task,a=new Controller(t),n=new AutoencoderWorker;let p=0;const i="AD"===r?dispAEad(e,n,t):"CT"===r?dispAEClt(e,n,t):dispAEdr(e,n,t);"DR"!==r&&(e.append("span").text(" Size "),e.append("input").attr("type","number").attr("name","node_number").attr("value",10).attr("min",1).attr("max",100).property("required",!0));const o=new NeuralNetworkBuilder;o.makeHtml(e,{optimizer:!0});const s=a.stepLoopButtons().init((()=>{if(t.init(),0===t.datas.length)return;const r=t.dimension||+e.select("[name=node_number]").property("value");n.initialize(t.datas.dimension,r,o.layers,o.invlayers,o.optimizer)}));return e.append("span").text(" Iteration "),e.append("select").attr("name","iteration").selectAll("option").data([1,10,100,1e3,1e4]).enter().append("option").property("value",(e=>e)).text((e=>e)),e.append("span").text(" Learning rate "),e.append("input").attr("type","number").attr("name","rate").attr("min",0).attr("max",100).attr("step",.01).attr("value",.001),e.append("span").text(" Batch size "),e.append("input").attr("type","number").attr("name","batch").attr("value",10).attr("min",1).attr("max",100).attr("step",1),e.append("span").text(" Sparse rho "),e.append("input").attr("type","number").attr("name","rho").attr("value",.02).attr("min",0).attr("max",1).attr("step",.01),"AD"===r&&(e.append("span").text(" threshold = "),e.append("input").attr("type","number").attr("name","threshold").attr("value",.02).attr("min",0).attr("max",10).attr("step",.01)),s.step((e=>{i((t=>{p=t,e&&e()}))})).epoch((()=>p)),()=>{n.terminate()}};export default function(e){e.setting.ml.usage='Click and add data point. Next, click "Initialize". Finally, click "Fit" button repeatedly.',e.setting.terminate=dispAE(e.setting.ml.configElement,e)}