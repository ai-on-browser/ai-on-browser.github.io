var p=Object.defineProperty;var m=(i,e)=>p(i,"name",{value:e,configurable:!0});import f from"../../lib/model/vbgmm.js";import v from"../controller.js";import{getCategoryColor as b}from"../utils.js";class w{static{m(this,"VBGMMPlotter")}constructor(e,t,r){this._platform=e,this._r=document.createElementNS("http://www.w3.org/2000/svg","g"),t.append(this._r),this._model=r,this._size=r._k,this._circle=[],this._rm=[],this._duration=200,this._scale=e._renderer[0].scale?.[0]??0;for(let s=0;s<this._size;s++)this.add(s+1)}terminate(){this._r.remove()}add(e){const t=document.createElementNS("http://www.w3.org/2000/svg","ellipse");t.setAttribute("cx",0),t.setAttribute("cy",0),t.setAttribute("stroke",b(e)),t.setAttribute("stroke-width",2),t.setAttribute("fill-opacity",0),t.style.transitionDuration=this._duration+"ms",this._r.append(t),this._set_el_attr(t,this._size-1),this._circle.push(t),this._rm.push(!1)}_set_el_attr(e,t){let r=this._platform.invertScale(this._model.means.row(t).value),s=this._model.covs[t].value;const h=(s[0]+s[3]+Math.sqrt((s[0]-s[3])**2+4*s[1]**2))/2,d=(s[0]+s[3]-Math.sqrt((s[0]-s[3])**2+4*s[1]**2))/2,_=2.146;let n=Math.atan((h-s[0])/s[1]);isNaN(n)&&(n=0);const l=this._platform.invertScale([Array(this._platform.datas.dimension).fill(1),Array(this._platform.datas.dimension).fill(2)]);e.setAttribute("rx",_*Math.sqrt(h)*this._scale),e.setAttribute("ry",_*Math.sqrt(d)*this._scale),e.setAttribute("vector-effect","non-scaling-stroke");const u=l[1][this._platform._renderer[0]._select[0]]-l[0][this._platform._renderer[0]._select[0]],o=l[1][this._platform._renderer[0]._select[1]]-l[0][this._platform._renderer[0]._select[1]];e.setAttribute("transform",`matrix(${Math.cos(n)*u} ${Math.sin(n)*o} ${-Math.sin(n)*u} ${Math.cos(n)*o} ${r[0]*this._scale} ${r[1]*this._scale})`)}move(){for(let e=0;e<this._circle.length;e++)this._model.effectivity[e]||(this._rm[e]||this._circle[e].remove(),this._rm[e]=!0);this._circle.forEach((e,t)=>{this._rm[t]||this._set_el_attr(e,t)})}}export default function M(i){i.setting.ml.usage='Click and add data point. Then, click "Fit" button.';const e=new v(i);let t=null,r=null;const s=m(async()=>{t||(t=new f(h.value,d.value,_.value),t.init(i.trainInput)),t.fit();const l=t.predict(i.trainInput);i.trainResult=l.map(a=>a+1),n.value=t.effectivity.reduce((a,c)=>a+(c?1:0),0),r||(r=new w(i,i.svg,t)),r.move();const u=t.effectivity,o=t.means.toArray().map((a,c)=>[a,c]).filter((a,c)=>u[c]);i.centroids(o.map(a=>a[0]),o.map(a=>a[1]+1),{duration:200}),await new Promise(a=>setTimeout(a,200))},"fitModel"),h=e.input.number({label:" alpha ",min:0,max:10,value:.001}),d=e.input.number({label:" beta ",min:0,max:10,value:.001}),_=e.input.number({label:" k ",min:1,max:1e3,value:10});e.stepLoopButtons().init(()=>{t=null,r?.terminate(),r=null,n.value="0",i.init()}).step(s).epoch();const n=e.text({label:" Clusters: "});return()=>{r?.terminate()}}m(M,"default");
