var M=Object.defineProperty;var o=(e,g)=>M(e,"name",{value:g,configurable:!0});import{CentroidAgglomerativeClustering as W,CompleteLinkageAgglomerativeClustering as q,GroupAverageAgglomerativeClustering as I,MedianAgglomerativeClustering as B,SingleLinkageAgglomerativeClustering as D,WardsAgglomerativeClustering as G,WeightedAverageAgglomerativeClustering as N}from"../../lib/model/agglomerative.js";import $ from"../controller.js";import{DataConvexHull as O}from"../renderer/util/figure.js";import{getCategoryColor as y}from"../utils.js";const k=o((e,g)=>e.length===0?-1:(e=g?e.map(g):e,e.indexOf(Math.min(...e))),"argmin"),L=o((e,g)=>e.length===0?-1:(e=g?e.map(g):e,e.indexOf(Math.max(...e))),"argmax");export default function P(e){e.setting.ml.usage='Click and add data point. Next, select distance type and click "Initialize". Finally, select cluster number.';const g=e.svg,S=o(a=>{let s="";for(let i=0;i<a.length;i++)s+=`${i===0?"M":"L"}${a[i][0]},${a[i][1]}`;return s},"line"),h=new $(e);let C=null,x=null,v=null;const d=document.createElementNS("http://www.w3.org/2000/svg","g");g.insertBefore(d,g.firstChild),d.classList.add("grouping");const b=o(a=>{let s=[];const i=u.value;let l=1;const r=[];x.getClusters(i).forEach(t=>{if(t.size>1){let n=[];const p=[t];for(;p.length>0;){const c=p.pop();c.size>1?(c.line||(c.line=a(c.children[0],c.children[1])),n=n.concat(c.line)):c.children||(r[c.index]=l),c.children&&p.push(...c.children)}n=n.map(c=>({path:c.map(E=>e._renderer[0].toPoint(E)),color:y(l)})),s=s.concat(n)}else r[t.index]=l;l+=t.size}),e.trainResult=r,d.querySelectorAll("path").forEach(t=>t.remove());for(const t of s){const n=document.createElementNS("http://www.w3.org/2000/svg","path");n.setAttribute("d",S(t.path)),n.setAttribute("stroke",t.color),d.append(n)}},"plotLink"),f=o(()=>{d.querySelectorAll("polygon").forEach(l=>l.remove());const a=u.value;let s=1;const i=[];x.getClusters(a).forEach(l=>{if(l.size>1){const r=[l];for(;r.length>0;){const t=r.pop();t.poly?t.poly.remove():t.children||(i[t.index]=s),t.children&&r.push(...t.children)}l.poly=new O(d,l.leafs.map(t=>e._renderer[0].points[t.index])),l.poly.color=y(s)}else i[l.index]=s;s+=l.size}),e.trainResult=i},"plotConvex"),A={"Complete Linkage":{class:q,plot:o(()=>{b((a,s)=>{const i=a.leafs,l=s.leafs,r=i.map(n=>[n,l[L(l,p=>n.distances[p.index])]]),t=r[L(r,n=>n[0].distances[n[1].index])];return[[t[0].point,t[1].point]]})},"plot")},"Single Linkage":{class:D,plot:o(()=>{b((a,s)=>{const i=a.leafs,l=s.leafs,r=i.map(n=>[n,l[k(l,p=>n.distances[p.index])]]),t=r[k(r,n=>n[0].distances[n[1].index])];return[[t[0].point,t[1].point]]})},"plot")},"Group Average":{class:I,plot:o(()=>f(),"plot")},"Ward's":{class:G,plot:o(()=>f(),"plot")},Centroid:{class:W,plot:o(()=>f(),"plot")},"Weighted Average":{class:N,plot:o(()=>f(),"plot")},Median:{class:B,plot:o(()=>f(),"plot")}},w=h.select(["Complete Linkage","Single Linkage","Group Average","Ward's","Centroid","Weighted Average","Median"]).on("change",()=>{C=A[w.value].class,v=A[w.value].plot});C=A["Complete Linkage"].class,v=A["Complete Linkage"].plot;const z=h.select(["euclid","manhattan","chebyshev"]);h.input.button("Initialize").on("click",()=>{C&&(x=new C(z.value),x.fit(e.trainInput),m.element.max=e.datas.length,m.element.value=10,m.element.disabled=!1,u.element.max=e.datas.length,u.element.value=10,u.element.disabled=!1,g.querySelectorAll("path").forEach(a=>a.remove()),d.replaceChildren(),v())});const m=h.input.number({label:"Cluster #",min:1,max:1,value:1,disabled:"disabled"}).on("change",()=>{u.value=m.value,v()}),u=h.input.range({min:1,disabled:"disabled"}).on("change",()=>{m.value=u.value,v()}).on("input",()=>{m.value=u.value});return()=>{document.querySelector("svg .grouping").remove()}}o(P,"default");
