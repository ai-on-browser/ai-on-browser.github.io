import{CompleteLinkageAgglomerativeClustering,SingleLinkageAgglomerativeClustering,GroupAverageAgglomerativeClustering,WardsAgglomerativeClustering,CentroidAgglomerativeClustering,WeightedAverageAgglomerativeClustering,MedianAgglomerativeClustering}from"../../lib/model/agglomerative.js";import Controller from"../controller.js";import{getCategoryColor,DataConvexHull}from"../utils.js";const argmin=function(e,t){return 0===e.length?-1:(e=t?e.map(t):e).indexOf(Math.min(...e))},argmax=function(e,t){return 0===e.length?-1:(e=t?e.map(t):e).indexOf(Math.max(...e))};var dispAgglomerative=function(e,t){const l=t.svg,a=d3.line().x((e=>e[0])).y((e=>e[1])),n=new Controller(t);let i=null,r=null,o=null;l.insert("g",":first-child").attr("class","grouping");const s=e=>{let n=[];const i=d.value;let o=1;r.getClusters(i).forEach((l=>{if(l.size>1){let a=[];const i=[l];for(;i.length>0;){const l=i.pop();l.size>1?(l.line||(l.line=e(l.children[0],l.children[1])),a=a.concat(l.line)):l.children||(t.datas.at(l.index).y=o),l.children&&i.push(...l.children)}a=a.map((e=>({path:e.map((e=>t._renderer.toPoint(e))),color:getCategoryColor(o)}))),n=n.concat(a)}else t.datas.at(l.index).y=o;o+=l.size})),l.selectAll(".grouping path").remove(),l.select(".grouping").selectAll("path").data(n).enter().append("path").attr("d",(e=>a(e.path))).attr("stroke",(e=>e.color))},g=function(){l.selectAll(".grouping polygon").remove();const e=d.value;let a=1;r.getClusters(e).forEach((e=>{if(e.size>1){const n=[e];for(;n.length>0;){const e=n.pop();e.poly?e.poly.remove():e.children||(t.datas.at(e.index).y=a),e.children&&n.push(...e.children)}Promise.resolve().then((()=>{e.poly=new DataConvexHull(l.select(".grouping"),r._leafs(e).map((e=>t.datas.points[e.index])))}))}else t.datas.at(e.index).y=a;a+=e.size}))};e.append("select").on("change",(function(){var e=d3.select(this);e.selectAll("option").filter((t=>t.value===e.property("value"))).each((e=>i=e.class)).each((e=>o=e.plot))})).selectAll("option").data([{value:"Complete Linkage",class:CompleteLinkageAgglomerativeClustering,plot:()=>{s(((e,t)=>{const l=r._leafs(e),a=r._leafs(t);let n=l.map((e=>[e,a[argmax(a,(t=>e.distances[t.index]))]])),i=n[argmax(n,(e=>e[0].distances[e[1].index]))];return[[i[0].point,i[1].point]]}))}},{value:"Single Linkage",class:SingleLinkageAgglomerativeClustering,plot:()=>{s(((e,t)=>{const l=r._leafs(e),a=r._leafs(t);let n=l.map((e=>[e,a[argmin(a,(t=>e.distances[t.index]))]])),i=n[argmin(n,(e=>e[0].distances[e[1].index]))];return[[i[0].point,i[1].point]]}))}},{value:"Group Average",class:GroupAverageAgglomerativeClustering,plot:()=>g()},{value:"Ward's",class:WardsAgglomerativeClustering,plot:()=>g()},{value:"Centroid",class:CentroidAgglomerativeClustering,plot:()=>g()},{value:"Weighted Average",class:WeightedAverageAgglomerativeClustering,plot:()=>g()},{value:"Median",class:MedianAgglomerativeClustering,plot:()=>g()}]).enter().append("option").attr("value",(e=>e.value)).text((e=>e.value)).each(((e,t)=>0===t&&(i=e.class))).each(((e,t)=>0===t&&(o=e.plot)));const c=n.select(["euclid","manhattan","chebyshev"]);n.input.button("Initialize").on("click",(()=>{i&&(r=new i(c.value),r.fit(t.trainInput),u.element.max=t.datas.length,u.element.value=10,u.element.disabled=!1,d.element.max=t.datas.length,d.element.value=10,d.element.disabled=!1,l.selectAll("path").remove(),l.selectAll(".grouping *").remove(),o())}));const u=n.input.number({label:"Cluster #",min:1,max:1,value:1,disabled:"disabled"}).on("change",(()=>{d.value=u.value,o()})),d=n.input.range({min:1,disabled:"disabled"}).on("change",(()=>{u.value=d.value,o()})).on("input",(()=>{u.value=d.value}))};export default function(e){e.setting.ml.usage='Click and add data point. Next, select distance type and click "Initialize". Finally, select cluster number.',dispAgglomerative(e.setting.ml.configElement,e),e.setting.terminate=()=>{d3.selectAll("svg .grouping").remove()}}