import{KMeans,KMeanspp,KMedoids,KMedians,SemiSupervisedKMeansModel}from"../../lib/model/kmeans.js";import Controller from"../controller.js";export default function(t){"SC"!==t.task?t.setting.ml.usage='Click and add data point. Next, select "k-means", "k-means++", "k-medoids" or "k-medians" and click "Add centroid" to add centroid. Finally, click "Step" button repeatedly.':t.setting.ml.usage='Click and add data point. Then, click "Step" button repeatedly.',t.setting.ml.detail="\n$ S_i $ as a set of datas in $ i $th cluster, the objective is to find\n$$\n  \\argmin_S \\sum_{i=1}^k \\sum_{x \\in S_i} \\| x - \\mu_i \\|^2\n$$\nwhere $ \\mu_i $ is the mean of points in $ S_i $.\n<br>\nThe algorithm is simple.\n<ol>\n<li>Initialize $ \\mu_i $.</li>\n<li>Assign the datas to the cluster $ S_i $ with the nearest mean $ \\mu_i $.</li>\n<li>Update $ \\mu_i $.\n$$\n\\mu_i = \\frac{1}{|S_i|} \\sum_{x \\in S_i} x\n$$\n</li>\n<li>Finish if $ \\mu_i $ does not change. Otherwise, go back to step 2.</li>\n</ol>\n";const e=new Controller(t);let i="SC"===t.task?new SemiSupervisedKMeansModel:new KMeans;const n=()=>{if(t.init(),"SC"!==t.task)i.clear(),a.value=i.size+" clusters";else{i.init(t.trainInput,t.trainOutput.map((t=>t[0])));const e=i.predict(t.trainInput);t.trainResult=e,t.centroids(i.centroids,i.categories,{line:!0})}},s=e.stepLoopButtons().init(n);let a=null;if("SC"!==t.task){const s={"k-means":KMeans,"k-means++":KMeanspp,"k-medoids":KMedoids,"k-medians":KMedians},o=e.select(["k-means","k-means++","k-medoids","k-medians"]).on("change",(()=>{i=new s[o.value],n()}));e.input.button("Add centroid").on("click",(()=>{i.add(t.trainInput);const e=i.predict(t.trainInput);t.trainResult=e.map((t=>t+1)),t.centroids(i.centroids,i.centroids.map(((t,e)=>e+1)),{line:!0}),a.value=i.size+" clusters"})),a=e.text("0 clusters")}s.step((e=>{if(0===i.size)return void(e&&e());i.fit(t.trainInput,t.trainOutput.map((t=>t[0])));const n=i.predict(t.trainInput);t.trainResult="SC"!==t.task?n.map((t=>t+1)):n,t.centroids(i.centroids,"SC"!==t.task?i.centroids.map(((t,e)=>e+1)):i.categories,{line:!0,duration:1e3}),e&&setTimeout(e,1e3)})),e.input.button("Skip").on("click",(()=>{const e=t.trainInput;let n=t.trainOutput;for(n=n.map((t=>t[0]));i.fit(e,n)>1e-8;);const s=i.predict(e);t.trainResult="SC"!==t.task?s.map((t=>t+1)):s,t.centroids(i.centroids,"SC"!==t.task?i.centroids.map(((t,e)=>e+1)):i.categories,{line:!0,duration:1e3})})),s.enable="SC"!==t.task}