var y=Object.defineProperty;var r=(t,e)=>y(t,"name",{value:e,configurable:!0});import _ from"../controller.js";import{BaseWorker as L}from"../utils.js";import*as f from"../../lib/model/nns/optimizer.js";class x extends L{static{r(this,"LadderNetworkWorker")}constructor(){super("js/view/worker/model_worker.js",{type:"module"})}initialize(e,a,n,i){return this._postMessage({name:"ladder_network",method:"constructor",arguments:[e,a,n,i]})}epoch(){return this._postMessage({name:"ladder_network",method:"epoch"}).then(e=>e.data)}fit(e,a,n,i,u){return this._postMessage({name:"ladder_network",method:"fit",arguments:[e,a,n,i,u]}).then(o=>o.data)}predict(e){return this._postMessage({name:"ladder_network",method:"predict",arguments:[e]}).then(a=>a.data)}}export default function z(t){t.setting.ml.usage='Click and add data point. Next, click "Initialize". Finally, click "Fit" button repeatedly.',t.setting.ml.reference={author:"H. Valpola",title:"From Neural PCA to Deep Unsupervised Learning",year:2015};const e=new _(t),a=new x,n=[10];let i=0;const u=r(async()=>{const s=t.datas.dimension,l=t.trainOutput.map(w=>w[0]),d=await a.fit(t.trainInput,l,+g.value,b.value,v.value);i=await a.epoch(),t.plotLoss({labeled:d.labeledLoss,unlabeled:d.unlabeledLoss});const k=await a.predict(t.testInput(s===1?2:4));t.testResult(k)},"fitModel");e.text(" Hidden Layers ");const o=e.span(),c=r(()=>{o.element.replaceChildren();for(let s=0;s<n.length;s++){const l=o.input.number({min:1,max:100,value:n[s]}).on("change",()=>{n[s]=l.value})}n.length>0&&o.input.button("-").on("click",()=>{n.pop(),c()})},"createHsElms");e.input.button("+").on("click",()=>{n.push(10),c()}),c();const p=e.select({label:" Activation ",values:["sigmoid","tanh","relu","elu","leaky_relu","rrelu","prelu","gaussian","softplus","softsign","identity"]}),m=e.select({label:" Optimizer ",values:Object.keys(f),value:"adam"}),h=e.stepLoopButtons().init(s=>{if(t.datas.length===0){s();return}const l=Array(n.length+2).fill(.001);a.initialize(n,l,p.value,m.value).then(s),t.init()}),g=e.select({label:" Iteration ",values:[1,10,100,1e3,1e4]}),b=e.input.number({label:" Learning rate ",min:0,max:100,step:.01,value:.001}),v=e.input.number({label:" Batch size ",min:1,max:1e3,value:1e3});return h.step(u).epoch(()=>i),()=>{a.terminate()}}r(z,"default");
