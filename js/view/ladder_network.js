var x=Object.defineProperty;var o=(e,t)=>x(e,"name",{value:t,configurable:!0});import _ from"../controller.js";import{BaseWorker as L}from"../utils.js";class z extends L{static{o(this,"LadderNetworkWorker")}constructor(){super("js/view/worker/ladder_network_worker.js",{type:"module"})}initialize(t,i,n,s){return this._postMessage({mode:"init",hidden_sizes:t,lambdas:i,activation:n,optimizer:s})}fit(t,i,n,s,r){return this._postMessage({mode:"fit",x:t,y:i,iteration:n,rate:s,batch:r})}predict(t){return this._postMessage({mode:"predict",x:t})}}export default function f(e){e.setting.ml.usage='Click and add data point. Next, click "Initialize". Finally, click "Fit" button repeatedly.',e.setting.ml.reference={author:"H. Valpola",title:"From Neural PCA to Deep Unsupervised Learning",year:2015};const t=new _(e),i=new z,n=[10];let s=0;const r=o(async a=>{const l=e.datas.dimension,y=e.trainOutput.map(w=>w[0]),d=await i.fit(e.trainInput,y,+h.value,v.value,b.value);s=d.data.epoch,e.plotLoss({labeled:d.data.labeledLoss,unlabeled:d.data.unlabeledLoss});const k=(await i.predict(e.testInput(l===1?2:4))).data;e.testResult(k),a&&a()},"fitModel");t.text(" Hidden Layers ");const u=e.setting.ml.configElement.append("span"),c=o(()=>{u.selectAll("*").remove();for(let a=0;a<n.length;a++){const l=u.append("input").attr("type","number").attr("min",1).attr("max",100).attr("value",n[a]).on("change",()=>{n[a]=+l.property("value")})}n.length>0&&u.append("input").attr("type","button").attr("value","-").on("click",()=>{n.pop(),c()})},"createHsElms");t.input.button("+").on("click",()=>{n.push(10),c()}),c();const p=t.select({label:" Activation ",values:["sigmoid","tanh","relu","elu","leaky_relu","rrelu","prelu","gaussian","softplus","softsign","identity"]}),m=t.select({label:" Optimizer ",values:["sgd","adam","momentum","rmsprop"]}),g=t.stepLoopButtons().init(a=>{if(e.datas.length===0){a();return}const l=Array(n.length+2).fill(.001);i.initialize(n,l,p.value,m.value).then(a),e.init()}),h=t.select({label:" Iteration ",values:[1,10,100,1e3,1e4]}),v=t.input.number({label:" Learning rate ",min:0,max:100,step:.01,value:.001}),b=t.input.number({label:" Batch size ",min:1,max:1e3,value:1e3});g.step(r).epoch(()=>s),e.setting.ternimate=()=>{i.terminate()}}o(f,"default");
