import NeuralNetworkBuilder from"../neuralnetwork_builder.js";import Controller from"../controller.js";import{BaseWorker,specialCategory}from"../utils.js";class GANWorker extends BaseWorker{constructor(){super("js/view/worker/gan_worker.js",{type:"module"})}initialize(e,t,a,n,i,r,s){this._postMessage({mode:"init",noise_dim:e,g_hidden:t,d_hidden:a,g_opt:n,d_opt:i,class_size:r,type:s}),this._type=s}fit(e,t,a,n,i,r){return this._postMessage({mode:"fit",x:e,y:t,iteration:a,gen_rate:n,dis_rate:i,batch:r}).then((e=>e.data))}prob(e,t){return this._postMessage({mode:"prob",x:e,y:t}).then((e=>e.data))}generate(e,t){return this._postMessage({mode:"generate",n:e,y:t}).then((e=>e.data))}}export default function(e){const t=e.setting.ml.configElement;e.setting.ml.usage='Click and add data point. Next, click "Initialize". Finally, click "Fit" button repeatedly.';const a=new Controller(e),n=new NeuralNetworkBuilder,i=new NeuralNetworkBuilder,r=new GANWorker;let s=0;const l=async()=>{const t=e.trainOutput,a=await r.generate(e.trainInput.length,t);"conditional"===o.value?e.trainResult=[a,t]:e.trainResult=a};let o;o="GR"===e.task?a.select(["default","conditional"]):a.input({type:"hidden",value:"default"});const p=a.input.number({label:"Noise dim",min:1,max:100,value:5});a.text("Hidden size ");const u=t.append("div").style("display","inline-block"),d=u.append("div");d.append("span").text("G"),n.makeHtml(d,{optimizer:!0});const c=u.append("div");c.append("span").text("D"),i.makeHtml(c,{optimizer:!0});const m=a.stepLoopButtons().init((()=>{const t=n.layers,a=i.layers,s=n.optimizer,l=i.optimizer,u=new Set(e.trainOutput.map((e=>e[0]))).size;r.initialize(p.value,t,a,s,l,u,o.value),e.init()})),g=a.select({label:" Iteration ",values:[1,10,100,1e3,1e4]});a.text("Learning rate ");const v=t.append("div").style("display","inline-block");for(const e of[{name:"gen_rate",title:"G",value:.01},{name:"dis_rate",title:"D",value:.5}]){const t=v.append("div");t.append("span").text(e.title),t.append("input").attr("type","number").attr("name",e.name).attr("min",0).attr("max",100).attr("step",.01).attr("value",e.value)}const y=a.input.number({label:" Batch size ",min:1,max:100,value:10});let h=null;"AD"===e.task&&(h=a.input.number({label:" threshold = ",min:0,max:10,step:.01,value:.8})),m.step((async a=>{if(0===e.datas.length)return void(a&&a());const n=+t.select("[name=gen_rate]").property("value"),i=+t.select("[name=dis_rate]").property("value"),l=e.trainInput,o=e.trainOutput,p=await r.fit(l,o,+g.value,n,i,y.value);if(s=p.epoch,e.plotLoss({generator:p.generatorLoss,discriminator:p.discriminatorLoss}),"GR"===e.task){const t=await r.generate(l.length,o);if("conditional"===r._type)e.trainResult=[t,o];else{const a=await r.prob(e.testInput(5));e.testResult(a.map((e=>specialCategory.errorRate(e[1])))),e.trainResult=t}}else{const t=l.concat(e.testInput(5)),a=await r.prob(t),n=a.slice(0,l.length),i=a.slice(l.length);e.trainResult=n.map((e=>e[1]>h.value)),e.testResult(i.map((e=>e[1]>h.value)))}a&&a()})).epoch((()=>s)),"GR"===e.task&&a.input.button("Generate").on("click",l),e.setting.terminate=()=>{r.terminate()}}