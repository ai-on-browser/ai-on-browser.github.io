var C=Object.defineProperty;var m=(e,i)=>C(e,"name",{value:i,configurable:!0});import F from"../neuralnetwork_builder.js";import v from"../../lib/util/matrix.js";import M from"../controller.js";import{BaseWorker as P}from"../utils.js";class T extends P{static{m(this,"NNWorker")}constructor(){super("js/view/worker/model_worker.js",{type:"module"})}initialize(i,n,s){return this._postMessage({name:"neuralnetwork",method:"fromObject",static:!0,initialize:!0,arguments:[i,n,s]})}fit(i,n,s,o,c){return this._postMessage({name:"neuralnetwork",method:"fit",arguments:[i,n,s,o,c]})}predict(i){return this._postMessage({name:"neuralnetwork",method:"calc",arguments:[i]})}}export default function _(e){e.setting.ml.usage='Click and add data point. Next, click "Initialize". Finally, click "Fit" button repeatedly.';const i=new M(e),n=e.task,s=new T,o=new F;let c=0,p=0;const b=m(async()=>{const r=f();let u=e.trainInput,a=e.trainOutput;const d=v.fromArray(u);if(n==="TP"){a=u.slice(r),u=[];for(let t=0;t<d.rows-r;t++)u.push(d.slice(t,t+r).value)}else if(n==="CF")for(let t=0;t<a.length;t++){const l=Array(p).fill(0);l[a[t]]=1,a[t]=l}if(await s.fit(u,a,+y.value,k.value,z.value),c+=+y.value,n==="TP"){let t=d.slice(d.rows-r).value;const l=[];for(;;){if(l.length>=h.value){e.trainResult=l;return}const g=await s.predict([t]);l.push(g.data[0]),t=t.slice(d.cols),t.push(...g.data[0])}}else{const t=await s.predict(e.testInput(r===1?2:4)),l=n==="CF"?v.fromArray(t.data).argmax(1).value:t.data;e.testResult(l)}},"fitModel"),f=m(()=>n==="TP"?w.value:e.datas.dimension||2,"getInputDim");let w=null;n==="TP"&&(w=i.input.number({label:"window width",min:1,max:1e3,value:20})),i.text(" Hidden Layers "),o.makeHtml(e.setting.ml.configElement,{optimizer:!0});const x=i.stepLoopButtons().init(r=>{if(e.datas.length===0){r();return}const u=o.optimizer;p=n==="CF"?Math.max.apply(null,e.datas.y)+1:n==="TP"?e.datas.dimension:1;const a=[{type:"input"}];a.push(...o.layers),a.push({type:"full",out_size:p}),n==="CF"&&a.push({type:"sigmoid"}),s.initialize(a,"mse",u).then(r),e.init(),c=0}),y=i.select({label:" Iteration ",values:[1,10,100,1e3,1e4]}),k=i.input.number({label:" Learning rate ",min:0,max:100,step:.01,value:.001}),z=i.input.number({label:" Batch size ",min:1,max:100,value:10});x.step(b).epoch(()=>c);let h;return n==="TP"?h=i.input.number({label:" predict count",min:1,max:1e3,value:100}):h=i.input({type:"hidden",value:0}),()=>{s.terminate()}}m(_,"default");
