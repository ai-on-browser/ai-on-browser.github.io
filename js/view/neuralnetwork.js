var F=Object.defineProperty;var m=(e,i)=>F(e,"name",{value:i,configurable:!0});import M from"../neuralnetwork_builder.js";import g from"../../lib/util/matrix.js";import P from"../controller.js";import{BaseWorker as T}from"../utils.js";class _ extends T{static{m(this,"NNWorker")}constructor(){super("js/view/worker/neuralnetwork_worker.js",{type:"module"})}initialize(i,n,a){return this._postMessage({mode:"init",layers:i,loss:n,optimizer:a})}fit(i,n,a,o,c){return this._postMessage({mode:"fit",x:i,y:n,iteration:a,rate:o,batch:c})}predict(i){return this._postMessage({mode:"predict",x:i})}}export default function I(e){e.setting.ml.usage='Click and add data point. Next, click "Initialize". Finally, click "Fit" button repeatedly.';const i=new P(e),n=e.task,a=new _,o=new M;let c=0,h=0;const f=m(async r=>{const u=k();let s=e.trainInput,d=e.trainOutput;const p=g.fromArray(s);if(n==="TP"){d=s.slice(u),s=[];for(let t=0;t<p.rows-u;t++)s.push(p.slice(t,t+u).value)}else if(n==="CF")for(let t=0;t<d.length;t++){const l=Array(h).fill(0);l[d[t]]=1,d[t]=l}if(await a.fit(s,d,+v.value,z.value,C.value),c+=+v.value,n==="TP"){let t=p.slice(p.rows-u).value;const l=[];for(;;){if(l.length>=y.value){e.trainResult=l,r&&r();return}const x=await a.predict([t]);l.push(x.data[0]),t=t.slice(p.cols),t.push(...x.data[0])}}else{const t=await a.predict(e.testInput(u===1?2:4)),l=n==="CF"?g.fromArray(t.data).argmax(1).value:t.data;e.testResult(l),r&&r()}},"fitModel"),k=m(()=>n==="TP"?w.value:e.datas.dimension||2,"getInputDim");let w=null;n==="TP"&&(w=i.input.number({label:"window width",min:1,max:1e3,value:20})),i.text(" Hidden Layers "),o.makeHtml(e.setting.ml.configElement,{optimizer:!0});const b=i.stepLoopButtons().init(r=>{if(e.datas.length===0){r();return}const u=o.optimizer;h=n==="CF"?Math.max.apply(null,e.datas.y)+1:n==="TP"?e.datas.dimension:1;const s=[{type:"input"}];s.push(...o.layers),s.push({type:"full",out_size:h}),n==="CF"&&s.push({type:"sigmoid"}),a.initialize(s,"mse",u).then(r),e.init(),c=0}),v=i.select({label:" Iteration ",values:[1,10,100,1e3,1e4]}),z=i.input.number({label:" Learning rate ",min:0,max:100,step:.01,value:.001}),C=i.input.number({label:" Batch size ",min:1,max:100,value:10});b.step(f).epoch(()=>c);let y;n==="TP"?y=i.input.number({label:" predict count",min:1,max:1e3,value:100}):y=i.input({type:"hidden",value:0}),e.setting.ternimate=()=>{a.terminate()}}m(I,"default");
