var C=Object.defineProperty;var p=(e,i)=>C(e,"name",{value:i,configurable:!0});import F from"../neuralnetwork_builder.js";import x from"../../lib/util/matrix.js";import M from"../controller.js";import{BaseWorker as P}from"../utils.js";class T extends P{static{p(this,"NNWorker")}constructor(){super("js/view/worker/neuralnetwork_worker.js",{type:"module"})}initialize(i,n,a){return this._postMessage({mode:"init",layers:i,loss:n,optimizer:a})}fit(i,n,a,o,c){return this._postMessage({mode:"fit",x:i,y:n,iteration:a,rate:o,batch:c})}predict(i){return this._postMessage({mode:"predict",x:i})}}export default function _(e){e.setting.ml.usage='Click and add data point. Next, click "Initialize". Finally, click "Fit" button repeatedly.';const i=new M(e),n=e.task,a=new T,o=new F;let c=0,m=0;const g=p(async()=>{const l=b();let u=e.trainInput,s=e.trainOutput;const d=x.fromArray(u);if(n==="TP"){s=u.slice(l),u=[];for(let t=0;t<d.rows-l;t++)u.push(d.slice(t,t+l).value)}else if(n==="CF")for(let t=0;t<s.length;t++){const r=Array(m).fill(0);r[s[t]]=1,s[t]=r}if(await a.fit(u,s,+w.value,k.value,z.value),c+=+w.value,n==="TP"){let t=d.slice(d.rows-l).value;const r=[];for(;;){if(r.length>=h.value){e.trainResult=r;return}const v=await a.predict([t]);r.push(v.data[0]),t=t.slice(d.cols),t.push(...v.data[0])}}else{const t=await a.predict(e.testInput(l===1?2:4)),r=n==="CF"?x.fromArray(t.data).argmax(1).value:t.data;e.testResult(r)}},"fitModel"),b=p(()=>n==="TP"?y.value:e.datas.dimension||2,"getInputDim");let y=null;n==="TP"&&(y=i.input.number({label:"window width",min:1,max:1e3,value:20})),i.text(" Hidden Layers "),o.makeHtml(e.setting.ml.configElement,{optimizer:!0});const f=i.stepLoopButtons().init(l=>{if(e.datas.length===0){l();return}const u=o.optimizer;m=n==="CF"?Math.max.apply(null,e.datas.y)+1:n==="TP"?e.datas.dimension:1;const s=[{type:"input"}];s.push(...o.layers),s.push({type:"full",out_size:m}),n==="CF"&&s.push({type:"sigmoid"}),a.initialize(s,"mse",u).then(l),e.init(),c=0}),w=i.select({label:" Iteration ",values:[1,10,100,1e3,1e4]}),k=i.input.number({label:" Learning rate ",min:0,max:100,step:.01,value:.001}),z=i.input.number({label:" Batch size ",min:1,max:100,value:10});f.step(g).epoch(()=>c);let h;return n==="TP"?h=i.input.number({label:" predict count",min:1,max:1e3,value:100}):h=i.input({type:"hidden",value:0}),()=>{a.terminate()}}p(_,"default");
