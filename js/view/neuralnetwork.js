import NeuralNetworkBuilder from"../neuralnetwork_builder.js";import Matrix from"../../lib/util/matrix.js";import Controller from"../controller.js";import{BaseWorker}from"../utils.js";class NNWorker extends BaseWorker{constructor(){super("js/view/worker/neuralnetwork_worker.js",{type:"module"})}initialize(e,t,i){return this._postMessage({mode:"init",layers:e,loss:t,optimizer:i})}fit(e,t,i,a,r){return this._postMessage({mode:"fit",x:e,y:t,iteration:i,rate:a,batch:r})}predict(e){return this._postMessage({mode:"predict",x:e})}}export default function(e){e.setting.ml.usage='Click and add data point. Next, click "Initialize". Finally, click "Fit" button repeatedly.';const t=new Controller(e),i=e.task,a=new NNWorker,r=new NeuralNetworkBuilder;let l=0,n=0;const s=()=>"TP"===i?o.value:e.datas.dimension||2;let o=null;"TP"===i&&(o=t.input.number({label:"window width",min:1,max:1e3,value:20})),t.text(" Hidden Layers "),r.makeHtml(e.setting.ml.configElement,{optimizer:!0});const u=t.stepLoopButtons().init((t=>{if(0===e.datas.length)return void t();const s=r.optimizer;n="CF"===i?Math.max.apply(null,e.datas.y)+1:"TP"===i?e.datas.dimension:1;const o=[{type:"input"}];o.push(...r.layers),o.push({type:"full",out_size:n}),"CF"===i&&o.push({type:"sigmoid"}),a.initialize(o,"mse",s).then(t),e.init(),l=0})),p=t.select({label:" Iteration ",values:[1,10,100,1e3,1e4]}),m=t.input.number({label:" Learning rate ",min:0,max:100,step:.01,value:.001}),c=t.input.number({label:" Batch size ",min:1,max:100,value:10});let d;u.step((async t=>{const r=s();let o=e.trainInput,u=e.trainOutput;const f=Matrix.fromArray(o);if("TP"===i){u=o.slice(r),o=[];for(let e=0;e<f.rows-r;e++)o.push(f.slice(e,e+r).value)}else if("CF"===i)for(let e=0;e<u.length;e++){const t=Array(n).fill(0);t[u[e]]=1,u[e]=t}if(await a.fit(o,u,+p.value,m.value,c.value),l+=+p.value,"TP"===i){let i=f.slice(f.rows-r).value;const l=[];for(;;){if(l.length>=d.value)return e.trainResult=l,void(t&&t());const r=await a.predict([i]);l.push(r.data[0]),i=i.slice(f.cols),i.push(...r.data[0])}}else{const l=await a.predict(e.testInput(1===r?2:4)),n="CF"===i?Matrix.fromArray(l.data).argmax(1).value:l.data;e.testResult(n),t&&t()}})).epoch((()=>l)),d="TP"===i?t.input.number({label:" predict count",min:1,max:1e3,value:100}):t.input({type:"hidden",value:0}),e.setting.ternimate=()=>{a.terminate()}}