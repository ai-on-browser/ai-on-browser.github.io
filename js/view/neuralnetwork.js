var C=Object.defineProperty;var m=(i,e)=>C(i,"name",{value:e,configurable:!0});import g from"../../lib/util/matrix.js";import F from"../controller.js";import M from"../neuralnetwork_builder.js";import{BaseWorker as P}from"../utils.js";class T extends P{static{m(this,"NNWorker")}constructor(){super("js/view/worker/model_worker.js",{type:"module"})}initialize(e,n,s){return this._postMessage({name:"neuralnetwork",method:"fromObject",static:!0,initialize:!0,arguments:[e,n,s]})}fit(e,n,s,o,c){return this._postMessage({name:"neuralnetwork",method:"fit",arguments:[e,n,s,o,c]})}predict(e){return this._postMessage({name:"neuralnetwork",method:"calc",arguments:[e]})}}export default function _(i){i.setting.ml.usage='Click and add data point. Next, click "Initialize". Finally, click "Fit" button repeatedly.';const e=new F(i),n=i.task,s=new T,o=new M;let c=0,p=0;const b=m(async()=>{const r=f();let u=i.trainInput,a=i.trainOutput;const d=g.fromArray(u);if(n==="TP"){a=u.slice(r),u=[];for(let t=0;t<d.rows-r;t++)u.push(d.slice(t,t+r).value)}else if(n==="CF")for(let t=0;t<a.length;t++){const l=Array(p).fill(0);l[a[t]]=1,a[t]=l}if(await s.fit(u,a,+y.value,k.value,z.value),c+=+y.value,n==="TP"){let t=d.slice(d.rows-r).value;const l=[];for(;;){if(l.length>=h.value){i.trainResult=l;return}const v=await s.predict([t]);l.push(v.data[0]),t=t.slice(d.cols),t.push(...v.data[0])}}else{const t=await s.predict(i.testInput(r===1?2:4)),l=n==="CF"?g.fromArray(t.data).argmax(1).value:t.data;i.testResult(l)}},"fitModel"),f=m(()=>n==="TP"?w.value:i.datas.dimension||2,"getInputDim");let w=null;n==="TP"&&(w=e.input.number({label:"window width",min:1,max:1e3,value:20})),e.text(" Hidden Layers "),o.makeHtml(e,{optimizer:!0});const x=e.stepLoopButtons().init(r=>{if(i.datas.length===0){r();return}const u=o.optimizer;p=n==="CF"?Math.max.apply(null,i.datas.y)+1:n==="TP"?i.datas.dimension:1;const a=[{type:"input"}];a.push(...o.layers),a.push({type:"full",out_size:p}),n==="CF"&&a.push({type:"sigmoid"}),s.initialize(a,"mse",u).then(r),i.init(),c=0}),y=e.select({label:" Iteration ",values:[1,10,100,1e3,1e4]}),k=e.input.number({label:" Learning rate ",min:0,max:100,step:.01,value:.001}),z=e.input.number({label:" Batch size ",min:1,max:100,value:10});x.step(b).epoch(()=>c);let h;return n==="TP"?h=e.input.number({label:" predict count",min:1,max:1e3,value:100}):h=e.input({type:"hidden",value:0}),()=>{s.terminate()}}m(_,"default");
