import Matrix from"../../lib/util/matrix.js";import Controller from"../controller.js";import{BaseWorker}from"../utils.js";class MLPWorker extends BaseWorker{constructor(){super("js/view/worker/mlp_worker.js",{type:"module"})}initialize(e,t,a,i,l){this._postMessage({mode:"init",type:e,hidden_sizes:t,activation:a,optimizer:i},l)}fit(e,t,a,i,l,n){this._postMessage({mode:"fit",x:e,y:t,iteration:a,rate:i,batch:l},n)}predict(e,t){this._postMessage({mode:"predict",x:e},t)}}export default function(e){e.setting.ml.usage='Click and add data point. Next, click "Initialize". Finally, click "Fit" button repeatedly.';const t=new Controller(e),a=e.task,i=new MLPWorker,l=[10];let n=0;const s=()=>"TP"===a?r.value:e.datas.dimension||2;let r=null;"TP"===a&&(r=t.input.number({label:"window width",min:1,max:1e3,value:20})),t.text(" Hidden Layers ");const o=e.setting.ml.configElement.append("span"),u=()=>{o.selectAll("*").remove();for(let e=0;e<l.length;e++){const t=o.append("input").attr("type","number").attr("min",1).attr("max",100).attr("value",l[e]).on("change",(()=>{l[e]=+t.property("value")}))}l.length>0&&o.append("input").attr("type","button").attr("value","-").on("click",(()=>{l.pop(),u()}))};t.input.button("+").on("click",(()=>{l.push(10),u()})),u();const p=t.select({label:" Activation ",values:["sigmoid","tanh","relu","elu","leaky_relu","rrelu","prelu","gaussian","softplus","softsign","linear"]}),c=t.select({label:" Optimizer ",values:["sgd","adam","momentum","rmsprop"]}),m=t.stepLoopButtons().init((()=>{0!==e.datas.length&&(i.initialize("CF"===a?"classifier":"regressor",l,p.value,c.value),e.init())})),d=t.select({label:" Iteration ",values:[1,10,100,1e3,1e4]}),v=t.input.number({label:" Learning rate ",min:0,max:100,step:.01,value:.001}),h=t.input.number({label:" Batch size ",min:1,max:100,value:10});let g;m.step((t=>{const l=s();let r=e.trainInput,o=e.trainOutput;const u=Matrix.fromArray(r);if("TP"===a){o=r.slice(l),r=[];for(let e=0;e<u.rows-l;e++)r.push(u.slice(e,e+l).value)}"CF"===a&&(o=o.map((e=>e[0]))),i.fit(r,o,+d.value,v.value,h.value,(s=>{if(n=s.data.epoch,e.plotLoss(s.data.loss),"TP"===a){let a=u.slice(u.rows-l).value;const n=[],s=()=>{if(n.length>=g.value)return e.trainResult=n,void(t&&t());i.predict([a],(e=>{e.data[0];n.push(e.data[0]),a=a.slice(u.cols),a.push(...e.data[0]),s()}))};s()}else i.predict(e.testInput(1===l?2:4),(a=>{const i=a.data;e.testResult(i),t&&t()}))}))})).epoch((()=>n)),g="TP"===a?t.input.number({label:" predict count",min:1,max:1e3,value:100}):t.input({type:"hidden",value:0}),e.setting.ternimate=()=>{i.terminate()}}