import Matrix from"../../lib/util/matrix.js";import Controller from"../controller.js";class MLPWorker extends BaseWorker{constructor(){super("js/view/worker/mlp_worker.js",{type:"module"})}initialize(t,e,a,n,r){this._postMessage({mode:"init",type:t,hidden_sizes:e,activation:a,optimizer:n},r)}fit(t,e,a,n,r,p){this._postMessage({mode:"fit",x:t,y:e,iteration:a,rate:n,batch:r},p)}predict(t,e){this._postMessage({mode:"predict",x:t},e)}}var dispMLP=function(t,e){const a=new Controller(e),n=e.task,r=new MLPWorker,p=[10];let i=0;const o=()=>"TP"===n?+t.select("[name=width]").property("value"):e.datas.dimension||2;"TP"===n&&(t.append("span").text("window width"),t.append("input").attr("type","number").attr("name","width").attr("min",1).attr("max",1e3).attr("value",20)),t.append("span").text(" Hidden Layers ");const s=t.append("span"),l=()=>{s.selectAll("*").remove();for(let t=0;t<p.length;t++){const e=s.append("input").attr("type","number").attr("min",1).attr("max",100).attr("value",p[t]).on("change",(()=>{p[t]=+e.property("value")}))}p.length>0&&s.append("input").attr("type","button").attr("value","-").on("click",(()=>{p.pop(),l()}))};t.append("input").attr("type","button").attr("value","+").on("click",(()=>{p.push(10),l()})),l(),t.append("span").text(" Activation "),t.append("select").attr("name","activation").selectAll("option").data(["sigmoid","tanh","relu","elu","leaky_relu","rrelu","prelu","gaussian","softplus","softsign","linear"]).enter().append("option").property("value",(t=>t)).text((t=>t)),t.append("span").text(" Optimizer "),t.append("select").attr("name","optimizer").selectAll("option").data(["sgd","adam","momentum","rmsprop"]).enter().append("option").property("value",(t=>t)).text((t=>t));const u=a.stepLoopButtons().init((()=>{if(0===e.datas.length)return;const a=t.select("[name=activation]").property("value"),i=t.select("[name=optimizer]").property("value");r.initialize("CF"===n?"classifier":"regressor",p,a,i),e.init()}));return t.append("span").text(" Iteration "),t.append("select").attr("name","iteration").selectAll("option").data([1,10,100,1e3,1e4]).enter().append("option").property("value",(t=>t)).text((t=>t)),t.append("span").text(" Learning rate "),t.append("input").attr("type","number").attr("name","rate").attr("min",0).attr("max",100).attr("step",.01).attr("value",.001),t.append("span").text(" Batch size "),t.append("input").attr("type","number").attr("name","batch").attr("value",10).attr("min",1).attr("max",100).attr("step",1),u.step((a=>{const p=+t.select("[name=iteration]").property("value"),s=+t.select("[name=batch]").property("value"),l=+t.select("[name=rate]").property("value"),u=+t.select("[name=pred_count]").property("value"),d=o();let c=e.trainInput,m=e.trainOutput;const v=Matrix.fromArray(c);if("TP"===n){m=c.slice(d),c=[];for(let t=0;t<v.rows-d;t++)c.push(v.slice(t,t+d).value)}"CF"===n&&(m=m.map((t=>t[0]))),r.fit(c,m,p,l,s,(t=>{if(i=t.data.epoch,"TP"===n){let t=v.slice(v.rows-d).value;const n=[],p=()=>{if(n.length>=u)return e.trainResult=n,void(a&&a());r.predict([t],(e=>{e.data[0];n.push(e.data[0]),t=t.slice(v.cols),t.push(...e.data[0]),p()}))};p()}else r.predict(e.testInput(1===d?2:4),(t=>{const n=t.data;e.testResult(n),a&&a()}))}))})).epoch((()=>i)),"TP"===n?(t.append("span").text(" predict count"),t.append("input").attr("type","number").attr("name","pred_count").attr("min",1).attr("max",1e3).attr("value",100)):t.append("input").attr("type","hidden").attr("name","pred_count").property("value",0),()=>{r.terminate()}};export default function(t){t.setting.ml.usage='Click and add data point. Next, click "Initialize". Finally, click "Fit" button repeatedly.',t.setting.ternimate=dispMLP(t.setting.ml.configElement,t)}