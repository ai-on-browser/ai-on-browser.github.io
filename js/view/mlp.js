import{Matrix}from"../../lib/util/math.js";class MLPWorker extends BaseWorker{constructor(){super("js/view/worker/mlp_worker.js",{type:"module"})}initialize(t,e,a,r){this._postMessage({mode:"init",output_size:t,layers:e,optimizer:a},r)}fit(t,e,a,r,n,i){this._postMessage({mode:"fit",x:t,y:e,iteration:a,rate:r,batch:n},i)}predict(t,e){this._postMessage({mode:"predict",x:t},e)}}var dispMLP=function(t,e){const a=e.task,r=new MLPWorker,n=new NeuralNetworkBuilder;let i=0;const p=()=>"TP"===a?+t.select("[name=width]").property("value"):e.datas.dimension||2;"TP"===a&&(t.append("span").text("window width"),t.append("input").attr("type","number").attr("name","width").attr("min",1).attr("max",1e3).attr("value",20)),t.append("span").text(" Hidden Layers "),n.makeHtml(t,{optimizer:!0});const s=e.setting.ml.controller.stepLoopButtons().init((()=>{if(0===e.datas.length)return;const t=n.optimizer;let i="CF"===a?Math.max.apply(null,e.datas.y)+1:0;r.initialize(i,n.layers,t),e.init()}));return t.append("span").text(" Iteration "),t.append("select").attr("name","iteration").selectAll("option").data([1,10,100,1e3,1e4]).enter().append("option").property("value",(t=>t)).text((t=>t)),t.append("span").text(" Learning rate "),t.append("input").attr("type","number").attr("name","rate").attr("min",0).attr("max",100).attr("step",.01).attr("value",.001),t.append("span").text(" Batch size "),t.append("input").attr("type","number").attr("name","batch").attr("value",10).attr("min",1).attr("max",100).attr("step",1),s.step((n=>{const s=+t.select("[name=iteration]").property("value"),o=+t.select("[name=batch]").property("value"),l=+t.select("[name=rate]").property("value"),d=+t.select("[name=pred_count]").property("value"),c=p();e.fit(((t,p,u)=>{const m=Matrix.fromArray(t);if("TP"===a){p=t.slice(c),t=[];for(let e=0;e<m.rows-c;e++)t.push(m.sliceRow(e,e+c).value)}r.fit(t,p,s,l,o,(t=>{if(i=t.data.epoch,"TP"===a){let t=m.sliceRow(m.rows-c).value;const e=[],a=()=>{if(e.length>=d)return u(e),void(n&&n());r.predict([t],(r=>{r.data[0];e.push(r.data[0]),t=t.slice(m.cols),t.push(...r.data[0]),a()}))};a()}else e.predict(((t,e)=>{r.predict(t,(t=>{const r="CF"===a?Matrix.fromArray(t.data).argmax(1).value:t.data;e(r),n&&n()}))}),1===c?2:4)}))}))})).epoch((()=>i)),"TP"===a?(t.append("span").text(" predict count"),t.append("input").attr("type","number").attr("name","pred_count").attr("min",1).attr("max",1e3).attr("value",100)):t.append("input").attr("type","hidden").attr("name","pred_count").property("value",0),()=>{r.terminate()}};export default function(t){t.setting.ml.usage='Click and add data point. Next, click "Initialize". Finally, click "Fit" button repeatedly.',t.setting.ternimate=dispMLP(t.setting.ml.configElement,t)}