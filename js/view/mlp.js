import Matrix from"../../lib/util/matrix.js";import Controller from"../controller.js";import{BaseWorker}from"../utils.js";class MLPWorker extends BaseWorker{constructor(){super("js/view/worker/mlp_worker.js",{type:"module"})}initialize(t,e,i,a,l){this._postMessage({mode:"init",type:t,hidden_sizes:e,activation:i,optimizer:a},l)}fit(t,e,i,a,l,n){this._postMessage({mode:"fit",x:t,y:e,iteration:i,rate:a,batch:l},n)}predict(t,e){this._postMessage({mode:"predict",x:t},e)}}export default function(t){t.setting.ml.usage='Click and add data point. Next, click "Initialize". Finally, click "Fit" button repeatedly.';const e=new Controller(t),i=t.task,a=new MLPWorker,l=[10];let n=0;const s=()=>"TP"===i?r.value:t.datas.dimension||2;let r=null;"TP"===i&&(r=e.input.number({label:"window width",min:1,max:1e3,value:20})),e.text(" Hidden Layers ");const o=t.setting.ml.configElement.append("span"),u=()=>{o.selectAll("*").remove();for(let t=0;t<l.length;t++){const e=o.append("input").attr("type","number").attr("min",1).attr("max",100).attr("value",l[t]).on("change",(()=>{l[t]=+e.property("value")}))}l.length>0&&o.append("input").attr("type","button").attr("value","-").on("click",(()=>{l.pop(),u()}))};e.input.button("+").on("click",(()=>{l.push(10),u()})),u();const p=e.select({label:" Activation ",values:["sigmoid","tanh","relu","elu","leaky_relu","rrelu","prelu","gaussian","softplus","softsign","identity"]}),c=e.select({label:" Optimizer ",values:["sgd","adam","momentum","rmsprop"]}),m=e.stepLoopButtons().init((()=>{0!==t.datas.length&&(a.initialize("CF"===i?"classifier":"regressor",l,p.value,c.value),t.init())})),d=e.select({label:" Iteration ",values:[1,10,100,1e3,1e4]}),v=e.input.number({label:" Learning rate ",min:0,max:100,step:.01,value:.001}),h=e.input.number({label:" Batch size ",min:1,max:100,value:10});let g;m.step((e=>{const l=s();let r=t.trainInput,o=t.trainOutput;const u=Matrix.fromArray(r);if("TP"===i){o=r.slice(l),r=[];for(let t=0;t<u.rows-l;t++)r.push(u.slice(t,t+l).value)}"CF"===i&&(o=o.map((t=>t[0]))),a.fit(r,o,+d.value,v.value,h.value,(s=>{if(n=s.data.epoch,t.plotLoss(s.data.loss),"TP"===i){let i=u.slice(u.rows-l).value;const n=[],s=()=>{if(n.length>=g.value)return t.trainResult=n,void(e&&e());a.predict([i],(t=>{t.data[0];n.push(t.data[0]),i=i.slice(u.cols),i.push(...t.data[0]),s()}))};s()}else a.predict(t.testInput(1===l?2:4),(i=>{const a=i.data;t.testResult(a),e&&e()}))}))})).epoch((()=>n)),g="TP"===i?e.input.number({label:" predict count",min:1,max:1e3,value:100}):e.input({type:"hidden",value:0}),t.setting.ternimate=()=>{a.terminate()}}