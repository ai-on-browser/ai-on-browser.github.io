import SmoothMazeRLEnvironment from"../../../lib/rl/maze.js";export default class SmoothMazeRenderer extends SmoothMazeRLEnvironment{constructor(t){super(t.width,t.height),this.platform=t,this._width=this.platform.width,this._height=this.platform.height,this._render_blocks=[];for(let t=0;t<this._map_resolution[0];t++)this._render_blocks[t]=Array(this._map_resolution[1])}init(t){const i=this._width/this._map_resolution[0],r=this._height/this._map_resolution[1];t.append("rect").attr("x",this._width-this._goal_size[0]).attr("y",this._height-this._goal_size[1]).attr("width",this._goal_size[0]).attr("height",this._goal_size[1]).attr("stroke-width",1).attr("stroke","black").attr("fill","yellow"),t.append("circle").classed("agent",!0).attr("cx",this._position[0]).attr("cy",this._position[1]).attr("fill","gray").attr("fill-opacity",.8).attr("stroke-width",1).attr("stroke","black").attr("r",2*Math.min(i,r)/3),this._blocks=t.append("g");const e=this;t.append("rect").attr("x",0).attr("y",0).attr("width",this._width).attr("height",this._height).attr("opacity",0).on("click",(t=>{const i=d3.pointer(t),r=e._width/e._map_resolution[0],s=e._height/e._map_resolution[1],h=Math.floor(i[0]/r),o=Math.floor(i[1]/s);e._points.push([h,o]),t.stopPropagation(),setTimeout((()=>{e.platform.render()}),0)}))}render(t){const i=this._width/this._map_resolution[0],r=this._height/this._map_resolution[1],e=this.map;for(let t=0;t<e.length;t++)for(let s=0;s<e[t].length;s++)e[t][s]&&!this._render_blocks[t][s]?this._render_blocks[t][s]=this._blocks.append("rect").classed("grid",!0).attr("x",i*t).attr("y",r*s).attr("width",i).attr("height",r).attr("fill","black"):!e[t][s]&&this._render_blocks[t][s]&&(this._render_blocks[t][s].remove(),this._render_blocks[t][s]=null);t.select("circle.agent").attr("cx",this._position[0]).attr("cy",this._position[1])}}