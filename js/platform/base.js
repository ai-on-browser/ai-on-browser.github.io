import ScatterRenderer from"../renderer/scatter.js";import Matrix from"../../lib/util/matrix.js";export class BasePlatform{constructor(t,e){this._manager=e,this._task=t,this._renderer=new ScatterRenderer(e)}get task(){return this._task}get setting(){return this._manager.setting}get svg(){return this._manager.setting.svg}get width(){return this._width||(this._width=d3.select("#plot-area svg").node().getBoundingClientRect().width),this._width}set width(t){d3.select("#plot-area").style("width",t-2+"px"),this._width=null}get height(){return this._height||(this._height=d3.select("#plot-area svg").node().getBoundingClientRect().height),this._height}set height(t){d3.select("#plot-area").style("height",t-2+"px"),this._height=null}get datas(){return this._manager._datas}get params(){return{}}set params(t){}get trainInput(){return null}get trainOutput(){return null}testInput(){return null}init(){}terminate(){this._renderer.terminate()}}export class DefaultPlatform extends BasePlatform{constructor(t,e){super(t,e);const s=this.setting.task.configElement;"DR"!==this._task&&"FS"!==this._task||(s.append("span").text("Target dimension"),s.append("input").attr("type","number").attr("min",1).attr("max",2).attr("value",2).attr("name","dimension"))}get dimension(){const t=this.setting.task.configElement.select("[name=dimension]");return t.node()?+t.property("value"):null}get trainInput(){return this.datas.dimension>0?this.datas.x:this.datas.index.map((t=>[t]))}get trainOutput(){return this.datas.y.map((t=>[t]))}set trainResult(t){if("CT"===this._task)t.forEach(((t,e)=>{this.datas.at(e).y=t}));else if("AD"===this._task){0===this._r_task.select(".tile").size()&&this._r_task.insert("g").classed("tile",!0).classed("anormal_point",!0),this._r_task.selectAll(".tile *").remove();const e=this._r_task.select(".anormal_point");t.forEach(((t,s)=>{if(t){new DataCircle(e,this.datas.points[s]).color=getCategoryColor(specialCategory.error)}}))}else if("DR"===this._task||"FS"===this._task||"TF"===this._task){0===this._r_task.select(".tile").size()&&this._r_task.insert("g",":first-child").classed("tile",!0).attr("opacity",.5);const e=this._r_task.select(".tile");e.selectAll("*").remove();const s=t[0].length;let i=t;1===s&&(i=i.map((t=>[t,0])));let r=[],a=[];for(let t=0;t<i[0].length;t++){const e=i.map((e=>e[t]));r.push(Math.max(...e)),a.push(Math.min(...e))}const n=this.datas.dimension<=1?[this.height,this.height]:[this.width,this.height],h=n.map(((t,e)=>(t-10)/(r[e]-a[e])));let l=Math.min(...h);const o=[5,5];for(let t=0;t<h.length;t++)(!isFinite(l)||h[t]>l)&&(isFinite(h[t])?o[t]+=(h[t]-l)*(r[t]-a[t])/2:o[t]=n[t]/2-a[t]);isFinite(l)||(l=0);let d=1/0,c=null;const _=Matrix.fromArray(this.datas.points.map((t=>t.at)));for(let t=0;t<(this.datas.dimension<=1?1:2**s);t++){const e=t.toString(2).padStart(s,"0").split("").map((t=>!!+t)),n=i.map((t=>t.map(((t,s)=>((e[s]?r[s]-t+a[s]:t)-a[s])*l+o[s])))),h=Matrix.fromArray(n);h.sub(_);const g=h.norm();g<d&&(d=g,c=n)}c.forEach(((t,s)=>{const i=new DataPoint(e,this.datas.dimension<=1?[this.datas.points[s].at[0],t[0]]:t,this.datas.points[s].category);i.radius=2;new DataLine(e,this.datas.points[s],i).setRemoveListener((()=>i.remove()))}))}else{if("GR"!==this._task)throw new Error(`Invalid task ${this._task}`);{0===this._r_task.select(".tile").size()&&this._r_task.insert("g",":first-child").classed("tile",!0).classed("generated",!0).attr("opacity",.5);const e=this._r_task.select(".tile.generated");e.selectAll("*").remove();let s=null;Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[0][0])&&([t,s]=t),t.forEach(((t,i)=>{new DataPoint(e,this._renderer.toPoint(t),s?s[i][0]:0).radius=2}))}}}testInput(t=10){const[e,s]=this._renderer.predict(t);return"CF"!==this._task&&"RG"!==this._task||e.push(...this.datas.dimension>0?this.datas.x:this.datas.index.map((t=>[t]))),this.__plot=s,e}testResult(t){if("AD"===this._task&&(t=t.map((t=>t?specialCategory.error:specialCategory.errorRate(0)))),"CF"===this._task||"RG"===this._task){const e=t.slice(t.length-this.datas.length),s=this.datas.y;if(t=t.slice(0,t.length-this.datas.length),"CF"===this._task){let t=0;for(let i=0;i<s.length;i++)s[i]===e[i]&&t++;this.setting.footer.text("Accuracy:"+t/s.length)}else if("RG"===this._task){let t=0;for(let i=0;i<s.length;i++)t+=(s[i]-e[i])**2;this.setting.footer.text("RMSE:"+Math.sqrt(t/s.length))}}this.__plot(t,this._r_tile)}evaluate(t){"CF"!==this._task&&"RG"!==this._task||t(this.datas.x,(t=>{const e=this.datas.y;if("CF"===this._task){let s=0;for(let i=0;i<e.length;i++)e[i]===t[i]&&s++;this.setting.footer.text("Accuracy:"+s/e.length)}else if("RG"===this._task){let s=0;for(let i=0;i<e.length;i++)s+=(e[i]-t[i])**2;this.setting.footer.text("RMSE:"+Math.sqrt(s/e.length))}}))}init(){this._r&&this._r.remove(),this._cur_dimension=this.setting.dimension;const t=1===this.datas?.dimension&&("RG"===this._task||"IN"===this._task);this._r=t?this.svg.append("g"):this.svg.insert("g",":first-child"),this._r.classed("default-render",!0),this._r_task=this._r.append("g").classed("tasked-render",!0),this._r_tile=this._r.append("g").classed("tile-render",!0).attr("opacity",t?1:.5),this.setting.footer.text(""),this.svg.select("g.centroids").remove(),this._renderer.init(),this.render()}render(){this._renderer.render()}centroids(t,e,{line:s=!1,duration:i=0}={}){let r=this.svg.select("g.centroids");0===r.size()&&(r=this.svg.append("g").classed("centroids",!0),r.append("g").classed("c-line",!0),this._centroids_line=[],this._centroids=null);const a=[];this._centroids&&this._centroids.forEach((t=>{Array.isArray(e)&&e.indexOf(t.category)<0?t.remove():a.push(t)}));const n=this._renderer.points;for(let t=0;t<n.length;t++)this._centroids_line[t]?._from===n[t]&&s||(this._centroids_line[t]?.remove(),this._centroids_line[t]=null);this._centroids=t.map(((t,i)=>{let n=Array.isArray(e)?a.find((t=>t.category===e[i])):a[i];if(n||(n=new DataPoint(r,this._renderer.toPoint(t),Array.isArray(e)?e[i]:e),n.plotter(DataPointStarPlotter)),s){const t=this._renderer.points,s=this.datas.y;for(let a=0;a<t.length;a++)s[a]===e[i]&&(this._centroids_line[a]?this._centroids_line[a].to=n:this._centroids_line[a]=new DataLine(r.select(".c-line"),t[a],n))}return n})),Promise.resolve().then((()=>{this._centroids.forEach(((e,s)=>{e.move(this._renderer.toPoint(t[s]),i)}))}))}terminate(){this._r&&this._r.remove(),this.svg.select("g.centroids").remove(),this.svg.selectAll("g").style("visibility",null);this.setting.task.configElement.selectAll("*").remove(),this.setting.footer.text(""),super.terminate()}}