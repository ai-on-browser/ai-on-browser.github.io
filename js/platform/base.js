import ScatterRenderer from"../renderer/scatter.js";import Matrix from"../../lib/util/matrix.js";export class BasePlatform{constructor(t,e){this._manager=e,this._task=t,this._renderer=new ScatterRenderer(e)}get task(){return this._task}get setting(){return this._manager.setting}get svg(){return this._manager.setting.svg}get width(){return this._width||(this._width=d3.select("#plot-area svg").node().getBoundingClientRect().width),this._width}set width(t){d3.select("#plot-area").style("width",t-2+"px"),this._width=null}get height(){return this._height||(this._height=d3.select("#plot-area svg").node().getBoundingClientRect().height),this._height}set height(t){d3.select("#plot-area").style("height",t-2+"px"),this._height=null}get datas(){return this._manager._datas}get params(){return{}}set params(t){}get trainInput(){return null}get trainOutput(){return null}testInput(){return null}init(){}terminate(){this._renderer.terminate()}}export class DefaultPlatform extends BasePlatform{constructor(t,e){super(t,e);const s=this.setting.task.configElement;"DR"!==this._task&&"FS"!==this._task||(s.append("span").text("Target dimension"),s.append("input").attr("type","number").attr("min",1).attr("max",2).attr("value",2).attr("name","dimension"))}get dimension(){const t=this.setting.task.configElement.select("[name=dimension]");return t.node()?+t.property("value"):null}get trainInput(){return this.datas.dimension>0?this.datas.x:this.datas.index.map((t=>[t]))}get trainOutput(){return this.datas.y.map((t=>[t]))}set trainResult(t){if("CT"===this._task)t.forEach(((t,e)=>{this.datas.at(e).y=t}));else if("AD"===this._task){0===this._r_task.select(".tile").size()&&this._r_task.insert("g").classed("tile",!0).classed("anormal_point",!0),this._r_task.selectAll(".tile *").remove();const e=this._r_task.select(".anormal_point");t.forEach(((t,s)=>{if(t){new DataCircle(e,this.datas.points[s]).color=getCategoryColor(specialCategory.error)}}))}else if("DR"===this._task||"FS"===this._task||"TF"===this._task){0===this._r_task.select(".tile").size()&&this._r_task.insert("g",":first-child").classed("tile",!0).attr("opacity",.5);const e=this._r_task.select(".tile");e.selectAll("*").remove();const s=t[0].length;let i=t;1===s&&(i=i.map((t=>[t,0])));let r=[],a=[];for(let t=0;t<i[0].length;t++){const e=i.map((e=>e[t]));r.push(Math.max(...e)),a.push(Math.min(...e))}const n=this.datas.dimension<=1?[this.height,this.height]:[this.width,this.height],o=n.map(((t,e)=>(t-10)/(r[e]-a[e])));let l=Math.min(...o);const h=[5,5];for(let t=0;t<o.length;t++)(!isFinite(l)||o[t]>l)&&(isFinite(o[t])?h[t]+=(o[t]-l)*(r[t]-a[t])/2:h[t]=n[t]/2-a[t]);isFinite(l)||(l=0);let _=1/0,d=null;const c=Matrix.fromArray(this.datas.points.map((t=>t.at)));for(let t=0;t<(this.datas.dimension<=1?1:2**s);t++){const e=t.toString(2).padStart(s,"0").split("").map((t=>!!+t)),n=i.map((t=>t.map(((t,s)=>((e[s]?r[s]-t+a[s]:t)-a[s])*l+h[s])))),o=Matrix.fromArray(n);o.sub(c);const p=o.norm();p<_&&(_=p,d=n)}d.forEach(((t,s)=>{const i=new DataPoint(e,this.datas.dimension<=1?[this.datas.points[s].at[0],t[0]]:t,this.datas.points[s].category);i.radius=2;new DataLine(e,this.datas.points[s],i).setRemoveListener((()=>i.remove()))}))}else{if("GR"!==this._task)throw new Error(`Invalid task ${this._task}`);{0===this._r_task.select(".tile").size()&&this._r_task.insert("g",":first-child").classed("tile",!0).classed("generated",!0).attr("opacity",.5);const e=this._r_task.select(".tile.generated");e.selectAll("*").remove();let s=null;Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[0][0])&&([t,s]=t),t.forEach(((t,i)=>{new DataPoint(e,this._renderer.toPoint(t),s?s[i][0]:0).radius=2}))}}}testInput(t=10){const[e,s]=this._renderer.predict(t);return"CF"!==this._task&&"RG"!==this._task||e.push(...this.datas.dimension>0?this.datas.x:this.datas.index.map((t=>[t]))),this.__plot=s,e}testResult(t){if("AD"===this._task&&(t=t.map((t=>t?specialCategory.error:specialCategory.errorRate(0)))),"CF"===this._task||"RG"===this._task){const e=t.slice(t.length-this.datas.length),s=this.datas.y;if(t=t.slice(0,t.length-this.datas.length),"CF"===this._task){let t=0;for(let i=0;i<s.length;i++)s[i]===e[i]&&t++;this._getEvaluateElm().text("Accuracy:"+t/s.length)}else if("RG"===this._task){let t=0;for(let i=0;i<s.length;i++)t+=(s[i]-e[i])**2;this._getEvaluateElm().text("RMSE:"+Math.sqrt(t/s.length))}}this.__plot(t,this._r_tile)}evaluate(t){"CF"!==this._task&&"RG"!==this._task||t(this.datas.x,(t=>{const e=this.datas.y;if("CF"===this._task){let s=0;for(let i=0;i<e.length;i++)e[i]===t[i]&&s++;this._getEvaluateElm().text("Accuracy:"+s/e.length)}else if("RG"===this._task){let s=0;for(let i=0;i<e.length;i++)s+=(e[i]-t[i])**2;this._getEvaluateElm().text("RMSE:"+Math.sqrt(s/e.length))}}))}init(){this._r&&this._r.remove(),this._cur_dimension=this.setting.dimension;const t=1===this.datas?.dimension&&("RG"===this._task||"IN"===this._task);this._r=t?this.svg.append("g"):this.svg.insert("g",":first-child"),this._r.classed("default-render",!0),this._r_task=this._r.append("g").classed("tasked-render",!0),this._r_tile=this._r.append("g").classed("tile-render",!0).attr("opacity",t?1:.5),this.setting.footer.text(""),this.svg.select("g.centroids").remove(),this._renderer.init(),this.render(),this._loss&&(this._loss.terminate(),this._loss=null,this.setting.footer.selectAll("*").remove())}render(){this._renderer.render()}centroids(t,e,{line:s=!1,duration:i=0}={}){let r=this.svg.select("g.centroids");0===r.size()&&(r=this.svg.append("g").classed("centroids",!0),r.append("g").classed("c-line",!0),this._centroids_line=[],this._centroids=null);const a=[];this._centroids&&this._centroids.forEach((t=>{Array.isArray(e)&&e.indexOf(t.category)<0?t.remove():a.push(t)}));const n=this._renderer.points;for(let t=0;t<n.length;t++)this._centroids_line[t]?._from===n[t]&&s||(this._centroids_line[t]?.remove(),this._centroids_line[t]=null);this._centroids=t.map(((t,i)=>{let n=Array.isArray(e)?a.find((t=>t.category===e[i])):a[i];if(n||(n=new DataPoint(r,this._renderer.toPoint(t),Array.isArray(e)?e[i]:e),n.plotter(DataPointStarPlotter)),s){const t=this._renderer.points,s=this.datas.y;for(let a=0;a<t.length;a++)s[a]===e[i]&&(this._centroids_line[a]?this._centroids_line[a].to=n:this._centroids_line[a]=new DataLine(r.select(".c-line"),t[a],n))}return n})),Promise.resolve().then((()=>{this._centroids.forEach(((e,s)=>{e.move(this._renderer.toPoint(t[s]),i)}))}))}_getEvaluateElm(){if(this._loss){const t=this.setting.footer.select("div.evaluate_result");return 0===t.size()?this.setting.footer.insert("div",":first-child").classed("evaluate_result",!0):t}return this.setting.footer}plotLoss(t){if(!this._loss){const t=this.setting.footer.text();this.setting.footer.text(""),this._loss=new LossPlotter(this,this.setting.footer),this._getEvaluateElm().text(t)}this._loss.add(t)}terminate(){this._r&&this._r.remove(),this.svg.select("g.centroids").remove(),this.svg.selectAll("g").style("visibility",null);this.setting.task.configElement.selectAll("*").remove(),this.setting.footer.text(""),super.terminate()}}export class LossPlotter{constructor(t,e){this._platform=t,this._r=e,this._item=null}add(t){if(!this._item)if("object"==typeof t){this._item={};for(const e of Object.keys(t))this._item[e]=new LossPlotterItem(this._platform,this._r),this._item[e].name=e}else this._item=new LossPlotterItem(this._platform,this._r);if("object"==typeof t)for(const e of Object.keys(t))this._item[e].add(t[e]);else this._item.add(t)}terminate(){if(this._item instanceof LossPlotterItem)this._item.terminate();else for(const t of Object.keys(this._item))this._item[t].terminate()}}class LossPlotterItem{constructor(t,e){this._platform=t,this._root=e.append("span").style("display","inline-flex").style("flex-direction","column"),this._caption=this._root.append("span").text("loss"),this._r=this._root.append("span").style("white-space","nowrap"),this._plot_count=1e4,this._print_count=10,this._plot_smooth_window=20,this._history=[]}set name(t){this._caption.text(t)}add(t){this._history.push(t),this.plotRewards()}terminate(){this._root.remove()}lastHistory(t=0){if(t<=0)return this._history;const e=this._history.length;return this._history.slice(Math.max(0,e-t),e)}plotRewards(){const t=200;let e=this._r.select("svg"),s=null,i=null,r=null,a=null,n=null;0===e.size()?(e=this._r.append("svg").attr("width",400).attr("height",50),s=e.append("path").attr("name","value").attr("stroke","black").attr("fill-opacity",0),i=e.append("path").attr("name","smooth").attr("stroke","green").attr("fill-opacity",0),r=e.append("text").classed("mintxt",!0).attr("x",t).attr("y",50).attr("fill","red").attr("font-weight","bold"),a=e.append("text").classed("maxtxt",!0).attr("x",t).attr("y",12).attr("fill","red").attr("font-weight","bold"),n=e.append("text").classed("avetxt",!0).attr("x",t).attr("y",24).attr("fill","blue").attr("font-weight","bold")):(s=e.select("path[name=value]"),i=e.select("path[name=smooth]"),r=e.select("text.mintxt"),a=e.select("text.maxtxt"),n=e.select("text.avetxt"));const o=this.lastHistory(this._plot_count);if(0===o.length)return e.style("display","none"),s.attr("d",null),void i.attr("d",null);e.style("display",null);const l=Math.max(...o),h=Math.min(...o),_=t=>{if("number"!=typeof t)return t;const e=3-Math.floor(Math.log10(Math.abs(t)));return Math.round(t*10**e)/10**e};if(r.text(`Min: ${_(h)}`),a.text(`Max: ${_(l)}`),l===h)return;const d=(e,s)=>[t*e/(o.length-1),50*(1-(s-h)/(l-h))],c=o.map(((t,e)=>d(e,t))),p=d3.line().x((t=>t[0])).y((t=>t[1]));s.attr("d",p(c));const m=[];for(let t=0;t<o.length-this._plot_smooth_window;t++){let e=0;for(let s=0;s<this._plot_smooth_window;s++)e+=o[t+s];m.push([t+this._plot_smooth_window,e/this._plot_smooth_window])}i.attr("d",p(m.map((t=>d(...t))))),n.text(`Mean(${this._plot_smooth_window}): ${_(m[m.length-1]?.[1])}`)}}