import FittingMode from"../fitting.js";const scale=function(t,e,s,i,a){return isFinite(e)&&isFinite(s)&&e!==s?(t-e)/(s-e)*(a-i)+i:(a+i)/2};class DataRenderer{constructor(t){if(this._manager=t,this._r=this.setting.svg.select("g.points g.datas"),0===this._r.size()){const t=this.setting.svg.append("g").classed("points",!0);this._r=t.append("g").classed("datas",!0)}this._p=[],this._pad=10,this._clip_pad=-1/0,this._pred_count=0,this._observe_target=null,this._observer=new MutationObserver((t=>{this._observe_target&&this._p.forEach(((t,e)=>t.title=this.data._categorical_output?this.data._output_category_names[this.data.y[e]-1]:this.data.y[e]))})),this._observer.observe(this.setting.svg.node(),{childList:!0}),this._will_render=!1}get padding(){return Array.isArray(this._pad)?this._pad:[this._pad,this._pad]}set padding(t){this._pad=t,this.render()}set clipPadding(t){this._clip_pad=t,this.render()}get _series(){return this.data?.isSeries}get setting(){return this._manager.setting}get width(){return this._manager.platform.width}get height(){return this._manager.platform.height}get points(){return this._p}get data(){return this._manager.datas}_clip(t){if(this._clip_pad===-1/0)return t;const e=[this.width,this.height];for(let s=0;s<t.length;s++)t[s]<this._clip_pad?t[s]=this._clip_pad:e[s]-this._clip_pad<t[s]&&(t[s]=e[s]-this._clip_pad);return t}render(){this._will_render||(this._will_render=!0,Promise.resolve().then((()=>{this._will_render&&(this._will_render=!1,this._render())})))}toPoint(t){const e=this.data.selectedColumnIndex,s=this._series?this.data.series.domain:this.data.domain,i=[this.width,this.height],[a,n]=this.data.range,h=e.map(((e,a)=>scale(t[e],s[e][0],s[e][1],0,i[a]-2*this.padding[a])+this.padding[a]));if(this._series)if(Array.isArray(t[0])){const e=this.data.domain[0];h[1]=scale(t[1],a,n,0,i[1]-2*this.padding[1])+this.padding[1],h[0]=scale(t[0][0],e[0],e[1],0,i[0]-2*this.padding[0])+this.padding[0]}else{const a=Math.min(e[0],t[1].length-1);h[1]=scale(t[1][a],s[e[0]][0],s[e[0]][1],0,i[1]-2*this.padding[1])+this.padding[1],h[0]=scale(t[0],0,this.data.length+this._pred_count,0,i[0]-2*this.padding[0])+this.padding[0]}return 1===h.length&&t.length>1&&(h[1]=scale(t[1],a,n,0,i[1]-2*this.padding[1])+this.padding[1]),h.map((t=>isNaN(t)?0:t))}toValue(t){return t&&this._series?[scale(t[0]-this.padding[0],0,this.width-2*this.padding[0],0,this.data.length)]:[]}_render(){if(!this.data||0===this.data.dimension)return this._p.map((t=>t.remove())),void(this._p.length=0);const t=this.data.selectedColumnIndex,e=this.data.length,s=this._series?this.data.series.values:this.data.x,i=this._series?this.data.series.domain:this.data.domain,a=[this.width,this.height],[n,h]=this.data.range,r=Math.max(1,Math.min(5,Math.floor(2e3/e)));for(let d=0;d<e;d++){const l=t.map(((t,e)=>scale(s[d][t],i[t][0],i[t][1],0,a[e]-2*this.padding[e])+this.padding[e]));this._series&&(l[1]=scale(s[d][t[0]],i[t[0]][0],i[t[0]][1],0,a[1]-2*this.padding[1])+this.padding[1],l[0]=scale(d,0,e+this._pred_count,0,a[0]-2*this.padding[0])+this.padding[0]),1===l.length&&(l[1]=scale(this.data.y[d],n,h,0,a[1]-2*this.padding[1])+this.padding[1]);const o=this._clip(l),g=1===this.data.dimension?0:this.data.y[d];if(this._p[d]){const t=this._p[d].at;t[0]===o[0]&&t[1]===o[1]||(this._p[d].at=o),this._p[d].category!==g&&(this._p[d].category=g)}else this._p[d]=new DataPoint(this._r,o,g);this._p[d].title=this.data._categorical_output?this.data._output_category_names[this.data.y[d]-1]:this.data.y[d],this._p[d].radius=r}for(let t=e;t<this._p.length;t++)this._p[t].remove();this._p.length=e}predict(t){Array.isArray(t)||(t=[t,t]);const e=this.data.domain,s=[this.width,this.height],i=[];if(this.data.dimension<=2)for(let a=0;a<s[0]+t[0];a+=t[0]){const n=scale(a-this.padding[0],0,s[0]-2*this.padding[0],e[0][0],e[0][1]);if(1===this.data.dimension)i.push([n]);else for(let a=0;a<s[1]-t[1]/100;a+=t[1]){const t=scale(a-this.padding[1],0,s[1]-2*this.padding[1],e[1][0],e[1][1]);i.push([n,t])}}else for(let t=0;t<this.data.x.length;t++)i.push(this.data.x[t].concat());const a=this.setting.vue.mlTask;return[i,(n,h)=>{h.selectAll("*").remove();let r=n.some((t=>!Number.isInteger(t)));if(1===this.data.dimension){const d=[];if("IN"===a||r&&"DE"!==a){const[t,a]=this.data.range;for(let h=0;h<n.length;h++)d.push([scale(i[h],e[0][0],e[0][1],0,s[0]-2*this.padding[0])+this.padding[0],scale(n[h],t,a,0,s[1]-2*this.padding[1])+this.padding[1]]);const r=d3.line().x((t=>t[0])).y((t=>t[1]));h.append("path").attr("stroke","red").attr("fill-opacity",0).attr("d",r(d))}else{d.push([],[]);for(let e=0,i=0;i<s[0]+t[0];e++,i+=t[0])d[0][e]=n[e],d[1][e]=n[e];const e=h.append("g");new DataHulls(e,d,[t[0],1e3],r)}}else if(2===this.data.dimension){let e=0;const i=[];for(let a=0,h=0;h<s[0]+t[0];a++,h+=t[0])for(let h=0,r=0;r<s[1]-t[1]/100;h++,r+=t[1])i[h]||(i[h]=[]),i[h][a]=n[e++];!r&&n.length>100&&(r|=new Set(n).size>100);const d=h.append("g");new DataHulls(d,i,t,r||"DE"===a)}else{const t=h.append("g"),e=n.every(Number.isInteger);for(let s=0;s<n.length;s++){new DataCircle(t,this._p[s]).color=getCategoryColor(n[s]),e&&this.data._categorical_output?this._p[s].title=`true: ${this.data._output_category_names[this.data.y[s]-1]}\npred: ${this.data._output_category_names[n[s]-1]}`:this._p[s].title=`true: ${this.data.y[s]}\npred: ${n[s]}`}this._observe_target=h}}]}terminate(){this._p.forEach((t=>t.remove())),this._observer.disconnect(),this._will_render=!1}}export class BasePlatform{constructor(t,e){this._manager=e,this._task=t,this._renderer=new DataRenderer(e)}get task(){return this._task}get setting(){return this._manager.setting}get svg(){return this._manager.setting.svg}get width(){return this._width||(this._width=d3.select("#plot-area svg").node().getBoundingClientRect().width),this._width}set width(t){d3.select("#plot-area").style("width",t-2+"px"),this._width=null}get height(){return this._height||(this._height=d3.select("#plot-area svg").node().getBoundingClientRect().height),this._height}set height(t){d3.select("#plot-area").style("height",t-2+"px"),this._height=null}get datas(){return this._manager._datas}get params(){return{}}set params(t){}init(){}terminate(){this._renderer.terminate()}}export class DefaultPlatform extends BasePlatform{constructor(t,e){super(t,e);const s=this.setting.task.configElement;"DR"!==this._task&&"FS"!==this._task||(s.append("span").text("Target dimension"),s.append("input").attr("type","number").attr("min",1).attr("max",2).attr("value",2).attr("name","dimension"))}get dimension(){const t=this.setting.task.configElement.select("[name=dimension]");return t.node()?+t.property("value"):null}fit(t){return this._cur_dimension!==this.setting.dimension&&this.init(),FittingMode[this._task](this._r_task,this.datas,t)}predict(t,e=10){const[s,i]=this._renderer.predict(e);"CF"!==this._task&&"RG"!==this._task||s.push(...this.datas.x),t(s,(t=>{if("AD"===this._task&&(t=t.map((t=>t?specialCategory.error:specialCategory.errorRate(0)))),"CF"===this._task||"RG"===this._task){const e=t.slice(s.length-this.datas.length),i=this.datas.y;if(t=t.slice(0,s.length-this.datas.length),"CF"===this._task){let t=0;for(let s=0;s<i.length;s++)i[s]===e[s]&&t++;this.setting.footer.text("Accuracy:"+t/i.length)}else if("RG"===this._task){let t=0;for(let s=0;s<i.length;s++)t+=(i[s]-e[s])**2;this.setting.footer.text("RMSE:"+Math.sqrt(t/i.length))}}i(t,this._r_tile)}))}evaluate(t){"CF"!==this._task&&"RG"!==this._task||t(this.datas.x,(t=>{const e=this.datas.y;if("CF"===this._task){let s=0;for(let i=0;i<e.length;i++)e[i]===t[i]&&s++;this.setting.footer.text("Accuracy:"+s/e.length)}else if("RG"===this._task){let s=0;for(let i=0;i<e.length;i++)s+=(e[i]-t[i])**2;this.setting.footer.text("RMSE:"+Math.sqrt(s/e.length))}}))}init(){this._r&&this._r.remove(),this._cur_dimension=this.setting.dimension;const t=1===this.datas?.dimension&&("RG"===this._task||"IN"===this._task);this._r=t?this.svg.append("g"):this.svg.insert("g",":first-child"),this._r.classed("default-render",!0),this._r_task=this._r.append("g").classed("tasked-render",!0),this._r_tile=this._r.append("g").classed("tile-render",!0).attr("opacity",t?1:.5),this.setting.footer.text(""),this.svg.select("g.centroids").remove(),this.render()}render(){this._renderer.render()}centroids(t,e,{line:s=!1,duration:i=0}={}){let a=this.svg.select("g.centroids");0===a.size()&&(a=this.svg.append("g").classed("centroids",!0),a.append("g").classed("c-line",!0),this._centroids_line=[],this._centroids=null);const n=[];this._centroids&&this._centroids.forEach((t=>{Array.isArray(e)&&e.indexOf(t.category)<0?t.remove():n.push(t)}));const h=this._renderer.points;for(let t=0;t<h.length;t++)this._centroids_line[t]?._from===h[t]&&s||(this._centroids_line[t]?.remove(),this._centroids_line[t]=null);this._centroids=t.map(((t,i)=>{let h=Array.isArray(e)?n.find((t=>t.category===e[i])):n[i];if(h||(h=new DataPoint(a,t.map((t=>t/this.datas.scale)),Array.isArray(e)?e[i]:e),h.plotter(DataPointStarPlotter)),s){const t=this._renderer.points,s=this.datas.y;for(let n=0;n<t.length;n++)s[n]===e[i]&&(this._centroids_line[n]?this._centroids_line[n].to=h:this._centroids_line[n]=new DataLine(a.select(".c-line"),t[n],h))}return h})),Promise.resolve().then((()=>{this._centroids.forEach(((e,s)=>{e.move(t[s].map((t=>t/this.datas.scale)),i)}))}))}terminate(){this._r&&this._r.remove(),this.svg.select("g.centroids").remove(),this.svg.selectAll("g").style("visibility",null);this.setting.task.configElement.selectAll("*").remove(),this.setting.footer.text(""),super.terminate()}}