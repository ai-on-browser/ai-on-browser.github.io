import BaseRenderer from"./base.js";const scale=function(t,s,e,i,a){return isFinite(s)&&isFinite(e)&&s!==e?(t-s)/(e-s)*(a-i)+i:(a+i)/2};export default class LineRenderer extends BaseRenderer{constructor(t){if(super(t),this._r=this.svg.select("g.points g.datas"),0===this._r.size()){const t=this.svg.append("g").classed("points",!0);this._r=t.append("g").classed("datas",!0)}this._pathg=this.svg.select("g.ts-render-path"),0===this._pathg.size()&&(this._pathg=this.svg.insert("g",":first-child").classed("ts-render-path",!0)),this._pathg.selectAll("g.ts-render-path *").remove(),this._path=this._pathg.append("path").attr("stroke","black").attr("fill-opacity",0).style("pointer-events","none"),this._p=[],this._pad=10,this._clip_pad=-1/0,this._pred_count=0,this._observe_target=null,this._observer=new MutationObserver((t=>{this._observe_target&&this._p.forEach(((t,s)=>t.title=this.datas.originalY[s]))})),this._observer.observe(this.setting.svg.node(),{childList:!0}),this._will_render=!1}get padding(){return Array.isArray(this._pad)?this._pad:[this._pad,this._pad]}set padding(t){this._pad=t,this.render()}set clipPadding(t){this._clip_pad=t,this.render()}get points(){return this._p}init(){this._make_selector()}_make_selector(){let t=this.datas?.columnNames||[],s=this.setting.render.configElement.select("div.column-selector");if(0===s.size()&&t.length>0?s=this.setting.render.configElement.append("div").classed("column-selector",!0):s.selectAll("*").remove(),t.length<=1)this._select=null;else if(t.length<=4){const e=s.append("table").style("border-collapse","collapse");let i=e.append("tr").style("text-align","center");i.append("td"),i.append("td").text("V").style("transform","rotate(180deg)");const a=[];for(let s=0;s<this.datas.dimension;s++){i=e.append("tr"),e.append("td").text(t[s]).style("text-align","right");const n=e.append("td").append("input").attr("type","radio").attr("name","data-d1").on("change",(()=>this._manager.platform.render()));a.push(n)}a[0].property("checked",!0),this._select=()=>{const t=[];for(let s=0;s<this.datas.dimension;s++)a[s].property("checked")&&(t[0]=s);return t}}else{t=t.map((t=>""+t)),s.append("span").text(">");const e=s.append("select").on("change",(()=>this._manager.platform.render()));e.selectAll("option").data(t).enter().append("option").attr("value",(t=>t)).text((t=>t)),e.property("value",t[0]),this._select=()=>[t.indexOf(e.property("value"))]}}_clip(t){if(this._clip_pad===-1/0)return t;const s=[this.width,this.height];for(let e=0;e<t.length;e++)t[e]<this._clip_pad?t[e]=this._clip_pad:s[e]-this._clip_pad<t[e]&&(t[e]=s[e]-this._clip_pad);return t}toPoint(t){if(0===this.datas.length)return[0,0];const s=[this.width,this.height],e=[];if(0===this.datas.dimension){const i=this.datas.range;e.push(scale(t[0],0,this.datas.length+this._pred_count,0,s[0]-2*this.padding[0])+this.padding[0],scale(t[1][0],i[0],i[1],0,s[1]-2*this.padding[1])+this.padding[1])}else{const i=this._select?.()??(0===this.datas.dimension?null:[Math.min(1,this.datas.dimension-1)]),a=this.datas.domain,n=Math.min(i[0],t[1].length-1);e.push(scale(t[0],0,this.datas.length+this._pred_count,0,s[0]-2*this.padding[0])+this.padding[0],scale(t[1][n],a[i[0]][0],a[i[0]][1],0,s[1]-2*this.padding[1])+this.padding[1])}return e.map((t=>isNaN(t)?0:t))}toValue(t){return t&&this.datas?[scale(t[0]-this.padding[0],0,this.width-2*this.padding[0],0,this.datas.length)]:[]}_render(){if(!this.datas||0===this.datas.length)return this._p.map((t=>t.remove())),this._p.length=0,void this._path.attr("opacity",0);const t=this._select?.()??(0===this.datas.dimension?null:[Math.min(1,this.datas.dimension-1)]),s=this.datas.length,e=this.datas.x,i=this.datas.domain,a=this.datas.y,n=[this.width,this.height],[h,d]=this.datas.range,r=[];for(let p=0;p<s;p++)0===this.datas.dimension?r.push([scale(p,0,s+this._pred_count,0,n[0]-2*this.padding[0])+this.padding[0],scale(a[p],h,d,0,n[1]-2*this.padding[1])+this.padding[1]]):r.push([scale(p,0,s+this._pred_count,0,n[0]-2*this.padding[0])+this.padding[0],scale(e[p][t[0]],i[t[0]][0],i[t[0]][1],0,n[1]-2*this.padding[1])+this.padding[1]]);const p=Math.max(1,Math.min(5,Math.floor(2e3/s)));for(let t=0;t<s;t++){const s=this._clip(r[t]),e=this.datas.dimension<=1?0:this.datas.y[t];if(this._p[t]){const i=this._p[t].at;i[0]===s[0]&&i[1]===s[1]||(this._p[t].at=s),this._p[t].category!==e&&(this._p[t].category=e)}else this._p[t]=new DataPoint(this._r,s,e);this._p[t].title=this.datas.originalY[t],this._p[t].radius=p}for(let t=s;t<this._p.length;t++)this._p[t].remove();this._p.length=s;const l=d3.line().x((t=>t[0])).y((t=>t[1]));this._path.attr("d",l(this.points.map((t=>t.at)))).attr("opacity",.5)}terminate(){this._p.forEach((t=>t.remove())),this._observer.disconnect(),this.setting.render.configElement.selectAll("*").remove(),this._pathg.remove(),super.terminate()}}