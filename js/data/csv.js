import{FixData}from"./base.js";class CSV{constructor(t){this._data=t,this._decoder=new TextDecoder("utf-8")}get data(){return this._data}async load(t){if(t instanceof File)await new Promise((e=>{const a=new FileReader;a.onload=()=>{this.loadFromString(a.result),e()},a.readAsText(t)}));else{this._data=[];for await(let e of this._fetch(t)){if(0===e.length)continue;const t=e.split(",").map((t=>isNaN(t)?t:+t));this._data.push(t)}}}loadFromString(t){this._data=[];for(let e of t.split(/\r\n?|\n/)){if(0===e.length)continue;const t=e.split(",").map((t=>isNaN(t)?t:+t));this._data.push(t)}}async*_fetch(t){const e=(await fetch(t)).body.getReader();let{value:a,done:s}=await e.read();if(a&&t.endsWith(".gz")){let t=a;for(;!s;)if(({value:a,done:s}=await e.read()),a){const e=new Uint8Array(t.length+a.length);e.set(t),e.set(a,t.length),t=e}a=pako.ungzip(t)}a=a?this._decoder.decode(a):"";const i=/\n|\r|\r\n/gm;let n=0;for(;;){const t=i.exec(a);if(t)yield a.substring(n,t.index),n=i.lastIndex;else{if(s)break;const t=a.substr(n);({value:a,done:s}=await e.read()),a=t+(a?this._decoder.decode(a):""),n=i.lastIndex=0}}n<a.length&&(yield a.substr(n))}}export default class CSVData extends FixData{constructor(t,e,a){super(t),this._input_category_names=[],this._output_category_names=null,e&&a&&this.setCSV(e,a)}readCSV(t,e){const a=new CSV;a.load(t).then((()=>e(a.data)))}setCSV(t,e,a=!1){if(Array.isArray(t)){if(a){const a=t[0];t=t.slice(1),e||((e=a.map(((e,a)=>({name:e,type:t.some((t=>isNaN(t[a])))?"category":"numeric"}))))[e.length-1].out=!0)}for(let a=0,s=0;a<e.length;a++)e[a].out?(this._categorical_output="category"===e[a].type,this._y=t.map((t=>t[a]))):e[a].ignore||("category"===e[a].type&&(this._input_category_names[s]=[...new Set(t.map((t=>t[a])))]),s++);if(!this._y)throw new Error("There is no 'out' column.");if(this._x=t.map((t=>t.filter(((t,a)=>!e[a].out&&!e[a].ignore)).map(((t,e)=>this._input_category_names[e]?this._input_category_names[e].indexOf(t):t)))),this._categorical_output){this._output_category_names=[...new Set(this._y)];for(let t=0;t<this._y.length;t++)this._y[t]=this._output_category_names.indexOf(this._y[t])+1}this._feature_names=e.filter((t=>!t.out&&!t.ignore)).map((t=>t.name)),this._domain=null,this._renderer._make_selector(this._feature_names)}else this.readCSV(t,(t=>{this.setCSV(t,e,a)}))}}