var d=Object.defineProperty;var a=(i,e)=>d(i,"name",{value:e,configurable:!0});export default class u{static{a(this,"BaseDB")}constructor(e,t){this.dbname=e,this.version=t,this.db=null}onupgradeneeded(e){throw new Error("Not implemented")}async _ready(){if(this.db)return;const e=indexedDB.open(this.dbname,this.version);return new Promise((t,r)=>{e.onerror=r,e.onsuccess=()=>{this.db=e.result,t()},e.onupgradeneeded=o=>{this.onupgradeneeded(o)}})}async save(e,t){return await this._ready(),new Promise((r,o)=>{const n=this.db.transaction([e],"readwrite"),s=n.objectStore(e);Array.isArray(t)||(t=[t]);for(const c of t)s.put(c);n.oncomplete=r,n.onerror=o})}async get(e,t){return await this._ready(),new Promise((r,o)=>{const s=this.db.transaction(e).objectStore(e).get(t);s.onsuccess=c=>{r(c.target.result)},s.onerror=o})}async list(e){return await this._ready(),new Promise((t,r)=>{const n=this.db.transaction(e).objectStore(e).getAll();n.onsuccess=s=>{t(s.target.result)},n.onerror=r})}async delete(e,t){return await this._ready(),new Promise((r,o)=>{const s=this.db.transaction(e,"readwrite").objectStore(e).delete(t);s.onsuccess=r,s.onerror=o})}async deleteDatabase(){return new Promise((e,t)=>{this.db?.close();const r=indexedDB.deleteDatabase(this.dbname);r.onerror=t,r.onsuccess=()=>{this.db=null,e()}})}}
