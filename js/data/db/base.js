export default class BaseDB{constructor(e,t){this.dbname=e,this.version=t,this.db=null}onupgradeneeded(e){throw new Error("Not implemented")}async _ready(){if(this.db)return;const e=indexedDB.open(this.dbname,this.version);return new Promise(((t,r)=>{e.onerror=r,e.onsuccess=()=>{this.db=e.result,t()},e.onupgradeneeded=e=>{this.onupgradeneeded(e)}}))}async save(e,t){return await this._ready(),new Promise(((r,s)=>{const n=this.db.transaction([e],"readwrite"),o=n.objectStore(e);Array.isArray(t)||(t=[t]);for(const e of t)o.put(e);n.oncomplete=r,n.onerror=s}))}async get(e,t){return await this._ready(),new Promise(((r,s)=>{const n=this.db.transaction(e).objectStore(e).get(t);n.onsuccess=e=>{r(e.target.result)},n.onerror=s}))}async list(e){return await this._ready(),new Promise(((t,r)=>{const s=this.db.transaction(e).objectStore(e).getAll();s.onsuccess=e=>{t(e.target.result)},s.onerror=r}))}async delete(e,t){return await this._ready(),new Promise(((r,s)=>{const n=this.db.transaction(e,"readwrite").objectStore(e).delete(t);n.onsuccess=r,n.onerror=s}))}async deleteDatabase(){return new Promise(((e,t)=>{this.db?.close();const r=indexedDB.deleteDatabase(this.dbname);r.onerror=t,r.onsuccess=()=>{this.db=null,e()}}))}}